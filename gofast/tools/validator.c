/* Generated by Cython 0.29.34 */

/* BEGIN: Cython Metadata
{
    "distutils": {
        "include_dirs": [
            "C:\\Users\\Daniel\\anaconda3\\envs\\watex\\lib\\site-packages\\numpy\\core\\include"
        ],
        "name": "validator",
        "sources": [
            "validator.pyx"
        ]
    },
    "module_name": "validator"
}
END: Cython Metadata */

#ifndef PY_SSIZE_T_CLEAN
#define PY_SSIZE_T_CLEAN
#endif /* PY_SSIZE_T_CLEAN */
#include "Python.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
    #error Cython requires Python 2.6+ or Python 3.3+.
#else
#define CYTHON_ABI "0_29_34"
#define CYTHON_HEX_VERSION 0x001D22F0
#define CYTHON_FUTURE_DIVISION 1
#include <stddef.h>
#ifndef offsetof
  #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
#endif
#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#endif
#ifndef DL_IMPORT
  #define DL_IMPORT(t) t
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#define __PYX_COMMA ,
#ifndef HAVE_LONG_LONG
  #if PY_VERSION_HEX >= 0x02070000
    #define HAVE_LONG_LONG
  #endif
#endif
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef Py_HUGE_VAL
  #define Py_HUGE_VAL HUGE_VAL
#endif
#ifdef PYPY_VERSION
  #define CYTHON_COMPILING_IN_PYPY 1
  #define CYTHON_COMPILING_IN_PYSTON 0
  #define CYTHON_COMPILING_IN_CPYTHON 0
  #define CYTHON_COMPILING_IN_NOGIL 0
  #undef CYTHON_USE_TYPE_SLOTS
  #define CYTHON_USE_TYPE_SLOTS 0
  #undef CYTHON_USE_PYTYPE_LOOKUP
  #define CYTHON_USE_PYTYPE_LOOKUP 0
  #if PY_VERSION_HEX < 0x03050000
    #undef CYTHON_USE_ASYNC_SLOTS
    #define CYTHON_USE_ASYNC_SLOTS 0
  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
    #define CYTHON_USE_ASYNC_SLOTS 1
  #endif
  #undef CYTHON_USE_PYLIST_INTERNALS
  #define CYTHON_USE_PYLIST_INTERNALS 0
  #undef CYTHON_USE_UNICODE_INTERNALS
  #define CYTHON_USE_UNICODE_INTERNALS 0
  #undef CYTHON_USE_UNICODE_WRITER
  #define CYTHON_USE_UNICODE_WRITER 0
  #undef CYTHON_USE_PYLONG_INTERNALS
  #define CYTHON_USE_PYLONG_INTERNALS 0
  #undef CYTHON_AVOID_BORROWED_REFS
  #define CYTHON_AVOID_BORROWED_REFS 1
  #undef CYTHON_ASSUME_SAFE_MACROS
  #define CYTHON_ASSUME_SAFE_MACROS 0
  #undef CYTHON_UNPACK_METHODS
  #define CYTHON_UNPACK_METHODS 0
  #undef CYTHON_FAST_THREAD_STATE
  #define CYTHON_FAST_THREAD_STATE 0
  #undef CYTHON_FAST_PYCALL
  #define CYTHON_FAST_PYCALL 0
  #undef CYTHON_PEP489_MULTI_PHASE_INIT
  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
  #undef CYTHON_USE_TP_FINALIZE
  #define CYTHON_USE_TP_FINALIZE 0
  #undef CYTHON_USE_DICT_VERSIONS
  #define CYTHON_USE_DICT_VERSIONS 0
  #undef CYTHON_USE_EXC_INFO_STACK
  #define CYTHON_USE_EXC_INFO_STACK 0
  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
  #endif
#elif defined(PYSTON_VERSION)
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_PYSTON 1
  #define CYTHON_COMPILING_IN_CPYTHON 0
  #define CYTHON_COMPILING_IN_NOGIL 0
  #ifndef CYTHON_USE_TYPE_SLOTS
    #define CYTHON_USE_TYPE_SLOTS 1
  #endif
  #undef CYTHON_USE_PYTYPE_LOOKUP
  #define CYTHON_USE_PYTYPE_LOOKUP 0
  #undef CYTHON_USE_ASYNC_SLOTS
  #define CYTHON_USE_ASYNC_SLOTS 0
  #undef CYTHON_USE_PYLIST_INTERNALS
  #define CYTHON_USE_PYLIST_INTERNALS 0
  #ifndef CYTHON_USE_UNICODE_INTERNALS
    #define CYTHON_USE_UNICODE_INTERNALS 1
  #endif
  #undef CYTHON_USE_UNICODE_WRITER
  #define CYTHON_USE_UNICODE_WRITER 0
  #undef CYTHON_USE_PYLONG_INTERNALS
  #define CYTHON_USE_PYLONG_INTERNALS 0
  #ifndef CYTHON_AVOID_BORROWED_REFS
    #define CYTHON_AVOID_BORROWED_REFS 0
  #endif
  #ifndef CYTHON_ASSUME_SAFE_MACROS
    #define CYTHON_ASSUME_SAFE_MACROS 1
  #endif
  #ifndef CYTHON_UNPACK_METHODS
    #define CYTHON_UNPACK_METHODS 1
  #endif
  #undef CYTHON_FAST_THREAD_STATE
  #define CYTHON_FAST_THREAD_STATE 0
  #undef CYTHON_FAST_PYCALL
  #define CYTHON_FAST_PYCALL 0
  #undef CYTHON_PEP489_MULTI_PHASE_INIT
  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
  #undef CYTHON_USE_TP_FINALIZE
  #define CYTHON_USE_TP_FINALIZE 0
  #undef CYTHON_USE_DICT_VERSIONS
  #define CYTHON_USE_DICT_VERSIONS 0
  #undef CYTHON_USE_EXC_INFO_STACK
  #define CYTHON_USE_EXC_INFO_STACK 0
  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
    #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
  #endif
#elif defined(PY_NOGIL)
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_PYSTON 0
  #define CYTHON_COMPILING_IN_CPYTHON 0
  #define CYTHON_COMPILING_IN_NOGIL 1
  #ifndef CYTHON_USE_TYPE_SLOTS
    #define CYTHON_USE_TYPE_SLOTS 1
  #endif
  #undef CYTHON_USE_PYTYPE_LOOKUP
  #define CYTHON_USE_PYTYPE_LOOKUP 0
  #ifndef CYTHON_USE_ASYNC_SLOTS
    #define CYTHON_USE_ASYNC_SLOTS 1
  #endif
  #undef CYTHON_USE_PYLIST_INTERNALS
  #define CYTHON_USE_PYLIST_INTERNALS 0
  #ifndef CYTHON_USE_UNICODE_INTERNALS
    #define CYTHON_USE_UNICODE_INTERNALS 1
  #endif
  #undef CYTHON_USE_UNICODE_WRITER
  #define CYTHON_USE_UNICODE_WRITER 0
  #undef CYTHON_USE_PYLONG_INTERNALS
  #define CYTHON_USE_PYLONG_INTERNALS 0
  #ifndef CYTHON_AVOID_BORROWED_REFS
    #define CYTHON_AVOID_BORROWED_REFS 0
  #endif
  #ifndef CYTHON_ASSUME_SAFE_MACROS
    #define CYTHON_ASSUME_SAFE_MACROS 1
  #endif
  #ifndef CYTHON_UNPACK_METHODS
    #define CYTHON_UNPACK_METHODS 1
  #endif
  #undef CYTHON_FAST_THREAD_STATE
  #define CYTHON_FAST_THREAD_STATE 0
  #undef CYTHON_FAST_PYCALL
  #define CYTHON_FAST_PYCALL 0
  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
  #endif
  #ifndef CYTHON_USE_TP_FINALIZE
    #define CYTHON_USE_TP_FINALIZE 1
  #endif
  #undef CYTHON_USE_DICT_VERSIONS
  #define CYTHON_USE_DICT_VERSIONS 0
  #undef CYTHON_USE_EXC_INFO_STACK
  #define CYTHON_USE_EXC_INFO_STACK 0
#else
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_PYSTON 0
  #define CYTHON_COMPILING_IN_CPYTHON 1
  #define CYTHON_COMPILING_IN_NOGIL 0
  #ifndef CYTHON_USE_TYPE_SLOTS
    #define CYTHON_USE_TYPE_SLOTS 1
  #endif
  #if PY_VERSION_HEX < 0x02070000
    #undef CYTHON_USE_PYTYPE_LOOKUP
    #define CYTHON_USE_PYTYPE_LOOKUP 0
  #elif !defined(CYTHON_USE_PYTYPE_LOOKUP)
    #define CYTHON_USE_PYTYPE_LOOKUP 1
  #endif
  #if PY_MAJOR_VERSION < 3
    #undef CYTHON_USE_ASYNC_SLOTS
    #define CYTHON_USE_ASYNC_SLOTS 0
  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
    #define CYTHON_USE_ASYNC_SLOTS 1
  #endif
  #if PY_VERSION_HEX < 0x02070000
    #undef CYTHON_USE_PYLONG_INTERNALS
    #define CYTHON_USE_PYLONG_INTERNALS 0
  #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
    #define CYTHON_USE_PYLONG_INTERNALS (PY_VERSION_HEX < 0x030C00A5)
  #endif
  #ifndef CYTHON_USE_PYLIST_INTERNALS
    #define CYTHON_USE_PYLIST_INTERNALS 1
  #endif
  #ifndef CYTHON_USE_UNICODE_INTERNALS
    #define CYTHON_USE_UNICODE_INTERNALS 1
  #endif
  #if PY_VERSION_HEX < 0x030300F0 || PY_VERSION_HEX >= 0x030B00A2
    #undef CYTHON_USE_UNICODE_WRITER
    #define CYTHON_USE_UNICODE_WRITER 0
  #elif !defined(CYTHON_USE_UNICODE_WRITER)
    #define CYTHON_USE_UNICODE_WRITER 1
  #endif
  #ifndef CYTHON_AVOID_BORROWED_REFS
    #define CYTHON_AVOID_BORROWED_REFS 0
  #endif
  #ifndef CYTHON_ASSUME_SAFE_MACROS
    #define CYTHON_ASSUME_SAFE_MACROS 1
  #endif
  #ifndef CYTHON_UNPACK_METHODS
    #define CYTHON_UNPACK_METHODS 1
  #endif
  #if PY_VERSION_HEX >= 0x030B00A4
    #undef CYTHON_FAST_THREAD_STATE
    #define CYTHON_FAST_THREAD_STATE 0
  #elif !defined(CYTHON_FAST_THREAD_STATE)
    #define CYTHON_FAST_THREAD_STATE 1
  #endif
  #ifndef CYTHON_FAST_PYCALL
    #define CYTHON_FAST_PYCALL (PY_VERSION_HEX < 0x030A0000)
  #endif
  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
    #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
  #endif
  #ifndef CYTHON_USE_TP_FINALIZE
    #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
  #endif
  #ifndef CYTHON_USE_DICT_VERSIONS
    #define CYTHON_USE_DICT_VERSIONS ((PY_VERSION_HEX >= 0x030600B1) && (PY_VERSION_HEX < 0x030C00A5))
  #endif
  #if PY_VERSION_HEX >= 0x030B00A4
    #undef CYTHON_USE_EXC_INFO_STACK
    #define CYTHON_USE_EXC_INFO_STACK 0
  #elif !defined(CYTHON_USE_EXC_INFO_STACK)
    #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
  #endif
  #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
    #define CYTHON_UPDATE_DESCRIPTOR_DOC 1
  #endif
#endif
#if !defined(CYTHON_FAST_PYCCALL)
#define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
#endif
#if CYTHON_USE_PYLONG_INTERNALS
  #if PY_MAJOR_VERSION < 3
    #include "longintrepr.h"
  #endif
  #undef SHIFT
  #undef BASE
  #undef MASK
  #ifdef SIZEOF_VOID_P
    enum { __pyx_check_sizeof_voidp = 1 / (int)(SIZEOF_VOID_P == sizeof(void*)) };
  #endif
#endif
#ifndef __has_attribute
  #define __has_attribute(x) 0
#endif
#ifndef __has_cpp_attribute
  #define __has_cpp_attribute(x) 0
#endif
#ifndef CYTHON_RESTRICT
  #if defined(__GNUC__)
    #define CYTHON_RESTRICT __restrict__
  #elif defined(_MSC_VER) && _MSC_VER >= 1400
    #define CYTHON_RESTRICT __restrict
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_RESTRICT restrict
  #else
    #define CYTHON_RESTRICT
  #endif
#endif
#ifndef CYTHON_UNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define CYTHON_UNUSED __attribute__ ((__unused__))
#   else
#     define CYTHON_UNUSED
#   endif
# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
#   define CYTHON_UNUSED __attribute__ ((__unused__))
# else
#   define CYTHON_UNUSED
# endif
#endif
#ifndef CYTHON_MAYBE_UNUSED_VAR
#  if defined(__cplusplus)
     template<class T> void CYTHON_MAYBE_UNUSED_VAR( const T& ) { }
#  else
#    define CYTHON_MAYBE_UNUSED_VAR(x) (void)(x)
#  endif
#endif
#ifndef CYTHON_NCP_UNUSED
# if CYTHON_COMPILING_IN_CPYTHON
#  define CYTHON_NCP_UNUSED
# else
#  define CYTHON_NCP_UNUSED CYTHON_UNUSED
# endif
#endif
#define __Pyx_void_to_None(void_result) ((void)(void_result), Py_INCREF(Py_None), Py_None)
#ifdef _MSC_VER
    #ifndef _MSC_STDINT_H_
        #if _MSC_VER < 1300
           typedef unsigned char     uint8_t;
           typedef unsigned int      uint32_t;
        #else
           typedef unsigned __int8   uint8_t;
           typedef unsigned __int32  uint32_t;
        #endif
    #endif
#else
   #include <stdint.h>
#endif
#ifndef CYTHON_FALLTHROUGH
  #if defined(__cplusplus) && __cplusplus >= 201103L
    #if __has_cpp_attribute(fallthrough)
      #define CYTHON_FALLTHROUGH [[fallthrough]]
    #elif __has_cpp_attribute(clang::fallthrough)
      #define CYTHON_FALLTHROUGH [[clang::fallthrough]]
    #elif __has_cpp_attribute(gnu::fallthrough)
      #define CYTHON_FALLTHROUGH [[gnu::fallthrough]]
    #endif
  #endif
  #ifndef CYTHON_FALLTHROUGH
    #if __has_attribute(fallthrough)
      #define CYTHON_FALLTHROUGH __attribute__((fallthrough))
    #else
      #define CYTHON_FALLTHROUGH
    #endif
  #endif
  #if defined(__clang__ ) && defined(__apple_build_version__)
    #if __apple_build_version__ < 7000000
      #undef  CYTHON_FALLTHROUGH
      #define CYTHON_FALLTHROUGH
    #endif
  #endif
#endif

#ifndef CYTHON_INLINE
  #if defined(__clang__)
    #define CYTHON_INLINE __inline__ __attribute__ ((__unused__))
  #elif defined(__GNUC__)
    #define CYTHON_INLINE __inline__
  #elif defined(_MSC_VER)
    #define CYTHON_INLINE __inline
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_INLINE inline
  #else
    #define CYTHON_INLINE
  #endif
#endif

#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
  #define Py_OptimizeFlag 0
#endif
#define __PYX_BUILD_PY_SSIZE_T "n"
#define CYTHON_FORMAT_SSIZE_T "z"
#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyClass_Type
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
  #define __Pyx_DefaultClassType PyType_Type
#if PY_VERSION_HEX >= 0x030B00A1
    static CYTHON_INLINE PyCodeObject* __Pyx_PyCode_New(int a, int k, int l, int s, int f,
                                                    PyObject *code, PyObject *c, PyObject* n, PyObject *v,
                                                    PyObject *fv, PyObject *cell, PyObject* fn,
                                                    PyObject *name, int fline, PyObject *lnos) {
        PyObject *kwds=NULL, *argcount=NULL, *posonlyargcount=NULL, *kwonlyargcount=NULL;
        PyObject *nlocals=NULL, *stacksize=NULL, *flags=NULL, *replace=NULL, *call_result=NULL, *empty=NULL;
        const char *fn_cstr=NULL;
        const char *name_cstr=NULL;
        PyCodeObject* co=NULL;
        PyObject *type, *value, *traceback;
        PyErr_Fetch(&type, &value, &traceback);
        if (!(kwds=PyDict_New())) goto end;
        if (!(argcount=PyLong_FromLong(a))) goto end;
        if (PyDict_SetItemString(kwds, "co_argcount", argcount) != 0) goto end;
        if (!(posonlyargcount=PyLong_FromLong(0))) goto end;
        if (PyDict_SetItemString(kwds, "co_posonlyargcount", posonlyargcount) != 0) goto end;
        if (!(kwonlyargcount=PyLong_FromLong(k))) goto end;
        if (PyDict_SetItemString(kwds, "co_kwonlyargcount", kwonlyargcount) != 0) goto end;
        if (!(nlocals=PyLong_FromLong(l))) goto end;
        if (PyDict_SetItemString(kwds, "co_nlocals", nlocals) != 0) goto end;
        if (!(stacksize=PyLong_FromLong(s))) goto end;
        if (PyDict_SetItemString(kwds, "co_stacksize", stacksize) != 0) goto end;
        if (!(flags=PyLong_FromLong(f))) goto end;
        if (PyDict_SetItemString(kwds, "co_flags", flags) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_code", code) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_consts", c) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_names", n) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_varnames", v) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_freevars", fv) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_cellvars", cell) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_linetable", lnos) != 0) goto end;
        if (!(fn_cstr=PyUnicode_AsUTF8AndSize(fn, NULL))) goto end;
        if (!(name_cstr=PyUnicode_AsUTF8AndSize(name, NULL))) goto end;
        if (!(co = PyCode_NewEmpty(fn_cstr, name_cstr, fline))) goto end;
        if (!(replace = PyObject_GetAttrString((PyObject*)co, "replace"))) goto cleanup_code_too;
        if (!(empty = PyTuple_New(0))) goto cleanup_code_too; // unfortunately __pyx_empty_tuple isn't available here
        if (!(call_result = PyObject_Call(replace, empty, kwds))) goto cleanup_code_too;
        Py_XDECREF((PyObject*)co);
        co = (PyCodeObject*)call_result;
        call_result = NULL;
        if (0) {
            cleanup_code_too:
            Py_XDECREF((PyObject*)co);
            co = NULL;
        }
        end:
        Py_XDECREF(kwds);
        Py_XDECREF(argcount);
        Py_XDECREF(posonlyargcount);
        Py_XDECREF(kwonlyargcount);
        Py_XDECREF(nlocals);
        Py_XDECREF(stacksize);
        Py_XDECREF(replace);
        Py_XDECREF(call_result);
        Py_XDECREF(empty);
        if (type) {
            PyErr_Restore(type, value, traceback);
        }
        return co;
    }
#else
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
#endif
  #define __Pyx_DefaultClassType PyType_Type
#endif
#ifndef Py_TPFLAGS_CHECKTYPES
  #define Py_TPFLAGS_CHECKTYPES 0
#endif
#ifndef Py_TPFLAGS_HAVE_INDEX
  #define Py_TPFLAGS_HAVE_INDEX 0
#endif
#ifndef Py_TPFLAGS_HAVE_NEWBUFFER
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif
#ifndef Py_TPFLAGS_HAVE_FINALIZE
  #define Py_TPFLAGS_HAVE_FINALIZE 0
#endif
#ifndef METH_STACKLESS
  #define METH_STACKLESS 0
#endif
#if PY_VERSION_HEX <= 0x030700A3 || !defined(METH_FASTCALL)
  #ifndef METH_FASTCALL
     #define METH_FASTCALL 0x80
  #endif
  typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject *const *args, Py_ssize_t nargs);
  typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject *const *args,
                                                          Py_ssize_t nargs, PyObject *kwnames);
#else
  #define __Pyx_PyCFunctionFast _PyCFunctionFast
  #define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
#endif
#if CYTHON_FAST_PYCCALL
#define __Pyx_PyFastCFunction_Check(func)\
    ((PyCFunction_Check(func) && (METH_FASTCALL == (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)))))
#else
#define __Pyx_PyFastCFunction_Check(func) 0
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Malloc)
  #define PyObject_Malloc(s)   PyMem_Malloc(s)
  #define PyObject_Free(p)     PyMem_Free(p)
  #define PyObject_Realloc(p)  PyMem_Realloc(p)
#endif
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030400A1
  #define PyMem_RawMalloc(n)           PyMem_Malloc(n)
  #define PyMem_RawRealloc(p, n)       PyMem_Realloc(p, n)
  #define PyMem_RawFree(p)             PyMem_Free(p)
#endif
#if CYTHON_COMPILING_IN_PYSTON
  #define __Pyx_PyCode_HasFreeVars(co)  PyCode_HasFreeVars(co)
  #define __Pyx_PyFrame_SetLineNumber(frame, lineno) PyFrame_SetLineNumber(frame, lineno)
#else
  #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
  #define __Pyx_PyFrame_SetLineNumber(frame, lineno)  (frame)->f_lineno = (lineno)
#endif
#if !CYTHON_FAST_THREAD_STATE || PY_VERSION_HEX < 0x02070000
  #define __Pyx_PyThreadState_Current PyThreadState_GET()
#elif PY_VERSION_HEX >= 0x03060000
  #define __Pyx_PyThreadState_Current _PyThreadState_UncheckedGet()
#elif PY_VERSION_HEX >= 0x03000000
  #define __Pyx_PyThreadState_Current PyThreadState_GET()
#else
  #define __Pyx_PyThreadState_Current _PyThreadState_Current
#endif
#if PY_VERSION_HEX < 0x030700A2 && !defined(PyThread_tss_create) && !defined(Py_tss_NEEDS_INIT)
#include "pythread.h"
#define Py_tss_NEEDS_INIT 0
typedef int Py_tss_t;
static CYTHON_INLINE int PyThread_tss_create(Py_tss_t *key) {
  *key = PyThread_create_key();
  return 0;
}
static CYTHON_INLINE Py_tss_t * PyThread_tss_alloc(void) {
  Py_tss_t *key = (Py_tss_t *)PyObject_Malloc(sizeof(Py_tss_t));
  *key = Py_tss_NEEDS_INIT;
  return key;
}
static CYTHON_INLINE void PyThread_tss_free(Py_tss_t *key) {
  PyObject_Free(key);
}
static CYTHON_INLINE int PyThread_tss_is_created(Py_tss_t *key) {
  return *key != Py_tss_NEEDS_INIT;
}
static CYTHON_INLINE void PyThread_tss_delete(Py_tss_t *key) {
  PyThread_delete_key(*key);
  *key = Py_tss_NEEDS_INIT;
}
static CYTHON_INLINE int PyThread_tss_set(Py_tss_t *key, void *value) {
  return PyThread_set_key_value(*key, value);
}
static CYTHON_INLINE void * PyThread_tss_get(Py_tss_t *key) {
  return PyThread_get_key_value(*key);
}
#endif
#if CYTHON_COMPILING_IN_CPYTHON || defined(_PyDict_NewPresized)
#define __Pyx_PyDict_NewPresized(n)  ((n <= 8) ? PyDict_New() : _PyDict_NewPresized(n))
#else
#define __Pyx_PyDict_NewPresized(n)  PyDict_New()
#endif
#if PY_MAJOR_VERSION >= 3 || CYTHON_FUTURE_DIVISION
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
#endif
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && CYTHON_USE_UNICODE_INTERNALS
#define __Pyx_PyDict_GetItemStr(dict, name)  _PyDict_GetItem_KnownHash(dict, name, ((PyASCIIObject *) name)->hash)
#else
#define __Pyx_PyDict_GetItemStr(dict, name)  PyDict_GetItem(dict, name)
#endif
#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
  #define CYTHON_PEP393_ENABLED 1
  #if PY_VERSION_HEX >= 0x030C0000
    #define __Pyx_PyUnicode_READY(op)       (0)
  #else
    #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
                                                0 : _PyUnicode_Ready((PyObject *)(op)))
  #endif
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   PyUnicode_MAX_CHAR_VALUE(u)
  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
  #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, ch)
  #if PY_VERSION_HEX >= 0x030C0000
    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_LENGTH(u))
  #else
    #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03090000
    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : ((PyCompactUnicodeObject *)(u))->wstr_length))
    #else
    #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
    #endif
  #endif
#else
  #define CYTHON_PEP393_ENABLED 0
  #define PyUnicode_1BYTE_KIND  1
  #define PyUnicode_2BYTE_KIND  2
  #define PyUnicode_4BYTE_KIND  4
  #define __Pyx_PyUnicode_READY(op)       (0)
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((sizeof(Py_UNICODE) == 2) ? 65535 : 1114111)
  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
  #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  (((void)(k)), ((Py_UNICODE*)d)[i] = ch)
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_SIZE(u))
#endif
#if CYTHON_COMPILING_IN_PYPY
  #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
#else
  #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ?\
      PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyUnicode_Contains)
  #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyByteArray_Check)
  #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Format)
  #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
#endif
#define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None || (PyString_Check(b) && !PyString_CheckExact(b)))) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None || (PyUnicode_Check(b) && !PyUnicode_CheckExact(b)))) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
#else
  #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
#endif
#if PY_MAJOR_VERSION < 3 && !defined(PyObject_ASCII)
  #define PyObject_ASCII(o)            PyObject_Repr(o)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
#ifndef PyObject_Unicode
  #define PyObject_Unicode             PyObject_Str
#endif
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
#else
  #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
  #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
#endif
#ifndef PySet_CheckExact
  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
#endif
#if PY_VERSION_HEX >= 0x030900A4
  #define __Pyx_SET_REFCNT(obj, refcnt) Py_SET_REFCNT(obj, refcnt)
  #define __Pyx_SET_SIZE(obj, size) Py_SET_SIZE(obj, size)
#else
  #define __Pyx_SET_REFCNT(obj, refcnt) Py_REFCNT(obj) = (refcnt)
  #define __Pyx_SET_SIZE(obj, size) Py_SIZE(obj) = (size)
#endif
#if CYTHON_ASSUME_SAFE_MACROS
  #define __Pyx_PySequence_SIZE(seq)  Py_SIZE(seq)
#else
  #define __Pyx_PySequence_SIZE(seq)  PySequence_Size(seq)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyIntObject                  PyLongObject
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
  #define PyNumber_Int                 PyNumber_Long
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBoolObject                 PyLongObject
#endif
#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_PYPY
  #ifndef PyUnicode_InternFromString
    #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
  #endif
#endif
#if PY_VERSION_HEX < 0x030200A4
  typedef long Py_hash_t;
  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsHash_t
#else
  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsSsize_t
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? ((void)(klass), PyMethod_New(func, self)) : __Pyx_NewRef(func))
#else
  #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
#endif
#if CYTHON_USE_ASYNC_SLOTS
  #if PY_VERSION_HEX >= 0x030500B1
    #define __Pyx_PyAsyncMethodsStruct PyAsyncMethods
    #define __Pyx_PyType_AsAsync(obj) (Py_TYPE(obj)->tp_as_async)
  #else
    #define __Pyx_PyType_AsAsync(obj) ((__Pyx_PyAsyncMethodsStruct*) (Py_TYPE(obj)->tp_reserved))
  #endif
#else
  #define __Pyx_PyType_AsAsync(obj) NULL
#endif
#ifndef __Pyx_PyAsyncMethodsStruct
    typedef struct {
        unaryfunc am_await;
        unaryfunc am_aiter;
        unaryfunc am_anext;
    } __Pyx_PyAsyncMethodsStruct;
#endif

#if defined(_WIN32) || defined(WIN32) || defined(MS_WINDOWS)
  #if !defined(_USE_MATH_DEFINES)
    #define _USE_MATH_DEFINES
  #endif
#endif
#include <math.h>
#ifdef NAN
#define __PYX_NAN() ((float) NAN)
#else
static CYTHON_INLINE float __PYX_NAN() {
  float value;
  memset(&value, 0xFF, sizeof(value));
  return value;
}
#endif
#if defined(__CYGWIN__) && defined(_LDBL_EQ_DBL)
#define __Pyx_truncl trunc
#else
#define __Pyx_truncl truncl
#endif

#define __PYX_MARK_ERR_POS(f_index, lineno) \
    { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__; (void)__pyx_clineno; }
#define __PYX_ERR(f_index, lineno, Ln_error) \
    { __PYX_MARK_ERR_POS(f_index, lineno) goto Ln_error; }

#ifndef __PYX_EXTERN_C
  #ifdef __cplusplus
    #define __PYX_EXTERN_C extern "C"
  #else
    #define __PYX_EXTERN_C extern
  #endif
#endif

#define __PYX_HAVE__validator
#define __PYX_HAVE_API__validator
/* Early includes */
#ifdef _OPENMP
#include <omp.h>
#endif /* _OPENMP */

#if defined(PYREX_WITHOUT_ASSERTIONS) && !defined(CYTHON_WITHOUT_ASSERTIONS)
#define CYTHON_WITHOUT_ASSERTIONS
#endif

typedef struct {PyObject **p; const char *s; const Py_ssize_t n; const char* encoding;
                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry;

#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_UTF8 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT (PY_MAJOR_VERSION >= 3 && __PYX_DEFAULT_STRING_ENCODING_IS_UTF8)
#define __PYX_DEFAULT_STRING_ENCODING ""
#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#define __Pyx_uchar_cast(c) ((unsigned char)c)
#define __Pyx_long_cast(x) ((long)x)
#define __Pyx_fits_Py_ssize_t(v, type, is_signed)  (\
    (sizeof(type) < sizeof(Py_ssize_t))  ||\
    (sizeof(type) > sizeof(Py_ssize_t) &&\
          likely(v < (type)PY_SSIZE_T_MAX ||\
                 v == (type)PY_SSIZE_T_MAX)  &&\
          (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||\
                                v == (type)PY_SSIZE_T_MIN)))  ||\
    (sizeof(type) == sizeof(Py_ssize_t) &&\
          (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||\
                               v == (type)PY_SSIZE_T_MAX)))  )
static CYTHON_INLINE int __Pyx_is_valid_index(Py_ssize_t i, Py_ssize_t limit) {
    return (size_t) i < (size_t) limit;
}
#if defined (__cplusplus) && __cplusplus >= 201103L
    #include <cstdlib>
    #define __Pyx_sst_abs(value) std::abs(value)
#elif SIZEOF_INT >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) abs(value)
#elif SIZEOF_LONG >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) labs(value)
#elif defined (_MSC_VER)
    #define __Pyx_sst_abs(value) ((Py_ssize_t)_abs64(value))
#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define __Pyx_sst_abs(value) llabs(value)
#elif defined (__GNUC__)
    #define __Pyx_sst_abs(value) __builtin_llabs(value)
#else
    #define __Pyx_sst_abs(value) ((value<0) ? -value : value)
#endif
static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject*);
static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
#define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
#define __Pyx_PyBytes_FromString        PyBytes_FromString
#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char*);
#if PY_MAJOR_VERSION < 3
    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#else
    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
#endif
#define __Pyx_PyBytes_AsWritableString(s)     ((char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsWritableSString(s)    ((signed char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsWritableUString(s)    ((unsigned char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsString(s)     ((const char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsSString(s)    ((const signed char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsUString(s)    ((const unsigned char*) PyBytes_AS_STRING(s))
#define __Pyx_PyObject_AsWritableString(s)    ((char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsWritableSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsWritableUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsSString(s)    ((const signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsUString(s)    ((const unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
#define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
#define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
#define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
#define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u) {
    const Py_UNICODE *u_end = u;
    while (*u_end++) ;
    return (size_t)(u_end - u - 1);
}
#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
#define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
#define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b);
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
#define __Pyx_PySequence_Tuple(obj)\
    (likely(PyTuple_CheckExact(obj)) ? __Pyx_NewRef(obj) : PySequence_Tuple(obj))
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject*);
#if CYTHON_ASSUME_SAFE_MACROS
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
#else
#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
#endif
#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
#if PY_MAJOR_VERSION >= 3
#define __Pyx_PyNumber_Int(x) (PyLong_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Long(x))
#else
#define __Pyx_PyNumber_Int(x) (PyInt_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Int(x))
#endif
#define __Pyx_PyNumber_Float(x) (PyFloat_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Float(x))
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
static int __Pyx_sys_getdefaultencoding_not_ascii;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    PyObject* ascii_chars_u = NULL;
    PyObject* ascii_chars_b = NULL;
    const char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    if (strcmp(default_encoding_c, "ascii") == 0) {
        __Pyx_sys_getdefaultencoding_not_ascii = 0;
    } else {
        char ascii_chars[128];
        int c;
        for (c = 0; c < 128; c++) {
            ascii_chars[c] = c;
        }
        __Pyx_sys_getdefaultencoding_not_ascii = 1;
        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
        if (!ascii_chars_u) goto bad;
        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
        if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
            PyErr_Format(
                PyExc_ValueError,
                "This module compiled with c_string_encoding=ascii, but default encoding '%.200s' is not a superset of ascii.",
                default_encoding_c);
            goto bad;
        }
        Py_DECREF(ascii_chars_u);
        Py_DECREF(ascii_chars_b);
    }
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    Py_XDECREF(ascii_chars_u);
    Py_XDECREF(ascii_chars_b);
    return -1;
}
#endif
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
#else
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
static char* __PYX_DEFAULT_STRING_ENCODING;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c) + 1);
    if (!__PYX_DEFAULT_STRING_ENCODING) goto bad;
    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    return -1;
}
#endif
#endif


/* Test for GCC > 2.95 */
#if defined(__GNUC__)     && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)))
  #define likely(x)   __builtin_expect(!!(x), 1)
  #define unlikely(x) __builtin_expect(!!(x), 0)
#else /* !__GNUC__ or GCC < 2.95 */
  #define likely(x)   (x)
  #define unlikely(x) (x)
#endif /* __GNUC__ */
static CYTHON_INLINE void __Pyx_pretend_to_initialize(void* ptr) { (void)ptr; }

static PyObject *__pyx_m = NULL;
static PyObject *__pyx_d;
static PyObject *__pyx_b;
static PyObject *__pyx_cython_runtime = NULL;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static PyObject *__pyx_empty_unicode;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;


static const char *__pyx_f[] = {
  "validator.pyx",
};

/*--- Type declarations ---*/
struct __pyx_obj_9validator___pyx_scope_struct__validate_scores;
struct __pyx_obj_9validator___pyx_scope_struct_1_genexpr;
struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types;
struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator;
struct __pyx_obj_9validator___pyx_scope_struct_4_validate_length_range;
struct __pyx_obj_9validator___pyx_scope_struct_5_genexpr;
struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects;
struct __pyx_obj_9validator___pyx_scope_struct_7_genexpr;
struct __pyx_obj_9validator___pyx_scope_struct_8_genexpr;
struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy;
struct __pyx_obj_9validator___pyx_scope_struct_10_genexpr;
struct __pyx_obj_9validator___pyx_scope_struct_11_genexpr;
struct __pyx_obj_9validator___pyx_scope_struct_12_check_classification_targets;
struct __pyx_obj_9validator___pyx_scope_struct_13_genexpr;
struct __pyx_obj_9validator___pyx_scope_struct_14__check_y;
struct __pyx_obj_9validator___pyx_scope_struct_15_genexpr;
struct __pyx_obj_9validator___pyx_scope_struct_16_genexpr;
struct __pyx_obj_9validator___pyx_scope_struct_17_has_required_attributes;
struct __pyx_obj_9validator___pyx_scope_struct_18_genexpr;
struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates;
struct __pyx_obj_9validator___pyx_scope_struct_20_validate_and_adjust_ranges;
struct __pyx_obj_9validator___pyx_scope_struct_21_genexpr;
struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input;
struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args;
struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args;
struct __pyx_obj_9validator___pyx_scope_struct_25_check_scalar;
struct __pyx_obj_9validator___pyx_scope_struct_26_genexpr;
struct __pyx_obj_9validator___pyx_scope_struct_27__get_feature_names;
struct __pyx_obj_9validator___pyx_scope_struct_28_genexpr;
struct __pyx_obj_9validator___pyx_scope_struct_29_genexpr;
struct __pyx_obj_9validator___pyx_scope_struct_30_check_array;
struct __pyx_obj_9validator___pyx_scope_struct_31_genexpr;
struct __pyx_obj_9validator___pyx_scope_struct_32_genexpr;

/* "validator.pyx":159
 *     return valid_kwargs
 * 
 * def validate_scores(             # <<<<<<<<<<<<<<
 *     scores, true_labels=None,
 *     mode="strict",
 */
struct __pyx_obj_9validator___pyx_scope_struct__validate_scores {
  PyObject_HEAD
  PyObject *__pyx_v_mode;
  PyObject *__pyx_v_scores;
};


/* "validator.pyx":239
 *             raise ValueError("Mismatch in the number of outputs between"
 *                              " scores and true_labels.")
 *         if any(not _is_probability_distribution(             # <<<<<<<<<<<<<<
 *                 score, mode=mode) for score in scores):
 *             raise ValueError("Each set of scores must be a valid"
 */
struct __pyx_obj_9validator___pyx_scope_struct_1_genexpr {
  PyObject_HEAD
  struct __pyx_obj_9validator___pyx_scope_struct__validate_scores *__pyx_outer_scope;
  PyObject *__pyx_v_score;
};


/* "validator.pyx":999
 *     return df
 * 
 * def validate_data_types(             # <<<<<<<<<<<<<<
 *     data, expected_type='numeric',
 *     nan_policy='omit',
 */
struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types {
  PyObject_HEAD
  PyObject *__pyx_v_error;
};


/* "validator.pyx":1275
 *         return pd.api.types.is_categorical_dtype(col_type) or pd.api.types.is_object_dtype(col_type)
 * 
 * def parameter_validator(             # <<<<<<<<<<<<<<
 *         param_name, target_strs, match_method='contains',
 *         raise_exception=True, **kws):
 */
struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator {
  PyObject_HEAD
  PyObject *__pyx_v_kws;
  PyObject *__pyx_v_match_method;
  PyObject *__pyx_v_normalize_string;
  PyObject *__pyx_v_raise_exception;
  PyObject *__pyx_v_target_strs;
};


/* "validator.pyx":1424
 *     return distribution
 * 
 * def validate_length_range(length_range, sorted_values=True, param_name=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates the review length range ensuring it's a tuple with two integers
 */
struct __pyx_obj_9validator___pyx_scope_struct_4_validate_length_range {
  PyObject_HEAD
  PyObject *__pyx_v_length_range;
};


/* "validator.pyx":1467
 *     min_length, max_length = length_range
 * 
 *     if not all(isinstance(x, ( float, int, np.integer, np.floating)             # <<<<<<<<<<<<<<
 *                           ) for x in length_range):
 *         raise ValueError(f"Both elements in {param_name} must be integers.")
 */
struct __pyx_obj_9validator___pyx_scope_struct_5_genexpr {
  PyObject_HEAD
  struct __pyx_obj_9validator___pyx_scope_struct_4_validate_length_range *__pyx_outer_scope;
  PyObject *__pyx_v_x;
};


/* "validator.pyx":1481
 *     return length_range
 * 
 * def contains_nested_objects(lst, strict=False, allowed_types=None):             # <<<<<<<<<<<<<<
 *     """
 *     Determines whether a list contains nested objects.
 */
struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects {
  PyObject_HEAD
  PyObject *__pyx_v_allowed_types;
  PyObject *__pyx_v_is_nested;
  PyObject *__pyx_v_lst;
};


/* "validator.pyx":1537
 *     if strict:
 *         # Check if all items are nested objects
 *         return all(is_nested(item) for item in lst)             # <<<<<<<<<<<<<<
 *     else:
 *         # Check if any item is a nested object
 */
struct __pyx_obj_9validator___pyx_scope_struct_7_genexpr {
  PyObject_HEAD
  struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects *__pyx_outer_scope;
  PyObject *__pyx_v_item;
};


/* "validator.pyx":1540
 *     else:
 *         # Check if any item is a nested object
 *         return any(is_nested(item) for item in lst)             # <<<<<<<<<<<<<<
 * 
 * def validate_nan_policy(nan_policy, *arrays, sample_weights=None):
 */
struct __pyx_obj_9validator___pyx_scope_struct_8_genexpr {
  PyObject_HEAD
  struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects *__pyx_outer_scope;
  PyObject *__pyx_v_item;
};


/* "validator.pyx":1542
 *         return any(is_nested(item) for item in lst)
 * 
 * def validate_nan_policy(nan_policy, *arrays, sample_weights=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates and applies a specified nan_policy to input arrays and
 */
struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy {
  PyObject_HEAD
  PyObject *__pyx_v_arrays;
  PyObject *__pyx_v_not_nan_mask;
};


/* "validator.pyx":1613
 * 
 *         # Filter out NaNs from all arrays and sample_weights
 *         arrays = tuple(array[not_nan_mask] for array in arrays)             # <<<<<<<<<<<<<<
 *         if sample_weights is not None:
 *             sample_weights = sample_weights[not_nan_mask]
 */
struct __pyx_obj_9validator___pyx_scope_struct_10_genexpr {
  PyObject_HEAD
  struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy *__pyx_outer_scope;
  PyObject *__pyx_v_array;
  PyObject *__pyx_t_0;
  Py_ssize_t __pyx_t_1;
};


/* "validator.pyx":1619
 *     elif nan_policy == 'raise':
 *         # Check for NaNs in any of the arrays or sample_weights
 *         if any(np.isnan(array).any() for array in arrays) or (             # <<<<<<<<<<<<<<
 *                 sample_weights is not None and np.isnan(sample_weights).any()):
 *             raise ValueError("Input values contain NaNs and nan_policy is 'raise'.")
 */
struct __pyx_obj_9validator___pyx_scope_struct_11_genexpr {
  PyObject_HEAD
  struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy *__pyx_outer_scope;
  PyObject *__pyx_v_array;
};


/* "validator.pyx":2011
 *     return y_true, y_pred
 * 
 * def check_classification_targets(             # <<<<<<<<<<<<<<
 *     *y,
 *     target_type='numeric',
 */
struct __pyx_obj_9validator___pyx_scope_struct_12_check_classification_targets {
  PyObject_HEAD
  PyObject *__pyx_v_target;
};


/* "validator.pyx":2132
 *         # Try to convert validated targets to numeric (integer), if possible
 *         for i, target in enumerate(validated_targets):
 *             if all(isinstance(item, (int, float, np.integer, np.floating)) for item in target):             # <<<<<<<<<<<<<<
 *                 try:
 *                     # Attempt conversion to integer
 */
struct __pyx_obj_9validator___pyx_scope_struct_13_genexpr {
  PyObject_HEAD
  struct __pyx_obj_9validator___pyx_scope_struct_12_check_classification_targets *__pyx_outer_scope;
  PyObject *__pyx_v_item;
};


/* "validator.pyx":2158
 *     return validated_targets
 * 
 * def _check_y(y, strategy='auto'):             # <<<<<<<<<<<<<<
 *     """
 *     Validates the target array `y`, ensuring it is suitable for classification
 */
struct __pyx_obj_9validator___pyx_scope_struct_14__check_y {
  PyObject_HEAD
  PyObject *__pyx_v_unique_values;
  PyObject *__pyx_v_y;
};


/* "validator.pyx":2182
 *     else:
 *         # For non-numeric data, ensure no elements are None or equivalent to np.nan
 *         if any(el is None or el is np.nan for el in y):             # <<<<<<<<<<<<<<
 *             raise ValueError("Non-numeric target values contain None or NaN,"
 *                              " not suitable for classification.")
 */
struct __pyx_obj_9validator___pyx_scope_struct_15_genexpr {
  PyObject_HEAD
  struct __pyx_obj_9validator___pyx_scope_struct_14__check_y *__pyx_outer_scope;
  PyObject *__pyx_v_el;
};


/* "validator.pyx":2207
 *     # Check for non-numeric data convertibility to categorical if not already checked
 *     if y.dtype.kind not in numeric_types:
 *         if not all(isinstance(val, (str, bool, int)) for val in unique_values):             # <<<<<<<<<<<<<<
 *             raise ValueError("Target values must be categorical, numeric,"
 *                              " or convertible to categories.")
 */
struct __pyx_obj_9validator___pyx_scope_struct_16_genexpr {
  PyObject_HEAD
  struct __pyx_obj_9validator___pyx_scope_struct_14__check_y *__pyx_outer_scope;
  PyObject *__pyx_v_val;
};


/* "validator.pyx":2354
 *     return isinstance(model, (tf.keras.models.Model, tf.keras.Sequential))
 * 
 * def has_required_attributes(model: Any, attributes: list[str]) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Check if the model has all required Keras-specific attributes.
 */
struct __pyx_obj_9validator___pyx_scope_struct_17_has_required_attributes {
  PyObject_HEAD
  PyObject *__pyx_v_attributes;
  PyObject *__pyx_v_model;
};


/* "validator.pyx":2375
 *         True if the model contains all specified attributes, False otherwise.
 *     """
 *     return all(hasattr(model, attr) for attr in attributes)             # <<<<<<<<<<<<<<
 * 
 * def validate_dates(
 */
struct __pyx_obj_9validator___pyx_scope_struct_18_genexpr {
  PyObject_HEAD
  struct __pyx_obj_9validator___pyx_scope_struct_17_has_required_attributes *__pyx_outer_scope;
  PyObject *__pyx_v_attr;
};


/* "validator.pyx":2377
 *     return all(hasattr(model, attr) for attr in attributes)
 * 
 * def validate_dates(             # <<<<<<<<<<<<<<
 *         start_date, end_date, return_as_date_str=False, date_format="%Y-%m-%d"):
 *     """
 */
struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates {
  PyObject_HEAD
  PyObject *__pyx_v_date_format;
};


/* "validator.pyx":2541
 *     return int(value)
 * 
 * def validate_and_adjust_ranges(**kwargs):             # <<<<<<<<<<<<<<
 *     """
 *     Validates and adjusts the provided range tuples to ensure each is
 */
struct __pyx_obj_9validator___pyx_scope_struct_20_validate_and_adjust_ranges {
  PyObject_HEAD
  PyObject *__pyx_v_range_tuple;
};


/* "validator.pyx":2595
 *             raise ValueError(f"{range_name} must be a tuple of two values.")
 * 
 *         if not all(isinstance(value, (int, float)) for value in range_tuple):             # <<<<<<<<<<<<<<
 *             raise ValueError(f"{range_name} must contain numerical values.")
 * 
 */
struct __pyx_obj_9validator___pyx_scope_struct_21_genexpr {
  PyObject_HEAD
  struct __pyx_obj_9validator___pyx_scope_struct_20_validate_and_adjust_ranges *__pyx_outer_scope;
  PyObject *__pyx_v_value;
};


/* "validator.pyx":3159
 * 
 * 
 * def _validate_input(ignore: str, x, y, _is_arraylike_1d):             # <<<<<<<<<<<<<<
 *     """
 *     Validates that x and y are one-dimensional array-like structures based
 */
struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input {
  PyObject_HEAD
  PyObject *__pyx_v__is_arraylike_1d;
  PyObject *__pyx_v_x;
  PyObject *__pyx_v_y;
};


/* "validator.pyx":3348
 * 
 * 
 * def _deprecate_positional_args(func=None, *, version="1.3"):             # <<<<<<<<<<<<<<
 *     """Decorator for methods that issues warnings for positional arguments.
 *     Using the keyword-only argument syntax in pep 3102, arguments after the
 */
struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args {
  PyObject_HEAD
  PyObject *__pyx_v_version;
};


/* "validator.pyx":3360
 *     """
 * 
 *     def _inner_deprecate_positional_args(f):             # <<<<<<<<<<<<<<
 *         sig = signature(f)
 *         kwonly_args = []
 */
struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args {
  PyObject_HEAD
  struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args *__pyx_outer_scope;
  PyObject *__pyx_v_all_args;
  PyObject *__pyx_v_f;
  PyObject *__pyx_v_kwonly_args;
  PyObject *__pyx_v_name;
  PyObject *__pyx_v_sig;
};


/* "validator.pyx":3673
 *     return array
 * 
 * def check_scalar(             # <<<<<<<<<<<<<<
 *     x,
 *     name,
 */
struct __pyx_obj_9validator___pyx_scope_struct_25_check_scalar {
  PyObject_HEAD
  PyObject *__pyx_v_target_type;
  PyObject *__pyx_v_type_name;
};


/* "validator.pyx":3735
 *     if not isinstance(x, target_type):
 *         if isinstance(target_type, tuple):
 *             types_str = ", ".join(type_name(t) for t in target_type)             # <<<<<<<<<<<<<<
 *             target_type_str = f"{{{types_str}}}"
 *         else:
 */
struct __pyx_obj_9validator___pyx_scope_struct_26_genexpr {
  PyObject_HEAD
  struct __pyx_obj_9validator___pyx_scope_struct_25_check_scalar *__pyx_outer_scope;
  PyObject *__pyx_v_t;
};


/* "validator.pyx":3785
 * 
 * 
 * def _get_feature_names(X):             # <<<<<<<<<<<<<<
 *     """Get feature names from X.
 *     Support for other array containers should place its implementation here.
 */
struct __pyx_obj_9validator___pyx_scope_struct_27__get_feature_names {
  PyObject_HEAD
  PyObject *__pyx_v_feature_names;
};


/* "validator.pyx":3810
 *         return
 * 
 *     types = sorted(t.__qualname__ for t in set(type(v) for v in feature_names))             # <<<<<<<<<<<<<<
 * 
 *     # mixed type of string and non-string is not supported
 */
struct __pyx_obj_9validator___pyx_scope_struct_28_genexpr {
  PyObject_HEAD
  struct __pyx_obj_9validator___pyx_scope_struct_27__get_feature_names *__pyx_outer_scope;
  PyObject *__pyx_v_genexpr;
  PyObject *__pyx_v_t;
};

struct __pyx_obj_9validator___pyx_scope_struct_29_genexpr {
  PyObject_HEAD
  struct __pyx_obj_9validator___pyx_scope_struct_28_genexpr *__pyx_outer_scope;
  PyObject *__pyx_v_v;
};


/* "validator.pyx":4179
 * 
 * 
 * def check_array(             # <<<<<<<<<<<<<<
 *     array,
 *     *,
 */
struct __pyx_obj_9validator___pyx_scope_struct_30_check_array {
  PyObject_HEAD
  PyObject *__pyx_v_dtypes_orig;
};


/* "validator.pyx":4315
 *         dtypes_orig = list(array.dtypes)
 *         pandas_requires_conversion = any(
 *             _pandas_dtype_needs_early_conversion(i) for i in dtypes_orig             # <<<<<<<<<<<<<<
 *         )
 *         if all(isinstance(dtype_iter, np.dtype) for dtype_iter in dtypes_orig):
 */
struct __pyx_obj_9validator___pyx_scope_struct_31_genexpr {
  PyObject_HEAD
  struct __pyx_obj_9validator___pyx_scope_struct_30_check_array *__pyx_outer_scope;
  PyObject *__pyx_v_i;
};


/* "validator.pyx":4317
 *             _pandas_dtype_needs_early_conversion(i) for i in dtypes_orig
 *         )
 *         if all(isinstance(dtype_iter, np.dtype) for dtype_iter in dtypes_orig):             # <<<<<<<<<<<<<<
 *             dtype_orig = np.result_type(*dtypes_orig)
 *     #xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 */
struct __pyx_obj_9validator___pyx_scope_struct_32_genexpr {
  PyObject_HEAD
  struct __pyx_obj_9validator___pyx_scope_struct_30_check_array *__pyx_outer_scope;
  PyObject *__pyx_v_dtype_iter;
};


/* --- Runtime support code (head) --- */
/* Refnanny.proto */
#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif
#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
#ifdef WITH_THREAD
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          if (acquire_gil) {\
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
              PyGILState_Release(__pyx_gilstate_save);\
          } else {\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
          }
#else
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
#endif
  #define __Pyx_RefNannyFinishContext()\
          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
#else
  #define __Pyx_RefNannyDeclarations
  #define __Pyx_RefNannySetupContext(name, acquire_gil)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XINCREF(r) Py_XINCREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
  #define __Pyx_XGOTREF(r)
  #define __Pyx_XGIVEREF(r)
#endif
#define __Pyx_XDECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_XDECREF(tmp);\
    } while (0)
#define __Pyx_DECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_DECREF(tmp);\
    } while (0)
#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)

/* PyObjectGetAttrStr.proto */
#if CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name);
#else
#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
#endif

/* GetBuiltinName.proto */
static PyObject *__Pyx_GetBuiltinName(PyObject *name);

/* RaiseArgTupleInvalid.proto */
static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);

/* RaiseDoubleKeywords.proto */
static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);

/* ParseKeywords.proto */
static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],\
    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,\
    const char* function_name);

/* PyDictVersioning.proto */
#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
#define __PYX_DICT_VERSION_INIT  ((PY_UINT64_T) -1)
#define __PYX_GET_DICT_VERSION(dict)  (((PyDictObject*)(dict))->ma_version_tag)
#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)\
    (version_var) = __PYX_GET_DICT_VERSION(dict);\
    (cache_var) = (value);
#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP) {\
    static PY_UINT64_T __pyx_dict_version = 0;\
    static PyObject *__pyx_dict_cached_value = NULL;\
    if (likely(__PYX_GET_DICT_VERSION(DICT) == __pyx_dict_version)) {\
        (VAR) = __pyx_dict_cached_value;\
    } else {\
        (VAR) = __pyx_dict_cached_value = (LOOKUP);\
        __pyx_dict_version = __PYX_GET_DICT_VERSION(DICT);\
    }\
}
static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj);
static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj);
static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version);
#else
#define __PYX_GET_DICT_VERSION(dict)  (0)
#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)
#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP)  (VAR) = (LOOKUP);
#endif

/* GetModuleGlobalName.proto */
#if CYTHON_USE_DICT_VERSIONS
#define __Pyx_GetModuleGlobalName(var, name)  do {\
    static PY_UINT64_T __pyx_dict_version = 0;\
    static PyObject *__pyx_dict_cached_value = NULL;\
    (var) = (likely(__pyx_dict_version == __PYX_GET_DICT_VERSION(__pyx_d))) ?\
        (likely(__pyx_dict_cached_value) ? __Pyx_NewRef(__pyx_dict_cached_value) : __Pyx_GetBuiltinName(name)) :\
        __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
} while(0)
#define __Pyx_GetModuleGlobalNameUncached(var, name)  do {\
    PY_UINT64_T __pyx_dict_version;\
    PyObject *__pyx_dict_cached_value;\
    (var) = __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
} while(0)
static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value);
#else
#define __Pyx_GetModuleGlobalName(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
#define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
#endif

/* PyCFunctionFastCall.proto */
#if CYTHON_FAST_PYCCALL
static CYTHON_INLINE PyObject *__Pyx_PyCFunction_FastCall(PyObject *func, PyObject **args, Py_ssize_t nargs);
#else
#define __Pyx_PyCFunction_FastCall(func, args, nargs)  (assert(0), NULL)
#endif

/* PyFunctionFastCall.proto */
#if CYTHON_FAST_PYCALL
#define __Pyx_PyFunction_FastCall(func, args, nargs)\
    __Pyx_PyFunction_FastCallDict((func), (args), (nargs), NULL)
#if 1 || PY_VERSION_HEX < 0x030600B1
static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs);
#else
#define __Pyx_PyFunction_FastCallDict(func, args, nargs, kwargs) _PyFunction_FastCallDict(func, args, nargs, kwargs)
#endif
#define __Pyx_BUILD_ASSERT_EXPR(cond)\
    (sizeof(char [1 - 2*!(cond)]) - 1)
#ifndef Py_MEMBER_SIZE
#define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)
#endif
#if CYTHON_FAST_PYCALL
  static size_t __pyx_pyframe_localsplus_offset = 0;
  #include "frameobject.h"
#if PY_VERSION_HEX >= 0x030b00a6
  #ifndef Py_BUILD_CORE
    #define Py_BUILD_CORE 1
  #endif
  #include "internal/pycore_frame.h"
#endif
  #define __Pxy_PyFrame_Initialize_Offsets()\
    ((void)__Pyx_BUILD_ASSERT_EXPR(sizeof(PyFrameObject) == offsetof(PyFrameObject, f_localsplus) + Py_MEMBER_SIZE(PyFrameObject, f_localsplus)),\
     (void)(__pyx_pyframe_localsplus_offset = ((size_t)PyFrame_Type.tp_basicsize) - Py_MEMBER_SIZE(PyFrameObject, f_localsplus)))
  #define __Pyx_PyFrame_GetLocalsplus(frame)\
    (assert(__pyx_pyframe_localsplus_offset), (PyObject **)(((char *)(frame)) + __pyx_pyframe_localsplus_offset))
#endif // CYTHON_FAST_PYCALL
#endif

/* PyObjectCall.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
#else
#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
#endif

/* PyObjectCall2Args.proto */
static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2);

/* PyObjectCallMethO.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
#endif

/* PyObjectCallOneArg.proto */
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);

/* CallableCheck.proto */
#if CYTHON_USE_TYPE_SLOTS && PY_MAJOR_VERSION >= 3
#define __Pyx_PyCallable_Check(obj)   (Py_TYPE(obj)->tp_call != NULL)
#else
#define __Pyx_PyCallable_Check(obj)   PyCallable_Check(obj)
#endif

/* PyObjectCallNoArg.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func);
#else
#define __Pyx_PyObject_CallNoArg(func) __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL)
#endif

/* IterFinish.proto */
static CYTHON_INLINE int __Pyx_IterFinish(void);

/* PyObjectGetMethod.proto */
static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method);

/* PyObjectCallMethod0.proto */
static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name);

/* RaiseNeedMoreValuesToUnpack.proto */
static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);

/* RaiseTooManyValuesToUnpack.proto */
static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);

/* UnpackItemEndCheck.proto */
static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected);

/* RaiseNoneIterError.proto */
static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);

/* UnpackTupleError.proto */
static void __Pyx_UnpackTupleError(PyObject *, Py_ssize_t index);

/* UnpackTuple2.proto */
#define __Pyx_unpack_tuple2(tuple, value1, value2, is_tuple, has_known_size, decref_tuple)\
    (likely(is_tuple || PyTuple_Check(tuple)) ?\
        (likely(has_known_size || PyTuple_GET_SIZE(tuple) == 2) ?\
            __Pyx_unpack_tuple2_exact(tuple, value1, value2, decref_tuple) :\
            (__Pyx_UnpackTupleError(tuple, 2), -1)) :\
        __Pyx_unpack_tuple2_generic(tuple, value1, value2, has_known_size, decref_tuple))
static CYTHON_INLINE int __Pyx_unpack_tuple2_exact(
    PyObject* tuple, PyObject** value1, PyObject** value2, int decref_tuple);
static int __Pyx_unpack_tuple2_generic(
    PyObject* tuple, PyObject** value1, PyObject** value2, int has_known_size, int decref_tuple);

/* dict_iter.proto */
static CYTHON_INLINE PyObject* __Pyx_dict_iterator(PyObject* dict, int is_dict, PyObject* method_name,
                                                   Py_ssize_t* p_orig_length, int* p_is_dict);
static CYTHON_INLINE int __Pyx_dict_iter_next(PyObject* dict_or_iter, Py_ssize_t orig_length, Py_ssize_t* ppos,
                                              PyObject** pkey, PyObject** pvalue, PyObject** pitem, int is_dict);

/* pyfrozenset_new.proto */
static CYTHON_INLINE PyObject* __Pyx_PyFrozenSet_New(PyObject* it);

/* PySetContains.proto */
static CYTHON_INLINE int __Pyx_PySet_ContainsTF(PyObject* key, PyObject* set, int eq);

/* None.proto */
static CYTHON_INLINE void __Pyx_RaiseClosureNameError(const char *varname);

/* PyThreadStateGet.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
#define __Pyx_PyThreadState_assign  __pyx_tstate = __Pyx_PyThreadState_Current;
#define __Pyx_PyErr_Occurred()  __pyx_tstate->curexc_type
#else
#define __Pyx_PyThreadState_declare
#define __Pyx_PyThreadState_assign
#define __Pyx_PyErr_Occurred()  PyErr_Occurred()
#endif

/* PyErrFetchRestore.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyErr_Clear() __Pyx_ErrRestore(NULL, NULL, NULL)
#define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_PyErr_SetNone(exc) (Py_INCREF(exc), __Pyx_ErrRestore((exc), NULL, NULL))
#else
#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
#endif
#else
#define __Pyx_PyErr_Clear() PyErr_Clear()
#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
#define __Pyx_ErrRestoreWithState(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
#define __Pyx_ErrRestoreInState(tstate, type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetchInState(tstate, type, value, tb)  PyErr_Fetch(type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
#endif

/* RaiseException.proto */
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);

/* IncludeStringH.proto */
#include <string.h>

/* BytesEquals.proto */
static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);

/* UnicodeEquals.proto */
static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals);

/* PyObjectFormatSimple.proto */
#if CYTHON_COMPILING_IN_PYPY
    #define __Pyx_PyObject_FormatSimple(s, f) (\
        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
        PyObject_Format(s, f))
#elif PY_MAJOR_VERSION < 3
    #define __Pyx_PyObject_FormatSimple(s, f) (\
        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
        likely(PyString_CheckExact(s)) ? PyUnicode_FromEncodedObject(s, NULL, "strict") :\
        PyObject_Format(s, f))
#elif CYTHON_USE_TYPE_SLOTS
    #define __Pyx_PyObject_FormatSimple(s, f) (\
        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
        likely(PyLong_CheckExact(s)) ? PyLong_Type.tp_str(s) :\
        likely(PyFloat_CheckExact(s)) ? PyFloat_Type.tp_str(s) :\
        PyObject_Format(s, f))
#else
    #define __Pyx_PyObject_FormatSimple(s, f) (\
        likely(PyUnicode_CheckExact(s)) ? (Py_INCREF(s), s) :\
        PyObject_Format(s, f))
#endif

/* JoinPyUnicode.proto */
static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
                                      Py_UCS4 max_char);

/* PyIntCompare.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_NeObjC(PyObject *op1, PyObject *op2, long intval, long inplace);

/* GetItemInt.proto */
#define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) :\
    (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) :\
               __Pyx_GetItemInt_Generic(o, to_py_func(i))))
#define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_List_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
    (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
#define __Pyx_GetItemInt_Tuple(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_Tuple_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
    (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
                                                     int is_list, int wraparound, int boundscheck);

/* GetTopmostException.proto */
#if CYTHON_USE_EXC_INFO_STACK
static _PyErr_StackItem * __Pyx_PyErr_GetTopmostException(PyThreadState *tstate);
#endif

/* SaveResetException.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_ExceptionSave(type, value, tb)  __Pyx__ExceptionSave(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#define __Pyx_ExceptionReset(type, value, tb)  __Pyx__ExceptionReset(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
#else
#define __Pyx_ExceptionSave(type, value, tb)   PyErr_GetExcInfo(type, value, tb)
#define __Pyx_ExceptionReset(type, value, tb)  PyErr_SetExcInfo(type, value, tb)
#endif

/* PyErrExceptionMatches.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
#else
#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
#endif

/* GetException.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_GetException(type, value, tb)  __Pyx__GetException(__pyx_tstate, type, value, tb)
static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#else
static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);
#endif

/* SwapException.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_ExceptionSwap(type, value, tb)  __Pyx__ExceptionSwap(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#else
static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb);
#endif

/* PySequenceContains.proto */
static CYTHON_INLINE int __Pyx_PySequence_ContainsTF(PyObject* item, PyObject* seq, int eq) {
    int result = PySequence_Contains(seq, item);
    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
}

/* PyIntCompare.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_EqObjC(PyObject *op1, PyObject *op2, long intval, long inplace);

/* PyObjectFormatAndDecref.proto */
static CYTHON_INLINE PyObject* __Pyx_PyObject_FormatSimpleAndDecref(PyObject* s, PyObject* f);
static CYTHON_INLINE PyObject* __Pyx_PyObject_FormatAndDecref(PyObject* s, PyObject* f);

/* PyObjectSetAttrStr.proto */
#if CYTHON_USE_TYPE_SLOTS
#define __Pyx_PyObject_DelAttrStr(o,n) __Pyx_PyObject_SetAttrStr(o, n, NULL)
static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value);
#else
#define __Pyx_PyObject_DelAttrStr(o,n)   PyObject_DelAttr(o,n)
#define __Pyx_PyObject_SetAttrStr(o,n,v) PyObject_SetAttr(o,n,v)
#endif

/* ObjectGetItem.proto */
#if CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key);
#else
#define __Pyx_PyObject_GetItem(obj, key)  PyObject_GetItem(obj, key)
#endif

/* FetchCommonType.proto */
static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);

/* CythonFunctionShared.proto */
#define __Pyx_CyFunction_USED 1
#define __Pyx_CYFUNCTION_STATICMETHOD  0x01
#define __Pyx_CYFUNCTION_CLASSMETHOD   0x02
#define __Pyx_CYFUNCTION_CCLASS        0x04
#define __Pyx_CyFunction_GetClosure(f)\
    (((__pyx_CyFunctionObject *) (f))->func_closure)
#define __Pyx_CyFunction_GetClassObj(f)\
    (((__pyx_CyFunctionObject *) (f))->func_classobj)
#define __Pyx_CyFunction_Defaults(type, f)\
    ((type *)(((__pyx_CyFunctionObject *) (f))->defaults))
#define __Pyx_CyFunction_SetDefaultsGetter(f, g)\
    ((__pyx_CyFunctionObject *) (f))->defaults_getter = (g)
typedef struct {
    PyCFunctionObject func;
#if PY_VERSION_HEX < 0x030500A0
    PyObject *func_weakreflist;
#endif
    PyObject *func_dict;
    PyObject *func_name;
    PyObject *func_qualname;
    PyObject *func_doc;
    PyObject *func_globals;
    PyObject *func_code;
    PyObject *func_closure;
    PyObject *func_classobj;
    void *defaults;
    int defaults_pyobjects;
    size_t defaults_size;  // used by FusedFunction for copying defaults
    int flags;
    PyObject *defaults_tuple;
    PyObject *defaults_kwdict;
    PyObject *(*defaults_getter)(PyObject *);
    PyObject *func_annotations;
} __pyx_CyFunctionObject;
static PyTypeObject *__pyx_CyFunctionType = 0;
#define __Pyx_CyFunction_Check(obj)  (__Pyx_TypeCheck(obj, __pyx_CyFunctionType))
static PyObject *__Pyx_CyFunction_Init(__pyx_CyFunctionObject* op, PyMethodDef *ml,
                                      int flags, PyObject* qualname,
                                      PyObject *self,
                                      PyObject *module, PyObject *globals,
                                      PyObject* code);
static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *m,
                                                         size_t size,
                                                         int pyobjects);
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *m,
                                                            PyObject *tuple);
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *m,
                                                             PyObject *dict);
static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *m,
                                                              PyObject *dict);
static int __pyx_CyFunction_init(void);

/* CythonFunction.proto */
static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml,
                                      int flags, PyObject* qualname,
                                      PyObject *closure,
                                      PyObject *module, PyObject *globals,
                                      PyObject* code);

/* MergeKeywords.proto */
static int __Pyx_MergeKeywords(PyObject *kwdict, PyObject *source_mapping);

/* Import.proto */
static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);

/* ImportFrom.proto */
static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);

/* GetAttr.proto */
static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *, PyObject *);

/* HasAttr.proto */
static CYTHON_INLINE int __Pyx_HasAttr(PyObject *, PyObject *);

/* ListAppend.proto */
#if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
    PyListObject* L = (PyListObject*) list;
    Py_ssize_t len = Py_SIZE(list);
    if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
        Py_INCREF(x);
        PyList_SET_ITEM(list, len, x);
        __Pyx_SET_SIZE(list, len + 1);
        return 0;
    }
    return PyList_Append(list, x);
}
#else
#define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
#endif

/* ListCompAppend.proto */
#if CYTHON_USE_PYLIST_INTERNALS && CYTHON_ASSUME_SAFE_MACROS
static CYTHON_INLINE int __Pyx_ListComp_Append(PyObject* list, PyObject* x) {
    PyListObject* L = (PyListObject*) list;
    Py_ssize_t len = Py_SIZE(list);
    if (likely(L->allocated > len)) {
        Py_INCREF(x);
        PyList_SET_ITEM(list, len, x);
        __Pyx_SET_SIZE(list, len + 1);
        return 0;
    }
    return PyList_Append(list, x);
}
#else
#define __Pyx_ListComp_Append(L,x) PyList_Append(L,x)
#endif

/* PyIntBinop.proto */
#if !CYTHON_COMPILING_IN_PYPY
static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, long intval, int inplace, int zerodivision_check);
#else
#define __Pyx_PyInt_AddObjC(op1, op2, intval, inplace, zerodivision_check)\
    (inplace ? PyNumber_InPlaceAdd(op1, op2) : PyNumber_Add(op1, op2))
#endif

/* SliceTupleAndList.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyList_GetSlice(PyObject* src, Py_ssize_t start, Py_ssize_t stop);
static CYTHON_INLINE PyObject* __Pyx_PyTuple_GetSlice(PyObject* src, Py_ssize_t start, Py_ssize_t stop);
#else
#define __Pyx_PyList_GetSlice(seq, start, stop)   PySequence_GetSlice(seq, start, stop)
#define __Pyx_PyTuple_GetSlice(seq, start, stop)  PySequence_GetSlice(seq, start, stop)
#endif

/* PyUnicodeContains.proto */
static CYTHON_INLINE int __Pyx_PyUnicode_ContainsTF(PyObject* substring, PyObject* text, int eq) {
    int result = PyUnicode_Contains(text, substring);
    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
}

/* PyUnicode_Unicode.proto */
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_Unicode(PyObject *obj);

/* KeywordStringCheck.proto */
static int __Pyx_CheckKeywordStrings(PyObject *kwdict, const char* function_name, int kw_allowed);

/* ArgTypeTest.proto */
#define __Pyx_ArgTypeTest(obj, type, none_allowed, name, exact)\
    ((likely((Py_TYPE(obj) == type) | (none_allowed && (obj == Py_None)))) ? 1 :\
        __Pyx__ArgTypeTest(obj, type, name, exact))
static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact);

/* IterNext.proto */
#define __Pyx_PyIter_Next(obj) __Pyx_PyIter_Next2(obj, NULL)
static CYTHON_INLINE PyObject *__Pyx_PyIter_Next2(PyObject *, PyObject *);

/* dict_getitem_default.proto */
static PyObject* __Pyx_PyDict_GetItemDefault(PyObject* d, PyObject* key, PyObject* default_value);

/* UnpackUnboundCMethod.proto */
typedef struct {
    PyObject *type;
    PyObject **method_name;
    PyCFunction func;
    PyObject *method;
    int flag;
} __Pyx_CachedCFunction;

/* CallUnboundCMethod1.proto */
static PyObject* __Pyx__CallUnboundCMethod1(__Pyx_CachedCFunction* cfunc, PyObject* self, PyObject* arg);
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_CallUnboundCMethod1(__Pyx_CachedCFunction* cfunc, PyObject* self, PyObject* arg);
#else
#define __Pyx_CallUnboundCMethod1(cfunc, self, arg)  __Pyx__CallUnboundCMethod1(cfunc, self, arg)
#endif

/* CallUnboundCMethod2.proto */
static PyObject* __Pyx__CallUnboundCMethod2(__Pyx_CachedCFunction* cfunc, PyObject* self, PyObject* arg1, PyObject* arg2);
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030600B1
static CYTHON_INLINE PyObject *__Pyx_CallUnboundCMethod2(__Pyx_CachedCFunction *cfunc, PyObject *self, PyObject *arg1, PyObject *arg2);
#else
#define __Pyx_CallUnboundCMethod2(cfunc, self, arg1, arg2)  __Pyx__CallUnboundCMethod2(cfunc, self, arg1, arg2)
#endif

/* DictGetItem.proto */
#if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
static PyObject *__Pyx_PyDict_GetItem(PyObject *d, PyObject* key);
#define __Pyx_PyObject_Dict_GetItem(obj, name)\
    (likely(PyDict_CheckExact(obj)) ?\
     __Pyx_PyDict_GetItem(obj, name) : PyObject_GetItem(obj, name))
#else
#define __Pyx_PyDict_GetItem(d, key) PyObject_GetItem(d, key)
#define __Pyx_PyObject_Dict_GetItem(obj, name)  PyObject_GetItem(obj, name)
#endif

/* py_abs.proto */
#if CYTHON_USE_PYLONG_INTERNALS
static PyObject *__Pyx_PyLong_AbsNeg(PyObject *num);
#define __Pyx_PyNumber_Absolute(x)\
    ((likely(PyLong_CheckExact(x))) ?\
         (likely(Py_SIZE(x) >= 0) ? (Py_INCREF(x), (x)) : __Pyx_PyLong_AbsNeg(x)) :\
         PyNumber_Absolute(x))
#else
#define __Pyx_PyNumber_Absolute(x)  PyNumber_Absolute(x)
#endif

/* set_iter.proto */
static CYTHON_INLINE PyObject* __Pyx_set_iterator(PyObject* iterable, int is_set,
                                                  Py_ssize_t* p_orig_length, int* p_source_is_set);
static CYTHON_INLINE int __Pyx_set_iter_next(
        PyObject* iter_obj, Py_ssize_t orig_length,
        Py_ssize_t* ppos, PyObject **value,
        int source_is_set);

/* GetAttr3.proto */
static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *, PyObject *, PyObject *);

/* GCCDiagnostics.proto */
#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
#define __Pyx_HAS_GCC_DIAGNOSTIC
#endif

/* BuildPyUnicode.proto */
static PyObject* __Pyx_PyUnicode_BuildFromAscii(Py_ssize_t ulength, char* chars, int clength,
                                                int prepend_sign, char padding_char);

/* CIntToPyUnicode.proto */
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_From_Py_ssize_t(Py_ssize_t value, Py_ssize_t width, char padding_char, char format_char);

/* PyObjectLookupSpecial.proto */
#if CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PyObject* __Pyx_PyObject_LookupSpecial(PyObject* obj, PyObject* attr_name) {
    PyObject *res;
    PyTypeObject *tp = Py_TYPE(obj);
#if PY_MAJOR_VERSION < 3
    if (unlikely(PyInstance_Check(obj)))
        return __Pyx_PyObject_GetAttrStr(obj, attr_name);
#endif
    res = _PyType_Lookup(tp, attr_name);
    if (likely(res)) {
        descrgetfunc f = Py_TYPE(res)->tp_descr_get;
        if (!f) {
            Py_INCREF(res);
        } else {
            res = f(res, obj, (PyObject *)tp);
        }
    } else {
        PyErr_SetObject(PyExc_AttributeError, attr_name);
    }
    return res;
}
#else
#define __Pyx_PyObject_LookupSpecial(o,n) __Pyx_PyObject_GetAttrStr(o,n)
#endif

/* FastTypeChecks.proto */
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_TypeCheck(obj, type) __Pyx_IsSubtype(Py_TYPE(obj), (PyTypeObject *)type)
static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b);
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject *type);
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *type1, PyObject *type2);
#else
#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
#define __Pyx_PyErr_GivenExceptionMatches(err, type) PyErr_GivenExceptionMatches(err, type)
#define __Pyx_PyErr_GivenExceptionMatches2(err, type1, type2) (PyErr_GivenExceptionMatches(err, type1) || PyErr_GivenExceptionMatches(err, type2))
#endif
#define __Pyx_PyException_Check(obj) __Pyx_TypeCheck(obj, PyExc_Exception)

/* None.proto */
static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname);

/* PyObject_GenericGetAttrNoDict.proto */
#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name);
#else
#define __Pyx_PyObject_GenericGetAttrNoDict PyObject_GenericGetAttr
#endif

/* PatchModuleWithCoroutine.proto */
static PyObject* __Pyx_Coroutine_patch_module(PyObject* module, const char* py_code);

/* PatchInspect.proto */
static PyObject* __Pyx_patch_inspect(PyObject* module);

/* CalculateMetaclass.proto */
static PyObject *__Pyx_CalculateMetaclass(PyTypeObject *metaclass, PyObject *bases);

/* Py3ClassCreate.proto */
static PyObject *__Pyx_Py3MetaclassPrepare(PyObject *metaclass, PyObject *bases, PyObject *name, PyObject *qualname,
                                           PyObject *mkw, PyObject *modname, PyObject *doc);
static PyObject *__Pyx_Py3ClassCreate(PyObject *metaclass, PyObject *name, PyObject *bases, PyObject *dict,
                                      PyObject *mkw, int calculate_metaclass, int allow_py2_metaclass);

/* CLineInTraceback.proto */
#ifdef CYTHON_CLINE_IN_TRACEBACK
#define __Pyx_CLineForTraceback(tstate, c_line)  (((CYTHON_CLINE_IN_TRACEBACK)) ? c_line : 0)
#else
static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line);
#endif

/* CodeObjectCache.proto */
typedef struct {
    PyCodeObject* code_object;
    int code_line;
} __Pyx_CodeObjectCacheEntry;
struct __Pyx_CodeObjectCache {
    int count;
    int max_count;
    __Pyx_CodeObjectCacheEntry* entries;
};
static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
static PyCodeObject *__pyx_find_code_object(int code_line);
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);

/* AddTraceback.proto */
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);

/* CIntFromPy.proto */
static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);

/* PyObjectCallMethod1.proto */
static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg);

/* CoroutineBase.proto */
typedef PyObject *(*__pyx_coroutine_body_t)(PyObject *, PyThreadState *, PyObject *);
#if CYTHON_USE_EXC_INFO_STACK
#define __Pyx_ExcInfoStruct  _PyErr_StackItem
#else
typedef struct {
    PyObject *exc_type;
    PyObject *exc_value;
    PyObject *exc_traceback;
} __Pyx_ExcInfoStruct;
#endif
typedef struct {
    PyObject_HEAD
    __pyx_coroutine_body_t body;
    PyObject *closure;
    __Pyx_ExcInfoStruct gi_exc_state;
    PyObject *gi_weakreflist;
    PyObject *classobj;
    PyObject *yieldfrom;
    PyObject *gi_name;
    PyObject *gi_qualname;
    PyObject *gi_modulename;
    PyObject *gi_code;
    PyObject *gi_frame;
    int resume_label;
    char is_running;
} __pyx_CoroutineObject;
static __pyx_CoroutineObject *__Pyx__Coroutine_New(
    PyTypeObject *type, __pyx_coroutine_body_t body, PyObject *code, PyObject *closure,
    PyObject *name, PyObject *qualname, PyObject *module_name);
static __pyx_CoroutineObject *__Pyx__Coroutine_NewInit(
            __pyx_CoroutineObject *gen, __pyx_coroutine_body_t body, PyObject *code, PyObject *closure,
            PyObject *name, PyObject *qualname, PyObject *module_name);
static CYTHON_INLINE void __Pyx_Coroutine_ExceptionClear(__Pyx_ExcInfoStruct *self);
static int __Pyx_Coroutine_clear(PyObject *self);
static PyObject *__Pyx_Coroutine_Send(PyObject *self, PyObject *value);
static PyObject *__Pyx_Coroutine_Close(PyObject *self);
static PyObject *__Pyx_Coroutine_Throw(PyObject *gen, PyObject *args);
#if CYTHON_USE_EXC_INFO_STACK
#define __Pyx_Coroutine_SwapException(self)
#define __Pyx_Coroutine_ResetAndClearException(self)  __Pyx_Coroutine_ExceptionClear(&(self)->gi_exc_state)
#else
#define __Pyx_Coroutine_SwapException(self) {\
    __Pyx_ExceptionSwap(&(self)->gi_exc_state.exc_type, &(self)->gi_exc_state.exc_value, &(self)->gi_exc_state.exc_traceback);\
    __Pyx_Coroutine_ResetFrameBackpointer(&(self)->gi_exc_state);\
    }
#define __Pyx_Coroutine_ResetAndClearException(self) {\
    __Pyx_ExceptionReset((self)->gi_exc_state.exc_type, (self)->gi_exc_state.exc_value, (self)->gi_exc_state.exc_traceback);\
    (self)->gi_exc_state.exc_type = (self)->gi_exc_state.exc_value = (self)->gi_exc_state.exc_traceback = NULL;\
    }
#endif
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyGen_FetchStopIterationValue(pvalue)\
    __Pyx_PyGen__FetchStopIterationValue(__pyx_tstate, pvalue)
#else
#define __Pyx_PyGen_FetchStopIterationValue(pvalue)\
    __Pyx_PyGen__FetchStopIterationValue(__Pyx_PyThreadState_Current, pvalue)
#endif
static int __Pyx_PyGen__FetchStopIterationValue(PyThreadState *tstate, PyObject **pvalue);
static CYTHON_INLINE void __Pyx_Coroutine_ResetFrameBackpointer(__Pyx_ExcInfoStruct *exc_state);

/* PatchGeneratorABC.proto */
static int __Pyx_patch_abc(void);

/* Generator.proto */
#define __Pyx_Generator_USED
static PyTypeObject *__pyx_GeneratorType = 0;
#define __Pyx_Generator_CheckExact(obj) (Py_TYPE(obj) == __pyx_GeneratorType)
#define __Pyx_Generator_New(body, code, closure, name, qualname, module_name)\
    __Pyx__Coroutine_New(__pyx_GeneratorType, body, code, closure, name, qualname, module_name)
static PyObject *__Pyx_Generator_Next(PyObject *self);
static int __pyx_Generator_init(void);

/* CheckBinaryVersion.proto */
static int __Pyx_check_binary_version(void);

/* InitStrings.proto */
static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);


/* Module declarations from 'validator' */
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct__validate_scores = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_1_genexpr = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_2_validate_data_types = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_3_parameter_validator = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_4_validate_length_range = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_5_genexpr = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_6_contains_nested_objects = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_7_genexpr = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_8_genexpr = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_9_validate_nan_policy = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_10_genexpr = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_11_genexpr = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_12_check_classification_targets = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_13_genexpr = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_14__check_y = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_15_genexpr = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_16_genexpr = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_17_has_required_attributes = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_18_genexpr = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_19_validate_dates = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_20_validate_and_adjust_ranges = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_21_genexpr = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_22__validate_input = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_23__deprecate_positional_args = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_24__inner_deprecate_positional_args = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_25_check_scalar = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_26_genexpr = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_27__get_feature_names = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_28_genexpr = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_29_genexpr = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_30_check_array = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_31_genexpr = 0;
static PyTypeObject *__pyx_ptype_9validator___pyx_scope_struct_32_genexpr = 0;
#define __Pyx_MODULE_NAME "validator"
extern int __pyx_module_is_main_validator;
int __pyx_module_is_main_validator = 0;

/* Implementation of 'validator' */
static PyObject *__pyx_builtin_all;
static PyObject *__pyx_builtin_UserWarning;
static PyObject *__pyx_builtin_ValueError;
static PyObject *__pyx_builtin_TypeError;
static PyObject *__pyx_builtin_RuntimeWarning;
static PyObject *__pyx_builtin_sum;
static PyObject *__pyx_builtin_enumerate;
static PyObject *__pyx_builtin_print;
static PyObject *__pyx_builtin_object;
static PyObject *__pyx_builtin_any;
static PyObject *__pyx_builtin_map;
static PyObject *__pyx_builtin_range;
static PyObject *__pyx_builtin_AttributeError;
static PyObject *__pyx_builtin_FutureWarning;
static PyObject *__pyx_builtin_zip;
static PyObject *__pyx_builtin_vars;
static PyObject *__pyx_builtin_ImportError;
static const char __pyx_k_C[] = "C";
static const char __pyx_k_O[] = "O";
static const char __pyx_k_T[] = "T";
static const char __pyx_k_X[] = "X";
static const char __pyx_k_a[] = " a ";
static const char __pyx_k_c[] = "c";
static const char __pyx_k_d[] = "d";
static const char __pyx_k_e[] = "e";
static const char __pyx_k_f[] = "f";
static const char __pyx_k_i[] = "i";
static const char __pyx_k_k[] = "k";
static const char __pyx_k_l[] = "l";
static const char __pyx_k_o[] = "o";
static const char __pyx_k_t[] = "t";
static const char __pyx_k_v[] = "v";
static const char __pyx_k_x[] = "x";
static const char __pyx_k_y[] = "y";
static const char __pyx_k_01[] = "01";
static const char __pyx_k__7[] = "";
static const char __pyx_k_df[] = "df";
static const char __pyx_k_fc[] = "fc";
static const char __pyx_k_ge[] = "ge";
static const char __pyx_k_gt[] = "gt";
static const char __pyx_k_in[] = " in ";
static const char __pyx_k_is[] = " is ";
static const char __pyx_k_iu[] = "iu";
static const char __pyx_k_le[] = "le";
static const char __pyx_k_lt[] = "lt";
static const char __pyx_k_np[] = "np";
static const char __pyx_k_pd[] = "pd";
static const char __pyx_k_re[] = "re";
static const char __pyx_k_sp[] = "sp";
static const char __pyx_k_tf[] = "tf";
static const char __pyx_k_to[] = "to";
static const char __pyx_k_xp[] = "xp";
static const char __pyx_k_1_3[] = "1.3";
static const char __pyx_k_Any[] = "Any";
static const char __pyx_k_Got[] = ". Got ";
static const char __pyx_k_NaN[] = "NaN";
static const char __pyx_k_USV[] = "USV";
static const char __pyx_k__16[] = ".";
static const char __pyx_k__18[] = "\342\210\236";
static const char __pyx_k__52[] = "'.";
static const char __pyx_k__53[] = "'";
static const char __pyx_k__54[] = "...";
static const char __pyx_k__63[] = "/";
static const char __pyx_k__64[] = "-";
static const char __pyx_k__81[] = " ";
static const char __pyx_k__82[] = "{}={}";
static const char __pyx_k__83[] = ", ";
static const char __pyx_k__92[] = "{";
static const char __pyx_k__93[] = "}";
static const char __pyx_k__97[] = " == ";
static const char __pyx_k__98[] = ">=";
static const char __pyx_k__99[] = ">";
static const char __pyx_k_all[] = "all";
static const char __pyx_k_and[] = " and ";
static const char __pyx_k_any[] = "any";
static const char __pyx_k_api[] = "api";
static const char __pyx_k_ar1[] = "ar1";
static const char __pyx_k_ar2[] = "ar2";
static const char __pyx_k_arg[] = "arg";
static const char __pyx_k_arr[] = "arr";
static const char __pyx_k_bsr[] = "bsr";
static const char __pyx_k_col[] = "col";
static const char __pyx_k_coo[] = "coo";
static const char __pyx_k_csc[] = "csc";
static const char __pyx_k_csr[] = "csr";
static const char __pyx_k_doc[] = "__doc__";
static const char __pyx_k_eps[] = "eps";
static const char __pyx_k_err[] = "err";
static const char __pyx_k_fit[] = "fit";
static const char __pyx_k_get[] = "get";
static const char __pyx_k_got[] = ", got ";
static const char __pyx_k_int[] = "int";
static const char __pyx_k_isf[] = "isf";
static const char __pyx_k_key[] = "key";
static const char __pyx_k_kws[] = "kws";
static const char __pyx_k_len[] = "__len__";
static const char __pyx_k_loc[] = "loc";
static const char __pyx_k_lst[] = "lst";
static const char __pyx_k_map[] = "map";
static const char __pyx_k_max[] = "max";
static const char __pyx_k_min[] = "min";
static const char __pyx_k_msg[] = "msg";
static const char __pyx_k_nan[] = "nan";
static const char __pyx_k_not[] = ", not ";
static const char __pyx_k_now[] = "now";
static const char __pyx_k_o_2[] = " o";
static const char __pyx_k_o_3[] = "o_";
static const char __pyx_k_obj[] = "obj";
static const char __pyx_k_row[] = "row";
static const char __pyx_k_sig[] = "sig";
static const char __pyx_k_std[] = "std";
static const char __pyx_k_str[] = "str";
static const char __pyx_k_sum[] = "sum";
static const char __pyx_k_tol[] = "tol";
static const char __pyx_k_zip[] = "zip";
static const char __pyx_k_Data[] = "Data";
static const char __pyx_k_None[] = "None";
static const char __pyx_k_Pass[] = "Pass ";
static const char __pyx_k_Real[] = "Real";
static const char __pyx_k_Year[] = "Year ";
static const char __pyx_k__100[] = "<=";
static const char __pyx_k__101[] = "<";
static const char __pyx_k__102[] = "_";
static const char __pyx_k__103[] = "__";
static const char __pyx_k__113[] = ". ";
static const char __pyx_k__117[] = "\n";
static const char __pyx_k__118[] = "*";
static const char __pyx_k_args[] = "args";
static const char __pyx_k_atol[] = "atol";
static const char __pyx_k_attr[] = "attr";
static const char __pyx_k_auto[] = "auto";
static const char __pyx_k_axis[] = "axis";
static const char __pyx_k_bool[] = "bool";
static const char __pyx_k_both[] = "both";
static const char __pyx_k_ceil[] = "ceil";
static const char __pyx_k_copy[] = "copy";
static const char __pyx_k_data[] = "data";
static const char __pyx_k_diff[] = "diff";
static const char __pyx_k_exit[] = "__exit__";
static const char __pyx_k_from[] = " from ";
static const char __pyx_k_func[] = "func";
static const char __pyx_k_isin[] = "isin";
static const char __pyx_k_item[] = "item";
static const char __pyx_k_iter[] = "__iter__";
static const char __pyx_k_keys[] = "keys";
static const char __pyx_k_kind[] = "kind";
static const char __pyx_k_left[] = "left";
static const char __pyx_k_main[] = "__main__";
static const char __pyx_k_math[] = "math";
static const char __pyx_k_mean[] = "mean";
static const char __pyx_k_mode[] = "mode";
static const char __pyx_k_mute[] = "mute";
static const char __pyx_k_name[] = "__name__";
static const char __pyx_k_ndim[] = "ndim";
static const char __pyx_k_omit[] = "omit";
static const char __pyx_k_only[] = "only";
static const char __pyx_k_over[] = "over";
static const char __pyx_k_rand[] = "rand";
static const char __pyx_k_safe[] = "safe";
static const char __pyx_k_seed[] = "seed";
static const char __pyx_k_send[] = "send";
static const char __pyx_k_size[] = "size";
static const char __pyx_k_soft[] = "soft";
static const char __pyx_k_sqrt[] = "sqrt";
static const char __pyx_k_test[] = "__test__";
static const char __pyx_k_type[] = "type_";
static const char __pyx_k_util[] = "util";
static const char __pyx_k_vars[] = "vars";
static const char __pyx_k_warn[] = "warn";
static const char __pyx_k_year[] = "year";
static const char __pyx_k_Array[] = "Array '";
static const char __pyx_k_Input[] = "Input ";
static const char __pyx_k_Model[] = "Model";
static const char __pyx_k_Union[] = "Union";
static const char __pyx_k_Value[] = "Value '";
static const char __pyx_k_Y_m_d[] = "%Y-%m-%d";
static const char __pyx_k_align[] = "align";
static const char __pyx_k_all_2[] = "__all__";
static const char __pyx_k_and_2[] = "' and '";
static const char __pyx_k_apply[] = "apply";
static const char __pyx_k_array[] = "array";
static const char __pyx_k_biufc[] = "biufc";
static const char __pyx_k_buifc[] = "buifc";
static const char __pyx_k_cache[] = "cache";
static const char __pyx_k_check[] = "check";
static const char __pyx_k_class[] = "__class__";
static const char __pyx_k_close[] = "close";
static const char __pyx_k_dtype[] = "dtype";
static const char __pyx_k_empty[] = "empty";
static const char __pyx_k_enter[] = "__enter__";
static const char __pyx_k_error[] = "error";
static const char __pyx_k_extra[] = "extra";
static const char __pyx_k_float[] = "float";
static const char __pyx_k_floor[] = "floor";
static const char __pyx_k_force[] = "force";
static const char __pyx_k_frame[] = "frame";
static const char __pyx_k_got_2[] = "), got ";
static const char __pyx_k_index[] = "index";
static const char __pyx_k_int32[] = "int32";
static const char __pyx_k_int64[] = "int64";
static const char __pyx_k_isinf[] = "isinf";
static const char __pyx_k_isnan[] = "isnan";
static const char __pyx_k_items[] = "items";
static const char __pyx_k_keras[] = "keras";
static const char __pyx_k_lower[] = "lower";
static const char __pyx_k_match[] = "match";
static const char __pyx_k_model[] = "model";
static const char __pyx_k_notna[] = "notna";
static const char __pyx_k_numpy[] = "numpy";
static const char __pyx_k_order[] = "order";
static const char __pyx_k_param[] = "param";
static const char __pyx_k_print[] = "print";
static const char __pyx_k_raise[] = "raise";
static const char __pyx_k_range[] = "range";
static const char __pyx_k_ravel[] = "ravel";
static const char __pyx_k_right[] = "right";
static const char __pyx_k_shape[] = "shape";
static const char __pyx_k_start[] = "start";
static const char __pyx_k_strip[] = "strip";
static const char __pyx_k_throw[] = "throw";
static const char __pyx_k_tocsr[] = "tocsr";
static const char __pyx_k_total[] = "total";
static const char __pyx_k_types[] = "types";
static const char __pyx_k_value[] = "value";
static const char __pyx_k_wraps[] = "wraps";
static const char __pyx_k_Column[] = "Column '";
static const char __pyx_k_Expect[] = "Expect";
static const char __pyx_k_Memory[] = "Memory";
static const char __pyx_k_Series[] = "Series";
static const char __pyx_k_arrays[] = "arrays";
static const char __pyx_k_astype[] = "astype";
static const char __pyx_k_coerce[] = "coerce";
static const char __pyx_k_column[] = "column";
static const char __pyx_k_dropna[] = "dropna";
static const char __pyx_k_dtypes[] = "dtypes";
static const char __pyx_k_equals[] = "equals";
static const char __pyx_k_errors[] = "errors";
static const char __pyx_k_fitted[] = "fitted";
static const char __pyx_k_format[] = "format";
static const char __pyx_k_ignore[] = "ignore";
static const char __pyx_k_import[] = "__import__";
static const char __pyx_k_indptr[] = "indptr";
static const char __pyx_k_isnull[] = "isnull";
static const char __pyx_k_joblib[] = "joblib";
static const char __pyx_k_kwargs[] = "kwargs";
static const char __pyx_k_mathex[] = "mathex";
static const char __pyx_k_matrix[] = "matrix";
static const char __pyx_k_memory[] = "memory";
static const char __pyx_k_method[] = "method";
static const char __pyx_k_models[] = "models";
static const char __pyx_k_module[] = "__module__";
static const char __pyx_k_mtrand[] = "mtrand";
static const char __pyx_k_name_2[] = "name";
static const char __pyx_k_number[] = "number";
static const char __pyx_k_object[] = "object";
static const char __pyx_k_only_2[] = "_only";
static const char __pyx_k_pandas[] = "pandas";
static const char __pyx_k_rand_2[] = "_rand";
static const char __pyx_k_random[] = "random";
static const char __pyx_k_result[] = "result";
static const char __pyx_k_scores[] = "scores";
static const char __pyx_k_sparse[] = "sparse";
static const char __pyx_k_strict[] = "strict";
static const char __pyx_k_suffix[] = "suffix";
static const char __pyx_k_target[] = "target";
static const char __pyx_k_typing[] = "typing";
static const char __pyx_k_unique[] = "unique";
static const char __pyx_k_update[] = "update";
static const char __pyx_k_values[] = "values";
static const char __pyx_k_y_eval[] = "y_eval";
static const char __pyx_k_y_pred[] = "y_pred";
static const char __pyx_k_y_true[] = "y_true";
static const char __pyx_k_zscore[] = "zscore";
static const char __pyx_k_Array_2[] = "Array ";
static const char __pyx_k_Value_2[] = "Value ";
static const char __pyx_k_array_2[] = "__array__";
static const char __pyx_k_asarray[] = "asarray";
static const char __pyx_k_casting[] = "casting";
static const char __pyx_k_check_y[] = "check_y";
static const char __pyx_k_columns[] = "columns";
static const char __pyx_k_compile[] = "compile";
static const char __pyx_k_df_only[] = "df_only";
static const char __pyx_k_epsilon[] = "epsilon";
static const char __pyx_k_err_msg[] = "err_msg";
static const char __pyx_k_expects[] = " expects";
static const char __pyx_k_feature[] = "feature";
static const char __pyx_k_flatten[] = "flatten";
static const char __pyx_k_float16[] = "float16";
static const char __pyx_k_float32[] = "float32";
static const char __pyx_k_float64[] = "float64";
static const char __pyx_k_genexpr[] = "genexpr";
static const char __pyx_k_has_inf[] = "has_inf";
static const char __pyx_k_indices[] = "indices";
static const char __pyx_k_inner_f[] = "inner_f";
static const char __pyx_k_inspect[] = "inspect";
static const char __pyx_k_instead[] = " instead.";
static const char __pyx_k_integer[] = "integer";
static const char __pyx_k_isclass[] = "isclass";
static const char __pyx_k_isclose[] = "isclose";
static const char __pyx_k_lengths[] = "lengths";
static const char __pyx_k_max_val[] = "max_val";
static const char __pyx_k_message[] = "message";
static const char __pyx_k_min_val[] = "min_val";
static const char __pyx_k_msg_err[] = "msg_err";
static const char __pyx_k_must_be[] = " must be ";
static const char __pyx_k_ndarray[] = "ndarray";
static const char __pyx_k_neither[] = "neither";
static const char __pyx_k_newaxis[] = "newaxis";
static const char __pyx_k_numbers[] = "numbers";
static const char __pyx_k_numeric[] = "numeric";
static const char __pyx_k_nunique[] = "nunique";
static const char __pyx_k_objname[] = "objname";
static const char __pyx_k_predict[] = "predict";
static const char __pyx_k_prepare[] = "__prepare__";
static const char __pyx_k_replace[] = "replace";
static const char __pyx_k_reshape[] = "reshape";
static const char __pyx_k_results[] = "results";
static const char __pyx_k_silence[] = "silence";
static const char __pyx_k_summary[] = "summary";
static const char __pyx_k_uniques[] = "uniques";
static const char __pyx_k_unknown[] = "unknown";
static const char __pyx_k_verbose[] = "verbose";
static const char __pyx_k_version[] = "version";
static const char __pyx_k_weights[] = "weights";
static const char __pyx_k_Callable[] = "Callable";
static const char __pyx_k_Expected[] = "Expected '";
static const char __pyx_k_Integral[] = "Integral";
static const char __pyx_k_Optional[] = "Optional";
static const char __pyx_k_all_args[] = "all_args";
static const char __pyx_k_allclose[] = "allclose";
static const char __pyx_k_allow_nd[] = "allow_nd";
static const char __pyx_k_args_msg[] = "args_msg";
static const char __pyx_k_arr_name[] = "arr_name";
static const char __pyx_k_asformat[] = "asformat";
static const char __pyx_k_biselect[] = "biselect";
static const char __pyx_k_builtins[] = "builtins";
static const char __pyx_k_category[] = "category";
static const char __pyx_k_cls_name[] = "cls_name";
static const char __pyx_k_col_data[] = "col_data";
static const char __pyx_k_col_type[] = "col_type";
static const char __pyx_k_contains[] = "contains";
static const char __pyx_k_datetime[] = "datetime";
static const char __pyx_k_elements[] = "elements";
static const char __pyx_k_end_date[] = "end_date";
static const char __pyx_k_endswith[] = "endswith";
static const char __pyx_k_errstate[] = "errstate";
static const char __pyx_k_floating[] = "floating";
static const char __pyx_k_is_frame[] = "is_frame";
static const char __pyx_k_isfinite[] = "isfinite";
static const char __pyx_k_isscalar[] = "isscalar";
static const char __pyx_k_issparse[] = "issparse";
static const char __pyx_k_location[] = "location";
static const char __pyx_k_module_2[] = "module";
static const char __pyx_k_operator[] = "operator";
static const char __pyx_k_pd_dtype[] = "pd_dtype";
static const char __pyx_k_qualname[] = "__qualname__";
static const char __pyx_k_spmatrix[] = "spmatrix";
static const char __pyx_k_strategy[] = "strategy";
static const char __pyx_k_strftime[] = "strftime";
static const char __pyx_k_strptime[] = "strptime";
static const char __pyx_k_suppress[] = "suppress";
static const char __pyx_k_time_col[] = "time_col";
static const char __pyx_k_to_array[] = "to_array";
static const char __pyx_k_to_frame[] = "to_frame";
static const char __pyx_k_to_numpy[] = "to_numpy";
static const char __pyx_k_type_err[] = "type_err";
static const char __pyx_k_warn_msg[] = "warn_msg";
static const char __pyx_k_warnings[] = "warnings";
static const char __pyx_k_y_arrays[] = "y_arrays";
static const char __pyx_k_DataFrame[] = "DataFrame";
static const char __pyx_k_Parameter[] = "Parameter";
static const char __pyx_k_TypeError[] = "TypeError";
static const char __pyx_k_alignment[] = "alignment";
static const char __pyx_k_allow_nan[] = "allow-nan";
static const char __pyx_k_array_api[] = "_array_api";
static const char __pyx_k_categoric[] = "categoric";
static const char __pyx_k_check_X_y[] = "check_X_y";
static const char __pyx_k_check_y_2[] = "_check_y";
static const char __pyx_k_condition[] = "condition";
static const char __pyx_k_coreutils[] = "coreutils";
static const char __pyx_k_data_type[] = "data_type";
static const char __pyx_k_dataframe[] = "dataframe";
static const char __pyx_k_ensure_2d[] = "ensure_2d";
static const char __pyx_k_enumerate[] = "enumerate";
static const char __pyx_k_estimator[] = "estimator";
static const char __pyx_k_find_spec[] = "find_spec";
static const char __pyx_k_full_like[] = "full_like";
static const char __pyx_k_functools[] = "functools";
static const char __pyx_k_getformat[] = "getformat";
static const char __pyx_k_importlib[] = "importlib";
static const char __pyx_k_intervals[] = "intervals";
static const char __pyx_k_is_nested[] = "is_nested";
static const char __pyx_k_is_normed[] = "is_normed";
static const char __pyx_k_isbuiltin[] = "isbuiltin";
static const char __pyx_k_max_value[] = "max_value";
static const char __pyx_k_metaclass[] = "__metaclass__";
static const char __pyx_k_min_value[] = "min_value";
static const char __pyx_k_msg_dtype[] = "msg_dtype";
static const char __pyx_k_must_be_2[] = ", must be ";
static const char __pyx_k_n_samples[] = "n_samples";
static const char __pyx_k_new_dtype[] = "new_dtype";
static const char __pyx_k_normalize[] = "normalize";
static const char __pyx_k_numeric_y[] = "numeric_y";
static const char __pyx_k_ones_like[] = "ones_like";
static const char __pyx_k_parameter[] = "parameter";
static const char __pyx_k_propagate[] = "propagate";
static const char __pyx_k_signature[] = "signature";
static const char __pyx_k_symmetric[] = "symmetric";
static const char __pyx_k_type_name[] = "type_name";
static const char __pyx_k_types_str[] = "types_str";
static const char __pyx_k_validator[] = "validator";
static const char __pyx_k_value_err[] = "value_err";
static const char __pyx_k_y_numeric[] = "y_numeric";
static const char __pyx_k_IGNORECASE[] = "IGNORECASE";
static const char __pyx_k_Sequential[] = "Sequential";
static const char __pyx_k_ValueError[] = "ValueError";
static const char __pyx_k_align_mode[] = "align_mode";
static const char __pyx_k_all_or_any[] = "all_or_any";
static const char __pyx_k_array_orig[] = "array_orig";
static const char __pyx_k_attributes[] = "attributes";
static const char __pyx_k_biselector[] = "biselector";
static const char __pyx_k_check_mode[] = "check_mode";
static const char __pyx_k_check_y_1d[] = "_check_y_1d";
static const char __pyx_k_contains_2[] = "contains ";
static const char __pyx_k_contextlib[] = "contextlib";
static const char __pyx_k_continuous[] = "continuous";
static const char __pyx_k_conversion[] = "conversion";
static const char __pyx_k_convert_to[] = "convert_to";
static const char __pyx_k_deep_check[] = "deep_check";
static const char __pyx_k_dependency[] = "_dependency";
static const char __pyx_k_dtype_orig[] = "dtype_orig";
static const char __pyx_k_elements_2[] = " elements";
static const char __pyx_k_exceptions[] = "exceptions";
static const char __pyx_k_expected_2[] = " expected <= 2.";
static const char __pyx_k_extra_args[] = "extra_args";
static const char __pyx_k_fill_value[] = "fill_value";
static const char __pyx_k_index_keys[] = "index_keys";
static const char __pyx_k_input_name[] = "input_name";
static const char __pyx_k_is_buildin[] = "_is_buildin";
static const char __pyx_k_is_numeric[] = "is_numeric";
static const char __pyx_k_issubdtype[] = "issubdtype";
static const char __pyx_k_max_length[] = "max_length";
static const char __pyx_k_min_length[] = "min_length";
static const char __pyx_k_n_features[] = "n_features";
static const char __pyx_k_nan_policy[] = "nan_policy";
static const char __pyx_k_param_name[] = "param_name";
static const char __pyx_k_parameters[] = "parameters";
static const char __pyx_k_qualname_2[] = "qualname";
static const char __pyx_k_range_name[] = "range_name";
static const char __pyx_k_raw_values[] = "raw_values";
static const char __pyx_k_stacklevel[] = "stacklevel";
static const char __pyx_k_start_date[] = "start_date";
static const char __pyx_k_startswith[] = "startswith";
static const char __pyx_k_tensorflow[] = "tensorflow";
static const char __pyx_k_to_numeric[] = "to_numeric";
static const char __pyx_k_type_error[] = "type_error";
static const char __pyx_k_weighted_y[] = "weighted_y";
static const char __pyx_k_with_shape[] = " with shape ";
static const char __pyx_k_xy_numeric[] = "xy_numeric";
static const char __pyx_k_year_input[] = "year_input";
static const char __pyx_k_zeros_mask[] = "zeros_mask";
static const char __pyx_k_Choose_from[] = ". Choose from ";
static const char __pyx_k_Columns_for[] = "Columns for ";
static const char __pyx_k_ImportError[] = "ImportError";
static const char __pyx_k_RandomState[] = "RandomState";
static const char __pyx_k_SparseDtype[] = "SparseDtype";
static const char __pyx_k_Time_column[] = "Time column '";
static const char __pyx_k_UserWarning[] = "UserWarning";
static const char __pyx_k_allow_nan_2[] = "allow_nan";
static const char __pyx_k_array_equal[] = "array_equal";
static const char __pyx_k_best_params[] = "best_params_";
static const char __pyx_k_check_array[] = "check_array";
static const char __pyx_k_column_orig[] = "column_orig";
static const char __pyx_k_computation[] = " computation.";
static const char __pyx_k_concatenate[] = "concatenate";
static const char __pyx_k_date_format[] = "date_format";
static const char __pyx_k_dt_datetime[] = "dt|datetime";
static const char __pyx_k_dtypes_orig[] = "dtypes_orig";
static const char __pyx_k_is_required[] = " is required.";
static const char __pyx_k_kwonly_args[] = "kwonly_args";
static const char __pyx_k_metric_name[] = "metric_name";
static const char __pyx_k_module_spec[] = "module_spec";
static const char __pyx_k_non_numeric[] = "non_numeric";
static const char __pyx_k_num_samples[] = "_num_samples";
static const char __pyx_k_param_value[] = "param_value";
static const char __pyx_k_passthrough[] = "passthrough";
static const char __pyx_k_range_tuple[] = "range_tuple";
static const char __pyx_k_result_type[] = "result_type";
static const char __pyx_k_return_data[] = "return_data";
static const char __pyx_k_round_float[] = "round_float";
static const char __pyx_k_target_strs[] = "target_strs";
static const char __pyx_k_target_type[] = "target_type";
static const char __pyx_k_to_datetime[] = "to_datetime";
static const char __pyx_k_true_labels[] = "true_labels";
static const char __pyx_k_validate_yy[] = "validate_yy";
static const char __pyx_k_value_lower[] = "value_lower";
static const char __pyx_k_FLOAT_DTYPES[] = "FLOAT_DTYPES";
static const char __pyx_k_KEYWORD_ONLY[] = "KEYWORD_ONLY";
static const char __pyx_k_allowed_dims[] = "allowed_dims";
static const char __pyx_k_assert_xy_in[] = "assert_xy_in";
static const char __pyx_k_base_epsilon[] = "base_epsilon";
static const char __pyx_k_callable_obj[] = "callable_obj";
static const char __pyx_k_check_memory[] = "check_memory";
static const char __pyx_k_check_scalar[] = "check_scalar";
static const char __pyx_k_column_stack[] = "column_stack";
static const char __pyx_k_current_year[] = "current_year";
static const char __pyx_k_custom_check[] = "custom_check";
static const char __pyx_k_distribution[] = "distribution";
static const char __pyx_k_first_sample[] = "first_sample";
static const char __pyx_k_include_zero[] = "include_zero";
static const char __pyx_k_is_array_api[] = "is_array_api";
static const char __pyx_k_is_arraylike[] = "_is_arraylike";
static const char __pyx_k_is_categoric[] = "is_categoric";
static const char __pyx_k_is_dataframe[] = "is_dataframe";
static const char __pyx_k_is_installed[] = "is_installed";
static const char __pyx_k_length_range[] = "length_range";
static const char __pyx_k_match_method[] = "match_method";
static const char __pyx_k_multi_output[] = "multi_output";
static const char __pyx_k_not_nan_mask[] = "not_nan_mask";
static const char __pyx_k_num_features[] = "_num_features";
static const char __pyx_k_numeric_only[] = "numeric_only";
static const char __pyx_k_replace_with[] = "replace_with";
static const char __pyx_k_respectively[] = "' respectively.";
static const char __pyx_k_scale_factor[] = "scale_factor";
static const char __pyx_k_scipy_sparse[] = "scipy.sparse";
static const char __pyx_k_simplefilter[] = "simplefilter";
static const char __pyx_k_to_dtype_str[] = "to_dtype_str";
static const char __pyx_k_valid_kwargs[] = "valid_kwargs";
static const char __pyx_k_valid_params[] = "valid_params";
static const char __pyx_k_valid_values[] = "valid_values";
static const char __pyx_k_Conversion_of[] = "Conversion of ";
static const char __pyx_k_FutureWarning[] = "FutureWarning";
static const char __pyx_k_Invalid_input[] = "Invalid input '";
static const char __pyx_k_NUMERIC_KINDS[] = "_NUMERIC_KINDS";
static const char __pyx_k_The_parameter[] = "The parameter '";
static const char __pyx_k_accept_sparse[] = "accept_sparse";
static const char __pyx_k_allowed_types[] = "allowed_types";
static const char __pyx_k_build_data_if[] = "build_data_if";
static const char __pyx_k_check_epsilon[] = "check_epsilon";
static const char __pyx_k_column_prefix[] = "column_prefix";
static const char __pyx_k_dtype_numeric[] = "dtype_numeric";
static const char __pyx_k_expected_type[] = "expected_type";
static const char __pyx_k_feature_names[] = "feature_names";
static const char __pyx_k_get_namespace[] = "get_namespace";
static const char __pyx_k_has_nan_error[] = "has_nan_error";
static const char __pyx_k_has_numerical[] = "has_numerical";
static const char __pyx_k_is_bool_dtype[] = "is_bool_dtype";
static const char __pyx_k_is_normalized[] = "is_normalized";
static const char __pyx_k_n_features_in[] = "n_features_in_";
static const char __pyx_k_numeric__only[] = "numeric(_only)?";
static const char __pyx_k_numeric_types[] = "numeric_types";
static const char __pyx_k_output_format[] = "output_format";
static const char __pyx_k_raise_warning[] = "raise_warning";
static const char __pyx_k_random_values[] = "random_values";
static const char __pyx_k_return_values[] = "return_values";
static const char __pyx_k_sample_weight[] = "sample_weight";
static const char __pyx_k_sorted_values[] = "sorted_values";
static const char __pyx_k_type_col_name[] = "type_col_name";
static const char __pyx_k_unique_values[] = "unique_values";
static const char __pyx_k_validator_pyx[] = "validator.pyx";
static const char __pyx_k_variable_name[] = "variable_name";
static const char __pyx_k_weights_array[] = "weights_array";
static const char __pyx_k_zero_division[] = "zero_division";
static const char __pyx_k_Array_at_index[] = "Array at index ";
static const char __pyx_k_AttributeError[] = "AttributeError";
static const char __pyx_k_ComplexWarning[] = "ComplexWarning";
static const char __pyx_k_NotFittedError[] = "NotFittedError";
static const char __pyx_k_RuntimeWarning[] = "RuntimeWarning";
static const char __pyx_k_allow_negative[] = "allow_negative";
static const char __pyx_k_array_to_frame[] = "array_to_frame";
static const char __pyx_k_best_estimator[] = "best_estimator_";
static const char __pyx_k_build_data_if2[] = "build_data_if2";
static const char __pyx_k_catch_warnings[] = "catch_warnings";
static const char __pyx_k_categoric_only[] = "categoric_only";
static const char __pyx_k_changed_format[] = "changed_format";
static const char __pyx_k_check_array_in[] = "_check_array_in";
static const char __pyx_k_coerce_numeric[] = "coerce_numeric";
static const char __pyx_k_dtype_selector[] = "dtype_selector";
static const char __pyx_k_estimator_name[] = "estimator_name";
static const char __pyx_k_exist_features[] = "exist_features";
static const char __pyx_k_generate_names[] = "generate_names";
static const char __pyx_k_handle_numeric[] = "_handle_numeric";
static const char __pyx_k_importlib_util[] = "importlib.util";
static const char __pyx_k_input_features[] = "input_features";
static const char __pyx_k_is_categorical[] = "is_categorical";
static const char __pyx_k_is_float_dtype[] = "is_float_dtype";
static const char __pyx_k_is_keras_model[] = "is_keras_model";
static const char __pyx_k_is_time_series[] = "is_time_series";
static const char __pyx_k_n_features_out[] = "n_features_out";
static const char __pyx_k_return_classes[] = "return_classes";
static const char __pyx_k_sample_s_shape[] = " sample(s) (shape=";
static const char __pyx_k_sample_weights[] = "sample_weights";
static const char __pyx_k_set_array_back[] = "set_array_back";
static const char __pyx_k_type_of_target[] = "type_of_target";
static const char __pyx_k_unique_classes[] = "unique_classes";
static const char __pyx_k_valid_policies[] = "valid_policies";
static const char __pyx_k_validate_dates[] = "validate_dates";
static const char __pyx_k_validate_input[] = "_validate_input";
static const char __pyx_k_Unsupports_mode[] = "Unsupports mode ";
static const char __pyx_k_adjusted_ranges[] = "adjusted_ranges";
static const char __pyx_k_array_to_frame2[] = "array_to_frame2";
static const char __pyx_k_average_uniform[] = "average_uniform";
static const char __pyx_k_check_is_fitted[] = "check_is_fitted";
static const char __pyx_k_check_symmetric[] = "check_symmetric";
static const char __pyx_k_coerce_datetime[] = "coerce_datetime";
static const char __pyx_k_complex_warning[] = "complex_warning";
static const char __pyx_k_feature_s_shape[] = " feature(s) (shape=";
static const char __pyx_k_has_categorical[] = "has_categorical";
static const char __pyx_k_is_arraylike_1d[] = "_is_arraylike_1d";
static const char __pyx_k_is_binary_class[] = "is_binary_class";
static const char __pyx_k_is_object_dtype[] = "is_object_dtype";
static const char __pyx_k_normalize_array[] = "normalize_array";
static const char __pyx_k_numeric_pattern[] = "numeric_pattern";
static const char __pyx_k_numpy_array_api[] = "numpy.array_api";
static const char __pyx_k_raise_exception[] = "raise_exception";
static const char __pyx_k_return_as_numpy[] = "return_as_numpy";
static const char __pyx_k_target_type_str[] = "target_type_str";
static const char __pyx_k_uniform_average[] = "uniform_average";
static const char __pyx_k_validate_scores[] = "validate_scores";
static const char __pyx_k_validation_mode[] = "validation_mode";
static const char __pyx_k_Both_elements_in[] = "Both elements in ";
static const char __pyx_k_CategoricalDtype[] = "CategoricalDtype";
static const char __pyx_k_Found_array_with[] = "Found array with ";
static const char __pyx_k_allowed_policies[] = "allowed_policies";
static const char __pyx_k_biselect_pattern[] = "biselect_pattern";
static const char __pyx_k_check_is_fitted2[] = "check_is_fitted2";
static const char __pyx_k_columns_to_index[] = "columns_to_index";
static const char __pyx_k_datetime_pattern[] = "datetime_pattern";
static const char __pyx_k_feature_names_in[] = "feature_names_in_";
static const char __pyx_k_force_all_finite[] = "force_all_finite";
static const char __pyx_k_handle_categoric[] = "_handle_categoric";
static const char __pyx_k_index_to_columns[] = "index_to_columns";
static const char __pyx_k_indices_datatype[] = "indices_datatype";
static const char __pyx_k_is_integer_dtype[] = "is_integer_dtype";
static const char __pyx_k_is_numeric_dtype[] = "_is_numeric_dtype";
static const char __pyx_k_is_square_matrix[] = "is_square_matrix";
static const char __pyx_k_may_share_memory[] = "may_share_memory";
static const char __pyx_k_must_be_integers[] = " must be integers.";
static const char __pyx_k_normalize_string[] = "normalize_string";
static const char __pyx_k_pandas_api_types[] = "pandas.api.types";
static const char __pyx_k_parse_year_input[] = "parse_year_input";
static const char __pyx_k_validate_numeric[] = "validate_numeric";
static const char __pyx_k_validate_weights[] = "validate_weights";
static const char __pyx_k_y_true_processed[] = "y_true_processed";
static const char __pyx_k_Valid_options_are[] = ". Valid options are ";
static const char __pyx_k_assert_all_finite[] = "_assert_all_finite";
static const char __pyx_k_categoric_pattern[] = "categoric_pattern";
static const char __pyx_k_determine_epsilon[] = "determine_epsilon";
static const char __pyx_k_ensure_y_is_valid[] = "_ensure_y_is_valid";
static const char __pyx_k_get_feature_names[] = "_get_feature_names";
static const char __pyx_k_has_fit_parameter[] = "has_fit_parameter";
static const char __pyx_k_is_valid_policies[] = "is_valid_policies";
static const char __pyx_k_padded_input_name[] = "padded_input_name";
static const char __pyx_k_replacement_value[] = "replacement_value";
static const char __pyx_k_sklearn_is_fitted[] = "__sklearn_is_fitted__";
static const char __pyx_k_supported_indices[] = "supported_indices";
static const char __pyx_k_validated_targets[] = "validated_targets";
static const char __pyx_k_validation_checks[] = "validation_checks";
static const char __pyx_k_weighted_y_values[] = "weighted_y_values";
static const char __pyx_k_Input_contains_NaN[] = "Input contains NaN. ";
static const char __pyx_k_Invalid_nan_policy[] = "Invalid nan_policy: ";
static const char __pyx_k_a_positive_integer[] = "a positive integer";
static const char __pyx_k_accept_multioutput[] = "accept_multioutput";
static const char __pyx_k_actual_type_y_pred[] = "actual_type_y_pred";
static const char __pyx_k_actual_type_y_true[] = "actual_type_y_true";
static const char __pyx_k_asarray_with_order[] = "_asarray_with_order";
static const char __pyx_k_check_large_sparse[] = "_check_large_sparse";
static const char __pyx_k_check_random_state[] = "check_random_state";
static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
static const char __pyx_k_ensure_min_samples[] = "ensure_min_samples";
static const char __pyx_k_get_estimator_name[] = "get_estimator_name";
static const char __pyx_k_include_boundaries[] = "include_boundaries";
static const char __pyx_k_is_cross_validated[] = "_is_cross_validated";
static const char __pyx_k_metric_computation[] = "metric computation";
static const char __pyx_k_numpy_core_numeric[] = "numpy.core.numeric";
static const char __pyx_k_object_dtype_isnan[] = "_object_dtype_isnan";
static const char __pyx_k_recheck_data_types[] = "recheck_data_types";
static const char __pyx_k_return_as_date_str[] = "return_as_date_str";
static const char __pyx_k_return_target_only[] = "return_target_only";
static const char __pyx_k_while_a_minimum_of[] = ") while a minimum of ";
static const char __pyx_k_BuiltinFunctionType[] = "BuiltinFunctionType";
static const char __pyx_k_Custom_check_failed[] = "Custom check failed: ";
static const char __pyx_k_Possible_values_are[] = ". Possible values are: ";
static const char __pyx_k_accept_large_sparse[] = "accept_large_sparse";
static const char __pyx_k_accept_multi_output[] = "accept_multi_output";
static const char __pyx_k_assert_all_finite_2[] = "assert_all_finite";
static const char __pyx_k_but_columns_implied[] = ", but columns implied ";
static const char __pyx_k_check_time_interval[] = "check_time_interval";
static const char __pyx_k_comparison_operator[] = "comparison_operator";
static const char __pyx_k_ensure_2d_line_1144[] = "ensure_2d (line 1144)";
static const char __pyx_k_ensure_min_features[] = "ensure_min_features";
static const char __pyx_k_ensure_non_negative[] = "ensure_non_negative";
static const char __pyx_k_filter_valid_kwargs[] = "filter_valid_kwargs";
static const char __pyx_k_first_pass_isfinite[] = "first_pass_isfinite";
static const char __pyx_k_parameter_validator[] = "parameter_validator";
static const char __pyx_k_validate_data_types[] = "validate_data_types";
static const char __pyx_k_validate_nan_policy[] = "validate_nan_policy";
static const char __pyx_k_Expects_an_array_got[] = "Expects an array, got: ";
static const char __pyx_k_Found_array_with_dim[] = "Found array with dim ";
static const char __pyx_k_Invalid_nan_policy_2[] = "Invalid nan_policy ";
static const char __pyx_k_The_first_element_in[] = "The first element in ";
static const char __pyx_k_check_estimator_name[] = "_check_estimator_name";
static const char __pyx_k_data_frame_or_series[] = "data frame or series";
static const char __pyx_k_distributed_elements[] = "distributed_elements";
static const char __pyx_k_ensure_sparse_format[] = "_ensure_sparse_format";
static const char __pyx_k_handle_zero_division[] = "handle_zero_division";
static const char __pyx_k_is_categorical_dtype[] = "is_categorical_dtype";
static const char __pyx_k_multilabel_indicator[] = "multilabel-indicator";
static const char __pyx_k_validate_fit_weights[] = "validate_fit_weights";
static const char __pyx_k_validate_keras_model[] = "validate_keras_model";
static const char __pyx_k_validate_multioutput[] = "validate_multioutput";
static const char __pyx_k_Columns_indices_imply[] = ". Columns indices imply ";
static const char __pyx_k_DataConversionWarning[] = "DataConversionWarning";
static const char __pyx_k_Expect_type_array_got[] = "Expect type array, got: ";
static const char __pyx_k_POSITIONAL_OR_KEYWORD[] = "POSITIONAL_OR_KEYWORD";
static const char __pyx_k_Target_array_at_index[] = "Target array at index ";
static const char __pyx_k_Use_numeric_or_object[] = "'. Use 'numeric' or 'object'.";
static const char __pyx_k_is_not_a_numeric_type[] = "' is not a numeric type.";
static const char __pyx_k_validate_distribution[] = "validate_distribution";
static const char __pyx_k_validate_length_range[] = "validate_length_range";
static const char __pyx_k_Expect_a_dataframe_Got[] = "Expect a dataframe. Got ";
static const char __pyx_k_a_non_negative_integer[] = "a non-negative integer";
static const char __pyx_k_assert_xy_in_line_2884[] = "assert_xy_in (line 2884)";
static const char __pyx_k_check_consistency_size[] = "check_consistency_size";
static const char __pyx_k_check_feature_names_in[] = "_check_feature_names_in";
static const char __pyx_k_check_mixed_data_types[] = "check_mixed_data_types";
static const char __pyx_k_check_y_locals_genexpr[] = "_check_y.<locals>.genexpr";
static const char __pyx_k_ensure_no_complex_data[] = "_ensure_no_complex_data";
static const char __pyx_k_expects_strict_or_soft[] = ", expects 'strict'or 'soft'";
static const char __pyx_k_is_installed_line_2764[] = "is_installed (line 2764)";
static const char __pyx_k_is_normalized_line_660[] = "is_normalized (line 660)";
static const char __pyx_k_must_be_an_instance_of[] = " must be an instance of ";
static const char __pyx_k_nly_supports_array_got[] = "nly supports array, got: ";
static const char __pyx_k_not_found_in_DataFrame[] = "' not found in DataFrame.";
static const char __pyx_k_validate_square_matrix[] = "validate_square_matrix";
static const char __pyx_k_validated_distribution[] = "validated_distribution";
static const char __pyx_k_Array_must_be_symmetric[] = "Array must be symmetric";
static const char __pyx_k_Invalid_rounding_method[] = "Invalid rounding method '";
static const char __pyx_k_Invalid_validation_mode[] = "Invalid validation mode: '";
static const char __pyx_k_PositiveSpectrumWarning[] = "PositiveSpectrumWarning";
static const char __pyx_k_Unable_to_find_the_name[] = "Unable to find the name ";
static const char __pyx_k_Unsupported_target_type[] = "Unsupported target_type '";
static const char __pyx_k_Weights_must_be_between[] = "Weights must be between ";
static const char __pyx_k_check_consistent_length[] = "check_consistent_length";
static const char __pyx_k_check_epsilon_line_1868[] = "check_epsilon (line 1868)";
static const char __pyx_k_contains_nested_objects[] = "contains_nested_objects";
static const char __pyx_k_convert_array_to_pandas[] = "convert_array_to_pandas";
static const char __pyx_k_has_required_attributes[] = "has_required_attributes";
static const char __pyx_k_is_arraylike_not_scalar[] = "_is_arraylike_not_scalar";
static const char __pyx_k_is_datetime64_any_dtype[] = "is_datetime64_any_dtype";
static const char __pyx_k_validate_dtype_selector[] = "validate_dtype_selector";
static const char __pyx_k_validate_sample_weights[] = "validate_sample_weights";
static const char __pyx_k_array_to_frame_line_4885[] = "array_to_frame (line 4885)";
static const char __pyx_k_check_consistency_size_2[] = "_check_consistency_size";
static const char __pyx_k_is_binary_class_line_798[] = "is_binary_class (line 798)";
static const char __pyx_k_is_categorical_line_1215[] = "is_categorical (line 1215)";
static const char __pyx_k_is_extension_array_dtype[] = "is_extension_array_dtype";
static const char __pyx_k_is_time_series_line_2787[] = "is_time_series (line 2787)";
static const char __pyx_k_normalize_array_line_712[] = "normalize_array (line 712)";
static const char __pyx_k_validate_comparison_data[] = "validate_comparison_data";
static const char __pyx_k_validate_dates_line_2377[] = "validate_dates (line 2377)";
static const char __pyx_k_validate_scores_line_159[] = "validate_scores (line 159)";
static const char __pyx_k_Choose_ceil_floor_or_None[] = "'. Choose 'ceil', 'floor', or None.";
static const char __pyx_k_Shape_of_passed_values_is[] = "Shape of passed values is ";
static const char __pyx_k_array_to_frame2_line_4956[] = "array_to_frame2 (line 4956)";
static const char __pyx_k_deprecate_positional_args[] = "_deprecate_positional_args";
static const char __pyx_k_is_square_matrix_line_360[] = "is_square_matrix (line 360)";
static const char __pyx_k_validate_positive_integer[] = "validate_positive_integer";
static const char __pyx_k_validate_weights_line_577[] = "validate_weights (line 577)";
static const char __pyx_k_Complex_data_not_supported[] = "Complex data not supported\n{}\n";
static const char __pyx_k_Shape_of_passed_values_for[] = "Shape of passed values for ";
static const char __pyx_k_check_array_locals_genexpr[] = "check_array.<locals>.genexpr";
static const char __pyx_k_check_is_fitted2_line_2836[] = "check_is_fitted2 (line 2836)";
static const char __pyx_k_import_optional_dependency[] = "import_optional_dependency";
static const char __pyx_k_is_a_class_not_an_instance[] = "{} is a class, not an instance.";
static const char __pyx_k_not_found_in_the_dataframe[] = "' not found in the dataframe.";
static const char __pyx_k_pandas_requires_conversion[] = "pandas_requires_conversion";
static const char __pyx_k_validate_and_adjust_ranges[] = "validate_and_adjust_ranges";
static const char __pyx_k_validate_multiclass_target[] = "validate_multiclass_target";
static const char __pyx_k_validate_numeric_line_3008[] = "validate_numeric (line 3008)";
static const char __pyx_k_check_scalar_locals_genexpr[] = "check_scalar.<locals>.genexpr";
static const char __pyx_k_ensure_y_is_valid_line_1957[] = "_ensure_y_is_valid (line 1957)";
static const char __pyx_k_expected_include_boundaries[] = "expected_include_boundaries";
static const char __pyx_k_filter_valid_kwargs_line_99[] = "filter_valid_kwargs (line 99)";
static const char __pyx_k_has_fit_parameter_line_3596[] = "has_fit_parameter (line 3596)";
static const char __pyx_k_is_probability_distribution[] = "_is_probability_distribution";
static const char __pyx_k_is_valid_policies_line_1700[] = "is_valid_policies (line 1700)";
static const char __pyx_k_must_be_an_integer_or_float[] = " must be an integer or float.";
static const char __pyx_k_NaN_values_found_in_the_data[] = "NaN values found in the data.";
static const char __pyx_k_as_keyword_args_From_version[] = " as keyword args. From version ";
static const char __pyx_k_check_classification_targets[] = "check_classification_targets";
static const char __pyx_k_must_be_less_than_the_second[] = " must be less than the second.";
static const char __pyx_k_recheck_data_types_line_2604[] = "recheck_data_types (line 2604)";
static const char __pyx_k_validate_data_types_line_999[] = "validate_data_types (line 999)";
static const char __pyx_k_validate_input_locals_lambda[] = "_validate_input.<locals>.<lambda>";
static const char __pyx_k_Input_must_be_a_square_matrix[] = "Input must be a square matrix. ";
static const char __pyx_k_check_scalar_locals_type_name[] = "check_scalar.<locals>.type_name";
static const char __pyx_k_ensure_non_negative_line_1826[] = "ensure_non_negative (line 1826)";
static const char __pyx_k_handle_zero_division_line_850[] = "handle_zero_division (line 850)";
static const char __pyx_k_is_not_a_valid_numeric_string[] = "' is not a valid numeric string.";
static const char __pyx_k_must_be_a_tuple_of_two_values[] = " must be a tuple of two values.";
static const char __pyx_k_must_contain_numerical_values[] = " must contain numerical values.";
static const char __pyx_k_parameter_validator_line_1275[] = "parameter_validator (line 1275)";
static const char __pyx_k_validate_nan_policy_line_1542[] = "validate_nan_policy (line 1542)";
static const char __pyx_k_where_the_samples_are_of_type[] = " where the samples are of type ";
static const char __pyx_k_Check_whether_the_target_array[] = "\n    Check whether the target array represents binary classification. Optionally,\n    handle multi-output arrays if each output is binary.\n\n    Parameters:\n    ----------\n    y : array-like\n        The target array to be checked. This can be a 1D array for single output\n        or a 2D array for multiple outputs if `accept_multioutput` is True.\n    accept_multioutput : bool, default False\n        If True, the function checks if each column in a multi-dimensional array\n        is binary. If False, the function checks if the entire array is binary.\n\n    Returns:\n    -------\n    bool\n        Returns True if `y` is binary (or each output is binary if multi-output\n        is accepted), False otherwise.\n\n    Examples:\n    --------\n    >>> from gofast.tools.validator import is_binary_class \n    >>> is_binary_class([0, 1, 1, 0])\n    True\n    >>> is_binary_class([[0, 1], [1, 0], [0, 1], [1, 0]], accept_multioutput=True)\n    True\n    >>> is_binary_class([0, 1, 2, 3])\n    False\n    ";
static const char __pyx_k_Checks_for_mixed_data_types_in[] = "\n    Checks for mixed data types in a pandas Series or DataFrame and handles\n    according to the specified policies. This function is designed to ensure \n    data consistency by verifying that data matches expected type criteria,\n    offering options to manage and report any discrepancies.\n\n    Parameters\n    ----------\n    data : pd.Series or pd.DataFrame\n        The data to be checked. This can be a pandas Series or DataFrame.\n    expected_type : {'numeric', 'categoric', 'both'}, default 'numeric'\n        Specifies the type of data expected:\n        \n        - 'numeric': All data should be of numeric types (int, float).\n        - 'categoric': All data should be categorical, typically strings\n          or pandas Categorical datatype.\n        - 'both': Any mix of numeric and categorical data is considered valid.\n        \n    nan_policy : {'raise', 'omit', 'propagate'}, default 'omit'\n        Determines how NaN values are handled:\n        \n        - 'raise': Raises an error if NaN values are found.\n        - 'warn': Issues a warning if NaN values are found but proceeds.\n        - 'propagate': Continues execution without addressing NaNs.\n        \n    return_data : bool, default False\n        If True, returns a DataFrame or Series (depending on the input) that \n        only includes data rows that conform to the expected_type. If False,\n        returns None.\n        \n    error : {'raise', 'warn'}, default 'raise'\n        Configures the error handling behavior when data types do not conform \n        to the expected_type:\n        \n        - 'raise': Raises a TypeError if mixed types are detected.\n        - 'warn': Emits a warning but attempts to continue by filtering \n          non-conforming data if `return_data` is True.\n\n    Returns\n    -------\n    pd.Series or pd.DataFrame or None\n        Depending on `return_data`, this function may return a filtered version\n        of `data` that conforms to the `expected_type` or None if ""`return_data` \n        is False.\n\n    Raises\n    ------\n    ValueError\n        If NaN values are present and `nan_policy` is set to 'error'.\n    TypeError\n        If data types do not conform to `expected_type` and `error` is set to 'raise'.\n\n    Examples\n    --------\n    >>> import pandas as pd \n    >>> from gofast.tools.validator import validate_data_types \n    >>> df = pd.DataFrame({'A': [1, 2, 'a', 3.5, np.nan], 'B': ['x', 'y', 'z', None, 't']})\n    >>> validate_data_types(df, expected_type='numeric', nan_policy='warn', \n    ...                  return_data=True, error='warn')\n    UserWarning: NaN values found in the data, but processing will continue.\n    UserWarning: Expected numeric types but found mixed types. \n    Non-numeric data will be ignored.\n       A\n    0  1.0\n    1  2.0\n    3  3.5\n\n    Notes\n    -----\n    The `check_data_types` function is useful in data preprocessing steps,\n    particularly when you need to ensure that data fed into a machine learning\n    algorithm meets certain type requirements. Handling mixed data types early\n    on can prevent issues in model training and evaluation.\n    ";
static const char __pyx_k_Time_intervals_are_not_regular[] = "Time intervals are not regular.";
static const char __pyx_k_Valid_modes_are_strict_soft_or[] = "'. Valid modes are 'strict', 'soft', or 'passthrough'.";
static const char __pyx_k_Validates_and_parses_start_and[] = "\n    Validates and parses start and end years/dates, with options for output formatting.\n\n    This function ensures the validity of provided start and end years or dates, checks\n    if they fall within a reasonable range, and allows the option to return the validated\n    years or dates in a specified string format.\n\n    Parameters\n    ----------\n    start_date : int, float, or str\n        The starting year or date. Can be an integer, float (converted to integer),\n        or string in \"YYYY\" or \"YYYY-MM-DD\" format.\n    end_date : int, float, or str\n        The ending year or date, with the same format options as `start_date`.\n    return_as_date_str : bool, optional\n        If True, returns the start and end dates as strings in the specified format.\n        Default is False, returning years as integers.\n    date_format : str, optional\n        The format string for output dates if `return_as_date_str` is True.\n        Default format is \"%Y-%m-%d\".\n\n    Returns\n    -------\n    tuple\n        A tuple of two elements, either integers (years) or strings (formatted dates),\n        representing the validated start and end years or dates.\n\n    Raises\n    ------\n    ValueError\n        If the input years or dates are invalid, out of the acceptable range,\n        or if the start year/date does not precede the end year/date.\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import validate_dates\n    >>> validate_dates(1999, 2001)\n    (1999, 2001)\n\n    >>> validate_dates(\"1999/01/01\", \"2001/12/31\", return_as_date_str=True)\n    ('1999-01-01', '2001-12-31')\n\n    >>> validate_dates(\"1999\", \"1998\")\n    ValueError: The start date/time must precede the end date/time.\n\n    >>> validate_years(\"1899\", \"2001\")\n    ValueError: Years must be within the valid range: 1900 to [current year].\n\n    Notes\n    -----\n    The function supports flexible input formats for years and dates, including\n    handling both slash ""\"/\" and dash \"-\" separators in date strings. It enforces\n    logical and chronological order between start and end inputs and allows\n    customization of the output format for date strings.\n    ";
static const char __pyx_k_Validates_that_the_target_data[] = "\n    Validates that the target data is suitable for multiclass classification.\n    Optionally accepts multi-output targets and can return the unique classes.\n\n    Parameters\n    ----------\n    y : array-like\n        The target data to be validated, expected to contain class labels for\n        multiclass classification. Can be a multi-output array if accept_multioutput\n        is set to True.\n    accept_multioutput : bool, optional\n        Allows the target array to be multi-dimensional (default is False).\n    return_classes : bool, optional\n        If True, returns the unique classes instead of a validation boolean.\n\n    Returns\n    -------\n    bool or array\n        If return_classes is False, returns True if the target data is valid for\n        multiclass classification, otherwise raises a ValueError.\n        If return_classes is True, returns the unique classes in the target data.\n\n    Raises\n    ------\n    ValueError\n        If any of the following conditions are not met:\n        - If accept_multioutput is False, the target data must be one-dimensional.\n        - All elements in the target array must be non-negative integers.\n        - The target array must contain at least two distinct classes.\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import validate_multiclass_target\n    >>> validate_multiclass_target([0, 1, 2, 1, 0])\n    array([0, 1, 2, 1, 0])\n    >>> validate_multiclass_target([0, 0, 0])\n    ValueError: Target array must contain at least two distinct classes.\n    >>> validate_multiclass_target([0.5, 1.2, 2.3])\n    ValueError: All elements in the target array must be non-negative integers.\n    >>> validate_multiclass_target([[1, 2], [2, 3]], accept_multioutput=True, \n    ...                              return_classes=True)\n    (array([1, 2, 2, 3]), 3)\n    True\n    ";
static const char __pyx_k_categoric_al__only_categorical[] = "categoric(al|_only)?|categorical";
static const char __pyx_k_does_not_accept_missing_values[] = " does not accept missing values encoded as NaN natively. Alternatively, it is possible to preprocess the data, for instance by using the imputer transformer like the ufunc 'soft_imputer' in 'gofast.tools.mlutils.soft_imputer'.";
static const char __pyx_k_elements_must_be_an_integer_or[] = "'elements' must be an integer or a list of strings.";
static const char __pyx_k_for_both_y_true_and_y_pred_but[] = "' for both y_true and y_pred, but got '";
static const char __pyx_k_generate_get_feature_names_out[] = "_generate_get_feature_names_out";
static const char __pyx_k_is_1d_array_only_pandas_Series[] = " is 1d-array, only pandas.Series conversion can be performed while name must be a hashable type: got ";
static const char __pyx_k_is_out_of_the_valid_range_1900[] = " is out of the valid range: 1900 to ";
static const char __pyx_k_memory_should_be_None_a_string[] = "'memory' should be None, a string or have the same interface as joblib.Memory. Got memory='{}' instead.";
static const char __pyx_k_s_is_not_an_estimator_instance[] = "%s is not an estimator instance.";
static const char __pyx_k_validate_fit_weights_line_1629[] = "validate_fit_weights (line 1629)";
static const char __pyx_k_validate_keras_model_line_2685[] = "validate_keras_model (line 2685)";
static const char __pyx_k_validate_multioutput_line_1756[] = "validate_multioutput (line 1756)";
static const char __pyx_k_validate_scores_locals_genexpr[] = "validate_scores.<locals>.genexpr";
static const char __pyx_k_All_distribution_values_must_be[] = "All distribution values must be numeric";
static const char __pyx_k_Array_is_not_symmetric_and_will[] = "Array is not symmetric, and will be converted to symmetric by average with its transpose.";
static const char __pyx_k_Assert_the_name_of_x_and_y_in_t[] = "\n    Assert the name of x and y in the given data. \n    \n    Check whether string arguments passed to x and y are valid in the data, \n    then retrieve the x and y array values. \n    \n    Parameters \n    -----------\n    x, y : Arraylike 1d or str, str  \n       One dimensional arrays. In principle if data is supplied, they must \n       constitute series.  If `x` and `y` are given as string values, the \n       `data` must be supplied. x and y names must be included in the  \n       dataframe otherwise an error raises. \n       \n    data: pd.DataFrame, \n       Data containing x and y names. Need to be supplied when x and y \n       are given as string names. \n    asarray: bool, default =True \n       Returns x and y as array rather than series. \n    to_frame: bool, default=False, \n       Convert data to a dataframe using either the columns names or \n       the input_names when the keyword parameter ``force=True``.\n    columns: list of str, Optional \n       Name of columns to transform the array ( ``data``) to a dataframe. \n    xy_numeric:bool, default=False\n       Convert x and y to numeric values. \n    ignore: str, optional \n       It should be 'x' or 'y'. If set the array is ignored and not asserted. \n       \n    kws: dict, \n       Keyword arguments passed to :func:`~.array_to_frame`.\n       \n       \n    Returns \n    --------\n    x, y : Arraylike \n       One dimensional array or pd.Series \n      \n    Examples \n    ---------\n    >>> import numpy as np \n    >>> import pandas as pd \n    >>> from gofast.tools.validator import assert_xy_in \n    >>> x, y = np.random.rand(7 ), np.arange (7 ) \n    >>> data = pd.DataFrame ({'x': x, 'y':y} ) \n    >>> assert_xy_in (x='x', y='y', data = data ) \n    (array([0.37454012, 0.95071431, 0.73199394, 0.59865848, 0.15601864,\n            0.15599452, 0.05808361]),\n     array([0, 1, 2, 3, 4, 5, 6]))\n    >>> assert_xy_in (x=x, y=y) \n    (array([0.37454012, 0.95071431, 0.73199394, 0.59865848, 0.156""01864,\n            0.15599452, 0.05808361]),\n     array([0, 1, 2, 3, 4, 5, 6]))\n    >>> assert_xy_in (x=x, y=data.y) # y is a series \n    (array([0.37454012, 0.95071431, 0.73199394, 0.59865848, 0.15601864,\n            0.15599452, 0.05808361]),\n     array([0, 1, 2, 3, 4, 5, 6]))\n    >>> assert_xy_in (x=x, y=data.y, asarray =False ) # return y like it was\n    (array([0.37454012, 0.95071431, 0.73199394, 0.59865848, 0.15601864,\n            0.15599452, 0.05808361]),\n    0    0\n    1    1\n    2    2\n    3    3\n    4    4\n    5    5\n    6    6\n    Name: y, dtype: int32)\n    ";
static const char __pyx_k_Automatic_strategy_detected_too[] = "Automatic strategy detected too many unique values for a classification task.";
static const char __pyx_k_Can_t_check_s_sparse_matrix_for[] = "Can't check %s sparse matrix for nan or inf.";
static const char __pyx_k_Check_if_the_provided_DataFrame[] = "\n    Check if the provided DataFrame is time series data.\n\n    Parameters\n    ----------\n    data : pandas.DataFrame\n        The DataFrame to be checked.\n    time_col : str\n        The name of the column in `df` expected to represent time.\n\n    Returns\n    -------\n    bool\n        True if `df` is a time series, False otherwise.\n        \n    Example\n    -------\n    >>> import pandas as pd \n    >>> df = pd.DataFrame({\n        'Date': ['2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04', '2021-01-05'],\n        'Value': [1, 2, 3, 4, 5]\n    })\n    >>> # Should return True if Date column \n    >>> # can be converted to datetime\n    >>> print(is_time_series(df, 'Date'))   \n \n    ";
static const char __pyx_k_Checks_if_TensorFlow_is_install[] = "\n    Checks if TensorFlow is installed.\n\n    This function attempts to find the TensorFlow package specification without\n    importing the package. It's a lightweight method to verify the presence of\n    TensorFlow in the environment.\n\n    Returns\n    -------\n    bool\n        True if TensorFlow is installed, False otherwise.\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import is_installed \n    >>> print(is_installed(\"tensorflow\"))\n    True  # Output will be True if TensorFlow is installed, False otherwise.\n    ";
static const char __pyx_k_Checks_if_a_specified_column_in[] = "\n    Checks if a specified column in a DataFrame or Series is of \n    a categorical type.\n    \n    Parameters\n    ----------\n    data : DataFrame or Series\n        The DataFrame or Series to check.\n    column : str\n        The name of the column to check.\n    strict : bool, optional\n        If True, only considers pandas CategoricalDtype as categorical. If False,\n        also considers object dtype that often represents categorical data.\n        Default is False.\n    error : str, optional\n        Specifies how to handle situations when the column does not exist.\n        Options are 'raise', 'warn', or 'ignore'. Default is 'raise'.\n\n    Returns\n    -------\n    bool\n        True if the column is categorical, otherwise False.\n\n    Raises\n    ------\n    ValueError\n        If the column does not exist and error is set to 'raise'.\n\n    Examples\n    --------\n    >>> import pandas as pd \n    >>> from gofast.tools.validator import is_categorical\n    >>> df = pd.DataFrame({\n    ...     'fruit': ['Apple', 'Banana', 'Cherry'],\n    ...     'count': [10, 20, 15]\n    ... })\n    >>> df['fruit'] = df['fruit'].astype('category')\n    >>> print(is_categorical(df, 'fruit'))\n    True\n    >>> print(is_categorical(df, 'count'))\n    False\n    >>> print(is_categorical(df, 'non_existent', error='warn'))\n    Warning: Column 'non_existent' not found in the dataframe.\n    False\n    ";
static const char __pyx_k_Checks_if_an_array_is_normalize[] = "\n    Checks if an array is normalized according to the specified method and \n    normalizes it if required based on the 'normalize' parameter.\n\n    Parameters:\n    ----------\n    arr : array-like\n        The input array to check and potentially normalize.\n\n    normalize : str, optional\n        Determines whether to normalize the array:\n        - 'auto': Normalize only if the array is not already normalized \n          according to the specified method.\n        - True: Always normalize the array regardless of its current state.\n        - False: Do not normalize the array, return as is.\n        Default is 'auto'.\n\n    method : str, optional\n        The normalization method to apply:\n        - '01': Normalize the array to have values between 0 and 1.\n        - 'zscore': Standardize the array to have a mean of 0 and a standard\n          deviation of 1.\n        - 'sum': Normalize the array so that the sum of its elements equals 1.\n        Default is '01'.\n\n    Returns:\n    -------\n    np.ndarray\n        The normalized array, or the original array if no normalization was applied.\n\n    Raises:\n    ------\n    ValueError\n        If an unknown normalization method is specified or if normalization \n        cannot be performed due to data characteristics (e.g., zero variance).\n        \n    Examples:\n    --------\n    >>> import numpy as np \n    >>> from gofast.tools.validator import normalize_array \n\n    >>> data = np.array([1, 2, 3, 4, 5])\n    >>> normalized_data = normalize_array(data, normalize=True, method='01')\n    >>> print(\"Normalized between 0 and 1:\", normalized_data)\n    Normalized between 0 and 1: [0.   0.25 0.5  0.75 1.  ]\n    \n    >>> zscore_data = normalize_array(data, normalize=True, method='zscore')\n    >>> print(\"Standardized (Z-score):\", zscore_data)\n    Standardized (Z-score): [-1.41421356 -0.70710678  0.          0.70710678  1.41421356]\n    \n    >>> sum_data = normalize_array(data, normalize=True, method='s""um')\n    >>> print(\"Normalized by sum:\", sum_data)\n    Normalized by sum: [0.06666667 0.13333333 0.2        0.26666667 0.33333333]\n    ";
static const char __pyx_k_Checks_if_the_given_data_DataFr[] = "\n    Checks if the given data (DataFrame or numpy array) contains both numerical \n    and categorical columns.\n\n    Parameters\n    ----------\n    data : pd.DataFrame or np.ndarray\n        The data to check. Can be a pandas DataFrame or a numpy array. If `data`\n        is a numpy array, it is temporarily converted to a DataFrame for type \n        checking.\n\n    Returns\n    -------\n    bool\n        True if the data contains both numerical and categorical columns, False\n        otherwise.\n\n    Examples\n    --------\n    Using with a pandas DataFrame:\n        \n    >>> import numpy as np \n    >>> import pandas as pd \n    >>> from gofast.tools.validator import check_mixed_data_types\n    >>> df = pd.DataFrame({'A': [1, 2, 3], 'B': ['a', 'b', 'c']})\n    >>> print(check_mixed_data_types(df))\n    True\n\n    Using with a numpy array:\n\n    >>> array = np.array([[1, 'a'], [2, 'b'], [3, 'c']])\n    >>> print(check_mixed_data_types(array))\n    True\n\n    With data containing only numerical values:\n\n    >>> df_numeric_only = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})\n    >>> print(check_mixed_data_types(df_numeric_only))\n    False\n\n    With data containing only categorical values:\n\n    >>> df_categorical_only = pd.DataFrame({'A': ['a', 'b', 'c'], 'B': ['d', 'e', 'f']})\n    >>> print(check_mixed_data_types(df_categorical_only))\n    False\n    ";
static const char __pyx_k_Checks_if_the_provided_array_is[] = "\n    Checks if the provided array is normalized according to the specified method.\n\n    Parameters:\n    ----------\n    arr : array-like\n        The array to check for normalization.\n    method : str, optional\n        The method of normalization to check against:\n        - '01': Checks if values are between 0 and 1 and if min is 0 and max is 1.\n        - 'zscore': Checks if the mean is 0 and the standard deviation is 1.\n        - 'sum': Checks if the sum of the array elements is 1.\n        Default is 'sum'.\n\n    Returns:\n    -------\n    bool\n        Returns True if the array is normalized according to the specified method,\n        False otherwise.\n\n    Examples:\n    --------\n    >>> arr = np.array([0.25, 0.25, 0.25, 0.25])\n    >>> is_normalized(arr, method='sum')\n    True\n\n    >>> arr = np.array([0, 0.5, 1])\n    >>> is_normalized(arr, method='01')\n    True\n\n    >>> arr = np.array([1, -1, 1, -1])\n    >>> is_normalized(arr, method='zscore')\n    True\n    ";
static const char __pyx_k_Checks_if_y_is_a_probability_di[] = "\n    Checks if `y` is a probability distribution across the last axis according \n    to the specified mode.\n\n    Parameters\n    ----------\n    y : np.ndarray\n        Array containing score values which need to be validated as probability\n        distributions.\n    mode : str, optional\n        Validation mode to be used. Available modes are:\n        - 'strict': Requires that the sum of scores exactly equals 1 \n        (within a tolerance).\n        - 'soft': Requires that the sum of scores does not exceed 1 and all\n        scores are non-negative.\n        - 'passthrough': Only checks that all scores are non-negative and do \n          not exceed 1, without summing them.\n\n    Returns\n    -------\n    bool\n        True if `y` satisfies the conditions of the specified mode, False \n        otherwise.\n\n    Raises\n    ------\n    ValueError\n        If an invalid mode is specified.\n\n    Examples\n    --------\n    >>> y = np.array([0.3, 0.7])\n    >>> print(is_probability_distribution(y, mode='strict'))\n    True\n\n    >>> y = np.array([0.5, 0.5, 0.2])\n    >>> print(is_probability_distribution(y, mode='soft'))\n    False\n\n    >>> y = np.array([0.2, 0.3, 0.4])\n    >>> print(is_probability_distribution(y, mode='passthrough'))\n    True\n    ";
static const char __pyx_k_Columns_for_input_name_r_expect[] = " Columns for {input_name!r} expects a list or tuple. Got ";
static const char __pyx_k_Creates_a_validator_function_fo[] = "\n    Creates a validator function for ensuring a parameter's value matches one \n    of the allowed target strings, optionally applying normalization.\n\n    This higher-order function returns a validator that can be used to check \n    if a given parameter value matches allowed criteria, optionally raising \n    an exception or normalizing the input.\n\n    Parameters\n    ----------\n    param_name : str\n        Name of the parameter to be validated. Used in error messages to \n        indicate which parameter failed validation.\n    target_strs : list of str\n        A list of acceptable string values for the parameter.\n    match_method : str, optional\n        The method used to match the input string against the target strings. \n        The default method is 'contains', which checks if the input string \n        contains any of the target strings.\n    raise_exception : bool, optional\n        Specifies whether an exception should be raised if validation fails. \n        Defaults to True, raising an exception on failure.\n    **kws: dict, \n       Keyword arguments passed to :func:`gofast.tools.coreutils.normalize_string`. \n    Returns\n    -------\n    function\n        A closure that takes a single string argument (the parameter value) \n        and returns a normalized version of it if the parameter matches the \n        target criteria. If the parameter does not match and `raise_exception` \n        is True, it raises an exception; otherwise, it returns the original value.\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import parameter_validator\n    >>> validate_outlier_method = parameter_validator(\n    ...  'outlier_method', ['z_score', 'iqr'])\n    >>> outlier_method = \"z_score\"\n    >>> print(validate_outlier_method(outlier_method))\n    'z_score'\n\n    >>> validate_fill_missing = parameter_validator(\n    ...  'fill_missing', ['median', 'mean', 'mode'], raise_exception=False)\n    >>> fill_missing = \"average\"  # This does"" not match but won't raise an exception.\n    >>> print(validate_fill_missing(fill_missing))\n    'average'\n\n    Notes\n    -----\n    - The function leverages a custom utility function `normalize_string` \n      from a module named `.coreutils`. This utility is assumed to handle \n      string normalization and matching based on the provided `match_method`.\n    - If `raise_exception` is set to False and the input does not match any \n      target string, the input string is returned unchanged. This behavior \n      allows for optional enforcement of the validation rules.\n    - The primary use case for this function is to validate and optionally \n      normalize parameters for configuration settings or function arguments \n      where only specific values are allowed.\n    ";
static const char __pyx_k_Determine_whether_the_input_eit[] = "\n    Determine whether the input, either a DataFrame or an array-like \n    structure, forms a square matrix.\n    \n    Automatically detects the data type unless specified. Supports data inputs\n    that can be converted to a NumPy array.\n    \n    Parameters:\n    -----------\n    data : DataFrame, array-like, or any object convertible to a numpy array\n        The input data to check.\n    data_type : str, optional\n        The expected type of the input data. Valid options are 'array' or \n        'dataframe'.\n        If not specified, the data type is inferred. Default interpretation \n        is as an 'array'.\n\n    Returns:\n    --------\n    bool\n        Returns True if the data is a square matrix, otherwise False.\n        \n    Raises:\n    ------\n    ValueError\n        If `data_type` is neither 'array' nor 'dataframe'.\n    TypeError\n        If the input `data` does not match the expected format or \n        cannot be processed.\n\n    Examples:\n    ---------\n    >>> is_square_matrix(np.array([[1, 2], [3, 4]]))\n    True\n\n    >>> is_square_matrix(pd.DataFrame([[1, 2, 3], [4, 5, 6]]))\n    False\n\n    >>> is_square_matrix([[1, 2], [3, 4]], data_type='array')\n    True\n\n    Notes:\n    ------\n    A square matrix has an equal number of rows and columns. This function \n    checks the dimensionality and shape of the data to confirm if it meets \n    this criterion.\n    ";
static const char __pyx_k_Determines_whether_a_list_conta[] = "\n    Determines whether a list contains nested objects.\n\n    Parameters\n    ----------\n    lst : list\n        The list to be checked for nested objects.\n    strict : bool, optional\n        If True, all items in the list must be nested objects. If False, the function\n        returns True if any item is a nested object. Default is False.\n    allowed_types : tuple of types, optional\n        A tuple of types to consider as nested objects. If None, common nested types\n        like list, set, dict, and tuple are checked. Default is None.\n\n    Returns\n    -------\n    bool\n        True if the list contains nested objects according to the given parameters,\n        otherwise False.\n\n    Notes\n    -----\n    A nested object is defined as any item within the list that is not a primitive\n    data type (e.g., int, float, str) or is a complex structure like lists, sets,\n    dictionaries, etc. The function can be customized to check for specific types\n    using the `allowed_types` parameter.\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import contains_nested_objects\n    >>> example_list1 = [{1, 2}, [3, 4], {'key': 'value'}]\n    >>> example_list2 = [1, 2, 3, [4]]\n    >>> example_list3 = [1, 2, 3, 4]\n    >>> contains_nested_objects(example_list1)\n    True  # non-strict, contains nested objects\n    >>> contains_nested_objects(example_list1, strict=True)\n    True  # strict, all are nested objects\n    >>> contains_nested_objects(example_list2)\n    True  # non-strict, contains at least one nested object\n    >>> contains_nested_objects(example_list2, strict=True)\n    False  # strict, not all are nested objects\n    >>> contains_nested_objects(example_list3)\n    False  # non-strict, no nested objects\n    >>> contains_nested_objects(example_list3, strict=True)\n    False  # strict, no nested objects\n    ";
static const char __pyx_k_Dynamically_determine_or_valida[] = "\n    Dynamically determine or validate an epsilon value for numerical computations.\n\n    This function either validates a provided epsilon if it is a numeric value, or \n    calculates an appropriate epsilon dynamically based on the input data. The dynamic\n    calculation aims to adjust epsilon based on the scale of the input data, providing\n    flexibility and adaptability in algorithms where numerical stability is critical.\n\n    Parameters\n    ----------\n    eps : {'auto', float}\n        The epsilon value to use. If 'auto', the function dynamically determines an\n        appropriate epsilon based on `y_true` and `y_pred`. If a float, it validates\n        this as the epsilon value.\n    y_true : array-like, optional\n        True values array. Used in conjunction with `y_pred` to dynamically determine\n        epsilon if `eps` is 'auto'. If `None`, this input is ignored.\n    y_pred : array-like, optional\n        Predicted values array. Used alongside `y_true` for epsilon determination.\n        If `None`, this input is ignored.\n    base_epsilon : float, optional\n        Base epsilon value used as a starting point in dynamic determination. This\n        value is adjusted based on the `scale_factor` and the input data to compute\n        the final epsilon.\n    scale_factor : float, optional\n        Scaling factor applied to adjust the base epsilon in relation to the scale\n        of the input data. Helps tailor the epsilon to the problem's numerical scale.\n\n    Returns\n    -------\n    float\n        The determined or validated epsilon value. Ensures numerical operations\n        are conducted with an appropriate epsilon to avoid division by zero or\n        other numerical instabilities.\n\n    Examples\n    --------\n    >>> y_true = [1, 2, 3]\n    >>> y_pred = [1.1, 1.9, 3.05]\n    >>> check_epsilon('auto', y_true, y_pred)\n    0.00001  # Example output, actual value depends on `determine_epsilon` implementation.\n\n    >>> check_epsilon(1e-8)""\n    1e-8\n\n    Notes\n    -----\n    Using 'auto' for `eps` allows algorithms to adapt to different scales of data,\n    enhancing numerical stability without manually tuning the epsilon value.\n    ";
static const char __pyx_k_Ensure_that_provided_arrays_con[] = "\n    Ensure that provided arrays contain only non-negative values.\n\n    This function checks each provided array for non-negativity. If any negative\n    values are found in any array, it raises a ValueError. This check is crucial\n    for computations or algorithms where negative values are not permissible, such\n    as logarithmic transformations.\n\n    Parameters\n    ----------\n    *arrays : array-like\n        One or more array-like structures (e.g., lists, numpy arrays). Each array\n        is checked for non-negativity.\n    err_msg: str, optional \n        Specify a custom error message if negative values are found.\n        \n    Raises\n    ------\n    ValueError\n        If any array contains negative values, a ValueError is raised with a message\n        indicating that only non-negative values are expected.\n\n    Examples\n    --------\n    >>> y_true = [0, 1, 2, 3]\n    >>> y_pred = [0.5, 2.1, 3.5, -0.1]\n    >>> ensure_non_negative(y_true, y_pred)\n    ValueError: Negative value found. Expect only non-negative values.\n\n    Note\n    ----\n    The function uses a variable number of arguments, allowing flexibility in the number\n    of arrays checked in a single call.\n    ";
static const char __pyx_k_Ensure_that_the_input_X_is_conv[] = "\n    Ensure that the input X is converted to a 2-dimensional structure.\n    \n    Parameters\n    ----------\n    X : array-like or pandas.DataFrame\n        The input data to convert. Can be a list, numpy array, or DataFrame.\n    output_format : str, optional\n        The format of the returned object. Options are \"auto\", \"array\", or \"frame\".\n        \"auto\" returns a DataFrame if X is a DataFrame, otherwise a numpy array.\n        \"array\" always returns a numpy array.\n        \"frame\" always returns a pandas DataFrame.\n        \n    Returns\n    -------\n    ndarray or DataFrame\n        The converted 2-dimensional structure, either as a numpy array or DataFrame.\n    \n    Raises\n    ------\n    ValueError\n        If the `output_format` is not one of the allowed values.\n    \n    Examples\n    --------\n    >>> import numpy as np \n    >>> from gofast.tools.validator import ensure_2d\n    >>> X = np.array([1, 2, 3])\n    >>> ensure_2d(X, output_format=\"array\")\n    array([[1],\n           [2],\n           [3]])\n    >>> df = pd.DataFrame([1, 2, 3])\n    >>> ensure_2d(df, output_format=\"frame\")\n       0\n    0  1\n    1  2\n    2  3\n    ";
static const char __pyx_k_Expected_both_x_and_y_to_be_one[] = "Expected both 'x' and 'y' to be one-dimensional array-like structures.";
static const char __pyx_k_Expected_format_YYYY_or_YYYY_MM[] = "'. Expected format: YYYY or YYYY-MM-DD.";
static const char __pyx_k_Expected_sequence_or_array_like[] = "Expected sequence or array-like, got %s";
static const char __pyx_k_Expects_a_one_dimensional_array[] = "Expects a one-dimensional array, got: ";
static const char __pyx_k_Failed_to_construct_a_DataFrame[] = "Failed to construct a DataFrame from the provided data. Ensure that your input data is structured correctly, such as a list of lists or a dictionary with equal-length lists. Alternatively, provide a DataFrame directly.";
static const char __pyx_k_Filter_and_return_only_the_vali[] = "\n    Filter and return only the valid keyword arguments for a given callable object.\n\n    This function checks if the arguments in `kwargs` are valid for the \n    provided callable object (function, lambda function, method, or class). \n    If any argument is not valid, it is removed from `kwargs`. The function \n    returns only the valid `kwargs`.\n\n    Parameters\n    ----------\n    callable_obj : callable\n        The callable object (function, lambda function, method, or class) for \n        which the keyword arguments need to be validated.\n    \n    kwargs : dict\n        Dictionary of keyword arguments to be validated against the callable object.\n\n    Returns\n    -------\n    valid_kwargs : dict\n        Dictionary containing only the valid keyword arguments for the callable object.\n\n    Examples\n    --------\n    >>> def example_func(a, b, c=3):\n    ...     pass\n    >>> kwargs = {'a': 1, 'b': 2, 'd': 4}\n    >>> filter_valid_kwargs(example_func, kwargs)\n    {'a': 1, 'b': 2}\n    \n    >>> class ExampleClass:\n    ...     def __init__(self, x, y, z=10):\n    ...         pass\n    >>> kwargs = {'x': 1, 'y': 2, 'a': 3}\n    >>> filter_valid_kwargs(ExampleClass, kwargs)\n    {'x': 1, 'y': 2}\n    >>> filter_valid_kwargs(ExampleClass(), kwargs)\n    {'x': 1, 'y': 2}\n\n    Notes\n    -----\n    This function uses the `inspect` module to retrieve the signature of \n    the given callable object and validate the keyword arguments.\n    ";
static const char __pyx_k_Found_array_with_0_length_while[] = "Found array with 0 length while a minimum of 1 is required.";
static const char __pyx_k_Invalid_dtype_selector_provided[] = "Invalid dtype_selector provided. Valid options are :";
static const char __pyx_k_Negative_values_are_not_allowed[] = "Negative values are not allowed: ";
static const char __pyx_k_Normalization_by_sum_impossible[] = "Normalization by sum impossible with zero sum.";
static const char __pyx_k_Perform_is_fitted_validation_fo[] = "\n    Perform is_fitted validation for estimator.\n\n    Checks if the estimator is fitted by looking for attributes set during fitting.\n    Typically, these attributes end with an underscore ('_').\n\n    Parameters\n    ----------\n    estimator : BaseEstimator\n        An instance of a scikit-learn estimator.\n\n    attributes : str or list of str\n        The attributes to check for. These are typically set in the 'fit' method.\n\n    msg : str, optional\n        The message to raise in the NotFittedError. If not provided, a default\n        message is used.\n\n    Raises\n    ------\n    NotFittedError\n        If the given attributes are not found in the estimator.\n\n    Examples\n    --------\n    >>> from sklearn.ensemble import RandomForestClassifier\n    >>> clf = RandomForestClassifier()\n    >>> check_is_fitted(clf, ['feature_importances_'])\n    NotFittedError: This RandomForestClassifier instance is not fitted yet.\n    ";
static const char __pyx_k_Preprocess_input_arrays_to_hand[] = "\n    Preprocess input arrays to handle cases where zero could cause division errors\n    in subsequent metric computations.\n\n    Parameters\n    ----------\n    y_true : array-like\n        The input data array where zeros might cause division errors.\n    zero_division : {'warn', 'raise', 'ignore'}, default 'warn'\n        Determines the action to perform when a zero is encountered:\n        - 'warn': Issues a warning and replaces zeros with `replace_with` or `epsilon`.\n        - 'raise': Raises an error if a zero is found in the input data.\n        - 'ignore': Leaves the zeros as they are, useful when the metric calculation\n          can handle zeros natively.\n    metric_name : str, optional\n        Name of the metric for which this preprocessing is being done, to be included\n        in warnings or error messages for better context.\n    epsilon : float, optional\n        Small value to use as default replacement if `replace_with` is None,\n        default is 1e-15.\n    replace_with : float or None, optional\n        A specific value to replace zeros with, if None, `epsilon` is used.\n\n    Returns\n    -------\n    numpy.ndarray\n        The processed array with modifications based on the zero_division strategy.\n    \n    Raises\n    ------\n    ValueError\n        If `zero_division` is 'raise' and zero is found in `y_true`.\n\n    Notes\n    -----\n    Using `replace_with` allows for custom behavior when handling zeros, which can\n    be tailored to the specific requirements of different metric computations.\n    \n    Examples \n    ---------\n    >>> from gofast.tools.validator import handle_zero_division \n    >>> y_true = [0, 1, 2, 3, 0]\n    >>> processed_y_true = handle_zero_division(\n        y_true, replace_with=0.001, zero_division='warn')\n    >>> print(processed_y_true)\n\n    ";
static const char __pyx_k_Rechecks_and_coerces_column_dat[] = "\n    Rechecks and coerces column data types in a DataFrame to the most appropriate\n    numeric or datetime types if initially identified as objects. It can also handle\n    non-DataFrame inputs by attempting to construct a DataFrame before processing.\n\n    Parameters\n    ----------\n    data : pd.DataFrame, pd.Series, list, or dict\n        The data to process. If not a DataFrame, an attempt will be made to convert it.\n    coerce_numeric : bool, default=True\n        If True, tries to convert object columns to numeric data types.\n    coerce_datetime : bool, default=True\n        If True, tries to convert object columns to datetime data types.\n    column_prefix : str, default=\"col\"\n        Prefix for column names when constructing a DataFrame from non-DataFrame input.\n    return_as_numpy : bool or str, default=\"auto\"\n        If True or \"auto\", converts the DataFrame to a NumPy array upon returning.\n        If \"auto\", the output type matches the input type.\n\n    Returns\n    -------\n    Union[pd.DataFrame, np.ndarray]\n        The processed data, either as a DataFrame or a NumPy array.\n\n    Examples\n    --------\n    >>> data = {'a': ['1', '2', '3'], 'b': ['2021-01-01', '2021-02-01', 'not a date'], \n                'c': ['1.1', '2.2', '3.3']}\n    >>> df = pd.DataFrame(data)\n    >>> df = recheck_data_types(df)\n    >>> print(df.dtypes)\n    a             int64\n    b            object  # remains object due to mixed valid and invalid dates\n    c           float64\n    ";
static const char __pyx_k_Standardization_impossible_with[] = "Standardization impossible with zero variance.";
static const char __pyx_k_Start_date_time_must_be_earlier[] = "Start date/time must be earlier than end date/time.";
static const char __pyx_k_Validate_and_compute_sample_wei[] = "\n    Validate and compute sample weights for fitting.\n\n    Parameters\n    ----------\n    y : array-like of shape (n_samples,)\n        Target values.\n\n    sample_weight : array-like of shape (n_samples,), default=None\n        Sample weights. If None, then samples are equally weighted.\n\n    weighted_y : bool, default=False\n        If True, compute the weighted target values.\n\n    Returns\n    -------\n    sample_weight : array-like of shape (n_samples,)\n        Validated sample weights.\n\n    weighted_y_values : array-like of shape (n_samples,), optional\n        Weighted target values if `weighted_y` is True.\n\n    Raises\n    ------\n    ValueError\n        If `sample_weight` is not None and its length does not match the length of `y`.\n        If any value in `sample_weight` is negative.\n\n    Notes\n    -----\n    This function checks the input sample weights, ensuring they are consistent with\n    the target values `y`. If `sample_weight` is None, it returns an array of ones\n    indicating equal weighting. Otherwise, it validates and returns the given \n    sample weights. If `weighted_y` is True, it also computes and returns the \n    weighted target values.\n\n    Examples\n    --------\n    >>> import numpy as np \n    >>> y = np.array([0, 1, 1, 0, 1])\n    >>> validate_fit_weights(y)\n    array([1., 1., 1., 1., 1.])\n\n    >>> sample_weight = np.array([1, 0.5, 1, 1.5, 1])\n    >>> validate_fit_weights(y, sample_weight)\n    array([1. , 0.5, 1. , 1.5, 1. ])\n\n    >>> validate_fit_weights(y, sample_weight, weighted_y=True)\n    (array([1. , 0.5, 1. , 1.5, 1. ]), array([0. , 0.5, 1. , 0. , 1. ]))\n\n    >>> validate_fit_weights(y, weighted_y=True)\n    (array([1., 1., 1., 1., 1.]), array([0., 1., 1., 0., 1.]))\n    ";
static const char __pyx_k_Validate_that_the_input_data_fo[] = "\n    Validate that the input data forms a square matrix and optionally aligns its \n    indices and columns if specified.\n\n    Parameters:\n    -----------\n    data : DataFrame or array-like\n        The input data to validate as a square matrix.\n    align : bool, default False\n        Whether to align the DataFrame's index with its columns.\n    align_mode : str, default 'auto'\n        Alignment mode if indices and columns do not match. Options are 'auto', \n        'index_to_columns', and 'columns_to_index'.\n    message : str, default ''\n        Additional message to append to the error if validation fails.\n\n    Returns:\n    --------\n    data\n        The validated or aligned square matrix.\n\n    Raises:\n    -------\n    ValueError\n        If the input is not a square matrix.\n\n    Examples:\n    ---------\n    >>> from gofast.tools.validator import validate_square_matrix\n    >>> validate_square(np.array([[1, 2], [3, 4]]))\n    array([[1, 2],\n           [3, 4]])\n\n    >>> validate_square(pd.DataFrame([[1, 2], [3, 4, 5]]))\n    ValueError: Input must be a square matrix.\n\n    Notes:\n    ------\n    A square matrix is defined as having equal number of rows and columns. \n    This function checks the dimensionality of the data and optionally aligns \n    the index and columns if `align` is set to True.\n    ";
static const char __pyx_k_Validate_that_the_target_arrays[] = "\n    Validate that the target arrays are suitable for classification tasks. \n    \n    This function is designed to ensure that target arrays (`y`) contain only \n    finite, categorical values, and it raises a ValueError if the targets do \n    not meet the criteria necessary for classification tasks, such as the \n    presence of continuous values, NaNs, or infinite values.\n    \n    This validation is crucial for preprocessing steps in machine learning \n    pipelines to ensure that the data is appropriate for classification \n    algorithms.\n\n    Parameters\n    ----------\n    *y : array-like\n        One or more target arrays to be validated. The input can be in the \n        form of lists, numpy arrays, or pandas series. Each array is checked \n        individually to ensure it  meets the criteria for classification targets.\n        \n    target_type : str, optional\n        The expected data type of the target arrays. Supported values are \n        'numeric' and 'object'. If 'numeric', the function attempts to \n        convert the target arrays to integers, raising an error if conversion \n        is not possible due to non-numeric values. If 'object', the target \n        arrays are left as numpy arrays of dtype `object`, suitable for \n        categorical classification without conversion. Default is 'numeric'.\n        \n    strategy : str, optional\n        Defines the approach for evaluating if the target arrays are suitable \n        for classification based on their unique values and data types. The \n        'auto' strategy uses heuristic or automatic detection to decide whether \n        target data should be treated as categorical, which is useful for most \n        cases. Custom strategies can be defined to enforce specific validation \n        rules or preprocessing steps based on the nature of the target data \n        (e.g., 'continuous', 'multilabel-indicator', 'unknown'). These custom \n        strategies should align with the outcomes"" of a predefined \n        `type_of_target` function, allowing for nuanced handling of different \n        target data scenarios. The default value is ``'auto'``, which applies \n        general rules for categorization and numeric conversion where applicable.\n        \n        If a strategy other than ``'auto'`` is specified, it directly influences \n        how the data is validated and potentially converted, based on the \n        expected or detected type of target data:\n\n        - If 'continuous', the function checks if the data can be used for \n          regression tasks and raises an error for classification use without \n          explicit binning.\n        - If 'multilabel-indicator', it validates the data for multilabel \n          classification tasks and ensures appropriate format.\n        - If 'unknown', it attempts to validate the data with generic checks, \n          raising errors for any unclear or unsupported data formats.\n\n    verbose : bool, optional\n        If set to True, the function prints a message for each target array \n        checked, confirming that it is suitable for classification. This \n        is helpful for debugging and when validating multiple target arrays \n        simultaneously.\n\n    Raises\n    ------\n    ValueError\n        If any of the target arrays contain values unsuitable for classification. This\n        includes arrays with continuous values, NaNs, infinite values, or arrays that do\n        not represent categorical data properly.\n\n    Examples\n    --------\n    Using the function with a single array of integer labels:\n    \n    >>> from gofast.tools.validator import check_classification_targets\n    >>> y = [1, 2, 3, 2, 1]\n    >>> check_classification_targets(y)\n    [array([1, 2, 3, 2, 1], dtype=object)]\n\n    Using the function with multiple arrays, including a mix of integer and \n    string labels:\n\n    >>> y1 = [0, 1, 0, 1]\n    >>> y2 = [\"spam\", \"ham\", \"spam\", \"ham\"]\n    >>> check""_classification_targets(y1, y2, verbose=True)\n    Targets are suitable for classification.\n    Targets are suitable for classification.\n    [array([0, 1, 0, 1], dtype=object), array(['spam', 'ham', 'spam', 'ham'], dtype=object)]\n\n    Attempting to use the function with an array containing NaN values:\n\n    >>> y_with_nan = [1, np.nan, 2, 1]\n    >>> check_classification_targets(y_with_nan)\n    ValueError: Target values contain NaN or infinite numbers, which are not \n    suitable for classification.\n\n    Attempting to use the function with a continuous target array:\n\n    >>> y_continuous = np.linspace(0, 1, 10)\n    >>> check_classification_targets(y_continuous)\n    ValueError: The number of unique values is too high for a classification task.\n    Validating and converting a mixed-type target array to numeric:\n\n    >>> y_mixed = [1, '2', 3.0, '4', 5]\n    >>> check_classification_targets(y_mixed, target_type='numeric')\n    ValueError: Target array at index 0 contains non-numeric values, which \n    cannot be converted to integers: ['2', '4']...\n\n    Validating object target arrays without attempting conversion:\n\n    >>> y_str = [\"apple\", \"banana\", \"cherry\"]\n    >>> check_classification_targets(y_str, target_type='object')\n    [array(['apple', 'banana', 'cherry'], dtype=object)]\n    \n    ";
static const char __pyx_k_Validate_the_multioutput_parame[] = "\n    Validate the `multioutput` parameter value and handle special cases.\n\n    This function checks if the provided `multioutput` value is one of the\n    accepted strings ('raw_values', 'uniform_average', 'raise', 'warn'). It\n    warns or raises an error based on the value if it's applicable.\n\n    Parameters\n    ----------\n    value : str\n        The value of the `multioutput` parameter to be validated. Accepted\n        values are 'raw_values', 'uniform_average', 'raise', 'warn'.\n    extra : str, optional\n        Additional text to include in the warning or error message if\n        `multioutput` is not applicable.\n\n    Returns\n    -------\n    str\n        The validated `multioutput` value in lowercase if it's one of the\n        accepted values. If the value is 'warn' or 'raise', the function\n        handles the case accordingly without returning a value.\n\n    Raises\n    ------\n    ValueError\n        If `value` is not one of the accepted strings and is not 'raise'.\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import validate_multioutput\n    >>> validate_multioutput('raw_values')\n    'raw_values'\n\n    >>> validate_multioutput('warn', extra=' for Dice Similarity Coefficient')\n    # This will warn that multioutput parameter is not applicable for Dice\n    # Similarity Coefficient.\n\n    >>> validate_multioutput('raise', extra=' for Gini Coefficient')\n    # This will raise a ValueError indicating that multioutput parameter\n    # is not applicable for Gini Coefficient.\n\n    >>> validate_multioutput('average')\n    # This will raise a ValueError indicating 'average' is an invalid value\n    # for multioutput parameter.\n\n    Note\n    ----\n    The function is designed to ensure API consistency across various metrics\n    functions by providing a standard way to handle `multioutput` parameter\n    values, especially in contexts where multiple outputs are not applicable.\n    ";
static const char __pyx_k_Validates_a_DataFrame_to_ensure[] = "\n    Validates a DataFrame to ensure it is a square matrix and that the index \n    and column names match. Optionally aligns the index names to the column \n    names or vice versa based on the alignment parameter.\n\n    Parameters\n    ----------\n    df : pandas.DataFrame\n        The DataFrame to validate.\n    alignment : str, default 'auto'\n        Controls how the DataFrame's index and columns are aligned if they d\n        o not match.\n        Options are 'auto', 'index_to_columns', and 'columns_to_index'.\n    \n    Returns\n    -------\n    pandas.DataFrame\n        The validated and potentially modified DataFrame.\n    \n    Raises\n    ------\n    ValueError\n        If the DataFrame is not square or if index and column names do not match\n        and no suitable alignment option is specified.\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import validate_comparison_data\n    >>> data = pd.DataFrame({\n    ...     'A': [1, 0.9, 0.8],\n    ...     'B': [0.9, 1, 0.85],\n    ...     'C': [0.8, 0.85, 1]\n    ... }, index=['A', 'B', 'X'])\n    >>> print(validate_comparison_data(data, alignment='index_to_columns'))\n    \n    >>> data = pd.DataFrame({\n    ...     1: [1, 0.9, 0.8],\n    ...     2: [0.9, 1, 0.85],\n    ...     3: [0.8, 0.85, 1]\n    ... }, index=[1, 2, 'X'])\n    >>> print(validate_comparison_data(data, alignment='auto'))\n    ";
static const char __pyx_k_Validates_and_adjusts_the_provi[] = "\n    Validates and adjusts the provided range tuples to ensure each is\n    composed of two numerical values and is sorted in ascending order.\n\n    This function takes multiple range specifications as keyword arguments,\n    each expected to be a tuple of two numerical values (min, max). It validates\n    the format and contents of each range, adjusting them if necessary to ensure\n    that each tuple is ordered as (min, max).\n\n    Parameters\n    ----------\n    **kwargs : dict\n        Keyword arguments where each key is the name of a range (e.g., 'lat_range')\n        and its corresponding value is a tuple of two numerical values representing\n        the minimum and maximum of that range.\n\n    Returns\n    -------\n    dict\n        A dictionary with the same keys as the input, but with each tuple value\n        adjusted to ensure it is in the format (min, max).\n\n    Raises\n    ------\n    ValueError\n        If any provided range tuple does not contain exactly two values, contains\n        non-numerical values, or if the min value is not less than the max value.\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import validate_and_adjust_ranges\n    >>> validate_and_adjust_ranges(lat_range=(34.00, 36.00), lon_range=(-118.50, -117.00))\n    {'lat_range': (34.00, 36.00), 'lon_range': (-118.50, -117.00)}\n\n    >>> validate_and_adjust_ranges(time_range=(10.0, 0.01))\n    {'time_range': (0.01, 10.0)}\n\n    >>> validate_and_adjust_ranges(invalid_range=(1, 'a'))\n    ValueError: invalid_range must contain numerical values.\n\n    Notes\n    -----\n    This function is particularly useful for preprocessing input ranges for\n    various analyses, ensuring consistency and correctness of range specifications.\n    It automates the adjustment of provided ranges, simplifying the setup process\n    for further data processing or modeling tasks.\n    ";
static const char __pyx_k_Validates_and_applies_a_specifi[] = "\n    Validates and applies a specified nan_policy to input arrays and\n    optionally to sample weights. This utility is essential for pre-processing\n    data prior to statistical analyses or model training, where appropriate\n    handling of NaN values is critical to ensure accurate and reliable outcomes.\n\n    Parameters\n    ----------\n    nan_policy : {'propagate', 'raise', 'omit'}\n        Defines how to handle NaNs in the input arrays. 'propagate' returns the\n        input data without changes. 'raise' throws an error if NaNs are detected.\n        'omit' removes rows with NaNs across all input arrays and sample weights.\n    *arrays : array-like\n        Variable number of input arrays to be validated and adjusted based on\n        the specified nan_policy.\n    sample_weights : array-like, optional\n        Sample weights array to be validated and adjusted in tandem with the\n        input arrays according to nan_policy. Defaults to None.\n\n    Returns\n    -------\n    arrays : tuple of np.ndarray\n        Adjusted input arrays, with modifications applied based on nan_policy.\n        The order of arrays in the tuple corresponds to the order of input.\n    sample_weights : np.ndarray or None\n        Adjusted sample weights, modified according to nan_policy if provided.\n        Returns None if no sample_weights were provided.\n\n    Raises\n    ------\n    ValueError\n        If `nan_policy` is not among the valid options ('propagate', 'raise',\n        'omit') or if NaNs are detected when `nan_policy` is set to 'raise'.\n\n    Notes\n    -----\n    Handling NaN values is a critical step in data preprocessing, especially\n    in datasets with missing values. The choice of nan_policy can significantly\n    impact subsequent statistical analysis or predictive modeling by either\n    including, excluding, or signaling errors for observations with missing\n    values. This function ensures consistent application of the chosen policy\n    across multiple ""datasets, facilitating robust and error-free analyses.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from gofast.tools.validator import validate_nan_policy\n    >>> y_true = np.array([1, np.nan, 3])\n    >>> y_pred = np.array([1, 2, 3])\n    >>> sample_weights = np.array([0.5, 0.5, 1.0])\n    >>> arrays, sw = validate_nan_policy('omit', y_true, y_pred, \n    ...                                  sample_weights=sample_weights)\n    >>> arrays\n    (array([1., 3.]), array([1., 3.]))\n    >>> sw\n    array([0.5, 1. ])\n    ";
static const char __pyx_k_Validates_and_optionally_conver[] = "\n    Validates and optionally converts an array-like object to a pandas DataFrame,\n    applying specified column names if provided or generating them if the `force`\n    parameter is set.\n\n    Parameters\n    ----------\n    X : array-like\n        The array to potentially convert to a DataFrame.\n    columns : str or list of str, optional\n        The names for the resulting DataFrame columns or the Series name.\n    to_frame : bool, default=False\n        If True, converts `X` to a DataFrame if it isn't already one.\n    input_name : str, default=''\n        The name of the input variable, used for error and warning messages.\n    raise_warning : bool, default=True\n        If True and `to_frame` is True but `columns` are not provided,\n        a warning is issued unless `force` is True.\n    raise_exception : bool, default=False\n        If True, raises an exception when `to_frame` is True but columns\n        are not provided and `force` is False.\n    force : bool, default=False\n        Forces the conversion of `X` to a DataFrame by generating column names\n        based on `input_name` if `columns` are not provided.\n\n    Returns\n    -------\n    pd.DataFrame or pd.Series\n        The potentially converted DataFrame or Series, or `X` unchanged.\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import array_to_frame\n    >>> from sklearn.datasets import load_iris\n    >>> data = load_iris()\n    >>> X = data.data\n    >>> array_to_frame(X, to_frame=True, columns=['sepal_length', 'sepal_width',\n                                                  'petal_length', 'petal_width'])\n    ";
static const char __pyx_k_Validates_and_optionally_normal[] = "\n    Validates and optionally normalizes the given weights array to ensure all elements \n    meet specified criteria and the structure is suitable for computations.\n\n    Parameters:\n    ----------\n    weights : array-like\n        Weights to be validated. Can be a list, tuple, or numpy array.\n    min_value : float, optional\n        Minimum allowable value for weights (inclusive). If None, weights are \n        expected to be non-negative. Explicitly set to a negative value if \n        negative weights are allowed.\n    max_value : float or None, optional\n        Maximum allowable value for weights (inclusive). If None, no upper \n        limit is enforced.\n    normalize : bool, optional\n        If True, weights will be normalized to sum to 1. Default is False.\n    allowed_dims : int or tuple, optional\n        Specifies the allowed dimensions of the weights array. Default is 1 \n        (one-dimensional). If a tuple is provided, weights must match one of \n        the dimensions specified in the tuple.\n\n    Returns:\n    -------\n    np.ndarray\n        A numpy array of the validated and optionally normalized weights.\n\n    Raises:\n    ------\n    ValueError\n        If weights contain values outside the specified range, or if the \n        format or dimensions are not suitable.\n\n    Examples:\n    --------\n    >>> from gofast.tools.validator import validate_weights\n    \n    >>> validate_weights([0.25, 0.75, 0.5], normalize=True)\n    array([0.2, 0.6, 0.4])\n\n    >>> validate_weights([-0.1, 0.9], min_value=0)\n    ValueError: Weights must be non-negative.\n\n    >>> validate_weights([0.1, 0.2, 0.7], max_value=0.5)\n    ValueError: Weights must not exceed 0.5.\n\n    >>> validate_weights([1, 2, 3], allowed_dims=(1, 2))\n    ValueError: Weights dimensions not allowed.\n    ";
static const char __pyx_k_Validates_if_a_given_value_is_n[] = "\n    Validates if a given value is numeric. It can accept numeric strings \n    and numpy arrays of single values. Optionally converts the value to \n    either float or integer.\n\n    Parameters\n    ----------\n    value : Any\n        The value to be validated as numeric. This can be of any type \n        but is expected to be convertible to a numeric type. Accepted \n        types include numeric strings (e.g., `\"42\"`), single-element \n        numpy arrays (e.g., `np.array([3.14])`), integers, and floats.\n    convert_to : str, optional\n        The type to convert the validated numeric value to. Options are \n        ``'float'`` or ``'int'``. Defaults to ``'float'``. \n        - If ``'float'``, the value will be converted to a floating-point number.\n        - If ``'int'``, the value will be converted to an integer.\n    allow_negative : bool, optional\n        Whether to allow negative values. Defaults to ``True``. \n        - If ``True``, negative values are allowed.\n        - If ``False``, negative values will raise a `ValueError`.\n    min_value : float or int, optional\n        The minimum value allowed. If `None`, no minimum value check \n        is applied. Defaults to ``None``.\n    max_value : float or int, optional\n        The maximum value allowed. If `None`, no maximum value check \n        is applied. Defaults to ``None``.\n    check_mode : str, optional\n        The mode of checking the value. Options are ``'soft'`` or ``'strict'``. \n        Defaults to ``'soft'``. \n        - If ``'soft'``, iterables containing a single value are accepted \n          and the single value is validated.\n        - If ``'strict'``, only non-iterable numeric values are accepted.\n\n    Returns\n    -------\n    float or int\n        The validated and optionally converted numeric value. The type \n        of the return value is determined by the `convert_to` parameter.\n\n    Raises\n    ------\n    ValueError\n        If the value is not numeric or does not m""eet the specified criteria.\n\n    Notes\n    -----\n    The function performs several checks and transformations:\n    1. If the value is a numpy array with a single element, it extracts \n       the element.\n    2. If the value is a numeric string, it attempts to convert it to \n       a float.\n    3. If `check_mode` is ``'soft'`` and the value is an iterable with \n       a single element, it extracts and validates the element.\n    4. It validates whether the value is numeric.\n    5. It converts the value to the specified type (`float` or `int`).\n    6. It checks if negative values are allowed.\n    7. It checks if the value is within the specified `min_value` and \n       `max_value` range.\n\n    The mathematical formulation for the validation can be expressed as:\n\n    .. math::\n        y = \n        \010egin{cases} \n        x & \text{if } x \\in \\mathbb{R} \\\n        \text{convert_to}(x) & \text{if } x \\in \text{numeric\\_string} \\\n        \text{single\\_element}(x) & \text{if } x \\in \text{numpy\\_array} \\\n        \\end{cases}\n\n    Where:\n    - :math:`x` is the input value\n    - :math:`y` is the output value after validation and conversion\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import validate_numeric\n    >>> validate_numeric(\"42\", convert_to='int')\n    42\n    >>> validate_numeric(np.array([3.14]), convert_to='float')\n    3.14\n    >>> validate_numeric([123], check_mode='soft')\n    123.0\n    >>> validate_numeric([123], check_mode='strict')\n    Traceback (most recent call last):\n        ...\n    ValueError: Value '[123]' is not a numeric type.\n    >>> validate_numeric(\"-123.45\", allow_negative=False)\n    Traceback (most recent call last):\n        ...\n    ValueError: Negative values are not allowed: -123.45\n\n    See Also\n    --------\n    numpy.array : Numpy arrays, which can be validated by this function.\n\n    References\n    ----------\n    .. [1] \"NumPy Documentation\", https://numpy.org/""doc/stable/\n    ";
static const char __pyx_k_Validates_or_generates_distribu[] = "\n    Validates or generates distributions for given elements ensuring the \n    sum equals 1.\n\n    Parameters:\n    ----------\n    distribution : str, tuple, list\n        The distribution to be validated or generated. If 'auto',\n        generates a random distribution for the specified number of elements. \n        Can also be a tuple or list representing an explicit distribution.\n    elements : int, list of str, optional\n        Defines how many elements the distribution should be generated for \n        when 'auto' is used. If a list of strings is provided, its length \n        is used to determine the number of elements.\n\n    Returns:\n    -------\n    tuple\n        A tuple representing the validated or generated distribution.\n\n    Raises:\n    ------\n    ValueError\n        If the provided distribution does not sum to 1 or contains invalid values.\n        \n    Examples \n    ---------\n    >>> from gofast.tools.validator import validate_distribution\n    >>> validate_distribution (\"auto\", elements= [ 'positive', 'neutral', 'negative'])\n    (0.1450318690603951, 0.5660028611331361, 0.2889652698064687)\n    ";
static const char __pyx_k_Validates_that_the_sample_weigh[] = "\n    Validates that the sample weights are suitable for use in calculations.\n\n    This function checks that the sample weights are non-negative and match\n    the length of the target array `y`. It raises an error if any conditions\n    are not met. If a single number is provided as weights, it will be\n    converted into an array with repeated values matching the length of `y`.\n\n    Parameters\n    ----------\n    weights : array-like or number\n        The sample weights to be validated. Each weight must be non-negative.\n        A single number will be converted to an array with repeated values.\n    y : array-like\n        The target array that the weights should correspond to. The length\n        of `weights` must match the length of `y`.\n    normalize : bool, optional\n        If True, weights will be normalized to sum to 1. Default is False.\n        \n    Returns\n    -------\n    numpy.ndarray\n        The validated sample weights as a numpy array.\n\n    Raises\n    ------\n    ValueError\n        If `weights` are not one-dimensional, if any weight is negative,\n        or if the length of `weights` does not match the length of `y`.\n\n    Examples\n    --------\n    >>> frpm gofast.tools.validator import validate_sample_weights\n    >>> y = [0, 1, 2, 3]\n    >>> weights = [0.1, 0.2, 0.3, 0.4]\n    >>> validate_sample_weights(weights, y)\n    array([0.1, 0.2, 0.3, 0.4])\n\n    >>> weights = [-0.1, 0.2, 0.3, 0.4]\n    >>> validate_sample_weights(weights, y)\n    ValueError: Sample weights must be non-negative.\n\n    >>> weights = [0.1, 0.2, 0.3]\n    >>> validate_sample_weights(weights, y)\n    ValueError: Length of sample weights must match length of y.\n    ";
static const char __pyx_k_Validates_that_the_scores_repre[] = "\n    Validates that the scores represent valid probability distributions and \n    checks consistency between scores and true labels in multi-output scenarios.\n\n    Parameters\n    ----------\n    scores : list or np.ndarray\n        A list of np.ndarrays for multi-output probabilities, or a single np.ndarray\n        for single-output probabilities. Each ndarray should contain probability\n        distributions where each row sums to approximately 1 and has \n        non-negative values.\n    true_labels : list or np.ndarray, optional\n        The true labels corresponding to the scores. This parameter must \n        be provided in multi-output scenarios to check the alignment of labels\n        and scores. Each element or row in true_labels should correspond to \n        the equivalent in scores.\n    mode : str, optional (default \"strict\")\n       Specifies the validation mode for checking probability distributions:\n       - 'strict': Each set of scores must sum exactly to 1, within a numerical\n         tolerance.\n       - 'soft': Scores must not exceed a total of 1, and all individual \n         scores must be non-negative.\n       - 'passthrough': Only checks that each score is between 0 and 1 \n         inclusive, without summing them.    \n    accept_multi_output : bool, default False\n        Flag indicating whether scores with multiple outputs are accepted. \n        If False and scores are provided as a list, a ValueError will be \n        raised.\n\n    Returns\n    -------\n    np.ndarray\n        The validated scores as a NumPy array.\n\n    Raises\n    ------\n    ValueError\n        If multi-output scores are provided and not accepted.\n        If there is a mismatch in the number of outputs between scores and \n        true_labels.\n        If scores or any subset of scores do not form valid probability \n        distributions.\n        If there is a mismatch in format expectations between scores and \n        true_labels in terms of multi-ou""tput handling.\n\n    Notes\n    -----\n    The function is designed to handle both single and multi-output probability\n    distributions. For multi-output scenarios, both scores and true_labels \n    should be lists of np.ndarrays.\n    This function is particularly useful in scenarios involving machine learning\n    models where output probabilities need to be validated before further\n    processing or metrics calculations.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from gofast.tools.validator import validate_scores\n    >>> scores_single = np.array([[0.1, 0.9], [0.8, 0.2]])\n    >>> print(validate_scores(scores_single))\n    [[0.1, 0.9]\n     [0.8, 0.2]]\n\n    >>> scores_multi = [np.array([[0.1, 0.9]]), np.array([[0.8, 0.2]])]\n    >>> true_labels_multi = [np.array([1]), np.array([0])]\n    >>> print(validate_scores(scores_multi, true_labels_multi, accept_multi_output=True))\n    [array([[0.1, 0.9]]), array([[0.8, 0.2]])]\n    ";
static const char __pyx_k_Validates_that_the_true_and_pre[] = "\n    Validates that the true and predicted target arrays are suitable for further\n    processing. This involves ensuring that both arrays are non-empty, of the\n    same length, and meet any additional criteria specified by keyword arguments.\n\n    Parameters\n    ----------\n    y_true : array-like\n        The true target values.\n    y_pred : array-like\n        The predicted target values.\n    **kwargs : dict\n        Additional keyword arguments to pass to the check_y function for any\n        extra validation criteria.\n\n    Returns\n    -------\n    y_true : array-like\n        Validated true target values.\n    y_pred : array-like\n        Validated predicted target values.\n\n    Raises\n    ------\n    ValueError\n        If the validation checks fail, indicating that the input arrays do not\n        meet the required criteria for processing.\n\n    Examples\n    --------\n    Suppose `check_y` validates that the input is a non-empty numpy array and\n    `check_consistent_length` ensures the arrays have the same number of elements.\n    Then, usage could be as follows:\n\n    >>> y_true = np.array([1, 2, 3])\n    >>> y_pred = np.array([1.1, 2.1, 3.1])\n    >>> y_true_valid, y_pred_valid = _ensure_y_is_valid(y_true, y_pred)\n    >>> print(y_true_valid, y_pred_valid)\n    [1 2 3] [1.1 2.1 3.1]\n    ";
static const char __pyx_k_Validates_the_nan_policy_or_any[] = "\n    Validates the `nan_policy` or any policy argument to ensure it is one\n    of the acceptable options (`allowed_policies`). \n    \n    Function is used to enforce conformity to predefined NaN handling\n    strategies in data processing tasks.\n\n    Parameters\n    ----------\n    nan_policy : str\n        The NaN handling policy to validate. Acceptable values are:\n        'propagate' - NaN values are propagated, i.e., no action is taken.\n        'omit' - NaN values are omitted before proceeding with the operation.\n        'raise' - Raises an error if NaN values are present.\n\n    allowed_policies : list of str, optional\n        A list of allowable policy options. If None, \n        defaults to ['propagate', 'omit', 'raise'].\n\n    Raises\n    ------\n    ValueError\n        If `nan_policy` is not one of the valid options in `allowed_policies`.\n\n    Returns\n    -------\n    str\n        The verified `nan_policy` value, confirming it is within \n        allowed parameters.        \n\n    Examples\n    --------\n    >>> from gofast.tools.validator import is_valid_policies\n    >>> is_valid_policies('omit')  # This should pass without an error.\n    >>> is_valid_policies('ignore')  # This should raise a ValueError.\n      \n    ";
static const char __pyx_k_Validates_the_review_length_ran[] = "\n    Validates the review length range ensuring it's a tuple with two integers \n    where the first value is less than the second.\n\n    Parameters:\n    ----------\n    length_range : tuple\n        A tuple containing two integers that represent the minimum and maximum\n        lengths of reviews.\n    sorted_values: bool, default=True \n        If True, the function expects the input length range to be sorted in \n        ascending order and will automatically sort it if not. If False, the \n        input length range is not expected to be sorted, and it will remain \n        as provided.\n    param_name : str, optional\n        The name of the parameter being validated. If None, the default name \n        'length_range' will be used in error messages.\n        \n    Returns\n    -------\n    tuple\n        The validated length range.\n\n    Raise\n    ------\n    ValueError\n        If the length range does not meet the requirements.\n        \n    Examples \n    --------\n    >>> from gofast.tools.validator import validate_length_range\n    >>> validate_length_range ( (202, 25) )\n    (25, 202)\n    >>> validate_length_range ( (202,) )\n    ValueError: length_range must be a tuple with two elements.\n    ";
static const char __pyx_k_Validates_whether_a_given_objec[] = "\n    Validates whether a given object is a Keras model and optionally performs \n    additional checks.\n\n    This function provides a mechanism to ensure that an object not only is an \n    instance of a Keras model but also conforms to additional, user-defined \n    criteria if specified. It offers an optional deep check that inspects the \n    model for key Keras methods, enhancing the validation\n    process.\n\n    Parameters\n    ----------\n    model : Any\n        The object to validate as a Keras model.\n    custom_check : Callable[[Any], bool], optional\n        An optional callback function that takes the model as input and returns\n        a boolean indicating whether the model passes custom validation criteria. \n        If `None`, no custom validation is performed.\n    deep_check : bool, optional\n        If True, performs a deep inspection of the model's attributes to ensure\n        it supports essential Keras functionality (default is False).\n        \n    raise_exception : bool, optional\n        If True, raises a TypeError when the model fails the validation\n        checks, instead of returning False.\n    Returns\n    -------\n    bool\n        True if the object is validated as a Keras model and satisfies any \n        specified custom validation criteria. False otherwise.\n\n    Raises\n    ------\n    ValueError\n        If the custom check is provided and raises an exception, indicating \n        failure of the custom validation logic.\n\n    Examples\n    --------\n    >>> from tensorflow.keras.layers import Dense\n    >>> from tensorflow.keras.models import Sequential\n    >>> from gofast.tools.validator import  validate_keras_model\n    >>> model = Sequential([Dense(2)])\n\n    Validate a simple Keras model without additional checks:\n    >>> validate_keras_model(model)\n    True\n\n    Validate with a custom check (e.g., model must have more than 1 layer):\n    >>> custom_layer_check = lambda m: len(m.layers) > 1\n    >>> validate_ke""ras_model(model, custom_check=custom_layer_check)\n    False\n\n    Validate with deep inspection:\n    >>> validate_keras_model(model, deep_check=True)\n    True\n    ";
static const char __pyx_k_Warning_used_to_notify_implicit[] = "Warning used to notify implicit data conversions happening in the code.\n    This warning occurs when some input data needs to be converted or\n    interpreted in a way that may not match the user's expectations.\n    For example, this warning may occur when the user\n        - passes an integer array to a function which expects float input and\n          will convert the input\n        - requests a non-copying operation, but a copy is required to meet the\n          implementation's data-type expectations;\n        - passes an input whose shape can be interpreted ambiguously.\n    .. versionchanged:: 0.18\n       Moved from sklearn.tools.validation.\n    ";
static const char __pyx_k_Weights_must_have_dimensions_in[] = "Weights must have dimensions in ";
static const char __pyx_k_When_providing_accept_sparse_as[] = "When providing 'accept_sparse' as a tuple or list, it must contain at least one string value.";
static const char __pyx_k_array_must_be_2_dimensional_and[] = "array must be 2-dimensional and square. shape = {0}";
static const char __pyx_k_as_it_inherently_combines_outpu[] = " as it inherently combines outputs into a single score.";
static const char __pyx_k_cannot_be_converted_to_DataFram[] = " cannot be converted to DataFrame with given columns.";
static const char __pyx_k_contains_negative_values_Expect[] = " contains negative values. Expect only non-negative values.";
static const char __pyx_k_contains_non_numeric_values_whi[] = " contains non-numeric values, which cannot be converted to integers: ";
static const char __pyx_k_deprecate_positional_args_local[] = "_deprecate_positional_args.<locals>._inner_deprecate_positional_args.<locals>.inner_f";
static const char __pyx_k_distributed_elements_must_be_sp[] = "'distributed_elements' must be specified when using 'auto' distribution.";
static const char __pyx_k_does_not_contain_datetime_objec[] = "' does not contain datetime objects.";
static const char __pyx_k_dtype_numeric_is_not_compatible[] = "dtype='numeric' is not compatible with arrays of bytes/strings.Convert your data to numeric values explicitly instead.";
static const char __pyx_k_get_feature_names_locals_genexp[] = "_get_feature_names.<locals>.genexpr.<locals>.genexpr";
static const char __pyx_k_include_boundaries_left_without[] = "`include_boundaries`='left' without specifying explicitly `min_val` is inconsistent.";
static const char __pyx_k_include_boundaries_right_withou[] = "`include_boundaries`='right' without specifying explicitly `max_val` is inconsistent.";
static const char __pyx_k_inner_deprecate_positional_args[] = "_inner_deprecate_positional_args";
static const char __pyx_k_is_greater_than_the_maximum_all[] = " is greater than the maximum allowed value ";
static const char __pyx_k_is_less_than_the_minimum_allowe[] = " is less than the minimum allowed value ";
static const char __pyx_k_is_originally_not_a_frame_Frame[] = " is originally not a frame. Frame conversion cannot be performed with no column names.";
static const char __pyx_k_is_probability_distribution_lin[] = "_is_probability_distribution (line 256)";
static const char __pyx_k_must_be_a_list_or_a_single_stri[] = " must be a list or a single string.";
static const char __pyx_k_must_be_a_tuple_with_two_elemen[] = " must be a tuple with two elements.";
static const char __pyx_k_o_is_expected_to_be_an_iterable[] = "'o' is expected to be an iterable object. got: ";
static const char __pyx_k_pandas_dtype_needs_early_conver[] = "_pandas_dtype_needs_early_conversion";
static const char __pyx_k_passing_these_as_positional_arg[] = " passing these as positional arguments will result in an error";
static const char __pyx_k_r_cannot_be_used_to_seed_a_nump[] = "%r cannot be used to seed a numpy.random.RandomState instance";
static const char __pyx_k_requires_column_names_for_conve[] = "' requires column names for conversion to a DataFrame. Provide `columns` or set `force=True` to auto-generate column names.";
static const char __pyx_k_requires_y_to_be_passed_but_the[] = " requires y to be passed, but the target y is None";
static const char __pyx_k_should_be_a_1d_array_got_an_arr[] = " should be a 1d array, got an array of shape ";
static const char __pyx_k_should_be_an_array_like_or_spar[] = "' should be an array-like or sparse matrix, but a string was passed.";
static const char __pyx_k_should_be_array_like_or_a_spars[] = "' should be array-like or a sparse matrix. Received: ";
static const char __pyx_k_to_DataFrame_requires_column_na[] = " to DataFrame requires column names. Provide `columns` or set `force=True` to generate them automatically.";
static const char __pyx_k_to_be_a_one_dimensional_array_l[] = "' to be a one-dimensional array-like structure.";
static const char __pyx_k_to_integers_Ensure_all_values_a[] = " to integers. Ensure all values are numeric and representable as integers. Original error: ";
static const char __pyx_k_validate_and_adjust_ranges_line[] = "validate_and_adjust_ranges (line 2541)";
static const char __pyx_k_validate_distribution_line_1352[] = "validate_distribution (line 1352)";
static const char __pyx_k_validate_length_range_line_1424[] = "validate_length_range (line 1424)";
static const char __pyx_k_validate_multiclass_target_line[] = "validate_multiclass_target (line 433)";
static const char __pyx_k_validate_square_matrix_line_311[] = "validate_square_matrix (line 311)";
static const char __pyx_k_validator_module_provides_a_com[] = "\n`validator` module provides a comprehensive set of functions and warnings\n for validating and ensuring the integrity of data. This includes \nutilities for checking data consistency, validating machine learning targets, \nensuring proper data types, and handling various validation scenarios.\n";
static const char __pyx_k_x_and_y_must_be_a_numeric_array[] = "x and y must be a numeric array.";
static const char __pyx_k_A_column_vector_y_was_passed_whe[] = "A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples, ), for example using ravel().";
static const char __pyx_k_A_singleton_array_r_cannot_be_co[] = "A singleton array %r cannot be considered a valid collection.";
static const char __pyx_k_A_sparse_matrix_was_passed_but_d[] = "A sparse matrix was passed, but dense data is required. Use X.toarray() to convert to a dense numpy array.";
static const char __pyx_k_Added_part_of_is_frame_dedicated[] = "Added part of `is_frame` dedicated to X and y frame reconversion \n    validation.\n    \n    Parameters \n    ------------\n    X: Array-like \n        Array to convert to frame. \n    columns: str or list of str \n        Series name or columns names for pandas.Series and DataFrame. \n        \n    to_frame: str, default=False\n        If ``True`` , reconvert the array to frame using the columns orthewise \n        no-action is performed and return the same array.\n    input_name : str, default=\"\"\n        The data name used to construct the error message. \n        \n    raise_warning : bool, default=True\n        If True then raise a warning if conversion is required.\n        If ``ignore``, warnings silence mode is triggered.\n    raise_exception : bool, default=False\n        If True then raise an exception if array is not symmetric.\n        \n    force:bool, default=False\n        Force conversion array to a frame is columns is not supplied.\n        Use the combinaison, `input_name` and `X.shape[1]` range.\n        \n    Returns\n    --------\n    X: converted array \n    \n    Example\n    ---------\n    >>> from gofast.datasets import fetch_data  \n    >>> from gofast.tools.validator import array_to_frame \n    >>> data = fetch_data ('hlogs').frame \n    >>> array_to_frame (data.k.values , \n                        to_frame= True, columns =None, input_name= 'y',\n                        raise_warning=\"silence\"\n                                ) \n    ... array([nan, nan, nan, ..., nan, nan, nan]) # mute \n    \n    ";
static const char __pyx_k_All_elements_in_the_target_array[] = "All elements in the target array must be non-negative integers.";
static const char __pyx_k_Array_sizes_must_be_consistent_a[] = "Array sizes must be consistent: '{}' and '{}' were given.";
static const char __pyx_k_Automatic_alignment_failed_Index[] = "Automatic alignment failed. Index and column names do not match and are of the same type. Please specify alignment explicitly.";
static const char __pyx_k_Both_y_true_and_y_pred_must_be_o[] = "Both y_true and y_pred must be one-dimensional arrays after optional flattening.";
static const char __pyx_k_Cannot_normalize_weights_because[] = "Cannot normalize weights because their sum is zero.";
static const char __pyx_k_Check_whether_the_estimator_s_fi[] = "Check whether the estimator's fit method supports the given parameter.\n    Parameters\n    ----------\n    estimator : object\n        An estimator to inspect.\n    parameter : str\n        The searched parameter.\n    Returns\n    -------\n    is_parameter : bool\n        Whether the parameter was found to be a named parameter of the\n        estimator's fit method.\n    Examples\n    --------\n    >>> from sklearn.svm import SVC\n    >>> from sklearn.tools.validation import has_fit_parameter\n    >>> has_fit_parameter(SVC(), \"sample_weight\")\n    True\n    ";
static const char __pyx_k_Check_your_date_data_For_datetim[] = "Check your date data. For datetime value, set `date_format` to '%Y-%m-%d %H:%M:%S'";
static const char __pyx_k_Columns_must_be_provided_for_Dat[] = "Columns must be provided for DataFrame conversion.";
static const char __pyx_k_Continuous_data_not_suitable_for[] = "Continuous data not suitable for classification without explicit binning.";
static const char __pyx_k_DataFrame_must_be_square_equal_n[] = "DataFrame must be square (equal number of rows and columns).";
static const char __pyx_k_Data_cannot_be_None_when_x_and_y[] = "Data cannot be None when x and y have string arguments.";
static const char __pyx_k_Each_set_of_scores_must_be_a_val[] = "Each set of scores must be a valid probability distribution.";
static const char __pyx_k_Encountered_zero_in_y_true_leadi[] = "Encountered zero in y_true, leading to division by zero in ";
static const char __pyx_k_Encountered_zero_in_y_true_which[] = "Encountered zero in y_true, which may lead to infinite values or NaNs in ";
static const char __pyx_k_Epsilon_must_be_auto_or_converti[] = "Epsilon must be 'auto' or convertible to float. Got '";
static const char __pyx_k_Error_converting_target_array_at[] = "Error converting target array at index ";
static const char __pyx_k_Expect_a_dataframe_while_columns[] = "Expect a dataframe while columns is missing.";
static const char __pyx_k_Expect_columns_to_build_the_data[] = "Expect columns to build the data frame or set `force` to ``True`` to create a temporary frame: Got ";
static const char __pyx_k_Expected_2D_array_got_1D_array_i[] = "Expected 2D array, got 1D array instead. Reshape your data either using array.reshape(-1, 1) if your data has a single feature or array.reshape(1, -1) if it contains a single sample.";
static const char __pyx_k_Expected_2D_array_got_scalar_arr[] = "Expected 2D array, got scalar array instead:\narray={}.\nReshape your data either using array.reshape(-1, 1) if your data has a single feature or array.reshape(1, -1) if it contains a single sample.";
static const char __pyx_k_Expected_categoric_types_but_fou[] = "Expected categoric types but found numeric data.";
static const char __pyx_k_Expected_int_float_or_str_for_ye[] = "Expected int, float, or str for year, got ";
static const char __pyx_k_Expected_multi_output_for_true_l[] = "Expected multi-output for true_labels but got a single output.";
static const char __pyx_k_Expected_numeric_types_but_found[] = "Expected numeric types but found mixed types. Non-numeric data will be ignored.";
static const char __pyx_k_Feature_names_only_support_names[] = "Feature names only support names that are all strings. Got feature names with dtypes: ";
static const char __pyx_k_Found_input_variables_with_incon[] = "Found input variables with inconsistent numbers of samples: %r";
static const char __pyx_k_Input_values_contain_NaNs_and_na[] = "Input values contain NaNs and nan_policy is 'raise'.";
static const char __pyx_k_Invalid_alignment_option_provide[] = "Invalid alignment option provided. Please choose from 'index_to_columns', 'columns_to_index', or 'auto'.";
static const char __pyx_k_Invalid_value_for_multioutput_pa[] = "Invalid value for multioutput parameter. Expect 'raw_values' or 'uniform_average'. Got '";
static const char __pyx_k_Length_of_sample_weights_must_ma[] = "Length of sample weights must match length of y.";
static const char __pyx_k_Mismatch_in_the_number_of_output[] = "Mismatch in the number of outputs between scores and true_labels.";
static const char __pyx_k_Missing_x_and_y_NoneType_not_sup[] = "Missing x and y. NoneType not supported.";
static const char __pyx_k_Mixed_data_types_found_Be_cautio[] = "Mixed data types found. Be cautious of unintended data type issues.";
static const char __pyx_k_Mixed_types_detected_Please_enco[] = "Mixed types detected. Please encode categorical variables first.";
static const char __pyx_k_Mixed_types_detected_with_unexpe[] = "Mixed types detected with unexpected numeric data.";
static const char __pyx_k_Model_does_not_support_essential[] = "Model does not support essential Keras functionalities.";
static const char __pyx_k_Multi_output_scores_provided_but[] = "Multi-output scores provided but not accepted.";
static const char __pyx_k_Multilabel_indicator_format_dete[] = "Multilabel-indicator format detected, requiring different handling.";
static const char __pyx_k_NaN_values_found_in_the_data_but[] = "NaN values found in the data, but processing will continue.";
static const char __pyx_k_Name_or_columns_must_be_supplied[] = "Name or columns must be supplied for frame conversion.";
static const char __pyx_k_Non_multi_output_scores_with_mul[] = "Non-multi-output scores with multi-output true_labels.";
static const char __pyx_k_Non_numeric_target_values_contai[] = "Non-numeric target values contain None or NaN, not suitable for classification.";
static const char __pyx_k_Normalization_impossible_with_ze[] = "Normalization impossible with zero variance.";
static const char __pyx_k_Numeric_target_values_contain_Na[] = "Numeric target values contain NaN or infinite numbers, not suitable for classification.";
static const char __pyx_k_Numpy_array_must_contain_exactly[] = "Numpy array must contain exactly one element.";
static const char __pyx_k_Only_sparse_matrices_with_32_bit[] = "Only sparse matrices with 32-bit integer indices are accepted. Got %s indices.";
static const char __pyx_k_Parameter_accept_sparse_should_b[] = "Parameter 'accept_sparse' should be a string, boolean or list of strings. You provided 'accept_sparse={}'.";
static const char __pyx_k_Performance_data_expects_a_DataF[] = "Performance data expects a DataFrame; got ";
static const char __pyx_k_Provided_object_is_not_a_Keras_m[] = "Provided object is not a Keras model.";
static const char __pyx_k_Sample_weights_must_be_non_negat[] = "Sample weights must be non-negative.";
static const char __pyx_k_Sample_weights_must_be_one_dimen[] = "Sample weights must be one-dimensional.";
static const char __pyx_k_Scores_must_be_a_valid_probabili[] = "Scores must be a valid probability distribution.";
static const char __pyx_k_Singleton_array_r_cannot_be_cons[] = "Singleton array %r cannot be considered a valid collection.";
static const char __pyx_k_Start_and_end_dates_are_within_t[] = "Start and end dates are within the same year but not the same date. Consider using return_as_date_str=True or providing specific dates.";
static const char __pyx_k_Target_array_must_be_one_dimensi[] = "Target array must be one-dimensional unless multi-output is accepted.";
static const char __pyx_k_Target_array_must_contain_at_lea[] = "Target array must contain at least two distinct classes.";
static const char __pyx_k_Target_values_must_be_categorica[] = "Target values must be categorical, numeric, or convertible to categories.";
static const char __pyx_k_Targets_are_suitable_for_classif[] = "Targets are suitable for classification.";
static const char __pyx_k_The_distribution_must_have_exact[] = "The distribution must have exactly ";
static const char __pyx_k_The_multioutput_parameter_is_not[] = "The `multioutput` parameter is not applicable";
static const char __pyx_k_The_sum_of_the_distribution_valu[] = "The sum of the distribution values must be equal to 1";
static const char __pyx_k_This_name_s_instance_is_not_fitt[] = "This %(name)s instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.";
static const char __pyx_k_This_s_instance_is_not_fitted_ye[] = "This %s instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.";
static const char __pyx_k_Unable_to_determine_the_target_t[] = "Unable to determine the target type, please check the input data.";
static const char __pyx_k_Unable_to_find_the_number_of_fea[] = "Unable to find the number of features from X of type ";
static const char __pyx_k_Unable_to_generate_feature_names[] = "Unable to generate feature names without n_features_in_";
static const char __pyx_k_Unknown_value_for_include_bounda[] = "Unknown value for `include_boundaries`: ";
static const char __pyx_k_Unsupported_expected_type_provid[] = "Unsupported expected_type provided. Choose 'numeric', 'categoric', or 'both'.";
static const char __pyx_k_Unsupported_or_mismatched_data_t[] = "Unsupported or mismatched data type: ";
static const char __pyx_k_Validation_failed_in_strict_mode[] = "Validation failed in strict mode. Expected type '";
static const char __pyx_k_Warning_raised_when_the_eigenval[] = "Warning raised when the eigenvalues of a PSD matrix have issues\n    This warning is typically raised by ``_check_psd_eigenvalues`` when the\n    eigenvalues of a positive semidefinite (PSD) matrix such as a gram matrix\n    (kernel) present significant negative eigenvalues, or bad conditioning i.e.\n    very small non-zero eigenvalues compared to the largest eigenvalue.\n    .. versionadded:: 0.22\n    ";
static const char __pyx_k_Weights_must_be_non_negative_unl[] = "Weights must be non-negative unless 'min_value' is explicitly set to allow negative values.";
static const char __pyx_k_Weights_must_be_provided_in_a_fo[] = "Weights must be provided in a format that can be converted to a numpy array.";
static const char __pyx_k_bi___selector_biselect_biselecto[] = "bi[-_]?selector|biselect|biselector";
static const char __pyx_k_check_classification_targets_lin[] = "check_classification_targets (line 2011)";
static const char __pyx_k_check_classification_targets_loc[] = "check_classification_targets.<locals>.genexpr";
static const char __pyx_k_check_mixed_data_types_line_2276[] = "check_mixed_data_types (line 2276)";
static const char __pyx_k_check_mixed_data_types_locals_la[] = "check_mixed_data_types.<locals>.<lambda>";
static const char __pyx_k_contains_nested_objects_line_148[] = "contains_nested_objects (line 1481)";
static const char __pyx_k_contains_nested_objects_locals_g[] = "contains_nested_objects.<locals>.genexpr";
static const char __pyx_k_contains_nested_objects_locals_i[] = "contains_nested_objects.<locals>.is_nested";
static const char __pyx_k_data_type_must_be_either_array_o[] = "data_type must be either 'array' or 'dataframe'";
static const char __pyx_k_distribution_must_be_auto_a_tupl[] = "distribution must be 'auto', a tuple, or a list of distributions";
static const char __pyx_k_does_not_accept_missing_values_2[] = " does not accept missing values encoded as NaN natively. For supervised learning, you might want to consider sklearn.ensemble.HistGradientBoostingClassifier and Regressor which accept missing values encoded as NaNs natively. Alternatively, it is possible to preprocess the data, for instance by using an imputer transformer in a pipeline or drop samples with missing values. See https://scikit-learn.org/stable/modules/impute.html You can find a list of all estimators that handle NaN values at the following page: https://scikit-learn.org/stable/modules/impute.html#estimators-that-handle-nan-values";
static const char __pyx_k_force_all_finite_should_be_a_boo[] = "force_all_finite should be a bool or \"allow-nan\". Got {!r} instead";
static const char __pyx_k_has_required_attributes_locals_g[] = "has_required_attributes.<locals>.genexpr";
static const char __pyx_k_infinity_or_a_value_too_large_fo[] = "infinity or a value too large for ";
static const char __pyx_k_input_features_is_not_equal_to_f[] = "input_features is not equal to feature_names_in_";
static const char __pyx_k_input_features_should_have_lengt[] = "input_features should have length equal to number of features (";
static const char __pyx_k_np_matrix_is_not_supported_Pleas[] = "np.matrix is not supported. Please convert to a numpy array with np.asarray. For more information see: https://numpy.org/doc/stable/reference/generated/numpy.matrix.html";
static const char __pyx_k_pandas_DataFrame_with_sparse_col[] = "pandas.DataFrame with sparse columns found.It will be converted to a dense numpy array.";
static const char __pyx_k_parameter_validator_locals_valid[] = "parameter_validator.<locals>.validator";
static const char __pyx_k_validate_and_adjust_ranges_local[] = "validate_and_adjust_ranges.<locals>.genexpr";
static const char __pyx_k_validate_comparison_data_line_92[] = "validate_comparison_data (line 925)";
static const char __pyx_k_validate_data_types_locals__hand[] = "validate_data_types.<locals>._handle_categoric.<locals>.<lambda>";
static const char __pyx_k_validate_dates_locals_parse_year[] = "validate_dates.<locals>.parse_year_input";
static const char __pyx_k_validate_length_range_locals_gen[] = "validate_length_range.<locals>.genexpr";
static const char __pyx_k_validate_nan_policy_locals_genex[] = "validate_nan_policy.<locals>.genexpr";
static const char __pyx_k_validate_sample_weights_line_507[] = "validate_sample_weights (line 507)";
static const char __pyx_k_deprecate_positional_args_local_2[] = "_deprecate_positional_args.<locals>._inner_deprecate_positional_args";
static const char __pyx_k_get_feature_names_locals_genexp_2[] = "_get_feature_names.<locals>.genexpr";
static const char __pyx_k_Sample_weights_must_be_non_negat_2[] = "Sample weights must be non-negative";
static const char __pyx_k_validate_data_types_locals__hand_2[] = "validate_data_types.<locals>._handle_numeric";
static const char __pyx_k_validate_data_types_locals__hand_3[] = "validate_data_types.<locals>._handle_categoric";
static PyObject *__pyx_kp_u_01;
static PyObject *__pyx_kp_u_1_3;
static PyObject *__pyx_kp_u_A_column_vector_y_was_passed_whe;
static PyObject *__pyx_kp_u_A_singleton_array_r_cannot_be_co;
static PyObject *__pyx_kp_u_A_sparse_matrix_was_passed_but_d;
static PyObject *__pyx_kp_u_Added_part_of_is_frame_dedicated;
static PyObject *__pyx_kp_u_All_distribution_values_must_be;
static PyObject *__pyx_kp_u_All_elements_in_the_target_array;
static PyObject *__pyx_n_s_Any;
static PyObject *__pyx_kp_u_Array;
static PyObject *__pyx_kp_u_Array_2;
static PyObject *__pyx_kp_u_Array_at_index;
static PyObject *__pyx_kp_u_Array_is_not_symmetric_and_will;
static PyObject *__pyx_kp_u_Array_must_be_symmetric;
static PyObject *__pyx_kp_u_Array_sizes_must_be_consistent_a;
static PyObject *__pyx_kp_u_Assert_the_name_of_x_and_y_in_t;
static PyObject *__pyx_n_s_AttributeError;
static PyObject *__pyx_kp_u_Automatic_alignment_failed_Index;
static PyObject *__pyx_kp_u_Automatic_strategy_detected_too;
static PyObject *__pyx_kp_u_Both_elements_in;
static PyObject *__pyx_kp_u_Both_y_true_and_y_pred_must_be_o;
static PyObject *__pyx_n_s_BuiltinFunctionType;
static PyObject *__pyx_n_u_C;
static PyObject *__pyx_n_s_Callable;
static PyObject *__pyx_kp_u_Can_t_check_s_sparse_matrix_for;
static PyObject *__pyx_kp_u_Cannot_normalize_weights_because;
static PyObject *__pyx_n_s_CategoricalDtype;
static PyObject *__pyx_kp_u_Check_if_the_provided_DataFrame;
static PyObject *__pyx_kp_u_Check_whether_the_estimator_s_fi;
static PyObject *__pyx_kp_u_Check_whether_the_target_array;
static PyObject *__pyx_kp_u_Check_your_date_data_For_datetim;
static PyObject *__pyx_kp_u_Checks_for_mixed_data_types_in;
static PyObject *__pyx_kp_u_Checks_if_TensorFlow_is_install;
static PyObject *__pyx_kp_u_Checks_if_a_specified_column_in;
static PyObject *__pyx_kp_u_Checks_if_an_array_is_normalize;
static PyObject *__pyx_kp_u_Checks_if_the_given_data_DataFr;
static PyObject *__pyx_kp_u_Checks_if_the_provided_array_is;
static PyObject *__pyx_kp_u_Checks_if_y_is_a_probability_di;
static PyObject *__pyx_kp_u_Choose_ceil_floor_or_None;
static PyObject *__pyx_kp_u_Choose_from;
static PyObject *__pyx_kp_u_Column;
static PyObject *__pyx_kp_u_Columns_for;
static PyObject *__pyx_kp_u_Columns_for_input_name_r_expect;
static PyObject *__pyx_kp_u_Columns_indices_imply;
static PyObject *__pyx_kp_u_Columns_must_be_provided_for_Dat;
static PyObject *__pyx_n_s_ComplexWarning;
static PyObject *__pyx_kp_u_Complex_data_not_supported;
static PyObject *__pyx_kp_u_Continuous_data_not_suitable_for;
static PyObject *__pyx_kp_u_Conversion_of;
static PyObject *__pyx_kp_u_Creates_a_validator_function_fo;
static PyObject *__pyx_kp_u_Custom_check_failed;
static PyObject *__pyx_n_u_Data;
static PyObject *__pyx_n_s_DataConversionWarning;
static PyObject *__pyx_n_u_DataConversionWarning;
static PyObject *__pyx_n_s_DataFrame;
static PyObject *__pyx_n_u_DataFrame;
static PyObject *__pyx_kp_u_DataFrame_must_be_square_equal_n;
static PyObject *__pyx_kp_u_Data_cannot_be_None_when_x_and_y;
static PyObject *__pyx_kp_u_Determine_whether_the_input_eit;
static PyObject *__pyx_kp_u_Determines_whether_a_list_conta;
static PyObject *__pyx_kp_u_Dynamically_determine_or_valida;
static PyObject *__pyx_kp_u_Each_set_of_scores_must_be_a_val;
static PyObject *__pyx_kp_u_Encountered_zero_in_y_true_leadi;
static PyObject *__pyx_kp_u_Encountered_zero_in_y_true_which;
static PyObject *__pyx_kp_u_Ensure_that_provided_arrays_con;
static PyObject *__pyx_kp_u_Ensure_that_the_input_X_is_conv;
static PyObject *__pyx_kp_u_Epsilon_must_be_auto_or_converti;
static PyObject *__pyx_kp_u_Error_converting_target_array_at;
static PyObject *__pyx_n_u_Expect;
static PyObject *__pyx_kp_u_Expect_a_dataframe_Got;
static PyObject *__pyx_kp_u_Expect_a_dataframe_while_columns;
static PyObject *__pyx_kp_u_Expect_columns_to_build_the_data;
static PyObject *__pyx_kp_u_Expect_type_array_got;
static PyObject *__pyx_kp_u_Expected;
static PyObject *__pyx_kp_u_Expected_2D_array_got_1D_array_i;
static PyObject *__pyx_kp_u_Expected_2D_array_got_scalar_arr;
static PyObject *__pyx_kp_u_Expected_both_x_and_y_to_be_one;
static PyObject *__pyx_kp_u_Expected_categoric_types_but_fou;
static PyObject *__pyx_kp_u_Expected_format_YYYY_or_YYYY_MM;
static PyObject *__pyx_kp_u_Expected_int_float_or_str_for_ye;
static PyObject *__pyx_kp_u_Expected_multi_output_for_true_l;
static PyObject *__pyx_kp_u_Expected_numeric_types_but_found;
static PyObject *__pyx_kp_u_Expected_sequence_or_array_like;
static PyObject *__pyx_kp_u_Expects_a_one_dimensional_array;
static PyObject *__pyx_kp_u_Expects_an_array_got;
static PyObject *__pyx_n_s_FLOAT_DTYPES;
static PyObject *__pyx_kp_u_Failed_to_construct_a_DataFrame;
static PyObject *__pyx_kp_u_Feature_names_only_support_names;
static PyObject *__pyx_kp_u_Filter_and_return_only_the_vali;
static PyObject *__pyx_kp_u_Found_array_with;
static PyObject *__pyx_kp_u_Found_array_with_0_length_while;
static PyObject *__pyx_kp_u_Found_array_with_dim;
static PyObject *__pyx_kp_u_Found_input_variables_with_incon;
static PyObject *__pyx_n_s_FutureWarning;
static PyObject *__pyx_kp_u_Got;
static PyObject *__pyx_n_s_IGNORECASE;
static PyObject *__pyx_n_s_ImportError;
static PyObject *__pyx_kp_u_Input;
static PyObject *__pyx_kp_u_Input_contains_NaN;
static PyObject *__pyx_kp_u_Input_must_be_a_square_matrix;
static PyObject *__pyx_kp_u_Input_values_contain_NaNs_and_na;
static PyObject *__pyx_n_s_Integral;
static PyObject *__pyx_kp_u_Invalid_alignment_option_provide;
static PyObject *__pyx_kp_u_Invalid_dtype_selector_provided;
static PyObject *__pyx_kp_u_Invalid_input;
static PyObject *__pyx_kp_u_Invalid_nan_policy;
static PyObject *__pyx_kp_u_Invalid_nan_policy_2;
static PyObject *__pyx_kp_u_Invalid_rounding_method;
static PyObject *__pyx_kp_u_Invalid_validation_mode;
static PyObject *__pyx_kp_u_Invalid_value_for_multioutput_pa;
static PyObject *__pyx_n_s_KEYWORD_ONLY;
static PyObject *__pyx_kp_u_Length_of_sample_weights_must_ma;
static PyObject *__pyx_n_s_Memory;
static PyObject *__pyx_kp_u_Mismatch_in_the_number_of_output;
static PyObject *__pyx_kp_u_Missing_x_and_y_NoneType_not_sup;
static PyObject *__pyx_kp_u_Mixed_data_types_found_Be_cautio;
static PyObject *__pyx_kp_u_Mixed_types_detected_Please_enco;
static PyObject *__pyx_kp_u_Mixed_types_detected_with_unexpe;
static PyObject *__pyx_n_s_Model;
static PyObject *__pyx_kp_u_Model_does_not_support_essential;
static PyObject *__pyx_kp_u_Multi_output_scores_provided_but;
static PyObject *__pyx_kp_u_Multilabel_indicator_format_dete;
static PyObject *__pyx_n_s_NUMERIC_KINDS;
static PyObject *__pyx_n_u_NaN;
static PyObject *__pyx_kp_u_NaN_values_found_in_the_data;
static PyObject *__pyx_kp_u_NaN_values_found_in_the_data_but;
static PyObject *__pyx_kp_u_Name_or_columns_must_be_supplied;
static PyObject *__pyx_kp_u_Negative_values_are_not_allowed;
static PyObject *__pyx_kp_u_Non_multi_output_scores_with_mul;
static PyObject *__pyx_kp_u_Non_numeric_target_values_contai;
static PyObject *__pyx_kp_u_None;
static PyObject *__pyx_kp_u_Normalization_by_sum_impossible;
static PyObject *__pyx_kp_u_Normalization_impossible_with_ze;
static PyObject *__pyx_n_s_NotFittedError;
static PyObject *__pyx_kp_u_Numeric_target_values_contain_Na;
static PyObject *__pyx_kp_u_Numpy_array_must_contain_exactly;
static PyObject *__pyx_n_u_O;
static PyObject *__pyx_kp_u_Only_sparse_matrices_with_32_bit;
static PyObject *__pyx_n_s_Optional;
static PyObject *__pyx_n_s_POSITIONAL_OR_KEYWORD;
static PyObject *__pyx_n_s_Parameter;
static PyObject *__pyx_kp_u_Parameter_accept_sparse_should_b;
static PyObject *__pyx_kp_u_Pass;
static PyObject *__pyx_kp_u_Perform_is_fitted_validation_fo;
static PyObject *__pyx_kp_u_Performance_data_expects_a_DataF;
static PyObject *__pyx_n_s_PositiveSpectrumWarning;
static PyObject *__pyx_n_u_PositiveSpectrumWarning;
static PyObject *__pyx_kp_u_Possible_values_are;
static PyObject *__pyx_kp_u_Preprocess_input_arrays_to_hand;
static PyObject *__pyx_kp_u_Provided_object_is_not_a_Keras_m;
static PyObject *__pyx_n_s_RandomState;
static PyObject *__pyx_n_s_Real;
static PyObject *__pyx_kp_u_Rechecks_and_coerces_column_dat;
static PyObject *__pyx_n_s_RuntimeWarning;
static PyObject *__pyx_kp_u_Sample_weights_must_be_non_negat;
static PyObject *__pyx_kp_u_Sample_weights_must_be_non_negat_2;
static PyObject *__pyx_kp_u_Sample_weights_must_be_one_dimen;
static PyObject *__pyx_kp_u_Scores_must_be_a_valid_probabili;
static PyObject *__pyx_n_s_Sequential;
static PyObject *__pyx_n_s_Series;
static PyObject *__pyx_kp_u_Shape_of_passed_values_for;
static PyObject *__pyx_kp_u_Shape_of_passed_values_is;
static PyObject *__pyx_kp_u_Singleton_array_r_cannot_be_cons;
static PyObject *__pyx_n_s_SparseDtype;
static PyObject *__pyx_kp_u_Standardization_impossible_with;
static PyObject *__pyx_kp_u_Start_and_end_dates_are_within_t;
static PyObject *__pyx_kp_u_Start_date_time_must_be_earlier;
static PyObject *__pyx_n_s_T;
static PyObject *__pyx_kp_u_Target_array_at_index;
static PyObject *__pyx_kp_u_Target_array_must_be_one_dimensi;
static PyObject *__pyx_kp_u_Target_array_must_contain_at_lea;
static PyObject *__pyx_kp_u_Target_values_must_be_categorica;
static PyObject *__pyx_kp_u_Targets_are_suitable_for_classif;
static PyObject *__pyx_kp_u_The_distribution_must_have_exact;
static PyObject *__pyx_kp_u_The_first_element_in;
static PyObject *__pyx_kp_u_The_multioutput_parameter_is_not;
static PyObject *__pyx_kp_u_The_parameter;
static PyObject *__pyx_kp_u_The_sum_of_the_distribution_valu;
static PyObject *__pyx_kp_u_This_name_s_instance_is_not_fitt;
static PyObject *__pyx_kp_u_This_s_instance_is_not_fitted_ye;
static PyObject *__pyx_kp_u_Time_column;
static PyObject *__pyx_kp_u_Time_intervals_are_not_regular;
static PyObject *__pyx_n_s_TypeError;
static PyObject *__pyx_n_u_USV;
static PyObject *__pyx_kp_u_Unable_to_determine_the_target_t;
static PyObject *__pyx_kp_u_Unable_to_find_the_name;
static PyObject *__pyx_kp_u_Unable_to_find_the_number_of_fea;
static PyObject *__pyx_kp_u_Unable_to_generate_feature_names;
static PyObject *__pyx_n_s_Union;
static PyObject *__pyx_kp_u_Unknown_value_for_include_bounda;
static PyObject *__pyx_kp_u_Unsupported_expected_type_provid;
static PyObject *__pyx_kp_u_Unsupported_or_mismatched_data_t;
static PyObject *__pyx_kp_u_Unsupported_target_type;
static PyObject *__pyx_kp_u_Unsupports_mode;
static PyObject *__pyx_kp_u_Use_numeric_or_object;
static PyObject *__pyx_n_s_UserWarning;
static PyObject *__pyx_kp_u_Valid_modes_are_strict_soft_or;
static PyObject *__pyx_kp_u_Valid_options_are;
static PyObject *__pyx_kp_u_Validate_and_compute_sample_wei;
static PyObject *__pyx_kp_u_Validate_that_the_input_data_fo;
static PyObject *__pyx_kp_u_Validate_that_the_target_arrays;
static PyObject *__pyx_kp_u_Validate_the_multioutput_parame;
static PyObject *__pyx_kp_u_Validates_a_DataFrame_to_ensure;
static PyObject *__pyx_kp_u_Validates_and_adjusts_the_provi;
static PyObject *__pyx_kp_u_Validates_and_applies_a_specifi;
static PyObject *__pyx_kp_u_Validates_and_optionally_conver;
static PyObject *__pyx_kp_u_Validates_and_optionally_normal;
static PyObject *__pyx_kp_u_Validates_and_parses_start_and;
static PyObject *__pyx_kp_u_Validates_if_a_given_value_is_n;
static PyObject *__pyx_kp_u_Validates_or_generates_distribu;
static PyObject *__pyx_kp_u_Validates_that_the_sample_weigh;
static PyObject *__pyx_kp_u_Validates_that_the_scores_repre;
static PyObject *__pyx_kp_u_Validates_that_the_target_data;
static PyObject *__pyx_kp_u_Validates_that_the_true_and_pre;
static PyObject *__pyx_kp_u_Validates_the_nan_policy_or_any;
static PyObject *__pyx_kp_u_Validates_the_review_length_ran;
static PyObject *__pyx_kp_u_Validates_whether_a_given_objec;
static PyObject *__pyx_kp_u_Validation_failed_in_strict_mode;
static PyObject *__pyx_kp_u_Value;
static PyObject *__pyx_n_s_ValueError;
static PyObject *__pyx_kp_u_Value_2;
static PyObject *__pyx_kp_s_Warning_raised_when_the_eigenval;
static PyObject *__pyx_kp_s_Warning_used_to_notify_implicit;
static PyObject *__pyx_kp_u_Weights_must_be_between;
static PyObject *__pyx_kp_u_Weights_must_be_non_negative_unl;
static PyObject *__pyx_kp_u_Weights_must_be_provided_in_a_fo;
static PyObject *__pyx_kp_u_Weights_must_have_dimensions_in;
static PyObject *__pyx_kp_u_When_providing_accept_sparse_as;
static PyObject *__pyx_n_s_X;
static PyObject *__pyx_n_u_X;
static PyObject *__pyx_kp_u_Y_m_d;
static PyObject *__pyx_kp_u_Year;
static PyObject *__pyx_kp_u__100;
static PyObject *__pyx_kp_u__101;
static PyObject *__pyx_n_s__102;
static PyObject *__pyx_n_u__102;
static PyObject *__pyx_n_u__103;
static PyObject *__pyx_kp_u__113;
static PyObject *__pyx_kp_u__117;
static PyObject *__pyx_n_s__118;
static PyObject *__pyx_kp_u__16;
static PyObject *__pyx_kp_u__18;
static PyObject *__pyx_kp_u__52;
static PyObject *__pyx_kp_u__53;
static PyObject *__pyx_kp_u__54;
static PyObject *__pyx_kp_u__63;
static PyObject *__pyx_kp_u__64;
static PyObject *__pyx_kp_u__7;
static PyObject *__pyx_kp_u__81;
static PyObject *__pyx_kp_u__82;
static PyObject *__pyx_kp_u__83;
static PyObject *__pyx_kp_u__92;
static PyObject *__pyx_kp_u__93;
static PyObject *__pyx_kp_u__97;
static PyObject *__pyx_kp_u__98;
static PyObject *__pyx_kp_u__99;
static PyObject *__pyx_kp_u_a;
static PyObject *__pyx_kp_u_a_non_negative_integer;
static PyObject *__pyx_kp_u_a_positive_integer;
static PyObject *__pyx_n_s_accept_large_sparse;
static PyObject *__pyx_n_s_accept_multi_output;
static PyObject *__pyx_n_s_accept_multioutput;
static PyObject *__pyx_n_s_accept_sparse;
static PyObject *__pyx_n_s_actual_type_y_pred;
static PyObject *__pyx_n_s_actual_type_y_true;
static PyObject *__pyx_n_s_adjusted_ranges;
static PyObject *__pyx_n_s_align;
static PyObject *__pyx_n_s_align_mode;
static PyObject *__pyx_n_s_alignment;
static PyObject *__pyx_n_s_all;
static PyObject *__pyx_n_s_all_2;
static PyObject *__pyx_n_s_all_args;
static PyObject *__pyx_n_s_all_or_any;
static PyObject *__pyx_n_s_allclose;
static PyObject *__pyx_kp_u_allow_nan;
static PyObject *__pyx_n_s_allow_nan_2;
static PyObject *__pyx_n_s_allow_nd;
static PyObject *__pyx_n_s_allow_negative;
static PyObject *__pyx_n_s_allowed_dims;
static PyObject *__pyx_n_s_allowed_policies;
static PyObject *__pyx_n_s_allowed_types;
static PyObject *__pyx_kp_u_and;
static PyObject *__pyx_kp_u_and_2;
static PyObject *__pyx_n_s_any;
static PyObject *__pyx_n_s_api;
static PyObject *__pyx_n_s_apply;
static PyObject *__pyx_n_s_ar1;
static PyObject *__pyx_n_s_ar2;
static PyObject *__pyx_n_s_arg;
static PyObject *__pyx_n_s_args;
static PyObject *__pyx_n_s_args_msg;
static PyObject *__pyx_n_s_arr;
static PyObject *__pyx_n_s_arr_name;
static PyObject *__pyx_n_s_array;
static PyObject *__pyx_n_u_array;
static PyObject *__pyx_n_u_array_2;
static PyObject *__pyx_n_s_array_api;
static PyObject *__pyx_n_s_array_equal;
static PyObject *__pyx_kp_u_array_must_be_2_dimensional_and;
static PyObject *__pyx_n_s_array_orig;
static PyObject *__pyx_n_s_array_to_frame;
static PyObject *__pyx_n_u_array_to_frame;
static PyObject *__pyx_n_s_array_to_frame2;
static PyObject *__pyx_n_u_array_to_frame2;
static PyObject *__pyx_kp_u_array_to_frame2_line_4956;
static PyObject *__pyx_kp_u_array_to_frame_line_4885;
static PyObject *__pyx_n_s_arrays;
static PyObject *__pyx_kp_u_as_it_inherently_combines_outpu;
static PyObject *__pyx_kp_u_as_keyword_args_From_version;
static PyObject *__pyx_n_s_asarray;
static PyObject *__pyx_n_s_asarray_with_order;
static PyObject *__pyx_n_s_asformat;
static PyObject *__pyx_n_s_assert_all_finite;
static PyObject *__pyx_n_s_assert_all_finite_2;
static PyObject *__pyx_n_u_assert_all_finite_2;
static PyObject *__pyx_n_s_assert_xy_in;
static PyObject *__pyx_n_u_assert_xy_in;
static PyObject *__pyx_kp_u_assert_xy_in_line_2884;
static PyObject *__pyx_n_s_astype;
static PyObject *__pyx_n_s_atol;
static PyObject *__pyx_n_s_attr;
static PyObject *__pyx_n_s_attributes;
static PyObject *__pyx_n_u_auto;
static PyObject *__pyx_n_u_average_uniform;
static PyObject *__pyx_n_s_axis;
static PyObject *__pyx_n_s_base_epsilon;
static PyObject *__pyx_n_u_best_estimator;
static PyObject *__pyx_n_u_best_params;
static PyObject *__pyx_kp_u_bi___selector_biselect_biselecto;
static PyObject *__pyx_n_u_biselect;
static PyObject *__pyx_n_s_biselect_pattern;
static PyObject *__pyx_n_u_biselector;
static PyObject *__pyx_n_u_biufc;
static PyObject *__pyx_n_u_bool;
static PyObject *__pyx_n_u_both;
static PyObject *__pyx_n_u_bsr;
static PyObject *__pyx_n_u_buifc;
static PyObject *__pyx_n_s_build_data_if;
static PyObject *__pyx_n_u_build_data_if;
static PyObject *__pyx_n_s_build_data_if2;
static PyObject *__pyx_n_u_build_data_if2;
static PyObject *__pyx_n_u_builtins;
static PyObject *__pyx_kp_u_but_columns_implied;
static PyObject *__pyx_n_u_c;
static PyObject *__pyx_n_u_cache;
static PyObject *__pyx_n_s_callable_obj;
static PyObject *__pyx_kp_u_cannot_be_converted_to_DataFram;
static PyObject *__pyx_n_s_casting;
static PyObject *__pyx_n_s_catch_warnings;
static PyObject *__pyx_n_u_categoric;
static PyObject *__pyx_kp_u_categoric_al__only_categorical;
static PyObject *__pyx_n_u_categoric_only;
static PyObject *__pyx_n_s_categoric_pattern;
static PyObject *__pyx_n_u_category;
static PyObject *__pyx_n_s_ceil;
static PyObject *__pyx_n_u_ceil;
static PyObject *__pyx_n_s_changed_format;
static PyObject *__pyx_n_s_check;
static PyObject *__pyx_n_s_check_X_y;
static PyObject *__pyx_n_u_check_X_y;
static PyObject *__pyx_n_s_check_array;
static PyObject *__pyx_n_u_check_array;
static PyObject *__pyx_n_s_check_array_in;
static PyObject *__pyx_n_s_check_array_locals_genexpr;
static PyObject *__pyx_n_s_check_classification_targets;
static PyObject *__pyx_n_u_check_classification_targets;
static PyObject *__pyx_kp_u_check_classification_targets_lin;
static PyObject *__pyx_n_s_check_classification_targets_loc;
static PyObject *__pyx_n_s_check_consistency_size;
static PyObject *__pyx_n_u_check_consistency_size;
static PyObject *__pyx_n_s_check_consistency_size_2;
static PyObject *__pyx_n_s_check_consistent_length;
static PyObject *__pyx_n_u_check_consistent_length;
static PyObject *__pyx_n_s_check_epsilon;
static PyObject *__pyx_n_u_check_epsilon;
static PyObject *__pyx_kp_u_check_epsilon_line_1868;
static PyObject *__pyx_n_s_check_estimator_name;
static PyObject *__pyx_n_s_check_feature_names_in;
static PyObject *__pyx_n_s_check_is_fitted;
static PyObject *__pyx_n_u_check_is_fitted;
static PyObject *__pyx_n_s_check_is_fitted2;
static PyObject *__pyx_n_u_check_is_fitted2;
static PyObject *__pyx_kp_u_check_is_fitted2_line_2836;
static PyObject *__pyx_n_s_check_large_sparse;
static PyObject *__pyx_n_s_check_memory;
static PyObject *__pyx_n_u_check_memory;
static PyObject *__pyx_n_s_check_mixed_data_types;
static PyObject *__pyx_n_u_check_mixed_data_types;
static PyObject *__pyx_kp_u_check_mixed_data_types_line_2276;
static PyObject *__pyx_n_s_check_mixed_data_types_locals_la;
static PyObject *__pyx_n_s_check_mode;
static PyObject *__pyx_n_s_check_random_state;
static PyObject *__pyx_n_u_check_random_state;
static PyObject *__pyx_n_s_check_scalar;
static PyObject *__pyx_n_u_check_scalar;
static PyObject *__pyx_n_s_check_scalar_locals_genexpr;
static PyObject *__pyx_n_s_check_scalar_locals_type_name;
static PyObject *__pyx_n_s_check_symmetric;
static PyObject *__pyx_n_u_check_symmetric;
static PyObject *__pyx_n_s_check_time_interval;
static PyObject *__pyx_n_s_check_y;
static PyObject *__pyx_n_u_check_y;
static PyObject *__pyx_n_s_check_y_1d;
static PyObject *__pyx_n_s_check_y_2;
static PyObject *__pyx_n_s_check_y_locals_genexpr;
static PyObject *__pyx_n_s_class;
static PyObject *__pyx_n_u_class;
static PyObject *__pyx_n_s_cline_in_traceback;
static PyObject *__pyx_n_s_close;
static PyObject *__pyx_n_s_cls_name;
static PyObject *__pyx_n_u_coerce;
static PyObject *__pyx_n_s_coerce_datetime;
static PyObject *__pyx_n_s_coerce_numeric;
static PyObject *__pyx_n_u_col;
static PyObject *__pyx_n_s_col_data;
static PyObject *__pyx_n_s_col_type;
static PyObject *__pyx_n_s_column;
static PyObject *__pyx_n_s_column_orig;
static PyObject *__pyx_n_s_column_prefix;
static PyObject *__pyx_n_s_column_stack;
static PyObject *__pyx_n_s_columns;
static PyObject *__pyx_n_u_columns;
static PyObject *__pyx_n_u_columns_to_index;
static PyObject *__pyx_n_s_comparison_operator;
static PyObject *__pyx_n_u_compile;
static PyObject *__pyx_n_s_complex_warning;
static PyObject *__pyx_kp_u_computation;
static PyObject *__pyx_n_s_concatenate;
static PyObject *__pyx_n_s_condition;
static PyObject *__pyx_n_u_contains;
static PyObject *__pyx_kp_u_contains_2;
static PyObject *__pyx_kp_u_contains_negative_values_Expect;
static PyObject *__pyx_n_s_contains_nested_objects;
static PyObject *__pyx_n_u_contains_nested_objects;
static PyObject *__pyx_kp_u_contains_nested_objects_line_148;
static PyObject *__pyx_n_s_contains_nested_objects_locals_g;
static PyObject *__pyx_n_s_contains_nested_objects_locals_i;
static PyObject *__pyx_kp_u_contains_non_numeric_values_whi;
static PyObject *__pyx_n_s_contextlib;
static PyObject *__pyx_n_u_continuous;
static PyObject *__pyx_n_s_conversion;
static PyObject *__pyx_n_s_convert_array_to_pandas;
static PyObject *__pyx_n_u_convert_array_to_pandas;
static PyObject *__pyx_n_s_convert_to;
static PyObject *__pyx_n_u_coo;
static PyObject *__pyx_n_s_copy;
static PyObject *__pyx_n_s_coreutils;
static PyObject *__pyx_n_u_csc;
static PyObject *__pyx_n_u_csr;
static PyObject *__pyx_n_s_current_year;
static PyObject *__pyx_n_s_custom_check;
static PyObject *__pyx_n_u_d;
static PyObject *__pyx_n_s_data;
static PyObject *__pyx_n_u_data;
static PyObject *__pyx_kp_u_data_frame_or_series;
static PyObject *__pyx_n_s_data_type;
static PyObject *__pyx_kp_u_data_type_must_be_either_array_o;
static PyObject *__pyx_n_u_dataframe;
static PyObject *__pyx_n_s_date_format;
static PyObject *__pyx_n_s_datetime;
static PyObject *__pyx_n_u_datetime;
static PyObject *__pyx_n_s_datetime_pattern;
static PyObject *__pyx_n_s_deep_check;
static PyObject *__pyx_n_s_dependency;
static PyObject *__pyx_n_s_deprecate_positional_args;
static PyObject *__pyx_n_s_deprecate_positional_args_local;
static PyObject *__pyx_n_s_deprecate_positional_args_local_2;
static PyObject *__pyx_n_s_determine_epsilon;
static PyObject *__pyx_n_s_df;
static PyObject *__pyx_n_s_df_only;
static PyObject *__pyx_n_s_diff;
static PyObject *__pyx_n_s_distributed_elements;
static PyObject *__pyx_kp_u_distributed_elements_must_be_sp;
static PyObject *__pyx_n_s_distribution;
static PyObject *__pyx_kp_u_distribution_must_be_auto_a_tupl;
static PyObject *__pyx_n_s_doc;
static PyObject *__pyx_kp_u_does_not_accept_missing_values;
static PyObject *__pyx_kp_u_does_not_accept_missing_values_2;
static PyObject *__pyx_kp_u_does_not_contain_datetime_objec;
static PyObject *__pyx_n_s_dropna;
static PyObject *__pyx_kp_u_dt_datetime;
static PyObject *__pyx_n_s_dtype;
static PyObject *__pyx_n_u_dtype;
static PyObject *__pyx_n_s_dtype_numeric;
static PyObject *__pyx_kp_u_dtype_numeric_is_not_compatible;
static PyObject *__pyx_n_s_dtype_orig;
static PyObject *__pyx_n_s_dtype_selector;
static PyObject *__pyx_n_s_dtypes;
static PyObject *__pyx_n_u_dtypes;
static PyObject *__pyx_n_s_dtypes_orig;
static PyObject *__pyx_n_s_e;
static PyObject *__pyx_n_s_elements;
static PyObject *__pyx_kp_u_elements_2;
static PyObject *__pyx_kp_u_elements_must_be_an_integer_or;
static PyObject *__pyx_n_s_empty;
static PyObject *__pyx_n_s_end_date;
static PyObject *__pyx_n_s_endswith;
static PyObject *__pyx_n_s_ensure_2d;
static PyObject *__pyx_n_u_ensure_2d;
static PyObject *__pyx_kp_u_ensure_2d_line_1144;
static PyObject *__pyx_n_s_ensure_min_features;
static PyObject *__pyx_n_s_ensure_min_samples;
static PyObject *__pyx_n_s_ensure_no_complex_data;
static PyObject *__pyx_n_s_ensure_non_negative;
static PyObject *__pyx_n_u_ensure_non_negative;
static PyObject *__pyx_kp_u_ensure_non_negative_line_1826;
static PyObject *__pyx_n_s_ensure_sparse_format;
static PyObject *__pyx_n_s_ensure_y_is_valid;
static PyObject *__pyx_kp_u_ensure_y_is_valid_line_1957;
static PyObject *__pyx_n_s_enter;
static PyObject *__pyx_n_s_enumerate;
static PyObject *__pyx_n_s_eps;
static PyObject *__pyx_n_s_epsilon;
static PyObject *__pyx_n_s_equals;
static PyObject *__pyx_n_s_err;
static PyObject *__pyx_n_s_err_msg;
static PyObject *__pyx_n_s_error;
static PyObject *__pyx_n_u_error;
static PyObject *__pyx_n_s_errors;
static PyObject *__pyx_n_s_errstate;
static PyObject *__pyx_n_s_estimator;
static PyObject *__pyx_n_u_estimator;
static PyObject *__pyx_n_s_estimator_name;
static PyObject *__pyx_n_s_exceptions;
static PyObject *__pyx_n_s_exist_features;
static PyObject *__pyx_n_s_exit;
static PyObject *__pyx_kp_u_expected_2;
static PyObject *__pyx_n_s_expected_include_boundaries;
static PyObject *__pyx_n_s_expected_type;
static PyObject *__pyx_n_u_expected_type;
static PyObject *__pyx_kp_u_expects;
static PyObject *__pyx_kp_u_expects_strict_or_soft;
static PyObject *__pyx_n_s_extra;
static PyObject *__pyx_n_s_extra_args;
static PyObject *__pyx_n_s_f;
static PyObject *__pyx_n_u_f;
static PyObject *__pyx_n_u_fc;
static PyObject *__pyx_n_u_feature;
static PyObject *__pyx_n_s_feature_names;
static PyObject *__pyx_n_s_feature_names_in;
static PyObject *__pyx_n_u_feature_names_in;
static PyObject *__pyx_kp_u_feature_s_shape;
static PyObject *__pyx_n_s_fill_value;
static PyObject *__pyx_n_s_filter_valid_kwargs;
static PyObject *__pyx_n_u_filter_valid_kwargs;
static PyObject *__pyx_kp_u_filter_valid_kwargs_line_99;
static PyObject *__pyx_n_s_find_spec;
static PyObject *__pyx_n_s_first_pass_isfinite;
static PyObject *__pyx_n_s_first_sample;
static PyObject *__pyx_n_s_fit;
static PyObject *__pyx_n_u_fit;
static PyObject *__pyx_n_s_fitted;
static PyObject *__pyx_n_s_flatten;
static PyObject *__pyx_n_s_float;
static PyObject *__pyx_n_u_float;
static PyObject *__pyx_n_s_float16;
static PyObject *__pyx_n_s_float32;
static PyObject *__pyx_n_s_float64;
static PyObject *__pyx_n_s_floating;
static PyObject *__pyx_n_s_floor;
static PyObject *__pyx_n_u_floor;
static PyObject *__pyx_kp_u_for_both_y_true_and_y_pred_but;
static PyObject *__pyx_n_s_force;
static PyObject *__pyx_n_s_force_all_finite;
static PyObject *__pyx_kp_u_force_all_finite_should_be_a_boo;
static PyObject *__pyx_n_s_format;
static PyObject *__pyx_n_u_frame;
static PyObject *__pyx_kp_u_from;
static PyObject *__pyx_n_s_full_like;
static PyObject *__pyx_n_s_func;
static PyObject *__pyx_n_s_functools;
static PyObject *__pyx_n_s_ge;
static PyObject *__pyx_n_s_generate_get_feature_names_out;
static PyObject *__pyx_n_s_generate_names;
static PyObject *__pyx_n_s_genexpr;
static PyObject *__pyx_n_s_get;
static PyObject *__pyx_n_s_get_estimator_name;
static PyObject *__pyx_n_u_get_estimator_name;
static PyObject *__pyx_n_s_get_feature_names;
static PyObject *__pyx_n_s_get_feature_names_locals_genexp;
static PyObject *__pyx_n_s_get_feature_names_locals_genexp_2;
static PyObject *__pyx_n_s_get_namespace;
static PyObject *__pyx_n_s_getformat;
static PyObject *__pyx_kp_u_got;
static PyObject *__pyx_kp_u_got_2;
static PyObject *__pyx_n_s_gt;
static PyObject *__pyx_n_s_handle_categoric;
static PyObject *__pyx_n_s_handle_numeric;
static PyObject *__pyx_n_s_handle_zero_division;
static PyObject *__pyx_n_u_handle_zero_division;
static PyObject *__pyx_kp_u_handle_zero_division_line_850;
static PyObject *__pyx_n_s_has_categorical;
static PyObject *__pyx_n_s_has_fit_parameter;
static PyObject *__pyx_n_u_has_fit_parameter;
static PyObject *__pyx_kp_u_has_fit_parameter_line_3596;
static PyObject *__pyx_n_s_has_inf;
static PyObject *__pyx_n_s_has_nan_error;
static PyObject *__pyx_n_s_has_numerical;
static PyObject *__pyx_n_s_has_required_attributes;
static PyObject *__pyx_n_u_has_required_attributes;
static PyObject *__pyx_n_s_has_required_attributes_locals_g;
static PyObject *__pyx_n_s_i;
static PyObject *__pyx_n_s_ignore;
static PyObject *__pyx_n_u_ignore;
static PyObject *__pyx_n_s_import;
static PyObject *__pyx_n_s_import_optional_dependency;
static PyObject *__pyx_n_s_importlib;
static PyObject *__pyx_n_s_importlib_util;
static PyObject *__pyx_kp_u_in;
static PyObject *__pyx_n_s_include_boundaries;
static PyObject *__pyx_kp_u_include_boundaries_left_without;
static PyObject *__pyx_kp_u_include_boundaries_right_withou;
static PyObject *__pyx_n_s_include_zero;
static PyObject *__pyx_n_s_index;
static PyObject *__pyx_n_s_index_keys;
static PyObject *__pyx_n_u_index_to_columns;
static PyObject *__pyx_n_u_indices;
static PyObject *__pyx_n_s_indices_datatype;
static PyObject *__pyx_n_u_indptr;
static PyObject *__pyx_kp_u_infinity_or_a_value_too_large_fo;
static PyObject *__pyx_n_s_inner_deprecate_positional_args;
static PyObject *__pyx_n_s_inner_f;
static PyObject *__pyx_n_s_input_features;
static PyObject *__pyx_kp_u_input_features_is_not_equal_to_f;
static PyObject *__pyx_kp_u_input_features_should_have_lengt;
static PyObject *__pyx_n_s_input_name;
static PyObject *__pyx_n_s_inspect;
static PyObject *__pyx_kp_u_instead;
static PyObject *__pyx_n_u_int;
static PyObject *__pyx_n_u_int32;
static PyObject *__pyx_n_s_int64;
static PyObject *__pyx_n_u_int64;
static PyObject *__pyx_n_s_integer;
static PyObject *__pyx_n_s_intervals;
static PyObject *__pyx_kp_u_is;
static PyObject *__pyx_kp_u_is_1d_array_only_pandas_Series;
static PyObject *__pyx_kp_u_is_a_class_not_an_instance;
static PyObject *__pyx_n_s_is_array_api;
static PyObject *__pyx_n_s_is_arraylike;
static PyObject *__pyx_n_s_is_arraylike_1d;
static PyObject *__pyx_n_s_is_arraylike_not_scalar;
static PyObject *__pyx_n_s_is_binary_class;
static PyObject *__pyx_n_u_is_binary_class;
static PyObject *__pyx_kp_u_is_binary_class_line_798;
static PyObject *__pyx_n_s_is_bool_dtype;
static PyObject *__pyx_n_s_is_buildin;
static PyObject *__pyx_n_s_is_categoric;
static PyObject *__pyx_n_s_is_categorical;
static PyObject *__pyx_n_u_is_categorical;
static PyObject *__pyx_n_s_is_categorical_dtype;
static PyObject *__pyx_kp_u_is_categorical_line_1215;
static PyObject *__pyx_n_s_is_cross_validated;
static PyObject *__pyx_n_s_is_dataframe;
static PyObject *__pyx_n_s_is_datetime64_any_dtype;
static PyObject *__pyx_n_s_is_extension_array_dtype;
static PyObject *__pyx_n_s_is_float_dtype;
static PyObject *__pyx_n_s_is_frame;
static PyObject *__pyx_n_u_is_frame;
static PyObject *__pyx_kp_u_is_greater_than_the_maximum_all;
static PyObject *__pyx_n_s_is_installed;
static PyObject *__pyx_n_u_is_installed;
static PyObject *__pyx_kp_u_is_installed_line_2764;
static PyObject *__pyx_n_s_is_integer_dtype;
static PyObject *__pyx_n_s_is_keras_model;
static PyObject *__pyx_n_u_is_keras_model;
static PyObject *__pyx_kp_u_is_less_than_the_minimum_allowe;
static PyObject *__pyx_n_s_is_nested;
static PyObject *__pyx_n_s_is_normalized;
static PyObject *__pyx_n_u_is_normalized;
static PyObject *__pyx_kp_u_is_normalized_line_660;
static PyObject *__pyx_n_s_is_normed;
static PyObject *__pyx_kp_u_is_not_a_numeric_type;
static PyObject *__pyx_kp_u_is_not_a_valid_numeric_string;
static PyObject *__pyx_n_s_is_numeric;
static PyObject *__pyx_n_s_is_numeric_dtype;
static PyObject *__pyx_n_s_is_object_dtype;
static PyObject *__pyx_kp_u_is_originally_not_a_frame_Frame;
static PyObject *__pyx_kp_u_is_out_of_the_valid_range_1900;
static PyObject *__pyx_n_s_is_probability_distribution;
static PyObject *__pyx_kp_u_is_probability_distribution_lin;
static PyObject *__pyx_kp_u_is_required;
static PyObject *__pyx_n_s_is_square_matrix;
static PyObject *__pyx_n_u_is_square_matrix;
static PyObject *__pyx_kp_u_is_square_matrix_line_360;
static PyObject *__pyx_n_s_is_time_series;
static PyObject *__pyx_n_u_is_time_series;
static PyObject *__pyx_kp_u_is_time_series_line_2787;
static PyObject *__pyx_n_s_is_valid_policies;
static PyObject *__pyx_n_u_is_valid_policies;
static PyObject *__pyx_kp_u_is_valid_policies_line_1700;
static PyObject *__pyx_n_s_isbuiltin;
static PyObject *__pyx_n_s_isclass;
static PyObject *__pyx_n_s_isclose;
static PyObject *__pyx_n_s_isf;
static PyObject *__pyx_n_s_isfinite;
static PyObject *__pyx_n_s_isin;
static PyObject *__pyx_n_s_isinf;
static PyObject *__pyx_n_s_isnan;
static PyObject *__pyx_n_s_isnull;
static PyObject *__pyx_n_s_isscalar;
static PyObject *__pyx_n_s_issparse;
static PyObject *__pyx_n_s_issubdtype;
static PyObject *__pyx_n_s_item;
static PyObject *__pyx_n_s_items;
static PyObject *__pyx_n_u_iter;
static PyObject *__pyx_n_u_iu;
static PyObject *__pyx_n_s_joblib;
static PyObject *__pyx_n_s_k;
static PyObject *__pyx_n_s_keras;
static PyObject *__pyx_n_s_key;
static PyObject *__pyx_n_s_keys;
static PyObject *__pyx_n_s_kind;
static PyObject *__pyx_n_u_kind;
static PyObject *__pyx_n_s_kwargs;
static PyObject *__pyx_n_s_kwonly_args;
static PyObject *__pyx_n_s_kws;
static PyObject *__pyx_n_s_l;
static PyObject *__pyx_n_s_le;
static PyObject *__pyx_n_u_left;
static PyObject *__pyx_n_u_len;
static PyObject *__pyx_n_s_length_range;
static PyObject *__pyx_n_u_length_range;
static PyObject *__pyx_n_s_lengths;
static PyObject *__pyx_n_s_loc;
static PyObject *__pyx_n_s_location;
static PyObject *__pyx_n_s_lower;
static PyObject *__pyx_n_s_lst;
static PyObject *__pyx_n_s_lt;
static PyObject *__pyx_n_s_main;
static PyObject *__pyx_n_s_map;
static PyObject *__pyx_n_s_match;
static PyObject *__pyx_n_s_match_method;
static PyObject *__pyx_n_s_math;
static PyObject *__pyx_n_s_mathex;
static PyObject *__pyx_n_s_matrix;
static PyObject *__pyx_n_s_max;
static PyObject *__pyx_n_s_max_length;
static PyObject *__pyx_n_s_max_val;
static PyObject *__pyx_n_s_max_value;
static PyObject *__pyx_n_s_may_share_memory;
static PyObject *__pyx_n_s_mean;
static PyObject *__pyx_n_s_memory;
static PyObject *__pyx_kp_u_memory_should_be_None_a_string;
static PyObject *__pyx_n_s_message;
static PyObject *__pyx_n_s_metaclass;
static PyObject *__pyx_n_s_method;
static PyObject *__pyx_n_u_method;
static PyObject *__pyx_kp_u_metric_computation;
static PyObject *__pyx_n_s_metric_name;
static PyObject *__pyx_n_s_min;
static PyObject *__pyx_n_s_min_length;
static PyObject *__pyx_n_s_min_val;
static PyObject *__pyx_n_s_min_value;
static PyObject *__pyx_n_s_mode;
static PyObject *__pyx_n_s_model;
static PyObject *__pyx_n_s_models;
static PyObject *__pyx_n_s_module;
static PyObject *__pyx_n_s_module_2;
static PyObject *__pyx_n_s_module_spec;
static PyObject *__pyx_n_s_msg;
static PyObject *__pyx_n_s_msg_dtype;
static PyObject *__pyx_n_s_msg_err;
static PyObject *__pyx_n_s_mtrand;
static PyObject *__pyx_n_s_multi_output;
static PyObject *__pyx_kp_u_multilabel_indicator;
static PyObject *__pyx_kp_u_must_be;
static PyObject *__pyx_kp_u_must_be_2;
static PyObject *__pyx_kp_u_must_be_a_list_or_a_single_stri;
static PyObject *__pyx_kp_u_must_be_a_tuple_of_two_values;
static PyObject *__pyx_kp_u_must_be_a_tuple_with_two_elemen;
static PyObject *__pyx_kp_u_must_be_an_instance_of;
static PyObject *__pyx_kp_u_must_be_an_integer_or_float;
static PyObject *__pyx_kp_u_must_be_integers;
static PyObject *__pyx_kp_u_must_be_less_than_the_second;
static PyObject *__pyx_kp_u_must_contain_numerical_values;
static PyObject *__pyx_n_u_mute;
static PyObject *__pyx_n_s_n_features;
static PyObject *__pyx_n_s_n_features_in;
static PyObject *__pyx_n_u_n_features_in;
static PyObject *__pyx_n_s_n_features_out;
static PyObject *__pyx_n_s_n_samples;
static PyObject *__pyx_n_s_name;
static PyObject *__pyx_n_u_name;
static PyObject *__pyx_n_s_name_2;
static PyObject *__pyx_n_u_name_2;
static PyObject *__pyx_n_s_nan;
static PyObject *__pyx_n_s_nan_policy;
static PyObject *__pyx_n_s_ndarray;
static PyObject *__pyx_n_s_ndim;
static PyObject *__pyx_n_u_neither;
static PyObject *__pyx_n_s_new_dtype;
static PyObject *__pyx_n_s_newaxis;
static PyObject *__pyx_kp_u_nly_supports_array_got;
static PyObject *__pyx_n_s_non_numeric;
static PyObject *__pyx_n_s_normalize;
static PyObject *__pyx_n_u_normalize;
static PyObject *__pyx_n_s_normalize_array;
static PyObject *__pyx_n_u_normalize_array;
static PyObject *__pyx_kp_u_normalize_array_line_712;
static PyObject *__pyx_n_s_normalize_string;
static PyObject *__pyx_kp_u_not;
static PyObject *__pyx_kp_u_not_found_in_DataFrame;
static PyObject *__pyx_kp_u_not_found_in_the_dataframe;
static PyObject *__pyx_n_s_not_nan_mask;
static PyObject *__pyx_n_s_notna;
static PyObject *__pyx_n_s_now;
static PyObject *__pyx_n_s_np;
static PyObject *__pyx_kp_u_np_matrix_is_not_supported_Pleas;
static PyObject *__pyx_n_s_num_features;
static PyObject *__pyx_n_s_num_samples;
static PyObject *__pyx_n_s_number;
static PyObject *__pyx_n_s_numbers;
static PyObject *__pyx_n_u_numeric;
static PyObject *__pyx_kp_u_numeric__only;
static PyObject *__pyx_n_u_numeric_only;
static PyObject *__pyx_n_s_numeric_pattern;
static PyObject *__pyx_n_s_numeric_types;
static PyObject *__pyx_n_s_numeric_y;
static PyObject *__pyx_n_s_numpy;
static PyObject *__pyx_n_u_numpy;
static PyObject *__pyx_kp_u_numpy_array_api;
static PyObject *__pyx_n_s_numpy_core_numeric;
static PyObject *__pyx_n_s_nunique;
static PyObject *__pyx_n_s_o;
static PyObject *__pyx_kp_u_o_2;
static PyObject *__pyx_n_s_o_3;
static PyObject *__pyx_kp_u_o_is_expected_to_be_an_iterable;
static PyObject *__pyx_n_s_obj;
static PyObject *__pyx_n_s_object;
static PyObject *__pyx_n_u_object;
static PyObject *__pyx_n_s_object_dtype_isnan;
static PyObject *__pyx_n_s_objname;
static PyObject *__pyx_n_u_omit;
static PyObject *__pyx_n_s_ones_like;
static PyObject *__pyx_n_u_only;
static PyObject *__pyx_n_u_only_2;
static PyObject *__pyx_n_s_operator;
static PyObject *__pyx_n_s_order;
static PyObject *__pyx_n_s_output_format;
static PyObject *__pyx_n_u_output_format;
static PyObject *__pyx_n_s_over;
static PyObject *__pyx_n_s_padded_input_name;
static PyObject *__pyx_n_s_pandas;
static PyObject *__pyx_kp_u_pandas_DataFrame_with_sparse_col;
static PyObject *__pyx_n_s_pandas_api_types;
static PyObject *__pyx_n_s_pandas_dtype_needs_early_conver;
static PyObject *__pyx_n_s_pandas_requires_conversion;
static PyObject *__pyx_n_s_param;
static PyObject *__pyx_n_s_param_name;
static PyObject *__pyx_n_s_param_value;
static PyObject *__pyx_n_s_parameter;
static PyObject *__pyx_n_s_parameter_validator;
static PyObject *__pyx_n_u_parameter_validator;
static PyObject *__pyx_kp_u_parameter_validator_line_1275;
static PyObject *__pyx_n_s_parameter_validator_locals_valid;
static PyObject *__pyx_n_s_parameters;
static PyObject *__pyx_n_s_parse_year_input;
static PyObject *__pyx_kp_u_passing_these_as_positional_arg;
static PyObject *__pyx_n_u_passthrough;
static PyObject *__pyx_n_s_pd;
static PyObject *__pyx_n_s_pd_dtype;
static PyObject *__pyx_n_u_predict;
static PyObject *__pyx_n_s_prepare;
static PyObject *__pyx_n_s_print;
static PyObject *__pyx_n_u_propagate;
static PyObject *__pyx_n_s_qualname;
static PyObject *__pyx_n_u_qualname;
static PyObject *__pyx_n_s_qualname_2;
static PyObject *__pyx_kp_u_r_cannot_be_used_to_seed_a_nump;
static PyObject *__pyx_n_u_raise;
static PyObject *__pyx_n_s_raise_exception;
static PyObject *__pyx_n_s_raise_warning;
static PyObject *__pyx_n_s_rand;
static PyObject *__pyx_n_s_rand_2;
static PyObject *__pyx_n_s_random;
static PyObject *__pyx_n_s_random_values;
static PyObject *__pyx_n_s_range;
static PyObject *__pyx_n_s_range_name;
static PyObject *__pyx_n_s_range_tuple;
static PyObject *__pyx_n_s_ravel;
static PyObject *__pyx_n_u_raw_values;
static PyObject *__pyx_n_s_re;
static PyObject *__pyx_n_s_recheck_data_types;
static PyObject *__pyx_kp_u_recheck_data_types_line_2604;
static PyObject *__pyx_n_s_replace;
static PyObject *__pyx_n_s_replace_with;
static PyObject *__pyx_n_s_replacement_value;
static PyObject *__pyx_kp_u_requires_column_names_for_conve;
static PyObject *__pyx_kp_u_requires_y_to_be_passed_but_the;
static PyObject *__pyx_n_s_reshape;
static PyObject *__pyx_kp_u_respectively;
static PyObject *__pyx_n_s_result;
static PyObject *__pyx_n_s_result_type;
static PyObject *__pyx_n_s_results;
static PyObject *__pyx_n_s_return_as_date_str;
static PyObject *__pyx_n_s_return_as_numpy;
static PyObject *__pyx_n_u_return_as_numpy;
static PyObject *__pyx_n_s_return_classes;
static PyObject *__pyx_n_s_return_data;
static PyObject *__pyx_n_s_return_target_only;
static PyObject *__pyx_n_s_return_values;
static PyObject *__pyx_n_u_right;
static PyObject *__pyx_n_s_round_float;
static PyObject *__pyx_n_u_row;
static PyObject *__pyx_kp_u_s_is_not_an_estimator_instance;
static PyObject *__pyx_n_u_safe;
static PyObject *__pyx_kp_u_sample_s_shape;
static PyObject *__pyx_n_s_sample_weight;
static PyObject *__pyx_n_s_sample_weights;
static PyObject *__pyx_n_s_scale_factor;
static PyObject *__pyx_n_s_scipy_sparse;
static PyObject *__pyx_n_s_scores;
static PyObject *__pyx_n_s_seed;
static PyObject *__pyx_n_s_send;
static PyObject *__pyx_n_s_set_array_back;
static PyObject *__pyx_n_s_shape;
static PyObject *__pyx_n_u_shape;
static PyObject *__pyx_kp_u_should_be_a_1d_array_got_an_arr;
static PyObject *__pyx_kp_u_should_be_an_array_like_or_spar;
static PyObject *__pyx_kp_u_should_be_array_like_or_a_spars;
static PyObject *__pyx_n_s_sig;
static PyObject *__pyx_n_s_signature;
static PyObject *__pyx_n_u_silence;
static PyObject *__pyx_n_s_simplefilter;
static PyObject *__pyx_n_s_size;
static PyObject *__pyx_n_s_sklearn_is_fitted;
static PyObject *__pyx_n_u_sklearn_is_fitted;
static PyObject *__pyx_n_u_soft;
static PyObject *__pyx_n_s_sorted_values;
static PyObject *__pyx_n_s_sp;
static PyObject *__pyx_n_u_sparse;
static PyObject *__pyx_n_s_spmatrix;
static PyObject *__pyx_n_s_sqrt;
static PyObject *__pyx_n_s_stacklevel;
static PyObject *__pyx_n_s_start;
static PyObject *__pyx_n_s_start_date;
static PyObject *__pyx_n_s_startswith;
static PyObject *__pyx_n_s_std;
static PyObject *__pyx_n_u_str;
static PyObject *__pyx_n_s_strategy;
static PyObject *__pyx_n_s_strftime;
static PyObject *__pyx_n_s_strict;
static PyObject *__pyx_n_u_strict;
static PyObject *__pyx_n_s_strip;
static PyObject *__pyx_n_s_strptime;
static PyObject *__pyx_n_s_suffix;
static PyObject *__pyx_n_s_sum;
static PyObject *__pyx_n_u_sum;
static PyObject *__pyx_n_u_summary;
static PyObject *__pyx_n_s_supported_indices;
static PyObject *__pyx_n_s_suppress;
static PyObject *__pyx_n_s_symmetric;
static PyObject *__pyx_n_s_t;
static PyObject *__pyx_n_s_target;
static PyObject *__pyx_n_s_target_strs;
static PyObject *__pyx_n_s_target_type;
static PyObject *__pyx_n_s_target_type_str;
static PyObject *__pyx_n_s_tensorflow;
static PyObject *__pyx_n_u_tensorflow;
static PyObject *__pyx_n_s_test;
static PyObject *__pyx_n_s_tf;
static PyObject *__pyx_n_s_throw;
static PyObject *__pyx_n_s_time_col;
static PyObject *__pyx_n_u_to;
static PyObject *__pyx_kp_u_to_DataFrame_requires_column_na;
static PyObject *__pyx_n_s_to_array;
static PyObject *__pyx_kp_u_to_be_a_one_dimensional_array_l;
static PyObject *__pyx_n_s_to_datetime;
static PyObject *__pyx_n_s_to_dtype_str;
static PyObject *__pyx_n_u_to_dtype_str;
static PyObject *__pyx_n_s_to_frame;
static PyObject *__pyx_kp_u_to_integers_Ensure_all_values_a;
static PyObject *__pyx_n_s_to_numeric;
static PyObject *__pyx_n_s_to_numpy;
static PyObject *__pyx_n_s_tocsr;
static PyObject *__pyx_n_s_tol;
static PyObject *__pyx_n_s_total;
static PyObject *__pyx_n_s_true_labels;
static PyObject *__pyx_n_s_type;
static PyObject *__pyx_n_s_type_col_name;
static PyObject *__pyx_n_s_type_err;
static PyObject *__pyx_n_s_type_error;
static PyObject *__pyx_n_s_type_name;
static PyObject *__pyx_n_s_type_of_target;
static PyObject *__pyx_n_s_types;
static PyObject *__pyx_n_s_types_str;
static PyObject *__pyx_n_s_typing;
static PyObject *__pyx_n_u_uniform_average;
static PyObject *__pyx_n_s_unique;
static PyObject *__pyx_n_s_unique_classes;
static PyObject *__pyx_n_s_unique_values;
static PyObject *__pyx_n_s_uniques;
static PyObject *__pyx_n_u_unknown;
static PyObject *__pyx_n_s_update;
static PyObject *__pyx_n_s_util;
static PyObject *__pyx_n_s_v;
static PyObject *__pyx_n_s_valid_kwargs;
static PyObject *__pyx_n_s_valid_params;
static PyObject *__pyx_n_s_valid_policies;
static PyObject *__pyx_n_s_valid_values;
static PyObject *__pyx_n_s_validate_and_adjust_ranges;
static PyObject *__pyx_n_u_validate_and_adjust_ranges;
static PyObject *__pyx_kp_u_validate_and_adjust_ranges_line;
static PyObject *__pyx_n_s_validate_and_adjust_ranges_local;
static PyObject *__pyx_n_s_validate_comparison_data;
static PyObject *__pyx_n_u_validate_comparison_data;
static PyObject *__pyx_kp_u_validate_comparison_data_line_92;
static PyObject *__pyx_n_s_validate_data_types;
static PyObject *__pyx_n_u_validate_data_types;
static PyObject *__pyx_kp_u_validate_data_types_line_999;
static PyObject *__pyx_n_s_validate_data_types_locals__hand;
static PyObject *__pyx_n_s_validate_data_types_locals__hand_2;
static PyObject *__pyx_n_s_validate_data_types_locals__hand_3;
static PyObject *__pyx_n_s_validate_dates;
static PyObject *__pyx_n_u_validate_dates;
static PyObject *__pyx_kp_u_validate_dates_line_2377;
static PyObject *__pyx_n_s_validate_dates_locals_parse_year;
static PyObject *__pyx_n_s_validate_distribution;
static PyObject *__pyx_n_u_validate_distribution;
static PyObject *__pyx_kp_u_validate_distribution_line_1352;
static PyObject *__pyx_n_s_validate_dtype_selector;
static PyObject *__pyx_n_u_validate_dtype_selector;
static PyObject *__pyx_n_s_validate_fit_weights;
static PyObject *__pyx_n_u_validate_fit_weights;
static PyObject *__pyx_kp_u_validate_fit_weights_line_1629;
static PyObject *__pyx_n_s_validate_input;
static PyObject *__pyx_n_s_validate_input_locals_lambda;
static PyObject *__pyx_n_s_validate_keras_model;
static PyObject *__pyx_n_u_validate_keras_model;
static PyObject *__pyx_kp_u_validate_keras_model_line_2685;
static PyObject *__pyx_n_s_validate_length_range;
static PyObject *__pyx_n_u_validate_length_range;
static PyObject *__pyx_kp_u_validate_length_range_line_1424;
static PyObject *__pyx_n_s_validate_length_range_locals_gen;
static PyObject *__pyx_n_s_validate_multiclass_target;
static PyObject *__pyx_n_u_validate_multiclass_target;
static PyObject *__pyx_kp_u_validate_multiclass_target_line;
static PyObject *__pyx_n_s_validate_multioutput;
static PyObject *__pyx_n_u_validate_multioutput;
static PyObject *__pyx_kp_u_validate_multioutput_line_1756;
static PyObject *__pyx_n_s_validate_nan_policy;
static PyObject *__pyx_n_u_validate_nan_policy;
static PyObject *__pyx_kp_u_validate_nan_policy_line_1542;
static PyObject *__pyx_n_s_validate_nan_policy_locals_genex;
static PyObject *__pyx_n_s_validate_numeric;
static PyObject *__pyx_n_u_validate_numeric;
static PyObject *__pyx_kp_u_validate_numeric_line_3008;
static PyObject *__pyx_n_s_validate_positive_integer;
static PyObject *__pyx_n_u_validate_positive_integer;
static PyObject *__pyx_n_s_validate_sample_weights;
static PyObject *__pyx_n_u_validate_sample_weights;
static PyObject *__pyx_kp_u_validate_sample_weights_line_507;
static PyObject *__pyx_n_s_validate_scores;
static PyObject *__pyx_n_u_validate_scores;
static PyObject *__pyx_kp_u_validate_scores_line_159;
static PyObject *__pyx_n_s_validate_scores_locals_genexpr;
static PyObject *__pyx_n_s_validate_square_matrix;
static PyObject *__pyx_n_u_validate_square_matrix;
static PyObject *__pyx_kp_u_validate_square_matrix_line_311;
static PyObject *__pyx_n_s_validate_weights;
static PyObject *__pyx_n_u_validate_weights;
static PyObject *__pyx_kp_u_validate_weights_line_577;
static PyObject *__pyx_n_s_validate_yy;
static PyObject *__pyx_n_u_validate_yy;
static PyObject *__pyx_n_s_validated_distribution;
static PyObject *__pyx_n_s_validated_targets;
static PyObject *__pyx_n_s_validation_checks;
static PyObject *__pyx_n_s_validation_mode;
static PyObject *__pyx_n_s_validator;
static PyObject *__pyx_kp_s_validator_pyx;
static PyObject *__pyx_n_s_value;
static PyObject *__pyx_n_s_value_err;
static PyObject *__pyx_n_s_value_lower;
static PyObject *__pyx_n_s_values;
static PyObject *__pyx_n_s_variable_name;
static PyObject *__pyx_n_s_vars;
static PyObject *__pyx_n_s_verbose;
static PyObject *__pyx_n_s_version;
static PyObject *__pyx_n_s_warn;
static PyObject *__pyx_n_u_warn;
static PyObject *__pyx_n_s_warn_msg;
static PyObject *__pyx_n_s_warnings;
static PyObject *__pyx_n_s_weighted_y;
static PyObject *__pyx_n_s_weighted_y_values;
static PyObject *__pyx_n_s_weights;
static PyObject *__pyx_n_s_weights_array;
static PyObject *__pyx_kp_u_where_the_samples_are_of_type;
static PyObject *__pyx_kp_u_while_a_minimum_of;
static PyObject *__pyx_kp_u_with_shape;
static PyObject *__pyx_n_s_wraps;
static PyObject *__pyx_n_s_x;
static PyObject *__pyx_n_u_x;
static PyObject *__pyx_kp_u_x_and_y_must_be_a_numeric_array;
static PyObject *__pyx_n_s_xp;
static PyObject *__pyx_n_s_xy_numeric;
static PyObject *__pyx_n_s_y;
static PyObject *__pyx_n_u_y;
static PyObject *__pyx_n_s_y_arrays;
static PyObject *__pyx_n_s_y_eval;
static PyObject *__pyx_n_s_y_numeric;
static PyObject *__pyx_n_s_y_pred;
static PyObject *__pyx_n_s_y_true;
static PyObject *__pyx_n_s_y_true_processed;
static PyObject *__pyx_n_s_year;
static PyObject *__pyx_n_s_year_input;
static PyObject *__pyx_n_s_zero_division;
static PyObject *__pyx_n_u_zero_division;
static PyObject *__pyx_n_s_zeros_mask;
static PyObject *__pyx_n_s_zip;
static PyObject *__pyx_n_u_zscore;
static PyObject *__pyx_pf_9validator_filter_valid_kwargs(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_callable_obj, PyObject *__pyx_v_kwargs); /* proto */
static PyObject *__pyx_pf_9validator_15validate_scores_genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9validator_2validate_scores(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_scores, PyObject *__pyx_v_true_labels, PyObject *__pyx_v_mode, PyObject *__pyx_v_accept_multi_output); /* proto */
static PyObject *__pyx_pf_9validator_4_is_probability_distribution(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y, PyObject *__pyx_v_mode); /* proto */
static PyObject *__pyx_pf_9validator_6validate_square_matrix(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_align, PyObject *__pyx_v_align_mode, PyObject *__pyx_v_message); /* proto */
static PyObject *__pyx_pf_9validator_8is_square_matrix(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_data_type); /* proto */
static PyObject *__pyx_pf_9validator_10validate_multiclass_target(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y, PyObject *__pyx_v_accept_multioutput, PyObject *__pyx_v_return_classes); /* proto */
static PyObject *__pyx_pf_9validator_12validate_sample_weights(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_weights, PyObject *__pyx_v_y, PyObject *__pyx_v_normalize); /* proto */
static PyObject *__pyx_pf_9validator_14validate_weights(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_weights, PyObject *__pyx_v_min_value, PyObject *__pyx_v_max_value, PyObject *__pyx_v_normalize, PyObject *__pyx_v_allowed_dims); /* proto */
static PyObject *__pyx_pf_9validator_16is_normalized(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_arr, PyObject *__pyx_v_method); /* proto */
static PyObject *__pyx_pf_9validator_18normalize_array(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_arr, PyObject *__pyx_v_normalize, PyObject *__pyx_v_method); /* proto */
static PyObject *__pyx_pf_9validator_20is_binary_class(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y, PyObject *__pyx_v_accept_multioutput); /* proto */
static PyObject *__pyx_pf_9validator_22handle_zero_division(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y_true, PyObject *__pyx_v_zero_division, PyObject *__pyx_v_metric_name, PyObject *__pyx_v_epsilon, PyObject *__pyx_v_replace_with); /* proto */
static PyObject *__pyx_pf_9validator_24validate_comparison_data(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_df, PyObject *__pyx_v_alignment); /* proto */
static PyObject *__pyx_pf_9validator_19validate_data_types__handle_numeric(PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_return_data); /* proto */
static PyObject *__pyx_lambda_funcdef_lambda1(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_9validator_19validate_data_types_2_handle_categoric(PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_return_data); /* proto */
static PyObject *__pyx_pf_9validator_26validate_data_types(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_expected_type, PyObject *__pyx_v_nan_policy, PyObject *__pyx_v_return_data, PyObject *__pyx_v_error); /* proto */
static PyObject *__pyx_pf_9validator_28ensure_2d(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X, PyObject *__pyx_v_output_format); /* proto */
static PyObject *__pyx_pf_9validator_30is_categorical(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_column, PyObject *__pyx_v_strict, PyObject *__pyx_v_error); /* proto */
static PyObject *__pyx_pf_9validator_19parameter_validator_validator(PyObject *__pyx_self, PyObject *__pyx_v_param_value); /* proto */
static PyObject *__pyx_pf_9validator_32parameter_validator(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_param_name, PyObject *__pyx_v_target_strs, PyObject *__pyx_v_match_method, PyObject *__pyx_v_raise_exception, PyObject *__pyx_v_kws); /* proto */
static PyObject *__pyx_pf_9validator_34validate_distribution(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_distribution, PyObject *__pyx_v_elements); /* proto */
static PyObject *__pyx_pf_9validator_21validate_length_range_genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9validator_36validate_length_range(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_length_range, PyObject *__pyx_v_sorted_values, PyObject *__pyx_v_param_name); /* proto */
static PyObject *__pyx_pf_9validator_23contains_nested_objects_is_nested(PyObject *__pyx_self, PyObject *__pyx_v_item); /* proto */
static PyObject *__pyx_pf_9validator_23contains_nested_objects_2genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9validator_23contains_nested_objects_5genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9validator_38contains_nested_objects(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_lst, PyObject *__pyx_v_strict, PyObject *__pyx_v_allowed_types); /* proto */
static PyObject *__pyx_pf_9validator_19validate_nan_policy_genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9validator_19validate_nan_policy_3genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9validator_40validate_nan_policy(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_nan_policy, PyObject *__pyx_v_sample_weights, PyObject *__pyx_v_arrays); /* proto */
static PyObject *__pyx_pf_9validator_42validate_fit_weights(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y, PyObject *__pyx_v_sample_weight, PyObject *__pyx_v_weighted_y); /* proto */
static PyObject *__pyx_pf_9validator_44is_valid_policies(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_nan_policy, PyObject *__pyx_v_allowed_policies); /* proto */
static PyObject *__pyx_pf_9validator_46validate_multioutput(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value, PyObject *__pyx_v_extra); /* proto */
static PyObject *__pyx_pf_9validator_48ensure_non_negative(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_err_msg, PyObject *__pyx_v_arrays); /* proto */
static PyObject *__pyx_pf_9validator_50check_epsilon(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_eps, PyObject *__pyx_v_y_true, PyObject *__pyx_v_y_pred, PyObject *__pyx_v_base_epsilon, PyObject *__pyx_v_scale_factor); /* proto */
static PyObject *__pyx_pf_9validator_52_ensure_y_is_valid(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y_true, PyObject *__pyx_v_y_pred, PyObject *__pyx_v_kwargs); /* proto */
static PyObject *__pyx_pf_9validator_28check_classification_targets_genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9validator_54check_classification_targets(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_target_type, PyObject *__pyx_v_strategy, PyObject *__pyx_v_verbose, PyObject *__pyx_v_y); /* proto */
static PyObject *__pyx_pf_9validator_8_check_y_genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9validator_8_check_y_3genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9validator_56_check_y(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y, PyObject *__pyx_v_strategy); /* proto */
static PyObject *__pyx_pf_9validator_58validate_yy(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y_true, PyObject *__pyx_v_y_pred, PyObject *__pyx_v_expected_type, PyObject *__pyx_v_validation_mode, PyObject *__pyx_v_flatten); /* proto */
static PyObject *__pyx_lambda_funcdef_lambda10(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_lambda_funcdef_lambda11(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_dtype); /* proto */
static PyObject *__pyx_pf_9validator_60check_mixed_data_types(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_data); /* proto */
static PyObject *__pyx_pf_9validator_62is_keras_model(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_model); /* proto */
static PyObject *__pyx_pf_9validator_23has_required_attributes_genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9validator_64has_required_attributes(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_model, PyObject *__pyx_v_attributes); /* proto */
static PyObject *__pyx_pf_9validator_14validate_dates_parse_year_input(PyObject *__pyx_self, PyObject *__pyx_v_year_input); /* proto */
static PyObject *__pyx_pf_9validator_66validate_dates(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_start_date, PyObject *__pyx_v_end_date, PyObject *__pyx_v_return_as_date_str, PyObject *__pyx_v_date_format); /* proto */
static PyObject *__pyx_pf_9validator_68validate_positive_integer(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value, PyObject *__pyx_v_variable_name, PyObject *__pyx_v_include_zero, PyObject *__pyx_v_round_float); /* proto */
static PyObject *__pyx_pf_9validator_26validate_and_adjust_ranges_genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9validator_70validate_and_adjust_ranges(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_kwargs); /* proto */
static PyObject *__pyx_pf_9validator_72recheck_data_types(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_coerce_numeric, PyObject *__pyx_v_coerce_datetime, PyObject *__pyx_v_column_prefix, PyObject *__pyx_v_return_as_numpy); /* proto */
static PyObject *__pyx_pf_9validator_74validate_keras_model(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_model, PyObject *__pyx_v_custom_check, PyObject *__pyx_v_deep_check, PyObject *__pyx_v_raise_exception); /* proto */
static PyObject *__pyx_pf_9validator_76is_installed(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_module); /* proto */
static PyObject *__pyx_pf_9validator_78is_time_series(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_time_col, PyObject *__pyx_v_check_time_interval); /* proto */
static PyObject *__pyx_pf_9validator_80check_is_fitted2(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_estimator, PyObject *__pyx_v_attributes, PyObject *__pyx_v_msg); /* proto */
static PyObject *__pyx_pf_9validator_82assert_xy_in(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_x, PyObject *__pyx_v_y, PyObject *__pyx_v_data, PyObject *__pyx_v_asarray, PyObject *__pyx_v_to_frame, PyObject *__pyx_v_columns, PyObject *__pyx_v_xy_numeric, PyObject *__pyx_v_ignore, PyObject *__pyx_v_kws); /* proto */
static PyObject *__pyx_pf_9validator_84validate_numeric(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value, PyObject *__pyx_v_convert_to, PyObject *__pyx_v_allow_negative, PyObject *__pyx_v_min_value, PyObject *__pyx_v_max_value, PyObject *__pyx_v_check_mode); /* proto */
static PyObject *__pyx_lambda_funcdef_lambda14(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_lambda_funcdef_lambda15(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_lambda_funcdef_lambda16(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9validator_86_validate_input(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_ignore, PyObject *__pyx_v_x, PyObject *__pyx_v_y, PyObject *__pyx_v__is_arraylike_1d); /* proto */
static PyObject *__pyx_pf_9validator_88_is_numeric_dtype(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_o, PyObject *__pyx_v_to_array); /* proto */
static PyObject *__pyx_pf_9validator_90_check_consistency_size(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_ar1, PyObject *__pyx_v_ar2, PyObject *__pyx_v_error); /* proto */
static PyObject *__pyx_pf_9validator_92check_consistency_size(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_arrays); /* proto */
static PyObject *__pyx_pf_9validator_94_is_buildin(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_o, PyObject *__pyx_v_mode); /* proto */
static PyObject *__pyx_pf_9validator_96get_estimator_name(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_estimator); /* proto */
static PyObject *__pyx_pf_9validator_98_is_cross_validated(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_estimator); /* proto */
static PyObject *__pyx_pf_9validator_100_check_array_in(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_obj, PyObject *__pyx_v_arr_name); /* proto */
static PyObject *__pyx_pf_9validator_26_deprecate_positional_args_32_inner_deprecate_positional_args_inner_f(PyObject *__pyx_self, PyObject *__pyx_v_args, PyObject *__pyx_v_kwargs); /* proto */
static PyObject *__pyx_pf_9validator_26_deprecate_positional_args__inner_deprecate_positional_args(PyObject *__pyx_self, PyObject *__pyx_v_f); /* proto */
static PyObject *__pyx_pf_9validator_102_deprecate_positional_args(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_func, PyObject *__pyx_v_version); /* proto */
static PyObject *__pyx_pf_9validator_104to_dtype_str(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_arr, PyObject *__pyx_v_return_values); /* proto */
static PyObject *__pyx_pf_9validator_106_is_arraylike_1d(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_9validator_108_is_arraylike(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_9validator_110_is_arraylike_not_scalar(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_array); /* proto */
static PyObject *__pyx_pf_9validator_112_num_features(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X); /* proto */
static PyObject *__pyx_pf_9validator_114_num_samples(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_x); /* proto */
static PyObject *__pyx_pf_9validator_116check_memory(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_memory); /* proto */
static PyObject *__pyx_pf_9validator_118check_consistent_length(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_arrays); /* proto */
static PyObject *__pyx_pf_9validator_120check_random_state(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_seed); /* proto */
static PyObject *__pyx_pf_9validator_122has_fit_parameter(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_estimator, PyObject *__pyx_v_parameter); /* proto */
static PyObject *__pyx_pf_9validator_124check_symmetric(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_array, PyObject *__pyx_v_tol, PyObject *__pyx_v_raise_warning, PyObject *__pyx_v_raise_exception); /* proto */
static PyObject *__pyx_pf_9validator_12check_scalar_type_name(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_t); /* proto */
static PyObject *__pyx_pf_9validator_12check_scalar_2genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9validator_126check_scalar(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_x, PyObject *__pyx_v_name, PyObject *__pyx_v_target_type, PyObject *__pyx_v_min_val, PyObject *__pyx_v_max_val, PyObject *__pyx_v_include_boundaries); /* proto */
static PyObject *__pyx_pf_9validator_18_get_feature_names_7genexpr_genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9validator_18_get_feature_names_genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9validator_128_get_feature_names(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X); /* proto */
static PyObject *__pyx_pf_9validator_130check_is_fitted(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_estimator, PyObject *__pyx_v_attributes, PyObject *__pyx_v_msg, PyObject *__pyx_v_all_or_any); /* proto */
static PyObject *__pyx_pf_9validator_132_check_feature_names_in(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_estimator, PyObject *__pyx_v_input_features, PyObject *__pyx_v_generate_names); /* proto */
static PyObject *__pyx_pf_9validator_134_pandas_dtype_needs_early_conversion(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_pd_dtype); /* proto */
static PyObject *__pyx_pf_9validator_136_ensure_no_complex_data(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_array); /* proto */
static PyObject *__pyx_pf_9validator_138_check_estimator_name(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_estimator); /* proto */
static PyObject *__pyx_pf_9validator_140set_array_back(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X, PyObject *__pyx_v_to_frame, PyObject *__pyx_v_columns, PyObject *__pyx_v_input_name); /* proto */
static PyObject *__pyx_pf_9validator_142convert_array_to_pandas(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X, PyObject *__pyx_v_to_frame, PyObject *__pyx_v_columns, PyObject *__pyx_v_input_name); /* proto */
static PyObject *__pyx_pf_9validator_144is_frame(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_arr, PyObject *__pyx_v_df_only, PyObject *__pyx_v_raise_exception, PyObject *__pyx_v_objname); /* proto */
static PyObject *__pyx_pf_9validator_11check_array_genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9validator_11check_array_3genexpr(PyObject *__pyx_self); /* proto */
static PyObject *__pyx_pf_9validator_146check_array(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_array, PyObject *__pyx_v_accept_large_sparse, PyObject *__pyx_v_dtype, PyObject *__pyx_v_accept_sparse, PyObject *__pyx_v_order, PyObject *__pyx_v_copy, PyObject *__pyx_v_force_all_finite, PyObject *__pyx_v_ensure_2d, PyObject *__pyx_v_allow_nd, PyObject *__pyx_v_ensure_min_samples, PyObject *__pyx_v_ensure_min_features, PyObject *__pyx_v_estimator, PyObject *__pyx_v_input_name, PyObject *__pyx_v_to_frame); /* proto */
static PyObject *__pyx_pf_9validator_148check_X_y(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X, PyObject *__pyx_v_y, PyObject *__pyx_v_accept_sparse, PyObject *__pyx_v_accept_large_sparse, PyObject *__pyx_v_dtype, PyObject *__pyx_v_order, PyObject *__pyx_v_copy, PyObject *__pyx_v_force_all_finite, PyObject *__pyx_v_ensure_2d, PyObject *__pyx_v_allow_nd, PyObject *__pyx_v_multi_output, PyObject *__pyx_v_ensure_min_samples, PyObject *__pyx_v_ensure_min_features, PyObject *__pyx_v_y_numeric, PyObject *__pyx_v_estimator, PyObject *__pyx_v_to_frame); /* proto */
static PyObject *__pyx_pf_9validator_150check_y(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y, PyObject *__pyx_v_multi_output, PyObject *__pyx_v_y_numeric, PyObject *__pyx_v_input_name, PyObject *__pyx_v_estimator, PyObject *__pyx_v_to_frame, PyObject *__pyx_v_allow_nan); /* proto */
static PyObject *__pyx_pf_9validator_152validate_dtype_selector(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_dtype_selector); /* proto */
static PyObject *__pyx_pf_9validator_154build_data_if(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_columns, PyObject *__pyx_v_to_frame, PyObject *__pyx_v_input_name, PyObject *__pyx_v_force, PyObject *__pyx_v_raise_warning, PyObject *__pyx_v_raise_exception, PyObject *__pyx_v_coerce_datetime); /* proto */
static PyObject *__pyx_pf_9validator_156build_data_if2(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_columns, PyObject *__pyx_v_to_frame, PyObject *__pyx_v_input_name, PyObject *__pyx_v_force, PyObject *__pyx_v_kws); /* proto */
static PyObject *__pyx_pf_9validator_158array_to_frame(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X, PyObject *__pyx_v_to_frame, PyObject *__pyx_v_columns, PyObject *__pyx_v_raise_exception, PyObject *__pyx_v_raise_warning, PyObject *__pyx_v_input_name, PyObject *__pyx_v_force); /* proto */
static PyObject *__pyx_pf_9validator_160array_to_frame2(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X, PyObject *__pyx_v_to_frame, PyObject *__pyx_v_columns, PyObject *__pyx_v_raise_exception, PyObject *__pyx_v_raise_warning, PyObject *__pyx_v_input_name, PyObject *__pyx_v_force); /* proto */
static PyObject *__pyx_pf_9validator_162_check_y_1d(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y, PyObject *__pyx_v_warn, PyObject *__pyx_v_input_name); /* proto */
static PyObject *__pyx_pf_9validator_164_check_large_sparse(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X, PyObject *__pyx_v_accept_large_sparse); /* proto */
static PyObject *__pyx_pf_9validator_166_ensure_sparse_format(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_spmatrix, PyObject *__pyx_v_accept_sparse, PyObject *__pyx_v_dtype, PyObject *__pyx_v_copy, PyObject *__pyx_v_force_all_finite, PyObject *__pyx_v_accept_large_sparse, PyObject *__pyx_v_estimator_name, PyObject *__pyx_v_input_name); /* proto */
static PyObject *__pyx_pf_9validator_168_object_dtype_isnan(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X); /* proto */
static PyObject *__pyx_pf_9validator_170_assert_all_finite(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X, PyObject *__pyx_v_allow_nan, PyObject *__pyx_v_msg_dtype, PyObject *__pyx_v_estimator_name, PyObject *__pyx_v_input_name); /* proto */
static PyObject *__pyx_pf_9validator_172assert_all_finite(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X, PyObject *__pyx_v_allow_nan, PyObject *__pyx_v_estimator_name, PyObject *__pyx_v_input_name); /* proto */
static PyObject *__pyx_pf_9validator_174_generate_get_feature_names_out(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_estimator, PyObject *__pyx_v_n_features_out, PyObject *__pyx_v_input_features); /* proto */
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct__validate_scores(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_1_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_2_validate_data_types(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_3_parameter_validator(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_4_validate_length_range(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_5_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_6_contains_nested_objects(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_7_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_8_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_9_validate_nan_policy(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_10_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_11_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_12_check_classification_targets(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_13_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_14__check_y(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_15_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_16_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_17_has_required_attributes(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_18_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_19_validate_dates(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_20_validate_and_adjust_ranges(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_21_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_22__validate_input(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_23__deprecate_positional_args(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_24__inner_deprecate_positional_args(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_25_check_scalar(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_26_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_27__get_feature_names(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_28_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_29_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_30_check_array(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_31_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_32_genexpr(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static __Pyx_CachedCFunction __pyx_umethod_PyDict_Type_get = {0, &__pyx_n_s_get, 0, 0, 0};
static __Pyx_CachedCFunction __pyx_umethod_PyDict_Type_update = {0, &__pyx_n_s_update, 0, 0, 0};
static __Pyx_CachedCFunction __pyx_umethod_PyUnicode_Type_format = {0, &__pyx_n_s_format, 0, 0, 0};
static PyObject *__pyx_float_0_;
static PyObject *__pyx_float_0_5;
static PyObject *__pyx_float_1eneg_5;
static PyObject *__pyx_float_1eneg_10;
static PyObject *__pyx_float_1eneg_15;
static PyObject *__pyx_int_0;
static PyObject *__pyx_int_1;
static PyObject *__pyx_int_2;
static PyObject *__pyx_int_3;
static PyObject *__pyx_int_1900;
static PyObject *__pyx_int_neg_1;
static PyObject *__pyx_tuple_;
static PyObject *__pyx_tuple__2;
static PyObject *__pyx_tuple__3;
static PyObject *__pyx_tuple__4;
static PyObject *__pyx_tuple__5;
static PyObject *__pyx_tuple__6;
static PyObject *__pyx_tuple__8;
static PyObject *__pyx_tuple__9;
static PyObject *__pyx_slice__40;
static PyObject *__pyx_tuple__10;
static PyObject *__pyx_tuple__11;
static PyObject *__pyx_tuple__12;
static PyObject *__pyx_tuple__13;
static PyObject *__pyx_tuple__14;
static PyObject *__pyx_tuple__15;
static PyObject *__pyx_tuple__17;
static PyObject *__pyx_tuple__19;
static PyObject *__pyx_tuple__20;
static PyObject *__pyx_tuple__21;
static PyObject *__pyx_tuple__22;
static PyObject *__pyx_tuple__23;
static PyObject *__pyx_tuple__24;
static PyObject *__pyx_tuple__25;
static PyObject *__pyx_tuple__26;
static PyObject *__pyx_tuple__27;
static PyObject *__pyx_tuple__28;
static PyObject *__pyx_tuple__29;
static PyObject *__pyx_tuple__30;
static PyObject *__pyx_tuple__31;
static PyObject *__pyx_tuple__32;
static PyObject *__pyx_tuple__33;
static PyObject *__pyx_tuple__34;
static PyObject *__pyx_tuple__36;
static PyObject *__pyx_tuple__38;
static PyObject *__pyx_tuple__39;
static PyObject *__pyx_tuple__41;
static PyObject *__pyx_tuple__43;
static PyObject *__pyx_tuple__44;
static PyObject *__pyx_tuple__45;
static PyObject *__pyx_tuple__46;
static PyObject *__pyx_tuple__47;
static PyObject *__pyx_tuple__48;
static PyObject *__pyx_tuple__50;
static PyObject *__pyx_tuple__51;
static PyObject *__pyx_tuple__55;
static PyObject *__pyx_tuple__56;
static PyObject *__pyx_tuple__57;
static PyObject *__pyx_tuple__58;
static PyObject *__pyx_tuple__59;
static PyObject *__pyx_tuple__60;
static PyObject *__pyx_tuple__61;
static PyObject *__pyx_tuple__62;
static PyObject *__pyx_tuple__65;
static PyObject *__pyx_tuple__66;
static PyObject *__pyx_tuple__67;
static PyObject *__pyx_tuple__69;
static PyObject *__pyx_tuple__70;
static PyObject *__pyx_tuple__71;
static PyObject *__pyx_tuple__72;
static PyObject *__pyx_tuple__73;
static PyObject *__pyx_tuple__74;
static PyObject *__pyx_tuple__75;
static PyObject *__pyx_tuple__76;
static PyObject *__pyx_tuple__77;
static PyObject *__pyx_tuple__78;
static PyObject *__pyx_tuple__79;
static PyObject *__pyx_tuple__80;
static PyObject *__pyx_tuple__84;
static PyObject *__pyx_tuple__86;
static PyObject *__pyx_tuple__88;
static PyObject *__pyx_tuple__89;
static PyObject *__pyx_tuple__90;
static PyObject *__pyx_tuple__94;
static PyObject *__pyx_tuple__95;
static PyObject *__pyx_tuple__96;
static PyObject *__pyx_tuple__104;
static PyObject *__pyx_tuple__105;
static PyObject *__pyx_tuple__106;
static PyObject *__pyx_tuple__107;
static PyObject *__pyx_tuple__108;
static PyObject *__pyx_tuple__109;
static PyObject *__pyx_tuple__110;
static PyObject *__pyx_tuple__111;
static PyObject *__pyx_tuple__112;
static PyObject *__pyx_tuple__114;
static PyObject *__pyx_tuple__115;
static PyObject *__pyx_tuple__116;
static PyObject *__pyx_tuple__119;
static PyObject *__pyx_tuple__121;
static PyObject *__pyx_tuple__123;
static PyObject *__pyx_tuple__125;
static PyObject *__pyx_tuple__127;
static PyObject *__pyx_tuple__129;
static PyObject *__pyx_tuple__131;
static PyObject *__pyx_tuple__133;
static PyObject *__pyx_tuple__135;
static PyObject *__pyx_tuple__137;
static PyObject *__pyx_tuple__139;
static PyObject *__pyx_tuple__141;
static PyObject *__pyx_tuple__143;
static PyObject *__pyx_tuple__145;
static PyObject *__pyx_tuple__147;
static PyObject *__pyx_tuple__149;
static PyObject *__pyx_tuple__151;
static PyObject *__pyx_tuple__153;
static PyObject *__pyx_tuple__155;
static PyObject *__pyx_tuple__157;
static PyObject *__pyx_tuple__159;
static PyObject *__pyx_tuple__161;
static PyObject *__pyx_tuple__163;
static PyObject *__pyx_tuple__165;
static PyObject *__pyx_tuple__167;
static PyObject *__pyx_tuple__169;
static PyObject *__pyx_tuple__171;
static PyObject *__pyx_tuple__173;
static PyObject *__pyx_tuple__175;
static PyObject *__pyx_tuple__177;
static PyObject *__pyx_tuple__179;
static PyObject *__pyx_tuple__181;
static PyObject *__pyx_tuple__183;
static PyObject *__pyx_tuple__185;
static PyObject *__pyx_tuple__187;
static PyObject *__pyx_tuple__189;
static PyObject *__pyx_tuple__191;
static PyObject *__pyx_tuple__193;
static PyObject *__pyx_tuple__195;
static PyObject *__pyx_tuple__197;
static PyObject *__pyx_tuple__199;
static PyObject *__pyx_tuple__201;
static PyObject *__pyx_tuple__203;
static PyObject *__pyx_tuple__205;
static PyObject *__pyx_tuple__207;
static PyObject *__pyx_tuple__209;
static PyObject *__pyx_tuple__211;
static PyObject *__pyx_tuple__213;
static PyObject *__pyx_tuple__215;
static PyObject *__pyx_tuple__217;
static PyObject *__pyx_tuple__219;
static PyObject *__pyx_tuple__221;
static PyObject *__pyx_tuple__223;
static PyObject *__pyx_tuple__225;
static PyObject *__pyx_tuple__227;
static PyObject *__pyx_tuple__229;
static PyObject *__pyx_tuple__231;
static PyObject *__pyx_tuple__233;
static PyObject *__pyx_tuple__235;
static PyObject *__pyx_tuple__237;
static PyObject *__pyx_tuple__239;
static PyObject *__pyx_tuple__241;
static PyObject *__pyx_tuple__243;
static PyObject *__pyx_tuple__245;
static PyObject *__pyx_tuple__247;
static PyObject *__pyx_tuple__249;
static PyObject *__pyx_tuple__251;
static PyObject *__pyx_tuple__253;
static PyObject *__pyx_tuple__255;
static PyObject *__pyx_tuple__257;
static PyObject *__pyx_tuple__259;
static PyObject *__pyx_tuple__261;
static PyObject *__pyx_tuple__263;
static PyObject *__pyx_tuple__265;
static PyObject *__pyx_tuple__267;
static PyObject *__pyx_tuple__269;
static PyObject *__pyx_tuple__271;
static PyObject *__pyx_tuple__273;
static PyObject *__pyx_tuple__275;
static PyObject *__pyx_tuple__277;
static PyObject *__pyx_tuple__279;
static PyObject *__pyx_tuple__281;
static PyObject *__pyx_tuple__283;
static PyObject *__pyx_tuple__285;
static PyObject *__pyx_tuple__287;
static PyObject *__pyx_tuple__289;
static PyObject *__pyx_tuple__291;
static PyObject *__pyx_tuple__293;
static PyObject *__pyx_tuple__295;
static PyObject *__pyx_tuple__296;
static PyObject *__pyx_codeobj__35;
static PyObject *__pyx_codeobj__37;
static PyObject *__pyx_codeobj__42;
static PyObject *__pyx_codeobj__49;
static PyObject *__pyx_codeobj__68;
static PyObject *__pyx_codeobj__85;
static PyObject *__pyx_codeobj__87;
static PyObject *__pyx_codeobj__91;
static PyObject *__pyx_codeobj__120;
static PyObject *__pyx_codeobj__122;
static PyObject *__pyx_codeobj__124;
static PyObject *__pyx_codeobj__126;
static PyObject *__pyx_codeobj__128;
static PyObject *__pyx_codeobj__130;
static PyObject *__pyx_codeobj__132;
static PyObject *__pyx_codeobj__134;
static PyObject *__pyx_codeobj__136;
static PyObject *__pyx_codeobj__138;
static PyObject *__pyx_codeobj__140;
static PyObject *__pyx_codeobj__142;
static PyObject *__pyx_codeobj__144;
static PyObject *__pyx_codeobj__146;
static PyObject *__pyx_codeobj__148;
static PyObject *__pyx_codeobj__150;
static PyObject *__pyx_codeobj__152;
static PyObject *__pyx_codeobj__154;
static PyObject *__pyx_codeobj__156;
static PyObject *__pyx_codeobj__158;
static PyObject *__pyx_codeobj__160;
static PyObject *__pyx_codeobj__162;
static PyObject *__pyx_codeobj__164;
static PyObject *__pyx_codeobj__166;
static PyObject *__pyx_codeobj__168;
static PyObject *__pyx_codeobj__170;
static PyObject *__pyx_codeobj__172;
static PyObject *__pyx_codeobj__174;
static PyObject *__pyx_codeobj__176;
static PyObject *__pyx_codeobj__178;
static PyObject *__pyx_codeobj__180;
static PyObject *__pyx_codeobj__182;
static PyObject *__pyx_codeobj__184;
static PyObject *__pyx_codeobj__186;
static PyObject *__pyx_codeobj__188;
static PyObject *__pyx_codeobj__190;
static PyObject *__pyx_codeobj__192;
static PyObject *__pyx_codeobj__194;
static PyObject *__pyx_codeobj__196;
static PyObject *__pyx_codeobj__198;
static PyObject *__pyx_codeobj__200;
static PyObject *__pyx_codeobj__202;
static PyObject *__pyx_codeobj__204;
static PyObject *__pyx_codeobj__206;
static PyObject *__pyx_codeobj__208;
static PyObject *__pyx_codeobj__210;
static PyObject *__pyx_codeobj__212;
static PyObject *__pyx_codeobj__214;
static PyObject *__pyx_codeobj__216;
static PyObject *__pyx_codeobj__218;
static PyObject *__pyx_codeobj__220;
static PyObject *__pyx_codeobj__222;
static PyObject *__pyx_codeobj__224;
static PyObject *__pyx_codeobj__226;
static PyObject *__pyx_codeobj__228;
static PyObject *__pyx_codeobj__230;
static PyObject *__pyx_codeobj__232;
static PyObject *__pyx_codeobj__234;
static PyObject *__pyx_codeobj__236;
static PyObject *__pyx_codeobj__238;
static PyObject *__pyx_codeobj__240;
static PyObject *__pyx_codeobj__242;
static PyObject *__pyx_codeobj__244;
static PyObject *__pyx_codeobj__246;
static PyObject *__pyx_codeobj__248;
static PyObject *__pyx_codeobj__250;
static PyObject *__pyx_codeobj__252;
static PyObject *__pyx_codeobj__254;
static PyObject *__pyx_codeobj__256;
static PyObject *__pyx_codeobj__258;
static PyObject *__pyx_codeobj__260;
static PyObject *__pyx_codeobj__262;
static PyObject *__pyx_codeobj__264;
static PyObject *__pyx_codeobj__266;
static PyObject *__pyx_codeobj__268;
static PyObject *__pyx_codeobj__270;
static PyObject *__pyx_codeobj__272;
static PyObject *__pyx_codeobj__274;
static PyObject *__pyx_codeobj__276;
static PyObject *__pyx_codeobj__278;
static PyObject *__pyx_codeobj__280;
static PyObject *__pyx_codeobj__282;
static PyObject *__pyx_codeobj__284;
static PyObject *__pyx_codeobj__286;
static PyObject *__pyx_codeobj__288;
static PyObject *__pyx_codeobj__290;
static PyObject *__pyx_codeobj__292;
static PyObject *__pyx_codeobj__294;
/* Late includes */

/* "validator.pyx":99
 *  ]
 * 
 * def filter_valid_kwargs(callable_obj, kwargs):             # <<<<<<<<<<<<<<
 *     """
 *     Filter and return only the valid keyword arguments for a given callable object.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_1filter_valid_kwargs(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_filter_valid_kwargs[] = "\n    Filter and return only the valid keyword arguments for a given callable object.\n\n    This function checks if the arguments in `kwargs` are valid for the \n    provided callable object (function, lambda function, method, or class). \n    If any argument is not valid, it is removed from `kwargs`. The function \n    returns only the valid `kwargs`.\n\n    Parameters\n    ----------\n    callable_obj : callable\n        The callable object (function, lambda function, method, or class) for \n        which the keyword arguments need to be validated.\n    \n    kwargs : dict\n        Dictionary of keyword arguments to be validated against the callable object.\n\n    Returns\n    -------\n    valid_kwargs : dict\n        Dictionary containing only the valid keyword arguments for the callable object.\n\n    Examples\n    --------\n    >>> def example_func(a, b, c=3):\n    ...     pass\n    >>> kwargs = {'a': 1, 'b': 2, 'd': 4}\n    >>> filter_valid_kwargs(example_func, kwargs)\n    {'a': 1, 'b': 2}\n    \n    >>> class ExampleClass:\n    ...     def __init__(self, x, y, z=10):\n    ...         pass\n    >>> kwargs = {'x': 1, 'y': 2, 'a': 3}\n    >>> filter_valid_kwargs(ExampleClass, kwargs)\n    {'x': 1, 'y': 2}\n    >>> filter_valid_kwargs(ExampleClass(), kwargs)\n    {'x': 1, 'y': 2}\n\n    Notes\n    -----\n    This function uses the `inspect` module to retrieve the signature of \n    the given callable object and validate the keyword arguments.\n    ";
static PyMethodDef __pyx_mdef_9validator_1filter_valid_kwargs = {"filter_valid_kwargs", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_1filter_valid_kwargs, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_filter_valid_kwargs};
static PyObject *__pyx_pw_9validator_1filter_valid_kwargs(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_callable_obj = 0;
  PyObject *__pyx_v_kwargs = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("filter_valid_kwargs (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_callable_obj,&__pyx_n_s_kwargs,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_callable_obj)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_kwargs)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("filter_valid_kwargs", 1, 2, 2, 1); __PYX_ERR(0, 99, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "filter_valid_kwargs") < 0)) __PYX_ERR(0, 99, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_callable_obj = values[0];
    __pyx_v_kwargs = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("filter_valid_kwargs", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 99, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.filter_valid_kwargs", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_filter_valid_kwargs(__pyx_self, __pyx_v_callable_obj, __pyx_v_kwargs);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_filter_valid_kwargs(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_callable_obj, PyObject *__pyx_v_kwargs) {
  PyObject *__pyx_v_signature = NULL;
  PyObject *__pyx_v_valid_params = NULL;
  PyObject *__pyx_v_valid_kwargs = NULL;
  PyObject *__pyx_7genexpr__pyx_v_k = NULL;
  PyObject *__pyx_7genexpr__pyx_v_v = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  Py_ssize_t __pyx_t_7;
  Py_ssize_t __pyx_t_8;
  int __pyx_t_9;
  PyObject *__pyx_t_10 = NULL;
  int __pyx_t_11;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("filter_valid_kwargs", 0);
  __Pyx_INCREF(__pyx_v_callable_obj);

  /* "validator.pyx":145
 *     """
 *     # If the callable_obj is an instance, get its class
 *     if not inspect.isclass(callable_obj) and not callable(callable_obj):             # <<<<<<<<<<<<<<
 *         callable_obj = callable_obj.__class__
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_inspect); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 145, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_isclass); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 145, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_3, __pyx_v_callable_obj) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_callable_obj);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 145, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 145, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_6 = ((!__pyx_t_5) != 0);
  if (__pyx_t_6) {
  } else {
    __pyx_t_1 = __pyx_t_6;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_6 = __Pyx_PyCallable_Check(__pyx_v_callable_obj); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(0, 145, __pyx_L1_error)
  __pyx_t_5 = ((!(__pyx_t_6 != 0)) != 0);
  __pyx_t_1 = __pyx_t_5;
  __pyx_L4_bool_binop_done:;
  if (__pyx_t_1) {

    /* "validator.pyx":146
 *     # If the callable_obj is an instance, get its class
 *     if not inspect.isclass(callable_obj) and not callable(callable_obj):
 *         callable_obj = callable_obj.__class__             # <<<<<<<<<<<<<<
 * 
 *     # Get the function signature
 */
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_callable_obj, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 146, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF_SET(__pyx_v_callable_obj, __pyx_t_2);
    __pyx_t_2 = 0;

    /* "validator.pyx":145
 *     """
 *     # If the callable_obj is an instance, get its class
 *     if not inspect.isclass(callable_obj) and not callable(callable_obj):             # <<<<<<<<<<<<<<
 *         callable_obj = callable_obj.__class__
 * 
 */
  }

  /* "validator.pyx":149
 * 
 *     # Get the function signature
 *     signature = inspect.signature(callable_obj)             # <<<<<<<<<<<<<<
 * 
 *     # Extract parameter names from the function signature
 */
  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_inspect); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 149, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_signature); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 149, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_callable_obj) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_callable_obj);
  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 149, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_signature = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "validator.pyx":152
 * 
 *     # Extract parameter names from the function signature
 *     valid_params = set(signature.parameters.keys())             # <<<<<<<<<<<<<<
 * 
 *     # Filter kwargs to retain only valid parameters
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_signature, __pyx_n_s_parameters); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 152, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_keys); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 152, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 152, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = PySet_New(__pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 152, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_valid_params = ((PyObject*)__pyx_t_4);
  __pyx_t_4 = 0;

  /* "validator.pyx":155
 * 
 *     # Filter kwargs to retain only valid parameters
 *     valid_kwargs = {k: v for k, v in kwargs.items() if k in valid_params}             # <<<<<<<<<<<<<<
 * 
 *     return valid_kwargs
 */
  { /* enter inner scope */
    __pyx_t_4 = PyDict_New(); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 155, __pyx_L8_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_7 = 0;
    if (unlikely(__pyx_v_kwargs == Py_None)) {
      PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "items");
      __PYX_ERR(0, 155, __pyx_L8_error)
    }
    __pyx_t_3 = __Pyx_dict_iterator(__pyx_v_kwargs, 0, __pyx_n_s_items, (&__pyx_t_8), (&__pyx_t_9)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 155, __pyx_L8_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_XDECREF(__pyx_t_2);
    __pyx_t_2 = __pyx_t_3;
    __pyx_t_3 = 0;
    while (1) {
      __pyx_t_11 = __Pyx_dict_iter_next(__pyx_t_2, __pyx_t_8, &__pyx_t_7, &__pyx_t_3, &__pyx_t_10, NULL, __pyx_t_9);
      if (unlikely(__pyx_t_11 == 0)) break;
      if (unlikely(__pyx_t_11 == -1)) __PYX_ERR(0, 155, __pyx_L8_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_GOTREF(__pyx_t_10);
      __Pyx_XDECREF_SET(__pyx_7genexpr__pyx_v_k, __pyx_t_3);
      __pyx_t_3 = 0;
      __Pyx_XDECREF_SET(__pyx_7genexpr__pyx_v_v, __pyx_t_10);
      __pyx_t_10 = 0;
      __pyx_t_1 = (__Pyx_PySet_ContainsTF(__pyx_7genexpr__pyx_v_k, __pyx_v_valid_params, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 155, __pyx_L8_error)
      __pyx_t_5 = (__pyx_t_1 != 0);
      if (__pyx_t_5) {
        if (unlikely(PyDict_SetItem(__pyx_t_4, (PyObject*)__pyx_7genexpr__pyx_v_k, (PyObject*)__pyx_7genexpr__pyx_v_v))) __PYX_ERR(0, 155, __pyx_L8_error)
      }
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_7genexpr__pyx_v_k); __pyx_7genexpr__pyx_v_k = 0;
    __Pyx_XDECREF(__pyx_7genexpr__pyx_v_v); __pyx_7genexpr__pyx_v_v = 0;
    goto __pyx_L12_exit_scope;
    __pyx_L8_error:;
    __Pyx_XDECREF(__pyx_7genexpr__pyx_v_k); __pyx_7genexpr__pyx_v_k = 0;
    __Pyx_XDECREF(__pyx_7genexpr__pyx_v_v); __pyx_7genexpr__pyx_v_v = 0;
    goto __pyx_L1_error;
    __pyx_L12_exit_scope:;
  } /* exit inner scope */
  __pyx_v_valid_kwargs = ((PyObject*)__pyx_t_4);
  __pyx_t_4 = 0;

  /* "validator.pyx":157
 *     valid_kwargs = {k: v for k, v in kwargs.items() if k in valid_params}
 * 
 *     return valid_kwargs             # <<<<<<<<<<<<<<
 * 
 * def validate_scores(
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_valid_kwargs);
  __pyx_r = __pyx_v_valid_kwargs;
  goto __pyx_L0;

  /* "validator.pyx":99
 *  ]
 * 
 * def filter_valid_kwargs(callable_obj, kwargs):             # <<<<<<<<<<<<<<
 *     """
 *     Filter and return only the valid keyword arguments for a given callable object.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_AddTraceback("validator.filter_valid_kwargs", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_signature);
  __Pyx_XDECREF(__pyx_v_valid_params);
  __Pyx_XDECREF(__pyx_v_valid_kwargs);
  __Pyx_XDECREF(__pyx_7genexpr__pyx_v_k);
  __Pyx_XDECREF(__pyx_7genexpr__pyx_v_v);
  __Pyx_XDECREF(__pyx_v_callable_obj);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":159
 *     return valid_kwargs
 * 
 * def validate_scores(             # <<<<<<<<<<<<<<
 *     scores, true_labels=None,
 *     mode="strict",
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_3validate_scores(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_2validate_scores[] = "\n    Validates that the scores represent valid probability distributions and \n    checks consistency between scores and true labels in multi-output scenarios.\n\n    Parameters\n    ----------\n    scores : list or np.ndarray\n        A list of np.ndarrays for multi-output probabilities, or a single np.ndarray\n        for single-output probabilities. Each ndarray should contain probability\n        distributions where each row sums to approximately 1 and has \n        non-negative values.\n    true_labels : list or np.ndarray, optional\n        The true labels corresponding to the scores. This parameter must \n        be provided in multi-output scenarios to check the alignment of labels\n        and scores. Each element or row in true_labels should correspond to \n        the equivalent in scores.\n    mode : str, optional (default \"strict\")\n       Specifies the validation mode for checking probability distributions:\n       - 'strict': Each set of scores must sum exactly to 1, within a numerical\n         tolerance.\n       - 'soft': Scores must not exceed a total of 1, and all individual \n         scores must be non-negative.\n       - 'passthrough': Only checks that each score is between 0 and 1 \n         inclusive, without summing them.    \n    accept_multi_output : bool, default False\n        Flag indicating whether scores with multiple outputs are accepted. \n        If False and scores are provided as a list, a ValueError will be \n        raised.\n\n    Returns\n    -------\n    np.ndarray\n        The validated scores as a NumPy array.\n\n    Raises\n    ------\n    ValueError\n        If multi-output scores are provided and not accepted.\n        If there is a mismatch in the number of outputs between scores and \n        true_labels.\n        If scores or any subset of scores do not form valid probability \n        distributions.\n        If there is a mismatch in format expectations between scores and \n        true_labels in terms of multi-ou""tput handling.\n\n    Notes\n    -----\n    The function is designed to handle both single and multi-output probability\n    distributions. For multi-output scenarios, both scores and true_labels \n    should be lists of np.ndarrays.\n    This function is particularly useful in scenarios involving machine learning\n    models where output probabilities need to be validated before further\n    processing or metrics calculations.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from gofast.tools.validator import validate_scores\n    >>> scores_single = np.array([[0.1, 0.9], [0.8, 0.2]])\n    >>> print(validate_scores(scores_single))\n    [[0.1, 0.9]\n     [0.8, 0.2]]\n\n    >>> scores_multi = [np.array([[0.1, 0.9]]), np.array([[0.8, 0.2]])]\n    >>> true_labels_multi = [np.array([1]), np.array([0])]\n    >>> print(validate_scores(scores_multi, true_labels_multi, accept_multi_output=True))\n    [array([[0.1, 0.9]]), array([[0.8, 0.2]])]\n    ";
static PyMethodDef __pyx_mdef_9validator_3validate_scores = {"validate_scores", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_3validate_scores, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_2validate_scores};
static PyObject *__pyx_pw_9validator_3validate_scores(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_scores = 0;
  PyObject *__pyx_v_true_labels = 0;
  PyObject *__pyx_v_mode = 0;
  PyObject *__pyx_v_accept_multi_output = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validate_scores (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_scores,&__pyx_n_s_true_labels,&__pyx_n_s_mode,&__pyx_n_s_accept_multi_output,0};
    PyObject* values[4] = {0,0,0,0};

    /* "validator.pyx":160
 * 
 * def validate_scores(
 *     scores, true_labels=None,             # <<<<<<<<<<<<<<
 *     mode="strict",
 *     accept_multi_output=False
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)__pyx_n_u_strict);

    /* "validator.pyx":162
 *     scores, true_labels=None,
 *     mode="strict",
 *     accept_multi_output=False             # <<<<<<<<<<<<<<
 *     ):
 *     """
 */
    values[3] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_scores)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_true_labels);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mode);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_accept_multi_output);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "validate_scores") < 0)) __PYX_ERR(0, 159, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_scores = values[0];
    __pyx_v_true_labels = values[1];
    __pyx_v_mode = values[2];
    __pyx_v_accept_multi_output = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("validate_scores", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 159, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.validate_scores", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_2validate_scores(__pyx_self, __pyx_v_scores, __pyx_v_true_labels, __pyx_v_mode, __pyx_v_accept_multi_output);

  /* "validator.pyx":159
 *     return valid_kwargs
 * 
 * def validate_scores(             # <<<<<<<<<<<<<<
 *     scores, true_labels=None,
 *     mode="strict",
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9validator_15validate_scores_2generator(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */

/* "validator.pyx":239
 *             raise ValueError("Mismatch in the number of outputs between"
 *                              " scores and true_labels.")
 *         if any(not _is_probability_distribution(             # <<<<<<<<<<<<<<
 *                 score, mode=mode) for score in scores):
 *             raise ValueError("Each set of scores must be a valid"
 */

static PyObject *__pyx_pf_9validator_15validate_scores_genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_9validator___pyx_scope_struct_1_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_1_genexpr *)__pyx_tp_new_9validator___pyx_scope_struct_1_genexpr(__pyx_ptype_9validator___pyx_scope_struct_1_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_1_genexpr *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 239, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct__validate_scores *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9validator_15validate_scores_2generator, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_validate_scores_locals_genexpr, __pyx_n_s_validator); if (unlikely(!gen)) __PYX_ERR(0, 239, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("validator.validate_scores.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9validator_15validate_scores_2generator(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9validator___pyx_scope_struct_1_genexpr *__pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_1_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *(*__pyx_t_3)(PyObject *);
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_t_8;
  int __pyx_t_9;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genexpr", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 239, __pyx_L1_error)

  /* "validator.pyx":240
 *                              " scores and true_labels.")
 *         if any(not _is_probability_distribution(
 *                 score, mode=mode) for score in scores):             # <<<<<<<<<<<<<<
 *             raise ValueError("Each set of scores must be a valid"
 *                              " probability distribution.")
 */
  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_scores)) { __Pyx_RaiseClosureNameError("scores"); __PYX_ERR(0, 240, __pyx_L1_error) }
  if (likely(PyList_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_scores)) || PyTuple_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_scores)) {
    __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_scores; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
    __pyx_t_3 = NULL;
  } else {
    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_scores); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 240, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 240, __pyx_L1_error)
  }
  for (;;) {
    if (likely(!__pyx_t_3)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 240, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 240, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 240, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 240, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_3(__pyx_t_1);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 240, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_score);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_score, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;

    /* "validator.pyx":239
 *             raise ValueError("Mismatch in the number of outputs between"
 *                              " scores and true_labels.")
 *         if any(not _is_probability_distribution(             # <<<<<<<<<<<<<<
 *                 score, mode=mode) for score in scores):
 *             raise ValueError("Each set of scores must be a valid"
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_is_probability_distribution); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 239, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);

    /* "validator.pyx":240
 *                              " scores and true_labels.")
 *         if any(not _is_probability_distribution(
 *                 score, mode=mode) for score in scores):             # <<<<<<<<<<<<<<
 *             raise ValueError("Each set of scores must be a valid"
 *                              " probability distribution.")
 */
    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 239, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_INCREF(__pyx_cur_scope->__pyx_v_score);
    __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_score);
    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_cur_scope->__pyx_v_score);
    __pyx_t_6 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 240, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_mode)) { __Pyx_RaiseClosureNameError("mode"); __PYX_ERR(0, 240, __pyx_L1_error) }
    if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_mode, __pyx_cur_scope->__pyx_outer_scope->__pyx_v_mode) < 0) __PYX_ERR(0, 240, __pyx_L1_error)

    /* "validator.pyx":239
 *             raise ValueError("Mismatch in the number of outputs between"
 *                              " scores and true_labels.")
 *         if any(not _is_probability_distribution(             # <<<<<<<<<<<<<<
 *                 score, mode=mode) for score in scores):
 *             raise ValueError("Each set of scores must be a valid"
 */
    __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 239, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_7); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 239, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_9 = ((!__pyx_t_8) != 0);
    if (__pyx_t_9) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_True);
      __pyx_r = Py_True;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }

    /* "validator.pyx":240
 *                              " scores and true_labels.")
 *         if any(not _is_probability_distribution(
 *                 score, mode=mode) for score in scores):             # <<<<<<<<<<<<<<
 *             raise ValueError("Each set of scores must be a valid"
 *                              " probability distribution.")
 */
  }
  /*else*/ {

    /* "validator.pyx":239
 *             raise ValueError("Mismatch in the number of outputs between"
 *                              " scores and true_labels.")
 *         if any(not _is_probability_distribution(             # <<<<<<<<<<<<<<
 *                 score, mode=mode) for score in scores):
 *             raise ValueError("Each set of scores must be a valid"
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    goto __pyx_L0;
  }

  /* "validator.pyx":240
 *                              " scores and true_labels.")
 *         if any(not _is_probability_distribution(
 *                 score, mode=mode) for score in scores):             # <<<<<<<<<<<<<<
 *             raise ValueError("Each set of scores must be a valid"
 *                              " probability distribution.")
 */
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* "validator.pyx":239
 *             raise ValueError("Mismatch in the number of outputs between"
 *                              " scores and true_labels.")
 *         if any(not _is_probability_distribution(             # <<<<<<<<<<<<<<
 *                 score, mode=mode) for score in scores):
 *             raise ValueError("Each set of scores must be a valid"
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  #if !CYTHON_USE_EXC_INFO_STACK
  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
  #endif
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":159
 *     return valid_kwargs
 * 
 * def validate_scores(             # <<<<<<<<<<<<<<
 *     scores, true_labels=None,
 *     mode="strict",
 */

static PyObject *__pyx_pf_9validator_2validate_scores(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_scores, PyObject *__pyx_v_true_labels, PyObject *__pyx_v_mode, PyObject *__pyx_v_accept_multi_output) {
  struct __pyx_obj_9validator___pyx_scope_struct__validate_scores *__pyx_cur_scope;
  PyObject *__pyx_gb_9validator_15validate_scores_2generator = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  Py_ssize_t __pyx_t_5;
  Py_ssize_t __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validate_scores", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct__validate_scores *)__pyx_tp_new_9validator___pyx_scope_struct__validate_scores(__pyx_ptype_9validator___pyx_scope_struct__validate_scores, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct__validate_scores *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 159, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_v_scores = __pyx_v_scores;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_scores);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_scores);
  __pyx_cur_scope->__pyx_v_mode = __pyx_v_mode;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_mode);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_mode);

  /* "validator.pyx":233
 *     """
 *     # Check if scores are in a list for multi-output handling
 *     if isinstance(scores, list):             # <<<<<<<<<<<<<<
 *         if not accept_multi_output:
 *             raise ValueError("Multi-output scores provided but not accepted.")
 */
  __pyx_t_1 = __pyx_cur_scope->__pyx_v_scores;
  __Pyx_INCREF(__pyx_t_1);
  __pyx_t_2 = PyList_Check(__pyx_t_1); 
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (__pyx_t_3) {

    /* "validator.pyx":234
 *     # Check if scores are in a list for multi-output handling
 *     if isinstance(scores, list):
 *         if not accept_multi_output:             # <<<<<<<<<<<<<<
 *             raise ValueError("Multi-output scores provided but not accepted.")
 *         if true_labels is not None and len(scores) != len(true_labels):
 */
    __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_accept_multi_output); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 234, __pyx_L1_error)
    __pyx_t_2 = ((!__pyx_t_3) != 0);
    if (unlikely(__pyx_t_2)) {

      /* "validator.pyx":235
 *     if isinstance(scores, list):
 *         if not accept_multi_output:
 *             raise ValueError("Multi-output scores provided but not accepted.")             # <<<<<<<<<<<<<<
 *         if true_labels is not None and len(scores) != len(true_labels):
 *             raise ValueError("Mismatch in the number of outputs between"
 */
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 235, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 235, __pyx_L1_error)

      /* "validator.pyx":234
 *     # Check if scores are in a list for multi-output handling
 *     if isinstance(scores, list):
 *         if not accept_multi_output:             # <<<<<<<<<<<<<<
 *             raise ValueError("Multi-output scores provided but not accepted.")
 *         if true_labels is not None and len(scores) != len(true_labels):
 */
    }

    /* "validator.pyx":236
 *         if not accept_multi_output:
 *             raise ValueError("Multi-output scores provided but not accepted.")
 *         if true_labels is not None and len(scores) != len(true_labels):             # <<<<<<<<<<<<<<
 *             raise ValueError("Mismatch in the number of outputs between"
 *                              " scores and true_labels.")
 */
    __pyx_t_3 = (__pyx_v_true_labels != Py_None);
    __pyx_t_4 = (__pyx_t_3 != 0);
    if (__pyx_t_4) {
    } else {
      __pyx_t_2 = __pyx_t_4;
      goto __pyx_L6_bool_binop_done;
    }
    __pyx_t_1 = __pyx_cur_scope->__pyx_v_scores;
    __Pyx_INCREF(__pyx_t_1);
    __pyx_t_5 = PyObject_Length(__pyx_t_1); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(0, 236, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_6 = PyObject_Length(__pyx_v_true_labels); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 236, __pyx_L1_error)
    __pyx_t_4 = ((__pyx_t_5 != __pyx_t_6) != 0);
    __pyx_t_2 = __pyx_t_4;
    __pyx_L6_bool_binop_done:;
    if (unlikely(__pyx_t_2)) {

      /* "validator.pyx":237
 *             raise ValueError("Multi-output scores provided but not accepted.")
 *         if true_labels is not None and len(scores) != len(true_labels):
 *             raise ValueError("Mismatch in the number of outputs between"             # <<<<<<<<<<<<<<
 *                              " scores and true_labels.")
 *         if any(not _is_probability_distribution(
 */
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 237, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 237, __pyx_L1_error)

      /* "validator.pyx":236
 *         if not accept_multi_output:
 *             raise ValueError("Multi-output scores provided but not accepted.")
 *         if true_labels is not None and len(scores) != len(true_labels):             # <<<<<<<<<<<<<<
 *             raise ValueError("Mismatch in the number of outputs between"
 *                              " scores and true_labels.")
 */
    }

    /* "validator.pyx":239
 *             raise ValueError("Mismatch in the number of outputs between"
 *                              " scores and true_labels.")
 *         if any(not _is_probability_distribution(             # <<<<<<<<<<<<<<
 *                 score, mode=mode) for score in scores):
 *             raise ValueError("Each set of scores must be a valid"
 */
    __pyx_t_1 = __pyx_pf_9validator_15validate_scores_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 239, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_7 = __Pyx_Generator_Next(__pyx_t_1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 239, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_7); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 239, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    if (unlikely(__pyx_t_2)) {

      /* "validator.pyx":241
 *         if any(not _is_probability_distribution(
 *                 score, mode=mode) for score in scores):
 *             raise ValueError("Each set of scores must be a valid"             # <<<<<<<<<<<<<<
 *                              " probability distribution.")
 *     else:
 */
      __pyx_t_7 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__3, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 241, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_Raise(__pyx_t_7, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __PYX_ERR(0, 241, __pyx_L1_error)

      /* "validator.pyx":239
 *             raise ValueError("Mismatch in the number of outputs between"
 *                              " scores and true_labels.")
 *         if any(not _is_probability_distribution(             # <<<<<<<<<<<<<<
 *                 score, mode=mode) for score in scores):
 *             raise ValueError("Each set of scores must be a valid"
 */
    }

    /* "validator.pyx":233
 *     """
 *     # Check if scores are in a list for multi-output handling
 *     if isinstance(scores, list):             # <<<<<<<<<<<<<<
 *         if not accept_multi_output:
 *             raise ValueError("Multi-output scores provided but not accepted.")
 */
    goto __pyx_L3;
  }

  /* "validator.pyx":244
 *                              " probability distribution.")
 *     else:
 *         if not _is_probability_distribution(scores, mode=mode):             # <<<<<<<<<<<<<<
 *             raise ValueError("Scores must be a valid probability distribution.")
 *         if true_labels is not None:
 */
  /*else*/ {
    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_is_probability_distribution); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 244, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 244, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_INCREF(__pyx_cur_scope->__pyx_v_scores);
    __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_scores);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_cur_scope->__pyx_v_scores);
    __pyx_t_8 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 244, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_mode, __pyx_cur_scope->__pyx_v_mode) < 0) __PYX_ERR(0, 244, __pyx_L1_error)
    __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_1, __pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 244, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 244, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_t_4 = ((!__pyx_t_2) != 0);
    if (unlikely(__pyx_t_4)) {

      /* "validator.pyx":245
 *     else:
 *         if not _is_probability_distribution(scores, mode=mode):
 *             raise ValueError("Scores must be a valid probability distribution.")             # <<<<<<<<<<<<<<
 *         if true_labels is not None:
 *             if accept_multi_output and not isinstance(true_labels, list):
 */
      __pyx_t_9 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 245, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      __Pyx_Raise(__pyx_t_9, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      __PYX_ERR(0, 245, __pyx_L1_error)

      /* "validator.pyx":244
 *                              " probability distribution.")
 *     else:
 *         if not _is_probability_distribution(scores, mode=mode):             # <<<<<<<<<<<<<<
 *             raise ValueError("Scores must be a valid probability distribution.")
 *         if true_labels is not None:
 */
    }

    /* "validator.pyx":246
 *         if not _is_probability_distribution(scores, mode=mode):
 *             raise ValueError("Scores must be a valid probability distribution.")
 *         if true_labels is not None:             # <<<<<<<<<<<<<<
 *             if accept_multi_output and not isinstance(true_labels, list):
 *                 raise ValueError("Expected multi-output for true_labels"
 */
    __pyx_t_4 = (__pyx_v_true_labels != Py_None);
    __pyx_t_2 = (__pyx_t_4 != 0);
    if (__pyx_t_2) {

      /* "validator.pyx":247
 *             raise ValueError("Scores must be a valid probability distribution.")
 *         if true_labels is not None:
 *             if accept_multi_output and not isinstance(true_labels, list):             # <<<<<<<<<<<<<<
 *                 raise ValueError("Expected multi-output for true_labels"
 *                                  " but got a single output.")
 */
      __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_accept_multi_output); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 247, __pyx_L1_error)
      if (__pyx_t_4) {
      } else {
        __pyx_t_2 = __pyx_t_4;
        goto __pyx_L12_bool_binop_done;
      }
      __pyx_t_4 = PyList_Check(__pyx_v_true_labels); 
      __pyx_t_3 = ((!(__pyx_t_4 != 0)) != 0);
      __pyx_t_2 = __pyx_t_3;
      __pyx_L12_bool_binop_done:;
      if (unlikely(__pyx_t_2)) {

        /* "validator.pyx":248
 *         if true_labels is not None:
 *             if accept_multi_output and not isinstance(true_labels, list):
 *                 raise ValueError("Expected multi-output for true_labels"             # <<<<<<<<<<<<<<
 *                                  " but got a single output.")
 *             if not accept_multi_output and isinstance(true_labels, list):
 */
        __pyx_t_9 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 248, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_Raise(__pyx_t_9, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        __PYX_ERR(0, 248, __pyx_L1_error)

        /* "validator.pyx":247
 *             raise ValueError("Scores must be a valid probability distribution.")
 *         if true_labels is not None:
 *             if accept_multi_output and not isinstance(true_labels, list):             # <<<<<<<<<<<<<<
 *                 raise ValueError("Expected multi-output for true_labels"
 *                                  " but got a single output.")
 */
      }

      /* "validator.pyx":250
 *                 raise ValueError("Expected multi-output for true_labels"
 *                                  " but got a single output.")
 *             if not accept_multi_output and isinstance(true_labels, list):             # <<<<<<<<<<<<<<
 *                 raise ValueError("Non-multi-output scores with multi-output"
 *                                  " true_labels.")
 */
      __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_accept_multi_output); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 250, __pyx_L1_error)
      __pyx_t_4 = ((!__pyx_t_3) != 0);
      if (__pyx_t_4) {
      } else {
        __pyx_t_2 = __pyx_t_4;
        goto __pyx_L15_bool_binop_done;
      }
      __pyx_t_4 = PyList_Check(__pyx_v_true_labels); 
      __pyx_t_3 = (__pyx_t_4 != 0);
      __pyx_t_2 = __pyx_t_3;
      __pyx_L15_bool_binop_done:;
      if (unlikely(__pyx_t_2)) {

        /* "validator.pyx":251
 *                                  " but got a single output.")
 *             if not accept_multi_output and isinstance(true_labels, list):
 *                 raise ValueError("Non-multi-output scores with multi-output"             # <<<<<<<<<<<<<<
 *                                  " true_labels.")
 *     # Return scores as numpy array
 */
        __pyx_t_9 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 251, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_Raise(__pyx_t_9, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        __PYX_ERR(0, 251, __pyx_L1_error)

        /* "validator.pyx":250
 *                 raise ValueError("Expected multi-output for true_labels"
 *                                  " but got a single output.")
 *             if not accept_multi_output and isinstance(true_labels, list):             # <<<<<<<<<<<<<<
 *                 raise ValueError("Non-multi-output scores with multi-output"
 *                                  " true_labels.")
 */
      }

      /* "validator.pyx":246
 *         if not _is_probability_distribution(scores, mode=mode):
 *             raise ValueError("Scores must be a valid probability distribution.")
 *         if true_labels is not None:             # <<<<<<<<<<<<<<
 *             if accept_multi_output and not isinstance(true_labels, list):
 *                 raise ValueError("Expected multi-output for true_labels"
 */
    }
  }
  __pyx_L3:;

  /* "validator.pyx":254
 *                                  " true_labels.")
 *     # Return scores as numpy array
 *     return np.asarray(scores)             # <<<<<<<<<<<<<<
 * 
 * def _is_probability_distribution(y, mode='strict'):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_np); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 254, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_asarray); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 254, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __pyx_t_8 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_8)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_8);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  __pyx_t_9 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_8, __pyx_cur_scope->__pyx_v_scores) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_cur_scope->__pyx_v_scores);
  __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
  if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 254, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_9);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_9;
  __pyx_t_9 = 0;
  goto __pyx_L0;

  /* "validator.pyx":159
 *     return valid_kwargs
 * 
 * def validate_scores(             # <<<<<<<<<<<<<<
 *     scores, true_labels=None,
 *     mode="strict",
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("validator.validate_scores", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_gb_9validator_15validate_scores_2generator);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":256
 *     return np.asarray(scores)
 * 
 * def _is_probability_distribution(y, mode='strict'):             # <<<<<<<<<<<<<<
 *     """
 *     Checks if `y` is a probability distribution across the last axis according
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_5_is_probability_distribution(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_4_is_probability_distribution[] = "\n    Checks if `y` is a probability distribution across the last axis according \n    to the specified mode.\n\n    Parameters\n    ----------\n    y : np.ndarray\n        Array containing score values which need to be validated as probability\n        distributions.\n    mode : str, optional\n        Validation mode to be used. Available modes are:\n        - 'strict': Requires that the sum of scores exactly equals 1 \n        (within a tolerance).\n        - 'soft': Requires that the sum of scores does not exceed 1 and all\n        scores are non-negative.\n        - 'passthrough': Only checks that all scores are non-negative and do \n          not exceed 1, without summing them.\n\n    Returns\n    -------\n    bool\n        True if `y` satisfies the conditions of the specified mode, False \n        otherwise.\n\n    Raises\n    ------\n    ValueError\n        If an invalid mode is specified.\n\n    Examples\n    --------\n    >>> y = np.array([0.3, 0.7])\n    >>> print(is_probability_distribution(y, mode='strict'))\n    True\n\n    >>> y = np.array([0.5, 0.5, 0.2])\n    >>> print(is_probability_distribution(y, mode='soft'))\n    False\n\n    >>> y = np.array([0.2, 0.3, 0.4])\n    >>> print(is_probability_distribution(y, mode='passthrough'))\n    True\n    ";
static PyMethodDef __pyx_mdef_9validator_5_is_probability_distribution = {"_is_probability_distribution", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_5_is_probability_distribution, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_4_is_probability_distribution};
static PyObject *__pyx_pw_9validator_5_is_probability_distribution(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_y = 0;
  PyObject *__pyx_v_mode = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_is_probability_distribution (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_y,&__pyx_n_s_mode,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_n_u_strict);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mode);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_is_probability_distribution") < 0)) __PYX_ERR(0, 256, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_y = values[0];
    __pyx_v_mode = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_is_probability_distribution", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 256, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator._is_probability_distribution", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_4_is_probability_distribution(__pyx_self, __pyx_v_y, __pyx_v_mode);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_4_is_probability_distribution(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y, PyObject *__pyx_v_mode) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  int __pyx_t_11;
  Py_ssize_t __pyx_t_12;
  Py_UCS4 __pyx_t_13;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_is_probability_distribution", 0);

  /* "validator.pyx":301
 *     """
 * 
 *     if mode == 'strict':             # <<<<<<<<<<<<<<
 *         return np.all(np.isclose(np.sum(y, axis=-1), 1)) and np.all(y >= 0)
 *     elif mode == 'soft':
 */
  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_mode, __pyx_n_u_strict, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 301, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "validator.pyx":302
 * 
 *     if mode == 'strict':
 *         return np.all(np.isclose(np.sum(y, axis=-1), 1)) and np.all(y >= 0)             # <<<<<<<<<<<<<<
 *     elif mode == 'soft':
 *         return np.all(np.sum(y, axis=-1) <= 1) and np.all(y >= 0)
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 302, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_all); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 302, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 302, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_isclose); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 302, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 302, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_sum); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 302, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 302, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_INCREF(__pyx_v_y);
    __Pyx_GIVEREF(__pyx_v_y);
    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_v_y);
    __pyx_t_9 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 302, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    if (PyDict_SetItem(__pyx_t_9, __pyx_n_s_axis, __pyx_int_neg_1) < 0) __PYX_ERR(0, 302, __pyx_L1_error)
    __pyx_t_10 = __Pyx_PyObject_Call(__pyx_t_8, __pyx_t_6, __pyx_t_9); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 302, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_t_9 = NULL;
    __pyx_t_11 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
      __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_7);
      if (likely(__pyx_t_9)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
        __Pyx_INCREF(__pyx_t_9);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_7, function);
        __pyx_t_11 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_7)) {
      PyObject *__pyx_temp[3] = {__pyx_t_9, __pyx_t_10, __pyx_int_1};
      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 302, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_7)) {
      PyObject *__pyx_temp[3] = {__pyx_t_9, __pyx_t_10, __pyx_int_1};
      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 302, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    } else
    #endif
    {
      __pyx_t_6 = PyTuple_New(2+__pyx_t_11); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 302, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      if (__pyx_t_9) {
        __Pyx_GIVEREF(__pyx_t_9); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_9); __pyx_t_9 = NULL;
      }
      __Pyx_GIVEREF(__pyx_t_10);
      PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_11, __pyx_t_10);
      __Pyx_INCREF(__pyx_int_1);
      __Pyx_GIVEREF(__pyx_int_1);
      PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_11, __pyx_int_1);
      __pyx_t_10 = 0;
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_6, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 302, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    }
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    __pyx_t_3 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_7, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_4);
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 302, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 302, __pyx_L1_error)
    if (__pyx_t_1) {
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else {
      __Pyx_INCREF(__pyx_t_3);
      __pyx_t_2 = __pyx_t_3;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      goto __pyx_L4_bool_binop_done;
    }
    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 302, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_all); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 302, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = PyObject_RichCompare(__pyx_v_y, __pyx_int_0, Py_GE); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 302, __pyx_L1_error)
    __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_3 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_7, __pyx_t_5) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5);
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 302, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_INCREF(__pyx_t_3);
    __pyx_t_2 = __pyx_t_3;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_L4_bool_binop_done:;
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;

    /* "validator.pyx":301
 *     """
 * 
 *     if mode == 'strict':             # <<<<<<<<<<<<<<
 *         return np.all(np.isclose(np.sum(y, axis=-1), 1)) and np.all(y >= 0)
 *     elif mode == 'soft':
 */
  }

  /* "validator.pyx":303
 *     if mode == 'strict':
 *         return np.all(np.isclose(np.sum(y, axis=-1), 1)) and np.all(y >= 0)
 *     elif mode == 'soft':             # <<<<<<<<<<<<<<
 *         return np.all(np.sum(y, axis=-1) <= 1) and np.all(y >= 0)
 *     elif mode == 'passthrough':
 */
  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_mode, __pyx_n_u_soft, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 303, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "validator.pyx":304
 *         return np.all(np.isclose(np.sum(y, axis=-1), 1)) and np.all(y >= 0)
 *     elif mode == 'soft':
 *         return np.all(np.sum(y, axis=-1) <= 1) and np.all(y >= 0)             # <<<<<<<<<<<<<<
 *     elif mode == 'passthrough':
 *         return np.all(np.asarray(y) <= 1) and np.all(np.asarray(y) >= 0)
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 304, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_all); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 304, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 304, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_sum); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 304, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 304, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_INCREF(__pyx_v_y);
    __Pyx_GIVEREF(__pyx_v_y);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_y);
    __pyx_t_6 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 304, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_axis, __pyx_int_neg_1) < 0) __PYX_ERR(0, 304, __pyx_L1_error)
    __pyx_t_10 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_4, __pyx_t_6); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 304, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = PyObject_RichCompare(__pyx_t_10, __pyx_int_1, Py_LE); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 304, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    __pyx_t_10 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_10)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_10);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    __pyx_t_3 = (__pyx_t_10) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_10, __pyx_t_6) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_6);
    __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 304, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 304, __pyx_L1_error)
    if (__pyx_t_1) {
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else {
      __Pyx_INCREF(__pyx_t_3);
      __pyx_t_2 = __pyx_t_3;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      goto __pyx_L6_bool_binop_done;
    }
    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 304, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_all); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 304, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = PyObject_RichCompare(__pyx_v_y, __pyx_int_0, Py_GE); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 304, __pyx_L1_error)
    __pyx_t_10 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
      __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_6);
      if (likely(__pyx_t_10)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
        __Pyx_INCREF(__pyx_t_10);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_6, function);
      }
    }
    __pyx_t_3 = (__pyx_t_10) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_10, __pyx_t_5) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_5);
    __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 304, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_INCREF(__pyx_t_3);
    __pyx_t_2 = __pyx_t_3;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_L6_bool_binop_done:;
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;

    /* "validator.pyx":303
 *     if mode == 'strict':
 *         return np.all(np.isclose(np.sum(y, axis=-1), 1)) and np.all(y >= 0)
 *     elif mode == 'soft':             # <<<<<<<<<<<<<<
 *         return np.all(np.sum(y, axis=-1) <= 1) and np.all(y >= 0)
 *     elif mode == 'passthrough':
 */
  }

  /* "validator.pyx":305
 *     elif mode == 'soft':
 *         return np.all(np.sum(y, axis=-1) <= 1) and np.all(y >= 0)
 *     elif mode == 'passthrough':             # <<<<<<<<<<<<<<
 *         return np.all(np.asarray(y) <= 1) and np.all(np.asarray(y) >= 0)
 *     else:
 */
  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_mode, __pyx_n_u_passthrough, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 305, __pyx_L1_error)
  if (likely(__pyx_t_1)) {

    /* "validator.pyx":306
 *         return np.all(np.sum(y, axis=-1) <= 1) and np.all(y >= 0)
 *     elif mode == 'passthrough':
 *         return np.all(np.asarray(y) <= 1) and np.all(np.asarray(y) >= 0)             # <<<<<<<<<<<<<<
 *     else:
 *         raise ValueError(f"Invalid validation mode: '{mode}'. Valid modes"
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 306, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_all); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 306, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_10, __pyx_n_s_np); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 306, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_10, __pyx_n_s_asarray); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 306, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    __pyx_t_10 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_10)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_10);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_6 = (__pyx_t_10) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_10, __pyx_v_y) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_y);
    __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
    if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 306, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = PyObject_RichCompare(__pyx_t_6, __pyx_int_1, Py_LE); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 306, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    __pyx_t_3 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_4);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 306, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 306, __pyx_L1_error)
    if (__pyx_t_1) {
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else {
      __Pyx_INCREF(__pyx_t_3);
      __pyx_t_2 = __pyx_t_3;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      goto __pyx_L8_bool_binop_done;
    }
    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 306, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_all); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 306, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 306, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_asarray); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 306, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_10))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_10);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_10);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_10, function);
      }
    }
    __pyx_t_5 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_10, __pyx_t_6, __pyx_v_y) : __Pyx_PyObject_CallOneArg(__pyx_t_10, __pyx_v_y);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 306, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    __pyx_t_10 = PyObject_RichCompare(__pyx_t_5, __pyx_int_0, Py_GE); __Pyx_XGOTREF(__pyx_t_10); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 306, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_t_10) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_10);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 306, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_INCREF(__pyx_t_3);
    __pyx_t_2 = __pyx_t_3;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_L8_bool_binop_done:;
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;

    /* "validator.pyx":305
 *     elif mode == 'soft':
 *         return np.all(np.sum(y, axis=-1) <= 1) and np.all(y >= 0)
 *     elif mode == 'passthrough':             # <<<<<<<<<<<<<<
 *         return np.all(np.asarray(y) <= 1) and np.all(np.asarray(y) >= 0)
 *     else:
 */
  }

  /* "validator.pyx":308
 *         return np.all(np.asarray(y) <= 1) and np.all(np.asarray(y) >= 0)
 *     else:
 *         raise ValueError(f"Invalid validation mode: '{mode}'. Valid modes"             # <<<<<<<<<<<<<<
 *                          " are 'strict', 'soft', or 'passthrough'.")
 * 
 */
  /*else*/ {
    __pyx_t_2 = PyTuple_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 308, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_12 = 0;
    __pyx_t_13 = 127;
    __Pyx_INCREF(__pyx_kp_u_Invalid_validation_mode);
    __pyx_t_12 += 26;
    __Pyx_GIVEREF(__pyx_kp_u_Invalid_validation_mode);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_kp_u_Invalid_validation_mode);
    __pyx_t_3 = __Pyx_PyObject_FormatSimple(__pyx_v_mode, __pyx_empty_unicode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 308, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_13 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) > __pyx_t_13) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) : __pyx_t_13;
    __pyx_t_12 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_3);
    __pyx_t_3 = 0;
    __Pyx_INCREF(__pyx_kp_u_Valid_modes_are_strict_soft_or);
    __pyx_t_12 += 54;
    __Pyx_GIVEREF(__pyx_kp_u_Valid_modes_are_strict_soft_or);
    PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_kp_u_Valid_modes_are_strict_soft_or);
    __pyx_t_3 = __Pyx_PyUnicode_Join(__pyx_t_2, 3, __pyx_t_12, __pyx_t_13); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 308, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 308, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 308, __pyx_L1_error)
  }

  /* "validator.pyx":256
 *     return np.asarray(scores)
 * 
 * def _is_probability_distribution(y, mode='strict'):             # <<<<<<<<<<<<<<
 *     """
 *     Checks if `y` is a probability distribution across the last axis according
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_AddTraceback("validator._is_probability_distribution", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":311
 *                          " are 'strict', 'soft', or 'passthrough'.")
 * 
 * def validate_square_matrix(data, align=False, align_mode="auto", message=''):             # <<<<<<<<<<<<<<
 *     """
 *     Validate that the input data forms a square matrix and optionally aligns its
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_7validate_square_matrix(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_6validate_square_matrix[] = "\n    Validate that the input data forms a square matrix and optionally aligns its \n    indices and columns if specified.\n\n    Parameters:\n    -----------\n    data : DataFrame or array-like\n        The input data to validate as a square matrix.\n    align : bool, default False\n        Whether to align the DataFrame's index with its columns.\n    align_mode : str, default 'auto'\n        Alignment mode if indices and columns do not match. Options are 'auto', \n        'index_to_columns', and 'columns_to_index'.\n    message : str, default ''\n        Additional message to append to the error if validation fails.\n\n    Returns:\n    --------\n    data\n        The validated or aligned square matrix.\n\n    Raises:\n    -------\n    ValueError\n        If the input is not a square matrix.\n\n    Examples:\n    ---------\n    >>> from gofast.tools.validator import validate_square_matrix\n    >>> validate_square(np.array([[1, 2], [3, 4]]))\n    array([[1, 2],\n           [3, 4]])\n\n    >>> validate_square(pd.DataFrame([[1, 2], [3, 4, 5]]))\n    ValueError: Input must be a square matrix.\n\n    Notes:\n    ------\n    A square matrix is defined as having equal number of rows and columns. \n    This function checks the dimensionality of the data and optionally aligns \n    the index and columns if `align` is set to True.\n    ";
static PyMethodDef __pyx_mdef_9validator_7validate_square_matrix = {"validate_square_matrix", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_7validate_square_matrix, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_6validate_square_matrix};
static PyObject *__pyx_pw_9validator_7validate_square_matrix(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_data = 0;
  PyObject *__pyx_v_align = 0;
  PyObject *__pyx_v_align_mode = 0;
  PyObject *__pyx_v_message = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validate_square_matrix (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_data,&__pyx_n_s_align,&__pyx_n_s_align_mode,&__pyx_n_s_message,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)Py_False);
    values[2] = ((PyObject *)__pyx_n_u_auto);
    values[3] = ((PyObject *)__pyx_kp_u__7);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_align);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_align_mode);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_message);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "validate_square_matrix") < 0)) __PYX_ERR(0, 311, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_data = values[0];
    __pyx_v_align = values[1];
    __pyx_v_align_mode = values[2];
    __pyx_v_message = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("validate_square_matrix", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 311, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.validate_square_matrix", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_6validate_square_matrix(__pyx_self, __pyx_v_data, __pyx_v_align, __pyx_v_align_mode, __pyx_v_message);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_6validate_square_matrix(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_align, PyObject *__pyx_v_align_mode, PyObject *__pyx_v_message) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validate_square_matrix", 0);
  __Pyx_INCREF(__pyx_v_data);

  /* "validator.pyx":354
 *     the index and columns if `align` is set to True.
 *     """
 *     if not is_square_matrix(data):             # <<<<<<<<<<<<<<
 *         raise ValueError(f"Input must be a square matrix. {message}")
 *     if align:
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_is_square_matrix); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 354, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_data) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_data);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 354, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 354, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (unlikely(__pyx_t_5)) {

    /* "validator.pyx":355
 *     """
 *     if not is_square_matrix(data):
 *         raise ValueError(f"Input must be a square matrix. {message}")             # <<<<<<<<<<<<<<
 *     if align:
 *         data = validate_comparison_data(data, alignment=align_mode)
 */
    __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_message, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 355, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Input_must_be_a_square_matrix, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 355, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 355, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 355, __pyx_L1_error)

    /* "validator.pyx":354
 *     the index and columns if `align` is set to True.
 *     """
 *     if not is_square_matrix(data):             # <<<<<<<<<<<<<<
 *         raise ValueError(f"Input must be a square matrix. {message}")
 *     if align:
 */
  }

  /* "validator.pyx":356
 *     if not is_square_matrix(data):
 *         raise ValueError(f"Input must be a square matrix. {message}")
 *     if align:             # <<<<<<<<<<<<<<
 *         data = validate_comparison_data(data, alignment=align_mode)
 *     return data
 */
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_v_align); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 356, __pyx_L1_error)
  if (__pyx_t_5) {

    /* "validator.pyx":357
 *         raise ValueError(f"Input must be a square matrix. {message}")
 *     if align:
 *         data = validate_comparison_data(data, alignment=align_mode)             # <<<<<<<<<<<<<<
 *     return data
 * 
 */
    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_validate_comparison_data); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 357, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 357, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_v_data);
    __Pyx_GIVEREF(__pyx_v_data);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_data);
    __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 357, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_alignment, __pyx_v_align_mode) < 0) __PYX_ERR(0, 357, __pyx_L1_error)
    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 357, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_6);
    __pyx_t_6 = 0;

    /* "validator.pyx":356
 *     if not is_square_matrix(data):
 *         raise ValueError(f"Input must be a square matrix. {message}")
 *     if align:             # <<<<<<<<<<<<<<
 *         data = validate_comparison_data(data, alignment=align_mode)
 *     return data
 */
  }

  /* "validator.pyx":358
 *     if align:
 *         data = validate_comparison_data(data, alignment=align_mode)
 *     return data             # <<<<<<<<<<<<<<
 * 
 * def is_square_matrix(data, data_type=None):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_data);
  __pyx_r = __pyx_v_data;
  goto __pyx_L0;

  /* "validator.pyx":311
 *                          " are 'strict', 'soft', or 'passthrough'.")
 * 
 * def validate_square_matrix(data, align=False, align_mode="auto", message=''):             # <<<<<<<<<<<<<<
 *     """
 *     Validate that the input data forms a square matrix and optionally aligns its
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("validator.validate_square_matrix", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_data);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":360
 *     return data
 * 
 * def is_square_matrix(data, data_type=None):             # <<<<<<<<<<<<<<
 *     """
 *     Determine whether the input, either a DataFrame or an array-like
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_9is_square_matrix(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_8is_square_matrix[] = "\n    Determine whether the input, either a DataFrame or an array-like \n    structure, forms a square matrix.\n    \n    Automatically detects the data type unless specified. Supports data inputs\n    that can be converted to a NumPy array.\n    \n    Parameters:\n    -----------\n    data : DataFrame, array-like, or any object convertible to a numpy array\n        The input data to check.\n    data_type : str, optional\n        The expected type of the input data. Valid options are 'array' or \n        'dataframe'.\n        If not specified, the data type is inferred. Default interpretation \n        is as an 'array'.\n\n    Returns:\n    --------\n    bool\n        Returns True if the data is a square matrix, otherwise False.\n        \n    Raises:\n    ------\n    ValueError\n        If `data_type` is neither 'array' nor 'dataframe'.\n    TypeError\n        If the input `data` does not match the expected format or \n        cannot be processed.\n\n    Examples:\n    ---------\n    >>> is_square_matrix(np.array([[1, 2], [3, 4]]))\n    True\n\n    >>> is_square_matrix(pd.DataFrame([[1, 2, 3], [4, 5, 6]]))\n    False\n\n    >>> is_square_matrix([[1, 2], [3, 4]], data_type='array')\n    True\n\n    Notes:\n    ------\n    A square matrix has an equal number of rows and columns. This function \n    checks the dimensionality and shape of the data to confirm if it meets \n    this criterion.\n    ";
static PyMethodDef __pyx_mdef_9validator_9is_square_matrix = {"is_square_matrix", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_9is_square_matrix, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_8is_square_matrix};
static PyObject *__pyx_pw_9validator_9is_square_matrix(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_data = 0;
  PyObject *__pyx_v_data_type = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("is_square_matrix (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_data,&__pyx_n_s_data_type,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data_type);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "is_square_matrix") < 0)) __PYX_ERR(0, 360, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_data = values[0];
    __pyx_v_data_type = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("is_square_matrix", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 360, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.is_square_matrix", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_8is_square_matrix(__pyx_self, __pyx_v_data, __pyx_v_data_type);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_8is_square_matrix(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_data_type) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("is_square_matrix", 0);
  __Pyx_INCREF(__pyx_v_data);
  __Pyx_INCREF(__pyx_v_data_type);

  /* "validator.pyx":409
 *     """
 *     # Determine the type based on the data provided
 *     if data_type is None:             # <<<<<<<<<<<<<<
 *         if isinstance(data, np.ndarray):
 *             data_type = 'array'
 */
  __pyx_t_1 = (__pyx_v_data_type == Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "validator.pyx":410
 *     # Determine the type based on the data provided
 *     if data_type is None:
 *         if isinstance(data, np.ndarray):             # <<<<<<<<<<<<<<
 *             data_type = 'array'
 *         elif isinstance(data, pd.DataFrame):
 */
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 410, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_ndarray); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 410, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_2 = PyObject_IsInstance(__pyx_v_data, __pyx_t_4); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 410, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_1 = (__pyx_t_2 != 0);
    if (__pyx_t_1) {

      /* "validator.pyx":411
 *     if data_type is None:
 *         if isinstance(data, np.ndarray):
 *             data_type = 'array'             # <<<<<<<<<<<<<<
 *         elif isinstance(data, pd.DataFrame):
 *             data_type = 'dataframe'
 */
      __Pyx_INCREF(__pyx_n_u_array);
      __Pyx_DECREF_SET(__pyx_v_data_type, __pyx_n_u_array);

      /* "validator.pyx":410
 *     # Determine the type based on the data provided
 *     if data_type is None:
 *         if isinstance(data, np.ndarray):             # <<<<<<<<<<<<<<
 *             data_type = 'array'
 *         elif isinstance(data, pd.DataFrame):
 */
      goto __pyx_L4;
    }

    /* "validator.pyx":412
 *         if isinstance(data, np.ndarray):
 *             data_type = 'array'
 *         elif isinstance(data, pd.DataFrame):             # <<<<<<<<<<<<<<
 *             data_type = 'dataframe'
 *         else:
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_pd); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 412, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_DataFrame); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 412, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_1 = PyObject_IsInstance(__pyx_v_data, __pyx_t_3); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 412, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_2 = (__pyx_t_1 != 0);
    if (__pyx_t_2) {

      /* "validator.pyx":413
 *             data_type = 'array'
 *         elif isinstance(data, pd.DataFrame):
 *             data_type = 'dataframe'             # <<<<<<<<<<<<<<
 *         else:
 *             data = np.array(data)  # Attempt to convert to a numpy array
 */
      __Pyx_INCREF(__pyx_n_u_dataframe);
      __Pyx_DECREF_SET(__pyx_v_data_type, __pyx_n_u_dataframe);

      /* "validator.pyx":412
 *         if isinstance(data, np.ndarray):
 *             data_type = 'array'
 *         elif isinstance(data, pd.DataFrame):             # <<<<<<<<<<<<<<
 *             data_type = 'dataframe'
 *         else:
 */
      goto __pyx_L4;
    }

    /* "validator.pyx":415
 *             data_type = 'dataframe'
 *         else:
 *             data = np.array(data)  # Attempt to convert to a numpy array             # <<<<<<<<<<<<<<
 *             data_type = 'array'
 * 
 */
    /*else*/ {
      __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 415, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_array); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 415, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_5, function);
        }
      }
      __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_v_data) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_data);
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 415, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_3);
      __pyx_t_3 = 0;

      /* "validator.pyx":416
 *         else:
 *             data = np.array(data)  # Attempt to convert to a numpy array
 *             data_type = 'array'             # <<<<<<<<<<<<<<
 * 
 *     if data_type not in ['array', 'dataframe']:
 */
      __Pyx_INCREF(__pyx_n_u_array);
      __Pyx_DECREF_SET(__pyx_v_data_type, __pyx_n_u_array);
    }
    __pyx_L4:;

    /* "validator.pyx":409
 *     """
 *     # Determine the type based on the data provided
 *     if data_type is None:             # <<<<<<<<<<<<<<
 *         if isinstance(data, np.ndarray):
 *             data_type = 'array'
 */
  }

  /* "validator.pyx":418
 *             data_type = 'array'
 * 
 *     if data_type not in ['array', 'dataframe']:             # <<<<<<<<<<<<<<
 *         raise ValueError("data_type must be either 'array' or 'dataframe'")
 * 
 */
  __Pyx_INCREF(__pyx_v_data_type);
  __pyx_t_3 = __pyx_v_data_type;
  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_t_3, __pyx_n_u_array, Py_NE)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 418, __pyx_L1_error)
  if (__pyx_t_1) {
  } else {
    __pyx_t_2 = __pyx_t_1;
    goto __pyx_L6_bool_binop_done;
  }
  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_t_3, __pyx_n_u_dataframe, Py_NE)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 418, __pyx_L1_error)
  __pyx_t_2 = __pyx_t_1;
  __pyx_L6_bool_binop_done:;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (unlikely(__pyx_t_1)) {

    /* "validator.pyx":419
 * 
 *     if data_type not in ['array', 'dataframe']:
 *         raise ValueError("data_type must be either 'array' or 'dataframe'")             # <<<<<<<<<<<<<<
 * 
 *     # Check if the data is a square matrix
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 419, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 419, __pyx_L1_error)

    /* "validator.pyx":418
 *             data_type = 'array'
 * 
 *     if data_type not in ['array', 'dataframe']:             # <<<<<<<<<<<<<<
 *         raise ValueError("data_type must be either 'array' or 'dataframe'")
 * 
 */
  }

  /* "validator.pyx":422
 * 
 *     # Check if the data is a square matrix
 *     if data_type == 'array':             # <<<<<<<<<<<<<<
 *         if data.ndim != 2 or data.shape[0] != data.shape[1]:
 *             return False
 */
  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_data_type, __pyx_n_u_array, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 422, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "validator.pyx":423
 *     # Check if the data is a square matrix
 *     if data_type == 'array':
 *         if data.ndim != 2 or data.shape[0] != data.shape[1]:             # <<<<<<<<<<<<<<
 *             return False
 *     elif data_type == 'dataframe':
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_ndim); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 423, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = __Pyx_PyInt_NeObjC(__pyx_t_3, __pyx_int_2, 2, 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 423, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 423, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (!__pyx_t_2) {
    } else {
      __pyx_t_1 = __pyx_t_2;
      goto __pyx_L10_bool_binop_done;
    }
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_shape); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 423, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_5, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 423, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_shape); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 423, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_4 = __Pyx_GetItemInt(__pyx_t_5, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 423, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = PyObject_RichCompare(__pyx_t_3, __pyx_t_4, Py_NE); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 423, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 423, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_1 = __pyx_t_2;
    __pyx_L10_bool_binop_done:;
    if (__pyx_t_1) {

      /* "validator.pyx":424
 *     if data_type == 'array':
 *         if data.ndim != 2 or data.shape[0] != data.shape[1]:
 *             return False             # <<<<<<<<<<<<<<
 *     elif data_type == 'dataframe':
 *         if data.shape[0] != data.shape[1]:
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_False);
      __pyx_r = Py_False;
      goto __pyx_L0;

      /* "validator.pyx":423
 *     # Check if the data is a square matrix
 *     if data_type == 'array':
 *         if data.ndim != 2 or data.shape[0] != data.shape[1]:             # <<<<<<<<<<<<<<
 *             return False
 *     elif data_type == 'dataframe':
 */
    }

    /* "validator.pyx":422
 * 
 *     # Check if the data is a square matrix
 *     if data_type == 'array':             # <<<<<<<<<<<<<<
 *         if data.ndim != 2 or data.shape[0] != data.shape[1]:
 *             return False
 */
    goto __pyx_L8;
  }

  /* "validator.pyx":425
 *         if data.ndim != 2 or data.shape[0] != data.shape[1]:
 *             return False
 *     elif data_type == 'dataframe':             # <<<<<<<<<<<<<<
 *         if data.shape[0] != data.shape[1]:
 *             return False
 */
  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_data_type, __pyx_n_u_dataframe, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 425, __pyx_L1_error)
  if (likely(__pyx_t_1)) {

    /* "validator.pyx":426
 *             return False
 *     elif data_type == 'dataframe':
 *         if data.shape[0] != data.shape[1]:             # <<<<<<<<<<<<<<
 *             return False
 *     else:
 */
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_shape); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 426, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_4 = __Pyx_GetItemInt(__pyx_t_5, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 426, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_shape); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 426, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_5, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 426, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = PyObject_RichCompare(__pyx_t_4, __pyx_t_3, Py_NE); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 426, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 426, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (__pyx_t_1) {

      /* "validator.pyx":427
 *     elif data_type == 'dataframe':
 *         if data.shape[0] != data.shape[1]:
 *             return False             # <<<<<<<<<<<<<<
 *     else:
 *         raise TypeError(f"Unsupported or mismatched data type: {data_type}")
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_False);
      __pyx_r = Py_False;
      goto __pyx_L0;

      /* "validator.pyx":426
 *             return False
 *     elif data_type == 'dataframe':
 *         if data.shape[0] != data.shape[1]:             # <<<<<<<<<<<<<<
 *             return False
 *     else:
 */
    }

    /* "validator.pyx":425
 *         if data.ndim != 2 or data.shape[0] != data.shape[1]:
 *             return False
 *     elif data_type == 'dataframe':             # <<<<<<<<<<<<<<
 *         if data.shape[0] != data.shape[1]:
 *             return False
 */
    goto __pyx_L8;
  }

  /* "validator.pyx":429
 *             return False
 *     else:
 *         raise TypeError(f"Unsupported or mismatched data type: {data_type}")             # <<<<<<<<<<<<<<
 * 
 *     return True
 */
  /*else*/ {
    __pyx_t_5 = __Pyx_PyObject_FormatSimple(__pyx_v_data_type, __pyx_empty_unicode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 429, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_3 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Unsupported_or_mismatched_data_t, __pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 429, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 429, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __PYX_ERR(0, 429, __pyx_L1_error)
  }
  __pyx_L8:;

  /* "validator.pyx":431
 *         raise TypeError(f"Unsupported or mismatched data type: {data_type}")
 * 
 *     return True             # <<<<<<<<<<<<<<
 * 
 * def validate_multiclass_target(
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_True);
  __pyx_r = Py_True;
  goto __pyx_L0;

  /* "validator.pyx":360
 *     return data
 * 
 * def is_square_matrix(data, data_type=None):             # <<<<<<<<<<<<<<
 *     """
 *     Determine whether the input, either a DataFrame or an array-like
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("validator.is_square_matrix", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_data);
  __Pyx_XDECREF(__pyx_v_data_type);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":433
 *     return True
 * 
 * def validate_multiclass_target(             # <<<<<<<<<<<<<<
 *         y, accept_multioutput=False, return_classes=False):
 *     """
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_11validate_multiclass_target(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_10validate_multiclass_target[] = "\n    Validates that the target data is suitable for multiclass classification.\n    Optionally accepts multi-output targets and can return the unique classes.\n\n    Parameters\n    ----------\n    y : array-like\n        The target data to be validated, expected to contain class labels for\n        multiclass classification. Can be a multi-output array if accept_multioutput\n        is set to True.\n    accept_multioutput : bool, optional\n        Allows the target array to be multi-dimensional (default is False).\n    return_classes : bool, optional\n        If True, returns the unique classes instead of a validation boolean.\n\n    Returns\n    -------\n    bool or array\n        If return_classes is False, returns True if the target data is valid for\n        multiclass classification, otherwise raises a ValueError.\n        If return_classes is True, returns the unique classes in the target data.\n\n    Raises\n    ------\n    ValueError\n        If any of the following conditions are not met:\n        - If accept_multioutput is False, the target data must be one-dimensional.\n        - All elements in the target array must be non-negative integers.\n        - The target array must contain at least two distinct classes.\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import validate_multiclass_target\n    >>> validate_multiclass_target([0, 1, 2, 1, 0])\n    array([0, 1, 2, 1, 0])\n    >>> validate_multiclass_target([0, 0, 0])\n    ValueError: Target array must contain at least two distinct classes.\n    >>> validate_multiclass_target([0.5, 1.2, 2.3])\n    ValueError: All elements in the target array must be non-negative integers.\n    >>> validate_multiclass_target([[1, 2], [2, 3]], accept_multioutput=True, \n    ...                              return_classes=True)\n    (array([1, 2, 2, 3]), 3)\n    True\n    ";
static PyMethodDef __pyx_mdef_9validator_11validate_multiclass_target = {"validate_multiclass_target", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_11validate_multiclass_target, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_10validate_multiclass_target};
static PyObject *__pyx_pw_9validator_11validate_multiclass_target(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_y = 0;
  PyObject *__pyx_v_accept_multioutput = 0;
  PyObject *__pyx_v_return_classes = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validate_multiclass_target (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_y,&__pyx_n_s_accept_multioutput,&__pyx_n_s_return_classes,0};
    PyObject* values[3] = {0,0,0};

    /* "validator.pyx":434
 * 
 * def validate_multiclass_target(
 *         y, accept_multioutput=False, return_classes=False):             # <<<<<<<<<<<<<<
 *     """
 *     Validates that the target data is suitable for multiclass classification.
 */
    values[1] = ((PyObject *)Py_False);
    values[2] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_accept_multioutput);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_return_classes);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "validate_multiclass_target") < 0)) __PYX_ERR(0, 433, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_y = values[0];
    __pyx_v_accept_multioutput = values[1];
    __pyx_v_return_classes = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("validate_multiclass_target", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 433, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.validate_multiclass_target", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_10validate_multiclass_target(__pyx_self, __pyx_v_y, __pyx_v_accept_multioutput, __pyx_v_return_classes);

  /* "validator.pyx":433
 *     return True
 * 
 * def validate_multiclass_target(             # <<<<<<<<<<<<<<
 *         y, accept_multioutput=False, return_classes=False):
 *     """
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_10validate_multiclass_target(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y, PyObject *__pyx_v_accept_multioutput, PyObject *__pyx_v_return_classes) {
  PyObject *__pyx_v_y_eval = NULL;
  PyObject *__pyx_v_unique_classes = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_t_9;
  PyObject *__pyx_t_10 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validate_multiclass_target", 0);
  __Pyx_INCREF(__pyx_v_y);

  /* "validator.pyx":480
 *     """
 *     # Convert input to a numpy array and create a copy if modifying data structure
 *     y = np.asarray(y)             # <<<<<<<<<<<<<<
 *     y_eval = y.copy() if accept_multioutput else y
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 480, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_asarray); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 480, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_v_y) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_y);
  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 480, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF_SET(__pyx_v_y, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":481
 *     # Convert input to a numpy array and create a copy if modifying data structure
 *     y = np.asarray(y)
 *     y_eval = y.copy() if accept_multioutput else y             # <<<<<<<<<<<<<<
 * 
 *     # Ensure the array is one-dimensional if multi-output is not accepted
 */
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_accept_multioutput); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 481, __pyx_L1_error)
  if (__pyx_t_4) {
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_y, __pyx_n_s_copy); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 481, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 481, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_1 = __pyx_t_3;
    __pyx_t_3 = 0;
  } else {
    __Pyx_INCREF(__pyx_v_y);
    __pyx_t_1 = __pyx_v_y;
  }
  __pyx_v_y_eval = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":484
 * 
 *     # Ensure the array is one-dimensional if multi-output is not accepted
 *     if not accept_multioutput and y.ndim > 1:             # <<<<<<<<<<<<<<
 *         raise ValueError("Target array must be one-dimensional unless"
 *                          " multi-output is accepted.")
 */
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_accept_multioutput); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 484, __pyx_L1_error)
  __pyx_t_7 = ((!__pyx_t_6) != 0);
  if (__pyx_t_7) {
  } else {
    __pyx_t_4 = __pyx_t_7;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_y, __pyx_n_s_ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 484, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = PyObject_RichCompare(__pyx_t_1, __pyx_int_1, Py_GT); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 484, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 484, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_4 = __pyx_t_7;
  __pyx_L4_bool_binop_done:;
  if (unlikely(__pyx_t_4)) {

    /* "validator.pyx":485
 *     # Ensure the array is one-dimensional if multi-output is not accepted
 *     if not accept_multioutput and y.ndim > 1:
 *         raise ValueError("Target array must be one-dimensional unless"             # <<<<<<<<<<<<<<
 *                          " multi-output is accepted.")
 * 
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 485, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 485, __pyx_L1_error)

    /* "validator.pyx":484
 * 
 *     # Ensure the array is one-dimensional if multi-output is not accepted
 *     if not accept_multioutput and y.ndim > 1:             # <<<<<<<<<<<<<<
 *         raise ValueError("Target array must be one-dimensional unless"
 *                          " multi-output is accepted.")
 */
  }

  /* "validator.pyx":489
 * 
 *     # Validate that all elements are non-negative integers
 *     if not (np.issubdtype(y_eval.dtype, np.integer) and np.all(y_eval >= 0)):             # <<<<<<<<<<<<<<
 *         raise ValueError("All elements in the target array must be non-negative integers.")
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 489, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_issubdtype); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 489, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_y_eval, __pyx_n_s_dtype); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 489, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 489, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_integer); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 489, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = NULL;
  __pyx_t_9 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_9 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_1, __pyx_t_8};
    __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_9, 2+__pyx_t_9); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 489, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_t_1, __pyx_t_8};
    __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_9, 2+__pyx_t_9); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 489, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  } else
  #endif
  {
    __pyx_t_10 = PyTuple_New(2+__pyx_t_9); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 489, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    if (__pyx_t_5) {
      __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_5); __pyx_t_5 = NULL;
    }
    __Pyx_GIVEREF(__pyx_t_1);
    PyTuple_SET_ITEM(__pyx_t_10, 0+__pyx_t_9, __pyx_t_1);
    __Pyx_GIVEREF(__pyx_t_8);
    PyTuple_SET_ITEM(__pyx_t_10, 1+__pyx_t_9, __pyx_t_8);
    __pyx_t_1 = 0;
    __pyx_t_8 = 0;
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_10, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 489, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 489, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_7) {
  } else {
    __pyx_t_4 = __pyx_t_7;
    goto __pyx_L7_bool_binop_done;
  }
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 489, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_all); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 489, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_10);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = PyObject_RichCompare(__pyx_v_y_eval, __pyx_int_0, Py_GE); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 489, __pyx_L1_error)
  __pyx_t_8 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_10))) {
    __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_10);
    if (likely(__pyx_t_8)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_10);
      __Pyx_INCREF(__pyx_t_8);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_10, function);
    }
  }
  __pyx_t_3 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_10, __pyx_t_8, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_10, __pyx_t_2);
  __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 489, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 489, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_4 = __pyx_t_7;
  __pyx_L7_bool_binop_done:;
  __pyx_t_7 = ((!__pyx_t_4) != 0);
  if (unlikely(__pyx_t_7)) {

    /* "validator.pyx":490
 *     # Validate that all elements are non-negative integers
 *     if not (np.issubdtype(y_eval.dtype, np.integer) and np.all(y_eval >= 0)):
 *         raise ValueError("All elements in the target array must be non-negative integers.")             # <<<<<<<<<<<<<<
 * 
 *     # Flatten the array for unique class check if multi-output is accepted
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 490, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 490, __pyx_L1_error)

    /* "validator.pyx":489
 * 
 *     # Validate that all elements are non-negative integers
 *     if not (np.issubdtype(y_eval.dtype, np.integer) and np.all(y_eval >= 0)):             # <<<<<<<<<<<<<<
 *         raise ValueError("All elements in the target array must be non-negative integers.")
 * 
 */
  }

  /* "validator.pyx":493
 * 
 *     # Flatten the array for unique class check if multi-output is accepted
 *     if accept_multioutput:             # <<<<<<<<<<<<<<
 *         y_eval = y_eval.flatten()
 * 
 */
  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_accept_multioutput); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 493, __pyx_L1_error)
  if (__pyx_t_7) {

    /* "validator.pyx":494
 *     # Flatten the array for unique class check if multi-output is accepted
 *     if accept_multioutput:
 *         y_eval = y_eval.flatten()             # <<<<<<<<<<<<<<
 * 
 *     # Ensure there are at least two distinct classes
 */
    __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_v_y_eval, __pyx_n_s_flatten); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 494, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    __pyx_t_2 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_10))) {
      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_10);
      if (likely(__pyx_t_2)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_10);
        __Pyx_INCREF(__pyx_t_2);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_10, function);
      }
    }
    __pyx_t_3 = (__pyx_t_2) ? __Pyx_PyObject_CallOneArg(__pyx_t_10, __pyx_t_2) : __Pyx_PyObject_CallNoArg(__pyx_t_10);
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 494, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    __Pyx_DECREF_SET(__pyx_v_y_eval, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "validator.pyx":493
 * 
 *     # Flatten the array for unique class check if multi-output is accepted
 *     if accept_multioutput:             # <<<<<<<<<<<<<<
 *         y_eval = y_eval.flatten()
 * 
 */
  }

  /* "validator.pyx":497
 * 
 *     # Ensure there are at least two distinct classes
 *     unique_classes = np.unique(y_eval)             # <<<<<<<<<<<<<<
 *     if unique_classes.size < 2:
 *         raise ValueError("Target array must contain at least two distinct classes.")
 */
  __Pyx_GetModuleGlobalName(__pyx_t_10, __pyx_n_s_np); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 497, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_10);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_10, __pyx_n_s_unique); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 497, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
  __pyx_t_10 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_10)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_10);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_3 = (__pyx_t_10) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_10, __pyx_v_y_eval) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_y_eval);
  __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 497, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_unique_classes = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "validator.pyx":498
 *     # Ensure there are at least two distinct classes
 *     unique_classes = np.unique(y_eval)
 *     if unique_classes.size < 2:             # <<<<<<<<<<<<<<
 *         raise ValueError("Target array must contain at least two distinct classes.")
 * 
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_unique_classes, __pyx_n_s_size); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 498, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyObject_RichCompare(__pyx_t_3, __pyx_int_2, Py_LT); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 498, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 498, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(__pyx_t_7)) {

    /* "validator.pyx":499
 *     unique_classes = np.unique(y_eval)
 *     if unique_classes.size < 2:
 *         raise ValueError("Target array must contain at least two distinct classes.")             # <<<<<<<<<<<<<<
 * 
 *     # Return the original array and the number of unique classes if requested
 */
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 499, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 499, __pyx_L1_error)

    /* "validator.pyx":498
 *     # Ensure there are at least two distinct classes
 *     unique_classes = np.unique(y_eval)
 *     if unique_classes.size < 2:             # <<<<<<<<<<<<<<
 *         raise ValueError("Target array must contain at least two distinct classes.")
 * 
 */
  }

  /* "validator.pyx":502
 * 
 *     # Return the original array and the number of unique classes if requested
 *     if return_classes:             # <<<<<<<<<<<<<<
 *         return y, unique_classes.size
 * 
 */
  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_return_classes); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 502, __pyx_L1_error)
  if (__pyx_t_7) {

    /* "validator.pyx":503
 *     # Return the original array and the number of unique classes if requested
 *     if return_classes:
 *         return y, unique_classes.size             # <<<<<<<<<<<<<<
 * 
 *     return y
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_unique_classes, __pyx_n_s_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 503, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 503, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_v_y);
    __Pyx_GIVEREF(__pyx_v_y);
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_y);
    __Pyx_GIVEREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
    __pyx_t_2 = 0;
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;

    /* "validator.pyx":502
 * 
 *     # Return the original array and the number of unique classes if requested
 *     if return_classes:             # <<<<<<<<<<<<<<
 *         return y, unique_classes.size
 * 
 */
  }

  /* "validator.pyx":505
 *         return y, unique_classes.size
 * 
 *     return y             # <<<<<<<<<<<<<<
 * 
 * def validate_sample_weights(weights, y, normalize =False):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_y);
  __pyx_r = __pyx_v_y;
  goto __pyx_L0;

  /* "validator.pyx":433
 *     return True
 * 
 * def validate_multiclass_target(             # <<<<<<<<<<<<<<
 *         y, accept_multioutput=False, return_classes=False):
 *     """
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_AddTraceback("validator.validate_multiclass_target", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_y_eval);
  __Pyx_XDECREF(__pyx_v_unique_classes);
  __Pyx_XDECREF(__pyx_v_y);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":507
 *     return y
 * 
 * def validate_sample_weights(weights, y, normalize =False):             # <<<<<<<<<<<<<<
 *     """
 *     Validates that the sample weights are suitable for use in calculations.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_13validate_sample_weights(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_12validate_sample_weights[] = "\n    Validates that the sample weights are suitable for use in calculations.\n\n    This function checks that the sample weights are non-negative and match\n    the length of the target array `y`. It raises an error if any conditions\n    are not met. If a single number is provided as weights, it will be\n    converted into an array with repeated values matching the length of `y`.\n\n    Parameters\n    ----------\n    weights : array-like or number\n        The sample weights to be validated. Each weight must be non-negative.\n        A single number will be converted to an array with repeated values.\n    y : array-like\n        The target array that the weights should correspond to. The length\n        of `weights` must match the length of `y`.\n    normalize : bool, optional\n        If True, weights will be normalized to sum to 1. Default is False.\n        \n    Returns\n    -------\n    numpy.ndarray\n        The validated sample weights as a numpy array.\n\n    Raises\n    ------\n    ValueError\n        If `weights` are not one-dimensional, if any weight is negative,\n        or if the length of `weights` does not match the length of `y`.\n\n    Examples\n    --------\n    >>> frpm gofast.tools.validator import validate_sample_weights\n    >>> y = [0, 1, 2, 3]\n    >>> weights = [0.1, 0.2, 0.3, 0.4]\n    >>> validate_sample_weights(weights, y)\n    array([0.1, 0.2, 0.3, 0.4])\n\n    >>> weights = [-0.1, 0.2, 0.3, 0.4]\n    >>> validate_sample_weights(weights, y)\n    ValueError: Sample weights must be non-negative.\n\n    >>> weights = [0.1, 0.2, 0.3]\n    >>> validate_sample_weights(weights, y)\n    ValueError: Length of sample weights must match length of y.\n    ";
static PyMethodDef __pyx_mdef_9validator_13validate_sample_weights = {"validate_sample_weights", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_13validate_sample_weights, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_12validate_sample_weights};
static PyObject *__pyx_pw_9validator_13validate_sample_weights(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_weights = 0;
  PyObject *__pyx_v_y = 0;
  PyObject *__pyx_v_normalize = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validate_sample_weights (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_weights,&__pyx_n_s_y,&__pyx_n_s_normalize,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_weights)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("validate_sample_weights", 0, 2, 3, 1); __PYX_ERR(0, 507, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_normalize);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "validate_sample_weights") < 0)) __PYX_ERR(0, 507, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_weights = values[0];
    __pyx_v_y = values[1];
    __pyx_v_normalize = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("validate_sample_weights", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 507, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.validate_sample_weights", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_12validate_sample_weights(__pyx_self, __pyx_v_weights, __pyx_v_y, __pyx_v_normalize);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_12validate_sample_weights(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_weights, PyObject *__pyx_v_y, PyObject *__pyx_v_normalize) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validate_sample_weights", 0);
  __Pyx_INCREF(__pyx_v_weights);
  __Pyx_INCREF(__pyx_v_y);

  /* "validator.pyx":554
 *     ValueError: Length of sample weights must match length of y.
 *     """
 *     if isinstance(weights, (int, float, np.integer, np.floating)):             # <<<<<<<<<<<<<<
 *         weights = np.full_like(y, fill_value=weights, dtype=np.float)
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 554, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_integer); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 554, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 554, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_floating); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 554, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = PyInt_Check(__pyx_v_weights); 
  __pyx_t_6 = (__pyx_t_5 != 0);
  if (!__pyx_t_6) {
  } else {
    __pyx_t_4 = __pyx_t_6;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_6 = PyFloat_Check(__pyx_v_weights); 
  __pyx_t_5 = (__pyx_t_6 != 0);
  if (!__pyx_t_5) {
  } else {
    __pyx_t_4 = __pyx_t_5;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_5 = PyObject_IsInstance(__pyx_v_weights, __pyx_t_2); 
  __pyx_t_6 = (__pyx_t_5 != 0);
  if (!__pyx_t_6) {
  } else {
    __pyx_t_4 = __pyx_t_6;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_6 = PyObject_IsInstance(__pyx_v_weights, __pyx_t_3); 
  __pyx_t_5 = (__pyx_t_6 != 0);
  __pyx_t_4 = __pyx_t_5;
  __pyx_L4_bool_binop_done:;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_5 = (__pyx_t_4 != 0);
  if (__pyx_t_5) {

    /* "validator.pyx":555
 *     """
 *     if isinstance(weights, (int, float, np.integer, np.floating)):
 *         weights = np.full_like(y, fill_value=weights, dtype=np.float)             # <<<<<<<<<<<<<<
 * 
 *     weights = np.asarray(weights)
 */
    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 555, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_full_like); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 555, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 555, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_v_y);
    __Pyx_GIVEREF(__pyx_v_y);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_y);
    __pyx_t_1 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 555, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_fill_value, __pyx_v_weights) < 0) __PYX_ERR(0, 555, __pyx_L1_error)
    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 555, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_float); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 555, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_dtype, __pyx_t_8) < 0) __PYX_ERR(0, 555, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_8 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, __pyx_t_1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 555, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF_SET(__pyx_v_weights, __pyx_t_8);
    __pyx_t_8 = 0;

    /* "validator.pyx":554
 *     ValueError: Length of sample weights must match length of y.
 *     """
 *     if isinstance(weights, (int, float, np.integer, np.floating)):             # <<<<<<<<<<<<<<
 *         weights = np.full_like(y, fill_value=weights, dtype=np.float)
 * 
 */
  }

  /* "validator.pyx":557
 *         weights = np.full_like(y, fill_value=weights, dtype=np.float)
 * 
 *     weights = np.asarray(weights)             # <<<<<<<<<<<<<<
 *     y = np.asarray(y)
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 557, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_asarray); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 557, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_1)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_1);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_8 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_1, __pyx_v_weights) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_weights);
  __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 557, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF_SET(__pyx_v_weights, __pyx_t_8);
  __pyx_t_8 = 0;

  /* "validator.pyx":558
 * 
 *     weights = np.asarray(weights)
 *     y = np.asarray(y)             # <<<<<<<<<<<<<<
 * 
 *     # Check if weights are one-dimensional
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 558, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_asarray); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 558, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  __pyx_t_8 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_2, __pyx_v_y) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_y);
  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 558, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF_SET(__pyx_v_y, __pyx_t_8);
  __pyx_t_8 = 0;

  /* "validator.pyx":561
 * 
 *     # Check if weights are one-dimensional
 *     if weights.ndim != 1:             # <<<<<<<<<<<<<<
 *         raise ValueError("Sample weights must be one-dimensional.")
 * 
 */
  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_weights, __pyx_n_s_ndim); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 561, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __pyx_t_1 = __Pyx_PyInt_NeObjC(__pyx_t_8, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 561, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 561, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (unlikely(__pyx_t_5)) {

    /* "validator.pyx":562
 *     # Check if weights are one-dimensional
 *     if weights.ndim != 1:
 *         raise ValueError("Sample weights must be one-dimensional.")             # <<<<<<<<<<<<<<
 * 
 *     # Check if any weights are negative
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__12, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 562, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 562, __pyx_L1_error)

    /* "validator.pyx":561
 * 
 *     # Check if weights are one-dimensional
 *     if weights.ndim != 1:             # <<<<<<<<<<<<<<
 *         raise ValueError("Sample weights must be one-dimensional.")
 * 
 */
  }

  /* "validator.pyx":565
 * 
 *     # Check if any weights are negative
 *     if np.any(weights < 0):             # <<<<<<<<<<<<<<
 *         raise ValueError("Sample weights must be non-negative.")
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_np); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 565, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_any); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 565, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __pyx_t_8 = PyObject_RichCompare(__pyx_v_weights, __pyx_int_0, Py_LT); __Pyx_XGOTREF(__pyx_t_8); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 565, __pyx_L1_error)
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_t_8) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_8);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 565, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 565, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (unlikely(__pyx_t_5)) {

    /* "validator.pyx":566
 *     # Check if any weights are negative
 *     if np.any(weights < 0):
 *         raise ValueError("Sample weights must be non-negative.")             # <<<<<<<<<<<<<<
 * 
 *     # Check if the length of weights matches the length of y
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__13, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 566, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 566, __pyx_L1_error)

    /* "validator.pyx":565
 * 
 *     # Check if any weights are negative
 *     if np.any(weights < 0):             # <<<<<<<<<<<<<<
 *         raise ValueError("Sample weights must be non-negative.")
 * 
 */
  }

  /* "validator.pyx":569
 * 
 *     # Check if the length of weights matches the length of y
 *     if weights.size != y.size:             # <<<<<<<<<<<<<<
 *         raise ValueError("Length of sample weights must match length of y.")
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_weights, __pyx_n_s_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 569, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_y, __pyx_n_s_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 569, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_8 = PyObject_RichCompare(__pyx_t_1, __pyx_t_2, Py_NE); __Pyx_XGOTREF(__pyx_t_8); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 569, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_8); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 569, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  if (unlikely(__pyx_t_5)) {

    /* "validator.pyx":570
 *     # Check if the length of weights matches the length of y
 *     if weights.size != y.size:
 *         raise ValueError("Length of sample weights must match length of y.")             # <<<<<<<<<<<<<<
 * 
 *     weights = normalize_array(weights, normalize=normalize, method="sum")
 */
    __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__14, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 570, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_Raise(__pyx_t_8, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __PYX_ERR(0, 570, __pyx_L1_error)

    /* "validator.pyx":569
 * 
 *     # Check if the length of weights matches the length of y
 *     if weights.size != y.size:             # <<<<<<<<<<<<<<
 *         raise ValueError("Length of sample weights must match length of y.")
 * 
 */
  }

  /* "validator.pyx":572
 *         raise ValueError("Length of sample weights must match length of y.")
 * 
 *     weights = normalize_array(weights, normalize=normalize, method="sum")             # <<<<<<<<<<<<<<
 * 
 *     return weights  # Return the validated weights as a numpy array
 */
  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_normalize_array); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 572, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 572, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_weights);
  __Pyx_GIVEREF(__pyx_v_weights);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_weights);
  __pyx_t_1 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 572, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_normalize, __pyx_v_normalize) < 0) __PYX_ERR(0, 572, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_method, __pyx_n_u_sum) < 0) __PYX_ERR(0, 572, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_8, __pyx_t_2, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 572, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF_SET(__pyx_v_weights, __pyx_t_3);
  __pyx_t_3 = 0;

  /* "validator.pyx":574
 *     weights = normalize_array(weights, normalize=normalize, method="sum")
 * 
 *     return weights  # Return the validated weights as a numpy array             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_weights);
  __pyx_r = __pyx_v_weights;
  goto __pyx_L0;

  /* "validator.pyx":507
 *     return y
 * 
 * def validate_sample_weights(weights, y, normalize =False):             # <<<<<<<<<<<<<<
 *     """
 *     Validates that the sample weights are suitable for use in calculations.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("validator.validate_sample_weights", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_weights);
  __Pyx_XDECREF(__pyx_v_y);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":577
 * 
 * 
 * def validate_weights(             # <<<<<<<<<<<<<<
 *         weights, min_value=None, max_value=None, normalize=False,
 *         allowed_dims=1):
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_15validate_weights(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_14validate_weights[] = "\n    Validates and optionally normalizes the given weights array to ensure all elements \n    meet specified criteria and the structure is suitable for computations.\n\n    Parameters:\n    ----------\n    weights : array-like\n        Weights to be validated. Can be a list, tuple, or numpy array.\n    min_value : float, optional\n        Minimum allowable value for weights (inclusive). If None, weights are \n        expected to be non-negative. Explicitly set to a negative value if \n        negative weights are allowed.\n    max_value : float or None, optional\n        Maximum allowable value for weights (inclusive). If None, no upper \n        limit is enforced.\n    normalize : bool, optional\n        If True, weights will be normalized to sum to 1. Default is False.\n    allowed_dims : int or tuple, optional\n        Specifies the allowed dimensions of the weights array. Default is 1 \n        (one-dimensional). If a tuple is provided, weights must match one of \n        the dimensions specified in the tuple.\n\n    Returns:\n    -------\n    np.ndarray\n        A numpy array of the validated and optionally normalized weights.\n\n    Raises:\n    ------\n    ValueError\n        If weights contain values outside the specified range, or if the \n        format or dimensions are not suitable.\n\n    Examples:\n    --------\n    >>> from gofast.tools.validator import validate_weights\n    \n    >>> validate_weights([0.25, 0.75, 0.5], normalize=True)\n    array([0.2, 0.6, 0.4])\n\n    >>> validate_weights([-0.1, 0.9], min_value=0)\n    ValueError: Weights must be non-negative.\n\n    >>> validate_weights([0.1, 0.2, 0.7], max_value=0.5)\n    ValueError: Weights must not exceed 0.5.\n\n    >>> validate_weights([1, 2, 3], allowed_dims=(1, 2))\n    ValueError: Weights dimensions not allowed.\n    ";
static PyMethodDef __pyx_mdef_9validator_15validate_weights = {"validate_weights", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_15validate_weights, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_14validate_weights};
static PyObject *__pyx_pw_9validator_15validate_weights(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_weights = 0;
  PyObject *__pyx_v_min_value = 0;
  PyObject *__pyx_v_max_value = 0;
  PyObject *__pyx_v_normalize = 0;
  PyObject *__pyx_v_allowed_dims = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validate_weights (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_weights,&__pyx_n_s_min_value,&__pyx_n_s_max_value,&__pyx_n_s_normalize,&__pyx_n_s_allowed_dims,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "validator.pyx":578
 * 
 * def validate_weights(
 *         weights, min_value=None, max_value=None, normalize=False,             # <<<<<<<<<<<<<<
 *         allowed_dims=1):
 *     """
 */
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_False);
    values[4] = ((PyObject *)__pyx_int_1);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_weights)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_min_value);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_max_value);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_normalize);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_allowed_dims);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "validate_weights") < 0)) __PYX_ERR(0, 577, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_weights = values[0];
    __pyx_v_min_value = values[1];
    __pyx_v_max_value = values[2];
    __pyx_v_normalize = values[3];
    __pyx_v_allowed_dims = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("validate_weights", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 577, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.validate_weights", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_14validate_weights(__pyx_self, __pyx_v_weights, __pyx_v_min_value, __pyx_v_max_value, __pyx_v_normalize, __pyx_v_allowed_dims);

  /* "validator.pyx":577
 * 
 * 
 * def validate_weights(             # <<<<<<<<<<<<<<
 *         weights, min_value=None, max_value=None, normalize=False,
 *         allowed_dims=1):
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_14validate_weights(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_weights, PyObject *__pyx_v_min_value, PyObject *__pyx_v_max_value, PyObject *__pyx_v_normalize, PyObject *__pyx_v_allowed_dims) {
  PyObject *__pyx_v_weights_array = NULL;
  PyObject *__pyx_v_e = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_t_8;
  int __pyx_t_9;
  char const *__pyx_t_10;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  PyObject *__pyx_t_15 = NULL;
  PyObject *__pyx_t_16 = NULL;
  int __pyx_t_17;
  int __pyx_t_18;
  Py_ssize_t __pyx_t_19;
  Py_UCS4 __pyx_t_20;
  int __pyx_t_21;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validate_weights", 0);
  __Pyx_INCREF(__pyx_v_min_value);
  __Pyx_INCREF(__pyx_v_allowed_dims);

  /* "validator.pyx":629
 *     ValueError: Weights dimensions not allowed.
 *     """
 *     try:             # <<<<<<<<<<<<<<
 *         weights_array = np.asarray(weights, dtype=float)
 *     except Exception as e:
 */
  {
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
    __Pyx_XGOTREF(__pyx_t_1);
    __Pyx_XGOTREF(__pyx_t_2);
    __Pyx_XGOTREF(__pyx_t_3);
    /*try:*/ {

      /* "validator.pyx":630
 *     """
 *     try:
 *         weights_array = np.asarray(weights, dtype=float)             # <<<<<<<<<<<<<<
 *     except Exception as e:
 *         raise ValueError("Weights must be provided in a format that can be"
 */
      __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 630, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_asarray); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 630, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 630, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_INCREF(__pyx_v_weights);
      __Pyx_GIVEREF(__pyx_v_weights);
      PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_weights);
      __pyx_t_6 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 630, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_6);
      if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_dtype, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 630, __pyx_L3_error)
      __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_4, __pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 630, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_v_weights_array = __pyx_t_7;
      __pyx_t_7 = 0;

      /* "validator.pyx":629
 *     ValueError: Weights dimensions not allowed.
 *     """
 *     try:             # <<<<<<<<<<<<<<
 *         weights_array = np.asarray(weights, dtype=float)
 *     except Exception as e:
 */
    }
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    goto __pyx_L8_try_end;
    __pyx_L3_error:;
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;

    /* "validator.pyx":631
 *     try:
 *         weights_array = np.asarray(weights, dtype=float)
 *     except Exception as e:             # <<<<<<<<<<<<<<
 *         raise ValueError("Weights must be provided in a format that can be"
 *                          " converted to a numpy array.") from e
 */
    __pyx_t_8 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
    if (__pyx_t_8) {
      __Pyx_AddTraceback("validator.validate_weights", __pyx_clineno, __pyx_lineno, __pyx_filename);
      if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_6, &__pyx_t_4) < 0) __PYX_ERR(0, 631, __pyx_L5_except_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_6);
      __pyx_v_e = __pyx_t_6;
      /*try:*/ {

        /* "validator.pyx":632
 *         weights_array = np.asarray(weights, dtype=float)
 *     except Exception as e:
 *         raise ValueError("Weights must be provided in a format that can be"             # <<<<<<<<<<<<<<
 *                          " converted to a numpy array.") from e
 * 
 */
        __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__15, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 632, __pyx_L14_error)
        __Pyx_GOTREF(__pyx_t_5);

        /* "validator.pyx":633
 *     except Exception as e:
 *         raise ValueError("Weights must be provided in a format that can be"
 *                          " converted to a numpy array.") from e             # <<<<<<<<<<<<<<
 * 
 *     if isinstance(allowed_dims, int):
 */
        __Pyx_Raise(__pyx_t_5, 0, 0, __pyx_v_e);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __PYX_ERR(0, 632, __pyx_L14_error)
      }

      /* "validator.pyx":631
 *     try:
 *         weights_array = np.asarray(weights, dtype=float)
 *     except Exception as e:             # <<<<<<<<<<<<<<
 *         raise ValueError("Weights must be provided in a format that can be"
 *                          " converted to a numpy array.") from e
 */
      /*finally:*/ {
        __pyx_L14_error:;
        /*exception exit:*/{
          __Pyx_PyThreadState_declare
          __Pyx_PyThreadState_assign
          __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0; __pyx_t_16 = 0;
          __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
          if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_14, &__pyx_t_15, &__pyx_t_16);
          if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_11, &__pyx_t_12, &__pyx_t_13) < 0)) __Pyx_ErrFetch(&__pyx_t_11, &__pyx_t_12, &__pyx_t_13);
          __Pyx_XGOTREF(__pyx_t_11);
          __Pyx_XGOTREF(__pyx_t_12);
          __Pyx_XGOTREF(__pyx_t_13);
          __Pyx_XGOTREF(__pyx_t_14);
          __Pyx_XGOTREF(__pyx_t_15);
          __Pyx_XGOTREF(__pyx_t_16);
          __pyx_t_8 = __pyx_lineno; __pyx_t_9 = __pyx_clineno; __pyx_t_10 = __pyx_filename;
          {
            __Pyx_DECREF(__pyx_v_e);
            __pyx_v_e = NULL;
          }
          if (PY_MAJOR_VERSION >= 3) {
            __Pyx_XGIVEREF(__pyx_t_14);
            __Pyx_XGIVEREF(__pyx_t_15);
            __Pyx_XGIVEREF(__pyx_t_16);
            __Pyx_ExceptionReset(__pyx_t_14, __pyx_t_15, __pyx_t_16);
          }
          __Pyx_XGIVEREF(__pyx_t_11);
          __Pyx_XGIVEREF(__pyx_t_12);
          __Pyx_XGIVEREF(__pyx_t_13);
          __Pyx_ErrRestore(__pyx_t_11, __pyx_t_12, __pyx_t_13);
          __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0; __pyx_t_16 = 0;
          __pyx_lineno = __pyx_t_8; __pyx_clineno = __pyx_t_9; __pyx_filename = __pyx_t_10;
          goto __pyx_L5_except_error;
        }
      }
    }
    goto __pyx_L5_except_error;
    __pyx_L5_except_error:;

    /* "validator.pyx":629
 *     ValueError: Weights dimensions not allowed.
 *     """
 *     try:             # <<<<<<<<<<<<<<
 *         weights_array = np.asarray(weights, dtype=float)
 *     except Exception as e:
 */
    __Pyx_XGIVEREF(__pyx_t_1);
    __Pyx_XGIVEREF(__pyx_t_2);
    __Pyx_XGIVEREF(__pyx_t_3);
    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
    goto __pyx_L1_error;
    __pyx_L8_try_end:;
  }

  /* "validator.pyx":635
 *                          " converted to a numpy array.") from e
 * 
 *     if isinstance(allowed_dims, int):             # <<<<<<<<<<<<<<
 *         allowed_dims = (allowed_dims,)
 *     if weights_array.ndim not in allowed_dims:
 */
  __pyx_t_17 = PyInt_Check(__pyx_v_allowed_dims); 
  __pyx_t_18 = (__pyx_t_17 != 0);
  if (__pyx_t_18) {

    /* "validator.pyx":636
 * 
 *     if isinstance(allowed_dims, int):
 *         allowed_dims = (allowed_dims,)             # <<<<<<<<<<<<<<
 *     if weights_array.ndim not in allowed_dims:
 *         raise ValueError(f"Weights must have dimensions in {allowed_dims}.")
 */
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 636, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_INCREF(__pyx_v_allowed_dims);
    __Pyx_GIVEREF(__pyx_v_allowed_dims);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_allowed_dims);
    __Pyx_DECREF_SET(__pyx_v_allowed_dims, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "validator.pyx":635
 *                          " converted to a numpy array.") from e
 * 
 *     if isinstance(allowed_dims, int):             # <<<<<<<<<<<<<<
 *         allowed_dims = (allowed_dims,)
 *     if weights_array.ndim not in allowed_dims:
 */
  }

  /* "validator.pyx":637
 *     if isinstance(allowed_dims, int):
 *         allowed_dims = (allowed_dims,)
 *     if weights_array.ndim not in allowed_dims:             # <<<<<<<<<<<<<<
 *         raise ValueError(f"Weights must have dimensions in {allowed_dims}.")
 * 
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_weights_array, __pyx_n_s_ndim); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 637, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_18 = (__Pyx_PySequence_ContainsTF(__pyx_t_4, __pyx_v_allowed_dims, Py_NE)); if (unlikely(__pyx_t_18 < 0)) __PYX_ERR(0, 637, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_17 = (__pyx_t_18 != 0);
  if (unlikely(__pyx_t_17)) {

    /* "validator.pyx":638
 *         allowed_dims = (allowed_dims,)
 *     if weights_array.ndim not in allowed_dims:
 *         raise ValueError(f"Weights must have dimensions in {allowed_dims}.")             # <<<<<<<<<<<<<<
 * 
 *     # Check if min_value is None and enforce non-negative weights by default
 */
    __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 638, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_19 = 0;
    __pyx_t_20 = 127;
    __Pyx_INCREF(__pyx_kp_u_Weights_must_have_dimensions_in);
    __pyx_t_19 += 32;
    __Pyx_GIVEREF(__pyx_kp_u_Weights_must_have_dimensions_in);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_kp_u_Weights_must_have_dimensions_in);
    __pyx_t_6 = __Pyx_PyObject_FormatSimple(__pyx_v_allowed_dims, __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 638, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_20 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) > __pyx_t_20) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) : __pyx_t_20;
    __pyx_t_19 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_6);
    __pyx_t_6 = 0;
    __Pyx_INCREF(__pyx_kp_u__16);
    __pyx_t_19 += 1;
    __Pyx_GIVEREF(__pyx_kp_u__16);
    PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_kp_u__16);
    __pyx_t_6 = __Pyx_PyUnicode_Join(__pyx_t_4, 3, __pyx_t_19, __pyx_t_20); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 638, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 638, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 638, __pyx_L1_error)

    /* "validator.pyx":637
 *     if isinstance(allowed_dims, int):
 *         allowed_dims = (allowed_dims,)
 *     if weights_array.ndim not in allowed_dims:             # <<<<<<<<<<<<<<
 *         raise ValueError(f"Weights must have dimensions in {allowed_dims}.")
 * 
 */
  }

  /* "validator.pyx":641
 * 
 *     # Check if min_value is None and enforce non-negative weights by default
 *     if min_value is None:             # <<<<<<<<<<<<<<
 *         if np.any(weights_array < 0):
 *             raise ValueError("Weights must be non-negative unless 'min_value'"
 */
  __pyx_t_17 = (__pyx_v_min_value == Py_None);
  __pyx_t_18 = (__pyx_t_17 != 0);
  if (__pyx_t_18) {

    /* "validator.pyx":642
 *     # Check if min_value is None and enforce non-negative weights by default
 *     if min_value is None:
 *         if np.any(weights_array < 0):             # <<<<<<<<<<<<<<
 *             raise ValueError("Weights must be non-negative unless 'min_value'"
 *                              " is explicitly set to allow negative values.")
 */
    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 642, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_any); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 642, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = PyObject_RichCompare(__pyx_v_weights_array, __pyx_int_0, Py_LT); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 642, __pyx_L1_error)
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_7);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_7, function);
      }
    }
    __pyx_t_4 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_5, __pyx_t_6) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_6);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 642, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_18 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_18 < 0)) __PYX_ERR(0, 642, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(__pyx_t_18)) {

      /* "validator.pyx":643
 *     if min_value is None:
 *         if np.any(weights_array < 0):
 *             raise ValueError("Weights must be non-negative unless 'min_value'"             # <<<<<<<<<<<<<<
 *                              " is explicitly set to allow negative values.")
 *         min_value=0.
 */
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 643, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __PYX_ERR(0, 643, __pyx_L1_error)

      /* "validator.pyx":642
 *     # Check if min_value is None and enforce non-negative weights by default
 *     if min_value is None:
 *         if np.any(weights_array < 0):             # <<<<<<<<<<<<<<
 *             raise ValueError("Weights must be non-negative unless 'min_value'"
 *                              " is explicitly set to allow negative values.")
 */
    }

    /* "validator.pyx":645
 *             raise ValueError("Weights must be non-negative unless 'min_value'"
 *                              " is explicitly set to allow negative values.")
 *         min_value=0.             # <<<<<<<<<<<<<<
 *     if np.any(weights_array < min_value) or (max_value is not None and np.any(
 *             weights_array > max_value)):
 */
    __Pyx_INCREF(__pyx_float_0_);
    __Pyx_DECREF_SET(__pyx_v_min_value, __pyx_float_0_);

    /* "validator.pyx":641
 * 
 *     # Check if min_value is None and enforce non-negative weights by default
 *     if min_value is None:             # <<<<<<<<<<<<<<
 *         if np.any(weights_array < 0):
 *             raise ValueError("Weights must be non-negative unless 'min_value'"
 */
  }

  /* "validator.pyx":646
 *                              " is explicitly set to allow negative values.")
 *         min_value=0.
 *     if np.any(weights_array < min_value) or (max_value is not None and np.any(             # <<<<<<<<<<<<<<
 *             weights_array > max_value)):
 *         raise ValueError(f"Weights must be between {min_value} and"
 */
  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 646, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_any); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 646, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __pyx_t_7 = PyObject_RichCompare(__pyx_v_weights_array, __pyx_v_min_value, Py_LT); __Pyx_XGOTREF(__pyx_t_7); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 646, __pyx_L1_error)
  __pyx_t_5 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_6);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_6, function);
    }
  }
  __pyx_t_4 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_5, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_7);
  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 646, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_17 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_17 < 0)) __PYX_ERR(0, 646, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (!__pyx_t_17) {
  } else {
    __pyx_t_18 = __pyx_t_17;
    goto __pyx_L25_bool_binop_done;
  }
  __pyx_t_17 = (__pyx_v_max_value != Py_None);
  __pyx_t_21 = (__pyx_t_17 != 0);
  if (__pyx_t_21) {
  } else {
    __pyx_t_18 = __pyx_t_21;
    goto __pyx_L25_bool_binop_done;
  }
  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 646, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_any); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 646, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

  /* "validator.pyx":647
 *         min_value=0.
 *     if np.any(weights_array < min_value) or (max_value is not None and np.any(
 *             weights_array > max_value)):             # <<<<<<<<<<<<<<
 *         raise ValueError(f"Weights must be between {min_value} and"
 *                          f" {max_value if max_value is not None else ''}.")
 */
  __pyx_t_6 = PyObject_RichCompare(__pyx_v_weights_array, __pyx_v_max_value, Py_GT); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 647, __pyx_L1_error)
  __pyx_t_5 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_7);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_7, function);
    }
  }
  __pyx_t_4 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_5, __pyx_t_6) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_6);
  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 646, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

  /* "validator.pyx":646
 *                              " is explicitly set to allow negative values.")
 *         min_value=0.
 *     if np.any(weights_array < min_value) or (max_value is not None and np.any(             # <<<<<<<<<<<<<<
 *             weights_array > max_value)):
 *         raise ValueError(f"Weights must be between {min_value} and"
 */
  __pyx_t_21 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_21 < 0)) __PYX_ERR(0, 646, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_18 = __pyx_t_21;
  __pyx_L25_bool_binop_done:;
  if (unlikely(__pyx_t_18)) {

    /* "validator.pyx":648
 *     if np.any(weights_array < min_value) or (max_value is not None and np.any(
 *             weights_array > max_value)):
 *         raise ValueError(f"Weights must be between {min_value} and"             # <<<<<<<<<<<<<<
 *                          f" {max_value if max_value is not None else ''}.")
 * 
 */
    __pyx_t_4 = PyTuple_New(5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 648, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_19 = 0;
    __pyx_t_20 = 127;
    __Pyx_INCREF(__pyx_kp_u_Weights_must_be_between);
    __pyx_t_19 += 24;
    __Pyx_GIVEREF(__pyx_kp_u_Weights_must_be_between);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_kp_u_Weights_must_be_between);
    __pyx_t_7 = __Pyx_PyObject_FormatSimple(__pyx_v_min_value, __pyx_empty_unicode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 648, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_20 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) > __pyx_t_20) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) : __pyx_t_20;
    __pyx_t_19 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_7);
    __Pyx_GIVEREF(__pyx_t_7);
    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_7);
    __pyx_t_7 = 0;
    __Pyx_INCREF(__pyx_kp_u_and);
    __pyx_t_19 += 5;
    __Pyx_GIVEREF(__pyx_kp_u_and);
    PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_kp_u_and);

    /* "validator.pyx":649
 *             weights_array > max_value)):
 *         raise ValueError(f"Weights must be between {min_value} and"
 *                          f" {max_value if max_value is not None else ''}.")             # <<<<<<<<<<<<<<
 * 
 *     if normalize:
 */
    __pyx_t_18 = (__pyx_v_max_value != Py_None);
    if ((__pyx_t_18 != 0)) {
      __Pyx_INCREF(__pyx_v_max_value);
      __pyx_t_7 = __pyx_v_max_value;
    } else {
      __Pyx_INCREF(__pyx_kp_u__18);
      __pyx_t_7 = __pyx_kp_u__18;
    }
    __pyx_t_6 = __Pyx_PyObject_FormatSimple(__pyx_t_7, __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 649, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_20 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) > __pyx_t_20) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) : __pyx_t_20;
    __pyx_t_19 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_4, 3, __pyx_t_6);
    __pyx_t_6 = 0;
    __Pyx_INCREF(__pyx_kp_u__16);
    __pyx_t_19 += 1;
    __Pyx_GIVEREF(__pyx_kp_u__16);
    PyTuple_SET_ITEM(__pyx_t_4, 4, __pyx_kp_u__16);

    /* "validator.pyx":648
 *     if np.any(weights_array < min_value) or (max_value is not None and np.any(
 *             weights_array > max_value)):
 *         raise ValueError(f"Weights must be between {min_value} and"             # <<<<<<<<<<<<<<
 *                          f" {max_value if max_value is not None else ''}.")
 * 
 */
    __pyx_t_6 = __Pyx_PyUnicode_Join(__pyx_t_4, 5, __pyx_t_19, __pyx_t_20); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 648, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 648, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 648, __pyx_L1_error)

    /* "validator.pyx":646
 *                              " is explicitly set to allow negative values.")
 *         min_value=0.
 *     if np.any(weights_array < min_value) or (max_value is not None and np.any(             # <<<<<<<<<<<<<<
 *             weights_array > max_value)):
 *         raise ValueError(f"Weights must be between {min_value} and"
 */
  }

  /* "validator.pyx":651
 *                          f" {max_value if max_value is not None else ''}.")
 * 
 *     if normalize:             # <<<<<<<<<<<<<<
 *         if np.sum(weights_array) == 0:
 *             raise ValueError("Cannot normalize weights because their sum is zero.")
 */
  __pyx_t_18 = __Pyx_PyObject_IsTrue(__pyx_v_normalize); if (unlikely(__pyx_t_18 < 0)) __PYX_ERR(0, 651, __pyx_L1_error)
  if (__pyx_t_18) {

    /* "validator.pyx":652
 * 
 *     if normalize:
 *         if np.sum(weights_array) == 0:             # <<<<<<<<<<<<<<
 *             raise ValueError("Cannot normalize weights because their sum is zero.")
 * 
 */
    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 652, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_sum); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 652, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_7);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_7, function);
      }
    }
    __pyx_t_4 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_6, __pyx_v_weights_array) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_v_weights_array);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 652, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_7 = __Pyx_PyInt_EqObjC(__pyx_t_4, __pyx_int_0, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 652, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_18 = __Pyx_PyObject_IsTrue(__pyx_t_7); if (unlikely(__pyx_t_18 < 0)) __PYX_ERR(0, 652, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    if (unlikely(__pyx_t_18)) {

      /* "validator.pyx":653
 *     if normalize:
 *         if np.sum(weights_array) == 0:
 *             raise ValueError("Cannot normalize weights because their sum is zero.")             # <<<<<<<<<<<<<<
 * 
 *         if not is_normalized(weights_array, method ='sum'):
 */
      __pyx_t_7 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__19, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 653, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_Raise(__pyx_t_7, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __PYX_ERR(0, 653, __pyx_L1_error)

      /* "validator.pyx":652
 * 
 *     if normalize:
 *         if np.sum(weights_array) == 0:             # <<<<<<<<<<<<<<
 *             raise ValueError("Cannot normalize weights because their sum is zero.")
 * 
 */
    }

    /* "validator.pyx":655
 *             raise ValueError("Cannot normalize weights because their sum is zero.")
 * 
 *         if not is_normalized(weights_array, method ='sum'):             # <<<<<<<<<<<<<<
 *             weights_array /= np.sum(weights_array)
 * 
 */
    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_is_normalized); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 655, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 655, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_INCREF(__pyx_v_weights_array);
    __Pyx_GIVEREF(__pyx_v_weights_array);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_weights_array);
    __pyx_t_6 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 655, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_method, __pyx_n_u_sum) < 0) __PYX_ERR(0, 655, __pyx_L1_error)
    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_4, __pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 655, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_18 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_18 < 0)) __PYX_ERR(0, 655, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_21 = ((!__pyx_t_18) != 0);
    if (__pyx_t_21) {

      /* "validator.pyx":656
 * 
 *         if not is_normalized(weights_array, method ='sum'):
 *             weights_array /= np.sum(weights_array)             # <<<<<<<<<<<<<<
 * 
 *     return weights_array
 */
      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 656, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_sum); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 656, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_6 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
        __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);
        if (likely(__pyx_t_6)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
          __Pyx_INCREF(__pyx_t_6);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_4, function);
        }
      }
      __pyx_t_5 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_6, __pyx_v_weights_array) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_weights_array);
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 656, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyNumber_InPlaceDivide(__pyx_v_weights_array, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 656, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_DECREF_SET(__pyx_v_weights_array, __pyx_t_4);
      __pyx_t_4 = 0;

      /* "validator.pyx":655
 *             raise ValueError("Cannot normalize weights because their sum is zero.")
 * 
 *         if not is_normalized(weights_array, method ='sum'):             # <<<<<<<<<<<<<<
 *             weights_array /= np.sum(weights_array)
 * 
 */
    }

    /* "validator.pyx":651
 *                          f" {max_value if max_value is not None else ''}.")
 * 
 *     if normalize:             # <<<<<<<<<<<<<<
 *         if np.sum(weights_array) == 0:
 *             raise ValueError("Cannot normalize weights because their sum is zero.")
 */
  }

  /* "validator.pyx":658
 *             weights_array /= np.sum(weights_array)
 * 
 *     return weights_array             # <<<<<<<<<<<<<<
 * 
 * def is_normalized(arr, method='sum'):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_weights_array);
  __pyx_r = __pyx_v_weights_array;
  goto __pyx_L0;

  /* "validator.pyx":577
 * 
 * 
 * def validate_weights(             # <<<<<<<<<<<<<<
 *         weights, min_value=None, max_value=None, normalize=False,
 *         allowed_dims=1):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("validator.validate_weights", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_weights_array);
  __Pyx_XDECREF(__pyx_v_e);
  __Pyx_XDECREF(__pyx_v_min_value);
  __Pyx_XDECREF(__pyx_v_allowed_dims);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":660
 *     return weights_array
 * 
 * def is_normalized(arr, method='sum'):             # <<<<<<<<<<<<<<
 *     """
 *     Checks if the provided array is normalized according to the specified method.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_17is_normalized(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_16is_normalized[] = "\n    Checks if the provided array is normalized according to the specified method.\n\n    Parameters:\n    ----------\n    arr : array-like\n        The array to check for normalization.\n    method : str, optional\n        The method of normalization to check against:\n        - '01': Checks if values are between 0 and 1 and if min is 0 and max is 1.\n        - 'zscore': Checks if the mean is 0 and the standard deviation is 1.\n        - 'sum': Checks if the sum of the array elements is 1.\n        Default is 'sum'.\n\n    Returns:\n    -------\n    bool\n        Returns True if the array is normalized according to the specified method,\n        False otherwise.\n\n    Examples:\n    --------\n    >>> arr = np.array([0.25, 0.25, 0.25, 0.25])\n    >>> is_normalized(arr, method='sum')\n    True\n\n    >>> arr = np.array([0, 0.5, 1])\n    >>> is_normalized(arr, method='01')\n    True\n\n    >>> arr = np.array([1, -1, 1, -1])\n    >>> is_normalized(arr, method='zscore')\n    True\n    ";
static PyMethodDef __pyx_mdef_9validator_17is_normalized = {"is_normalized", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_17is_normalized, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_16is_normalized};
static PyObject *__pyx_pw_9validator_17is_normalized(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_arr = 0;
  PyObject *__pyx_v_method = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("is_normalized (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_arr,&__pyx_n_s_method,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_n_u_sum);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arr)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_method);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "is_normalized") < 0)) __PYX_ERR(0, 660, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_arr = values[0];
    __pyx_v_method = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("is_normalized", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 660, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.is_normalized", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_16is_normalized(__pyx_self, __pyx_v_arr, __pyx_v_method);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_16is_normalized(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_arr, PyObject *__pyx_v_method) {
  PyObject *__pyx_v_mean = NULL;
  PyObject *__pyx_v_std = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_t_8;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("is_normalized", 0);
  __Pyx_INCREF(__pyx_v_arr);
  __Pyx_INCREF(__pyx_v_method);

  /* "validator.pyx":695
 *     True
 *     """
 *     arr = np.asarray(arr, dtype=float)             # <<<<<<<<<<<<<<
 *     method =parameter_validator(
 *         "method", target_strs={"01", "zscore", "sum"}) ( method)
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 695, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_asarray); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 695, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 695, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_v_arr);
  __Pyx_GIVEREF(__pyx_v_arr);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_arr);
  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 695, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 695, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 695, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF_SET(__pyx_v_arr, __pyx_t_4);
  __pyx_t_4 = 0;

  /* "validator.pyx":696
 *     """
 *     arr = np.asarray(arr, dtype=float)
 *     method =parameter_validator(             # <<<<<<<<<<<<<<
 *         "method", target_strs={"01", "zscore", "sum"}) ( method)
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_parameter_validator); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 696, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);

  /* "validator.pyx":697
 *     arr = np.asarray(arr, dtype=float)
 *     method =parameter_validator(
 *         "method", target_strs={"01", "zscore", "sum"}) ( method)             # <<<<<<<<<<<<<<
 * 
 *     if method == '01':
 */
  __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 697, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PySet_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 697, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PySet_Add(__pyx_t_2, __pyx_kp_u_01) < 0) __PYX_ERR(0, 697, __pyx_L1_error)
  if (PySet_Add(__pyx_t_2, __pyx_n_u_zscore) < 0) __PYX_ERR(0, 697, __pyx_L1_error)
  if (PySet_Add(__pyx_t_2, __pyx_n_u_sum) < 0) __PYX_ERR(0, 697, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_target_strs, __pyx_t_2) < 0) __PYX_ERR(0, 697, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":696
 *     """
 *     arr = np.asarray(arr, dtype=float)
 *     method =parameter_validator(             # <<<<<<<<<<<<<<
 *         "method", target_strs={"01", "zscore", "sum"}) ( method)
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__20, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 696, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":697
 *     arr = np.asarray(arr, dtype=float)
 *     method =parameter_validator(
 *         "method", target_strs={"01", "zscore", "sum"}) ( method)             # <<<<<<<<<<<<<<
 * 
 *     if method == '01':
 */
  __pyx_t_1 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_1)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_1);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_4 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_1, __pyx_v_method) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_method);
  __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 697, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF_SET(__pyx_v_method, __pyx_t_4);
  __pyx_t_4 = 0;

  /* "validator.pyx":699
 *         "method", target_strs={"01", "zscore", "sum"}) ( method)
 * 
 *     if method == '01':             # <<<<<<<<<<<<<<
 *         # Check if all elements are within [0, 1] and max is 1, min is 0
 *         return np.all((arr >= 0) & (arr <= 1)) and np.isclose(
 */
  __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_method, __pyx_kp_u_01, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 699, __pyx_L1_error)
  if (__pyx_t_5) {

    /* "validator.pyx":701
 *     if method == '01':
 *         # Check if all elements are within [0, 1] and max is 1, min is 0
 *         return np.all((arr >= 0) & (arr <= 1)) and np.isclose(             # <<<<<<<<<<<<<<
 *             np.min(arr), 0) and np.isclose(np.max(arr), 1)
 *     elif method == 'zscore':
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 701, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_all); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 701, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = PyObject_RichCompare(__pyx_v_arr, __pyx_int_0, Py_GE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 701, __pyx_L1_error)
    __pyx_t_6 = PyObject_RichCompare(__pyx_v_arr, __pyx_int_1, Py_LE); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 701, __pyx_L1_error)
    __pyx_t_7 = PyNumber_And(__pyx_t_1, __pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 701, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_6, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_7);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 701, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 701, __pyx_L1_error)
    if (__pyx_t_5) {
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    } else {
      __Pyx_INCREF(__pyx_t_2);
      __pyx_t_4 = __pyx_t_2;
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      goto __pyx_L4_bool_binop_done;
    }

    /* "validator.pyx":702
 *         # Check if all elements are within [0, 1] and max is 1, min is 0
 *         return np.all((arr >= 0) & (arr <= 1)) and np.isclose(
 *             np.min(arr), 0) and np.isclose(np.max(arr), 1)             # <<<<<<<<<<<<<<
 *     elif method == 'zscore':
 *         # Check if mean is approximately 0 and std is approximately 1
 */
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 701, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);

    /* "validator.pyx":701
 *     if method == '01':
 *         # Check if all elements are within [0, 1] and max is 1, min is 0
 *         return np.all((arr >= 0) & (arr <= 1)) and np.isclose(             # <<<<<<<<<<<<<<
 *             np.min(arr), 0) and np.isclose(np.max(arr), 1)
 *     elif method == 'zscore':
 */
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_isclose); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 701, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "validator.pyx":702
 *         # Check if all elements are within [0, 1] and max is 1, min is 0
 *         return np.all((arr >= 0) & (arr <= 1)) and np.isclose(
 *             np.min(arr), 0) and np.isclose(np.max(arr), 1)             # <<<<<<<<<<<<<<
 *     elif method == 'zscore':
 *         # Check if mean is approximately 0 and std is approximately 1
 */
    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 702, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_min); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 702, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    __pyx_t_3 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_6, __pyx_v_arr) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_arr);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 702, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = NULL;
    __pyx_t_8 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_7);
      if (likely(__pyx_t_1)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_7, function);
        __pyx_t_8 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_7)) {
      PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_t_3, __pyx_int_0};
      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 701, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_7)) {
      PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_t_3, __pyx_int_0};
      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 701, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else
    #endif
    {
      __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 701, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      if (__pyx_t_1) {
        __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_1); __pyx_t_1 = NULL;
      }
      __Pyx_GIVEREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_8, __pyx_t_3);
      __Pyx_INCREF(__pyx_int_0);
      __Pyx_GIVEREF(__pyx_int_0);
      PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_8, __pyx_int_0);
      __pyx_t_3 = 0;
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 701, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    }
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 701, __pyx_L1_error)
    if (__pyx_t_5) {
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    } else {
      __Pyx_INCREF(__pyx_t_2);
      __pyx_t_4 = __pyx_t_2;
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      goto __pyx_L4_bool_binop_done;
    }
    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 702, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_isclose); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 702, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 702, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_max); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 702, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    __pyx_t_7 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_3, __pyx_v_arr) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_arr);
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 702, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = NULL;
    __pyx_t_8 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_6);
      if (likely(__pyx_t_1)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_6, function);
        __pyx_t_8 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_6)) {
      PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_t_7, __pyx_int_1};
      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 702, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
      PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_t_7, __pyx_int_1};
      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 702, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    } else
    #endif
    {
      __pyx_t_3 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 702, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      if (__pyx_t_1) {
        __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1); __pyx_t_1 = NULL;
      }
      __Pyx_GIVEREF(__pyx_t_7);
      PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_8, __pyx_t_7);
      __Pyx_INCREF(__pyx_int_1);
      __Pyx_GIVEREF(__pyx_int_1);
      PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_8, __pyx_int_1);
      __pyx_t_7 = 0;
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 702, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    }
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_INCREF(__pyx_t_2);
    __pyx_t_4 = __pyx_t_2;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_L4_bool_binop_done:;
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "validator.pyx":699
 *         "method", target_strs={"01", "zscore", "sum"}) ( method)
 * 
 *     if method == '01':             # <<<<<<<<<<<<<<
 *         # Check if all elements are within [0, 1] and max is 1, min is 0
 *         return np.all((arr >= 0) & (arr <= 1)) and np.isclose(
 */
  }

  /* "validator.pyx":703
 *         return np.all((arr >= 0) & (arr <= 1)) and np.isclose(
 *             np.min(arr), 0) and np.isclose(np.max(arr), 1)
 *     elif method == 'zscore':             # <<<<<<<<<<<<<<
 *         # Check if mean is approximately 0 and std is approximately 1
 *         mean = np.mean(arr)
 */
  __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_method, __pyx_n_u_zscore, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 703, __pyx_L1_error)
  if (__pyx_t_5) {

    /* "validator.pyx":705
 *     elif method == 'zscore':
 *         # Check if mean is approximately 0 and std is approximately 1
 *         mean = np.mean(arr)             # <<<<<<<<<<<<<<
 *         std = np.std(arr)
 *         return np.isclose(mean, 0) and np.isclose(std, 1)
 */
    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 705, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_mean); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 705, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_6);
      if (likely(__pyx_t_2)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
        __Pyx_INCREF(__pyx_t_2);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_6, function);
      }
    }
    __pyx_t_4 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_2, __pyx_v_arr) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_arr);
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 705, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_v_mean = __pyx_t_4;
    __pyx_t_4 = 0;

    /* "validator.pyx":706
 *         # Check if mean is approximately 0 and std is approximately 1
 *         mean = np.mean(arr)
 *         std = np.std(arr)             # <<<<<<<<<<<<<<
 *         return np.isclose(mean, 0) and np.isclose(std, 1)
 *     elif method == 'sum':
 */
    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 706, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_std); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 706, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    __pyx_t_4 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_6, __pyx_v_arr) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_arr);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 706, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_v_std = __pyx_t_4;
    __pyx_t_4 = 0;

    /* "validator.pyx":707
 *         mean = np.mean(arr)
 *         std = np.std(arr)
 *         return np.isclose(mean, 0) and np.isclose(std, 1)             # <<<<<<<<<<<<<<
 *     elif method == 'sum':
 *         # Check if the sum of the elements is approximately 1
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 707, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_isclose); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 707, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    __pyx_t_8 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
        __pyx_t_8 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_mean, __pyx_int_0};
      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 707, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_GOTREF(__pyx_t_2);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
      PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_mean, __pyx_int_0};
      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 707, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_GOTREF(__pyx_t_2);
    } else
    #endif
    {
      __pyx_t_7 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 707, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      if (__pyx_t_6) {
        __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_6); __pyx_t_6 = NULL;
      }
      __Pyx_INCREF(__pyx_v_mean);
      __Pyx_GIVEREF(__pyx_v_mean);
      PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_8, __pyx_v_mean);
      __Pyx_INCREF(__pyx_int_0);
      __Pyx_GIVEREF(__pyx_int_0);
      PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_8, __pyx_int_0);
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_7, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 707, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 707, __pyx_L1_error)
    if (__pyx_t_5) {
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    } else {
      __Pyx_INCREF(__pyx_t_2);
      __pyx_t_4 = __pyx_t_2;
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      goto __pyx_L7_bool_binop_done;
    }
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 707, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_isclose); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 707, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = NULL;
    __pyx_t_8 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_7);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_7, function);
        __pyx_t_8 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_7)) {
      PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_std, __pyx_int_1};
      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 707, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_2);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_7)) {
      PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_std, __pyx_int_1};
      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 707, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_2);
    } else
    #endif
    {
      __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 707, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      if (__pyx_t_3) {
        __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3); __pyx_t_3 = NULL;
      }
      __Pyx_INCREF(__pyx_v_std);
      __Pyx_GIVEREF(__pyx_v_std);
      PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_8, __pyx_v_std);
      __Pyx_INCREF(__pyx_int_1);
      __Pyx_GIVEREF(__pyx_int_1);
      PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_8, __pyx_int_1);
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 707, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    }
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_INCREF(__pyx_t_2);
    __pyx_t_4 = __pyx_t_2;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_L7_bool_binop_done:;
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "validator.pyx":703
 *         return np.all((arr >= 0) & (arr <= 1)) and np.isclose(
 *             np.min(arr), 0) and np.isclose(np.max(arr), 1)
 *     elif method == 'zscore':             # <<<<<<<<<<<<<<
 *         # Check if mean is approximately 0 and std is approximately 1
 *         mean = np.mean(arr)
 */
  }

  /* "validator.pyx":708
 *         std = np.std(arr)
 *         return np.isclose(mean, 0) and np.isclose(std, 1)
 *     elif method == 'sum':             # <<<<<<<<<<<<<<
 *         # Check if the sum of the elements is approximately 1
 *         return np.isclose(np.sum(arr), 1)
 */
  __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_method, __pyx_n_u_sum, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 708, __pyx_L1_error)
  if (__pyx_t_5) {

    /* "validator.pyx":710
 *     elif method == 'sum':
 *         # Check if the sum of the elements is approximately 1
 *         return np.isclose(np.sum(arr), 1)             # <<<<<<<<<<<<<<
 * 
 * def normalize_array(arr, normalize="auto", method='01'):
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 710, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_isclose); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 710, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 710, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_sum); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 710, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_6, __pyx_v_arr) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_arr);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 710, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = NULL;
    __pyx_t_8 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_7);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_7, function);
        __pyx_t_8 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_7)) {
      PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_t_2, __pyx_int_1};
      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 710, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_7)) {
      PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_t_2, __pyx_int_1};
      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 710, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    } else
    #endif
    {
      __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 710, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      if (__pyx_t_3) {
        __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_3); __pyx_t_3 = NULL;
      }
      __Pyx_GIVEREF(__pyx_t_2);
      PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_8, __pyx_t_2);
      __Pyx_INCREF(__pyx_int_1);
      __Pyx_GIVEREF(__pyx_int_1);
      PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_8, __pyx_int_1);
      __pyx_t_2 = 0;
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_6, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 710, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    }
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "validator.pyx":708
 *         std = np.std(arr)
 *         return np.isclose(mean, 0) and np.isclose(std, 1)
 *     elif method == 'sum':             # <<<<<<<<<<<<<<
 *         # Check if the sum of the elements is approximately 1
 *         return np.isclose(np.sum(arr), 1)
 */
  }

  /* "validator.pyx":660
 *     return weights_array
 * 
 * def is_normalized(arr, method='sum'):             # <<<<<<<<<<<<<<
 *     """
 *     Checks if the provided array is normalized according to the specified method.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("validator.is_normalized", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_mean);
  __Pyx_XDECREF(__pyx_v_std);
  __Pyx_XDECREF(__pyx_v_arr);
  __Pyx_XDECREF(__pyx_v_method);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":712
 *         return np.isclose(np.sum(arr), 1)
 * 
 * def normalize_array(arr, normalize="auto", method='01'):             # <<<<<<<<<<<<<<
 *     """
 *     Checks if an array is normalized according to the specified method and
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_19normalize_array(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_18normalize_array[] = "\n    Checks if an array is normalized according to the specified method and \n    normalizes it if required based on the 'normalize' parameter.\n\n    Parameters:\n    ----------\n    arr : array-like\n        The input array to check and potentially normalize.\n\n    normalize : str, optional\n        Determines whether to normalize the array:\n        - 'auto': Normalize only if the array is not already normalized \n          according to the specified method.\n        - True: Always normalize the array regardless of its current state.\n        - False: Do not normalize the array, return as is.\n        Default is 'auto'.\n\n    method : str, optional\n        The normalization method to apply:\n        - '01': Normalize the array to have values between 0 and 1.\n        - 'zscore': Standardize the array to have a mean of 0 and a standard\n          deviation of 1.\n        - 'sum': Normalize the array so that the sum of its elements equals 1.\n        Default is '01'.\n\n    Returns:\n    -------\n    np.ndarray\n        The normalized array, or the original array if no normalization was applied.\n\n    Raises:\n    ------\n    ValueError\n        If an unknown normalization method is specified or if normalization \n        cannot be performed due to data characteristics (e.g., zero variance).\n        \n    Examples:\n    --------\n    >>> import numpy as np \n    >>> from gofast.tools.validator import normalize_array \n\n    >>> data = np.array([1, 2, 3, 4, 5])\n    >>> normalized_data = normalize_array(data, normalize=True, method='01')\n    >>> print(\"Normalized between 0 and 1:\", normalized_data)\n    Normalized between 0 and 1: [0.   0.25 0.5  0.75 1.  ]\n    \n    >>> zscore_data = normalize_array(data, normalize=True, method='zscore')\n    >>> print(\"Standardized (Z-score):\", zscore_data)\n    Standardized (Z-score): [-1.41421356 -0.70710678  0.          0.70710678  1.41421356]\n    \n    >>> sum_data = normalize_array(data, normalize=True, method='s""um')\n    >>> print(\"Normalized by sum:\", sum_data)\n    Normalized by sum: [0.06666667 0.13333333 0.2        0.26666667 0.33333333]\n    ";
static PyMethodDef __pyx_mdef_9validator_19normalize_array = {"normalize_array", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_19normalize_array, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_18normalize_array};
static PyObject *__pyx_pw_9validator_19normalize_array(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_arr = 0;
  PyObject *__pyx_v_normalize = 0;
  PyObject *__pyx_v_method = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("normalize_array (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_arr,&__pyx_n_s_normalize,&__pyx_n_s_method,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)__pyx_n_u_auto);
    values[2] = ((PyObject *)__pyx_kp_u_01);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arr)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_normalize);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_method);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "normalize_array") < 0)) __PYX_ERR(0, 712, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_arr = values[0];
    __pyx_v_normalize = values[1];
    __pyx_v_method = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("normalize_array", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 712, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.normalize_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_18normalize_array(__pyx_self, __pyx_v_arr, __pyx_v_normalize, __pyx_v_method);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_18normalize_array(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_arr, PyObject *__pyx_v_normalize, PyObject *__pyx_v_method) {
  PyObject *__pyx_v_is_normed = NULL;
  PyObject *__pyx_v_min_val = NULL;
  PyObject *__pyx_v_max_val = NULL;
  PyObject *__pyx_v_mean = NULL;
  PyObject *__pyx_v_std = NULL;
  PyObject *__pyx_v_total = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("normalize_array", 0);
  __Pyx_INCREF(__pyx_v_arr);
  __Pyx_INCREF(__pyx_v_normalize);

  /* "validator.pyx":767
 *     Normalized by sum: [0.06666667 0.13333333 0.2        0.26666667 0.33333333]
 *     """
 *     arr = np.asarray(arr, dtype=float)             # <<<<<<<<<<<<<<
 *     is_normed = is_normalized(arr, method=method)
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 767, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_asarray); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 767, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 767, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_v_arr);
  __Pyx_GIVEREF(__pyx_v_arr);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_arr);
  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 767, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 767, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 767, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF_SET(__pyx_v_arr, __pyx_t_4);
  __pyx_t_4 = 0;

  /* "validator.pyx":768
 *     """
 *     arr = np.asarray(arr, dtype=float)
 *     is_normed = is_normalized(arr, method=method)             # <<<<<<<<<<<<<<
 * 
 *     normalize = parameter_validator(
 */
  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_is_normalized); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 768, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 768, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_v_arr);
  __Pyx_GIVEREF(__pyx_v_arr);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_arr);
  __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 768, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_method, __pyx_v_method) < 0) __PYX_ERR(0, 768, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_3, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 768, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_is_normed = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "validator.pyx":770
 *     is_normed = is_normalized(arr, method=method)
 * 
 *     normalize = parameter_validator(             # <<<<<<<<<<<<<<
 *         "normalize", target_strs={True, False, "auto"})( normalize)
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_parameter_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 770, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);

  /* "validator.pyx":771
 * 
 *     normalize = parameter_validator(
 *         "normalize", target_strs={True, False, "auto"})( normalize)             # <<<<<<<<<<<<<<
 * 
 *     if normalize == 'auto':
 */
  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 771, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = PySet_New(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 771, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PySet_Add(__pyx_t_4, Py_True) < 0) __PYX_ERR(0, 771, __pyx_L1_error)
  if (PySet_Add(__pyx_t_4, Py_False) < 0) __PYX_ERR(0, 771, __pyx_L1_error)
  if (PySet_Add(__pyx_t_4, __pyx_n_u_auto) < 0) __PYX_ERR(0, 771, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_target_strs, __pyx_t_4) < 0) __PYX_ERR(0, 771, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "validator.pyx":770
 *     is_normed = is_normalized(arr, method=method)
 * 
 *     normalize = parameter_validator(             # <<<<<<<<<<<<<<
 *         "normalize", target_strs={True, False, "auto"})( normalize)
 * 
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__21, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 770, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "validator.pyx":771
 * 
 *     normalize = parameter_validator(
 *         "normalize", target_strs={True, False, "auto"})( normalize)             # <<<<<<<<<<<<<<
 * 
 *     if normalize == 'auto':
 */
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_3, __pyx_v_normalize) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_normalize);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 771, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF_SET(__pyx_v_normalize, __pyx_t_2);
  __pyx_t_2 = 0;

  /* "validator.pyx":773
 *         "normalize", target_strs={True, False, "auto"})( normalize)
 * 
 *     if normalize == 'auto':             # <<<<<<<<<<<<<<
 *         normalize = not is_normed
 * 
 */
  __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_normalize, __pyx_n_u_auto, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 773, __pyx_L1_error)
  if (__pyx_t_5) {

    /* "validator.pyx":774
 * 
 *     if normalize == 'auto':
 *         normalize = not is_normed             # <<<<<<<<<<<<<<
 * 
 *     if normalize:
 */
    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_v_is_normed); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 774, __pyx_L1_error)
    __pyx_t_2 = __Pyx_PyBool_FromLong((!__pyx_t_5)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 774, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF_SET(__pyx_v_normalize, __pyx_t_2);
    __pyx_t_2 = 0;

    /* "validator.pyx":773
 *         "normalize", target_strs={True, False, "auto"})( normalize)
 * 
 *     if normalize == 'auto':             # <<<<<<<<<<<<<<
 *         normalize = not is_normed
 * 
 */
  }

  /* "validator.pyx":776
 *         normalize = not is_normed
 * 
 *     if normalize:             # <<<<<<<<<<<<<<
 *         if method == '01':
 *             min_val = np.min(arr)
 */
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_v_normalize); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 776, __pyx_L1_error)
  if (__pyx_t_5) {

    /* "validator.pyx":777
 * 
 *     if normalize:
 *         if method == '01':             # <<<<<<<<<<<<<<
 *             min_val = np.min(arr)
 *             max_val = np.max(arr)
 */
    __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_method, __pyx_kp_u_01, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 777, __pyx_L1_error)
    if (__pyx_t_5) {

      /* "validator.pyx":778
 *     if normalize:
 *         if method == '01':
 *             min_val = np.min(arr)             # <<<<<<<<<<<<<<
 *             max_val = np.max(arr)
 *             if min_val == max_val:
 */
      __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 778, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_min); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 778, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_arr) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_arr);
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 778, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_v_min_val = __pyx_t_2;
      __pyx_t_2 = 0;

      /* "validator.pyx":779
 *         if method == '01':
 *             min_val = np.min(arr)
 *             max_val = np.max(arr)             # <<<<<<<<<<<<<<
 *             if min_val == max_val:
 *                 raise ValueError("Normalization impossible with zero variance.")
 */
      __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 779, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_max); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 779, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
        __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
        if (likely(__pyx_t_3)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
          __Pyx_INCREF(__pyx_t_3);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_4, function);
        }
      }
      __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_3, __pyx_v_arr) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_arr);
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 779, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_v_max_val = __pyx_t_2;
      __pyx_t_2 = 0;

      /* "validator.pyx":780
 *             min_val = np.min(arr)
 *             max_val = np.max(arr)
 *             if min_val == max_val:             # <<<<<<<<<<<<<<
 *                 raise ValueError("Normalization impossible with zero variance.")
 *             arr = (arr - min_val) / (max_val - min_val)
 */
      __pyx_t_2 = PyObject_RichCompare(__pyx_v_min_val, __pyx_v_max_val, Py_EQ); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 780, __pyx_L1_error)
      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 780, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      if (unlikely(__pyx_t_5)) {

        /* "validator.pyx":781
 *             max_val = np.max(arr)
 *             if min_val == max_val:
 *                 raise ValueError("Normalization impossible with zero variance.")             # <<<<<<<<<<<<<<
 *             arr = (arr - min_val) / (max_val - min_val)
 *         elif method == 'zscore':
 */
        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__22, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 781, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_Raise(__pyx_t_2, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __PYX_ERR(0, 781, __pyx_L1_error)

        /* "validator.pyx":780
 *             min_val = np.min(arr)
 *             max_val = np.max(arr)
 *             if min_val == max_val:             # <<<<<<<<<<<<<<
 *                 raise ValueError("Normalization impossible with zero variance.")
 *             arr = (arr - min_val) / (max_val - min_val)
 */
      }

      /* "validator.pyx":782
 *             if min_val == max_val:
 *                 raise ValueError("Normalization impossible with zero variance.")
 *             arr = (arr - min_val) / (max_val - min_val)             # <<<<<<<<<<<<<<
 *         elif method == 'zscore':
 *             mean = np.mean(arr)
 */
      __pyx_t_2 = PyNumber_Subtract(__pyx_v_arr, __pyx_v_min_val); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 782, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_4 = PyNumber_Subtract(__pyx_v_max_val, __pyx_v_min_val); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 782, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_3 = __Pyx_PyNumber_Divide(__pyx_t_2, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 782, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_DECREF_SET(__pyx_v_arr, __pyx_t_3);
      __pyx_t_3 = 0;

      /* "validator.pyx":777
 * 
 *     if normalize:
 *         if method == '01':             # <<<<<<<<<<<<<<
 *             min_val = np.min(arr)
 *             max_val = np.max(arr)
 */
      goto __pyx_L5;
    }

    /* "validator.pyx":783
 *                 raise ValueError("Normalization impossible with zero variance.")
 *             arr = (arr - min_val) / (max_val - min_val)
 *         elif method == 'zscore':             # <<<<<<<<<<<<<<
 *             mean = np.mean(arr)
 *             std = np.std(arr)
 */
    __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_method, __pyx_n_u_zscore, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 783, __pyx_L1_error)
    if (__pyx_t_5) {

      /* "validator.pyx":784
 *             arr = (arr - min_val) / (max_val - min_val)
 *         elif method == 'zscore':
 *             mean = np.mean(arr)             # <<<<<<<<<<<<<<
 *             std = np.std(arr)
 *             if std == 0:
 */
      __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 784, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_mean); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 784, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_2, function);
        }
      }
      __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_v_arr) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_arr);
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 784, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_v_mean = __pyx_t_3;
      __pyx_t_3 = 0;

      /* "validator.pyx":785
 *         elif method == 'zscore':
 *             mean = np.mean(arr)
 *             std = np.std(arr)             # <<<<<<<<<<<<<<
 *             if std == 0:
 *                 raise ValueError("Standardization impossible with zero variance.")
 */
      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 785, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_std); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 785, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_2 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
        __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_4);
        if (likely(__pyx_t_2)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
          __Pyx_INCREF(__pyx_t_2);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_4, function);
        }
      }
      __pyx_t_3 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_2, __pyx_v_arr) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_arr);
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 785, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_v_std = __pyx_t_3;
      __pyx_t_3 = 0;

      /* "validator.pyx":786
 *             mean = np.mean(arr)
 *             std = np.std(arr)
 *             if std == 0:             # <<<<<<<<<<<<<<
 *                 raise ValueError("Standardization impossible with zero variance.")
 *             arr = (arr - mean) / std
 */
      __pyx_t_3 = __Pyx_PyInt_EqObjC(__pyx_v_std, __pyx_int_0, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 786, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 786, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (unlikely(__pyx_t_5)) {

        /* "validator.pyx":787
 *             std = np.std(arr)
 *             if std == 0:
 *                 raise ValueError("Standardization impossible with zero variance.")             # <<<<<<<<<<<<<<
 *             arr = (arr - mean) / std
 *         elif method == 'sum':
 */
        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__23, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 787, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_Raise(__pyx_t_3, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __PYX_ERR(0, 787, __pyx_L1_error)

        /* "validator.pyx":786
 *             mean = np.mean(arr)
 *             std = np.std(arr)
 *             if std == 0:             # <<<<<<<<<<<<<<
 *                 raise ValueError("Standardization impossible with zero variance.")
 *             arr = (arr - mean) / std
 */
      }

      /* "validator.pyx":788
 *             if std == 0:
 *                 raise ValueError("Standardization impossible with zero variance.")
 *             arr = (arr - mean) / std             # <<<<<<<<<<<<<<
 *         elif method == 'sum':
 *             total = np.sum(arr)
 */
      __pyx_t_3 = PyNumber_Subtract(__pyx_v_arr, __pyx_v_mean); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 788, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = __Pyx_PyNumber_Divide(__pyx_t_3, __pyx_v_std); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 788, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF_SET(__pyx_v_arr, __pyx_t_4);
      __pyx_t_4 = 0;

      /* "validator.pyx":783
 *                 raise ValueError("Normalization impossible with zero variance.")
 *             arr = (arr - min_val) / (max_val - min_val)
 *         elif method == 'zscore':             # <<<<<<<<<<<<<<
 *             mean = np.mean(arr)
 *             std = np.std(arr)
 */
      goto __pyx_L5;
    }

    /* "validator.pyx":789
 *                 raise ValueError("Standardization impossible with zero variance.")
 *             arr = (arr - mean) / std
 *         elif method == 'sum':             # <<<<<<<<<<<<<<
 *             total = np.sum(arr)
 *             if total == 0:
 */
    __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_method, __pyx_n_u_sum, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 789, __pyx_L1_error)
    if (__pyx_t_5) {

      /* "validator.pyx":790
 *             arr = (arr - mean) / std
 *         elif method == 'sum':
 *             total = np.sum(arr)             # <<<<<<<<<<<<<<
 *             if total == 0:
 *                 raise ValueError("Normalization by sum impossible with zero sum.")
 */
      __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 790, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_sum); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 790, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
        __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
        if (likely(__pyx_t_3)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
          __Pyx_INCREF(__pyx_t_3);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_2, function);
        }
      }
      __pyx_t_4 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_arr) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_arr);
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 790, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_v_total = __pyx_t_4;
      __pyx_t_4 = 0;

      /* "validator.pyx":791
 *         elif method == 'sum':
 *             total = np.sum(arr)
 *             if total == 0:             # <<<<<<<<<<<<<<
 *                 raise ValueError("Normalization by sum impossible with zero sum.")
 *             arr = arr / total
 */
      __pyx_t_4 = __Pyx_PyInt_EqObjC(__pyx_v_total, __pyx_int_0, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 791, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 791, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      if (unlikely(__pyx_t_5)) {

        /* "validator.pyx":792
 *             total = np.sum(arr)
 *             if total == 0:
 *                 raise ValueError("Normalization by sum impossible with zero sum.")             # <<<<<<<<<<<<<<
 *             arr = arr / total
 * 
 */
        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 792, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_Raise(__pyx_t_4, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __PYX_ERR(0, 792, __pyx_L1_error)

        /* "validator.pyx":791
 *         elif method == 'sum':
 *             total = np.sum(arr)
 *             if total == 0:             # <<<<<<<<<<<<<<
 *                 raise ValueError("Normalization by sum impossible with zero sum.")
 *             arr = arr / total
 */
      }

      /* "validator.pyx":793
 *             if total == 0:
 *                 raise ValueError("Normalization by sum impossible with zero sum.")
 *             arr = arr / total             # <<<<<<<<<<<<<<
 * 
 *     # If normalization is not required, return the original array
 */
      __pyx_t_4 = __Pyx_PyNumber_Divide(__pyx_v_arr, __pyx_v_total); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 793, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF_SET(__pyx_v_arr, __pyx_t_4);
      __pyx_t_4 = 0;

      /* "validator.pyx":789
 *                 raise ValueError("Standardization impossible with zero variance.")
 *             arr = (arr - mean) / std
 *         elif method == 'sum':             # <<<<<<<<<<<<<<
 *             total = np.sum(arr)
 *             if total == 0:
 */
    }
    __pyx_L5:;

    /* "validator.pyx":776
 *         normalize = not is_normed
 * 
 *     if normalize:             # <<<<<<<<<<<<<<
 *         if method == '01':
 *             min_val = np.min(arr)
 */
  }

  /* "validator.pyx":796
 * 
 *     # If normalization is not required, return the original array
 *     return arr             # <<<<<<<<<<<<<<
 * 
 * def is_binary_class(y, accept_multioutput=False):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_arr);
  __pyx_r = __pyx_v_arr;
  goto __pyx_L0;

  /* "validator.pyx":712
 *         return np.isclose(np.sum(arr), 1)
 * 
 * def normalize_array(arr, normalize="auto", method='01'):             # <<<<<<<<<<<<<<
 *     """
 *     Checks if an array is normalized according to the specified method and
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("validator.normalize_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_is_normed);
  __Pyx_XDECREF(__pyx_v_min_val);
  __Pyx_XDECREF(__pyx_v_max_val);
  __Pyx_XDECREF(__pyx_v_mean);
  __Pyx_XDECREF(__pyx_v_std);
  __Pyx_XDECREF(__pyx_v_total);
  __Pyx_XDECREF(__pyx_v_arr);
  __Pyx_XDECREF(__pyx_v_normalize);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":798
 *     return arr
 * 
 * def is_binary_class(y, accept_multioutput=False):             # <<<<<<<<<<<<<<
 *     """
 *     Check whether the target array represents binary classification. Optionally,
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_21is_binary_class(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_20is_binary_class[] = "\n    Check whether the target array represents binary classification. Optionally,\n    handle multi-output arrays if each output is binary.\n\n    Parameters:\n    ----------\n    y : array-like\n        The target array to be checked. This can be a 1D array for single output\n        or a 2D array for multiple outputs if `accept_multioutput` is True.\n    accept_multioutput : bool, default False\n        If True, the function checks if each column in a multi-dimensional array\n        is binary. If False, the function checks if the entire array is binary.\n\n    Returns:\n    -------\n    bool\n        Returns True if `y` is binary (or each output is binary if multi-output\n        is accepted), False otherwise.\n\n    Examples:\n    --------\n    >>> from gofast.tools.validator import is_binary_class \n    >>> is_binary_class([0, 1, 1, 0])\n    True\n    >>> is_binary_class([[0, 1], [1, 0], [0, 1], [1, 0]], accept_multioutput=True)\n    True\n    >>> is_binary_class([0, 1, 2, 3])\n    False\n    ";
static PyMethodDef __pyx_mdef_9validator_21is_binary_class = {"is_binary_class", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_21is_binary_class, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_20is_binary_class};
static PyObject *__pyx_pw_9validator_21is_binary_class(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_y = 0;
  PyObject *__pyx_v_accept_multioutput = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("is_binary_class (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_y,&__pyx_n_s_accept_multioutput,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_accept_multioutput);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "is_binary_class") < 0)) __PYX_ERR(0, 798, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_y = values[0];
    __pyx_v_accept_multioutput = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("is_binary_class", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 798, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.is_binary_class", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_20is_binary_class(__pyx_self, __pyx_v_y, __pyx_v_accept_multioutput);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_20is_binary_class(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y, PyObject *__pyx_v_accept_multioutput) {
  PyObject *__pyx_v_unique_values = NULL;
  PyObject *__pyx_v_column = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  Py_ssize_t __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  int __pyx_t_11;
  PyObject *__pyx_t_12 = NULL;
  PyObject *(*__pyx_t_13)(PyObject *);
  Py_ssize_t __pyx_t_14;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("is_binary_class", 0);
  __Pyx_INCREF(__pyx_v_y);

  /* "validator.pyx":828
 *     False
 *     """
 *     y = np.asarray(y)             # <<<<<<<<<<<<<<
 *     y = check_y( y, multi_output= True, y_numeric =True )
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 828, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_asarray); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 828, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_v_y) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_y);
  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 828, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF_SET(__pyx_v_y, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":829
 *     """
 *     y = np.asarray(y)
 *     y = check_y( y, multi_output= True, y_numeric =True )             # <<<<<<<<<<<<<<
 * 
 *     if not accept_multioutput:
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_check_y); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 829, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 829, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_v_y);
  __Pyx_GIVEREF(__pyx_v_y);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_y);
  __pyx_t_2 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 829, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_multi_output, Py_True) < 0) __PYX_ERR(0, 829, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_y_numeric, Py_True) < 0) __PYX_ERR(0, 829, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 829, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF_SET(__pyx_v_y, __pyx_t_4);
  __pyx_t_4 = 0;

  /* "validator.pyx":831
 *     y = check_y( y, multi_output= True, y_numeric =True )
 * 
 *     if not accept_multioutput:             # <<<<<<<<<<<<<<
 *         # Check if the entire array is binary
 *         unique_values = np.unique(y)
 */
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_v_accept_multioutput); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 831, __pyx_L1_error)
  __pyx_t_6 = ((!__pyx_t_5) != 0);
  if (__pyx_t_6) {

    /* "validator.pyx":833
 *     if not accept_multioutput:
 *         # Check if the entire array is binary
 *         unique_values = np.unique(y)             # <<<<<<<<<<<<<<
 *         return len(unique_values) == 2 and np.all(np.isin(unique_values, [0, 1]))
 * 
 */
    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 833, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_unique); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 833, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_2)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_2);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    __pyx_t_4 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_v_y) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_y);
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 833, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_v_unique_values = __pyx_t_4;
    __pyx_t_4 = 0;

    /* "validator.pyx":834
 *         # Check if the entire array is binary
 *         unique_values = np.unique(y)
 *         return len(unique_values) == 2 and np.all(np.isin(unique_values, [0, 1]))             # <<<<<<<<<<<<<<
 * 
 *     if y.ndim == 1:
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_7 = PyObject_Length(__pyx_v_unique_values); if (unlikely(__pyx_t_7 == ((Py_ssize_t)-1))) __PYX_ERR(0, 834, __pyx_L1_error)
    __pyx_t_6 = (__pyx_t_7 == 2);
    if (__pyx_t_6) {
    } else {
      __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 834, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = __pyx_t_3;
      __pyx_t_3 = 0;
      goto __pyx_L4_bool_binop_done;
    }
    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 834, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_all); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 834, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_np); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 834, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_isin); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 834, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_8 = PyList_New(2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 834, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_INCREF(__pyx_int_0);
    __Pyx_GIVEREF(__pyx_int_0);
    PyList_SET_ITEM(__pyx_t_8, 0, __pyx_int_0);
    __Pyx_INCREF(__pyx_int_1);
    __Pyx_GIVEREF(__pyx_int_1);
    PyList_SET_ITEM(__pyx_t_8, 1, __pyx_int_1);
    __pyx_t_10 = NULL;
    __pyx_t_11 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_9))) {
      __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_9);
      if (likely(__pyx_t_10)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
        __Pyx_INCREF(__pyx_t_10);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_9, function);
        __pyx_t_11 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_9)) {
      PyObject *__pyx_temp[3] = {__pyx_t_10, __pyx_v_unique_values, __pyx_t_8};
      __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_9, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 834, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_9)) {
      PyObject *__pyx_temp[3] = {__pyx_t_10, __pyx_v_unique_values, __pyx_t_8};
      __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_9, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 834, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    } else
    #endif
    {
      __pyx_t_12 = PyTuple_New(2+__pyx_t_11); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 834, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_12);
      if (__pyx_t_10) {
        __Pyx_GIVEREF(__pyx_t_10); PyTuple_SET_ITEM(__pyx_t_12, 0, __pyx_t_10); __pyx_t_10 = NULL;
      }
      __Pyx_INCREF(__pyx_v_unique_values);
      __Pyx_GIVEREF(__pyx_v_unique_values);
      PyTuple_SET_ITEM(__pyx_t_12, 0+__pyx_t_11, __pyx_v_unique_values);
      __Pyx_GIVEREF(__pyx_t_8);
      PyTuple_SET_ITEM(__pyx_t_12, 1+__pyx_t_11, __pyx_t_8);
      __pyx_t_8 = 0;
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_9, __pyx_t_12, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 834, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
    }
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_t_9 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_9)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_9);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    __pyx_t_3 = (__pyx_t_9) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_9, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_2);
    __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 834, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_INCREF(__pyx_t_3);
    __pyx_t_4 = __pyx_t_3;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_L4_bool_binop_done:;
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "validator.pyx":831
 *     y = check_y( y, multi_output= True, y_numeric =True )
 * 
 *     if not accept_multioutput:             # <<<<<<<<<<<<<<
 *         # Check if the entire array is binary
 *         unique_values = np.unique(y)
 */
  }

  /* "validator.pyx":836
 *         return len(unique_values) == 2 and np.all(np.isin(unique_values, [0, 1]))
 * 
 *     if y.ndim == 1:             # <<<<<<<<<<<<<<
 *         # If the array is 1D and multioutput is expected, treat it as a single column
 *         y = y.reshape(-1, 1)
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_y, __pyx_n_s_ndim); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 836, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = __Pyx_PyInt_EqObjC(__pyx_t_4, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 836, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 836, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_6) {

    /* "validator.pyx":838
 *     if y.ndim == 1:
 *         # If the array is 1D and multioutput is expected, treat it as a single column
 *         y = y.reshape(-1, 1)             # <<<<<<<<<<<<<<
 * 
 *     if y.ndim > 1:
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_y, __pyx_n_s_reshape); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 838, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 838, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF_SET(__pyx_v_y, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "validator.pyx":836
 *         return len(unique_values) == 2 and np.all(np.isin(unique_values, [0, 1]))
 * 
 *     if y.ndim == 1:             # <<<<<<<<<<<<<<
 *         # If the array is 1D and multioutput is expected, treat it as a single column
 *         y = y.reshape(-1, 1)
 */
  }

  /* "validator.pyx":840
 *         y = y.reshape(-1, 1)
 * 
 *     if y.ndim > 1:             # <<<<<<<<<<<<<<
 *         # Check each column independently
 *         for column in y.T:
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_y, __pyx_n_s_ndim); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 840, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = PyObject_RichCompare(__pyx_t_4, __pyx_int_1, Py_GT); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 840, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 840, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_6) {

    /* "validator.pyx":842
 *     if y.ndim > 1:
 *         # Check each column independently
 *         for column in y.T:             # <<<<<<<<<<<<<<
 *             unique_values = np.unique(column)
 *             if not (len(unique_values) == 2 and np.all(np.isin(unique_values, [0, 1]))):
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_y, __pyx_n_s_T); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 842, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    if (likely(PyList_CheckExact(__pyx_t_3)) || PyTuple_CheckExact(__pyx_t_3)) {
      __pyx_t_4 = __pyx_t_3; __Pyx_INCREF(__pyx_t_4); __pyx_t_7 = 0;
      __pyx_t_13 = NULL;
    } else {
      __pyx_t_7 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 842, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_13 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 842, __pyx_L1_error)
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    for (;;) {
      if (likely(!__pyx_t_13)) {
        if (likely(PyList_CheckExact(__pyx_t_4))) {
          if (__pyx_t_7 >= PyList_GET_SIZE(__pyx_t_4)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_3 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_7); __Pyx_INCREF(__pyx_t_3); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 842, __pyx_L1_error)
          #else
          __pyx_t_3 = PySequence_ITEM(__pyx_t_4, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 842, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_3);
          #endif
        } else {
          if (__pyx_t_7 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_7); __Pyx_INCREF(__pyx_t_3); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 842, __pyx_L1_error)
          #else
          __pyx_t_3 = PySequence_ITEM(__pyx_t_4, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 842, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_3);
          #endif
        }
      } else {
        __pyx_t_3 = __pyx_t_13(__pyx_t_4);
        if (unlikely(!__pyx_t_3)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else __PYX_ERR(0, 842, __pyx_L1_error)
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_3);
      }
      __Pyx_XDECREF_SET(__pyx_v_column, __pyx_t_3);
      __pyx_t_3 = 0;

      /* "validator.pyx":843
 *         # Check each column independently
 *         for column in y.T:
 *             unique_values = np.unique(column)             # <<<<<<<<<<<<<<
 *             if not (len(unique_values) == 2 and np.all(np.isin(unique_values, [0, 1]))):
 *                 return False
 */
      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 843, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_unique); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 843, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_1 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
        __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
        if (likely(__pyx_t_1)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
          __Pyx_INCREF(__pyx_t_1);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_2, function);
        }
      }
      __pyx_t_3 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_1, __pyx_v_column) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_column);
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 843, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF_SET(__pyx_v_unique_values, __pyx_t_3);
      __pyx_t_3 = 0;

      /* "validator.pyx":844
 *         for column in y.T:
 *             unique_values = np.unique(column)
 *             if not (len(unique_values) == 2 and np.all(np.isin(unique_values, [0, 1]))):             # <<<<<<<<<<<<<<
 *                 return False
 *         return True
 */
      __pyx_t_14 = PyObject_Length(__pyx_v_unique_values); if (unlikely(__pyx_t_14 == ((Py_ssize_t)-1))) __PYX_ERR(0, 844, __pyx_L1_error)
      __pyx_t_5 = ((__pyx_t_14 == 2) != 0);
      if (__pyx_t_5) {
      } else {
        __pyx_t_6 = __pyx_t_5;
        goto __pyx_L11_bool_binop_done;
      }
      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 844, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_all); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 844, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GetModuleGlobalName(__pyx_t_9, __pyx_n_s_np); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 844, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      __pyx_t_12 = __Pyx_PyObject_GetAttrStr(__pyx_t_9, __pyx_n_s_isin); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 844, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_12);
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      __pyx_t_9 = PyList_New(2); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 844, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      __Pyx_INCREF(__pyx_int_0);
      __Pyx_GIVEREF(__pyx_int_0);
      PyList_SET_ITEM(__pyx_t_9, 0, __pyx_int_0);
      __Pyx_INCREF(__pyx_int_1);
      __Pyx_GIVEREF(__pyx_int_1);
      PyList_SET_ITEM(__pyx_t_9, 1, __pyx_int_1);
      __pyx_t_8 = NULL;
      __pyx_t_11 = 0;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_12))) {
        __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_12);
        if (likely(__pyx_t_8)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_12);
          __Pyx_INCREF(__pyx_t_8);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_12, function);
          __pyx_t_11 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_12)) {
        PyObject *__pyx_temp[3] = {__pyx_t_8, __pyx_v_unique_values, __pyx_t_9};
        __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_12, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 844, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_12)) {
        PyObject *__pyx_temp[3] = {__pyx_t_8, __pyx_v_unique_values, __pyx_t_9};
        __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_12, __pyx_temp+1-__pyx_t_11, 2+__pyx_t_11); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 844, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      } else
      #endif
      {
        __pyx_t_10 = PyTuple_New(2+__pyx_t_11); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 844, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_10);
        if (__pyx_t_8) {
          __Pyx_GIVEREF(__pyx_t_8); PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_8); __pyx_t_8 = NULL;
        }
        __Pyx_INCREF(__pyx_v_unique_values);
        __Pyx_GIVEREF(__pyx_v_unique_values);
        PyTuple_SET_ITEM(__pyx_t_10, 0+__pyx_t_11, __pyx_v_unique_values);
        __Pyx_GIVEREF(__pyx_t_9);
        PyTuple_SET_ITEM(__pyx_t_10, 1+__pyx_t_11, __pyx_t_9);
        __pyx_t_9 = 0;
        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_12, __pyx_t_10, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 844, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
      }
      __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
      __pyx_t_12 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
        __pyx_t_12 = PyMethod_GET_SELF(__pyx_t_1);
        if (likely(__pyx_t_12)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
          __Pyx_INCREF(__pyx_t_12);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_1, function);
        }
      }
      __pyx_t_3 = (__pyx_t_12) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_12, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_2);
      __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 844, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 844, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = __pyx_t_5;
      __pyx_L11_bool_binop_done:;
      __pyx_t_5 = ((!__pyx_t_6) != 0);
      if (__pyx_t_5) {

        /* "validator.pyx":845
 *             unique_values = np.unique(column)
 *             if not (len(unique_values) == 2 and np.all(np.isin(unique_values, [0, 1]))):
 *                 return False             # <<<<<<<<<<<<<<
 *         return True
 * 
 */
        __Pyx_XDECREF(__pyx_r);
        __Pyx_INCREF(Py_False);
        __pyx_r = Py_False;
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        goto __pyx_L0;

        /* "validator.pyx":844
 *         for column in y.T:
 *             unique_values = np.unique(column)
 *             if not (len(unique_values) == 2 and np.all(np.isin(unique_values, [0, 1]))):             # <<<<<<<<<<<<<<
 *                 return False
 *         return True
 */
      }

      /* "validator.pyx":842
 *     if y.ndim > 1:
 *         # Check each column independently
 *         for column in y.T:             # <<<<<<<<<<<<<<
 *             unique_values = np.unique(column)
 *             if not (len(unique_values) == 2 and np.all(np.isin(unique_values, [0, 1]))):
 */
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "validator.pyx":846
 *             if not (len(unique_values) == 2 and np.all(np.isin(unique_values, [0, 1]))):
 *                 return False
 *         return True             # <<<<<<<<<<<<<<
 * 
 *     return False
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_True);
    __pyx_r = Py_True;
    goto __pyx_L0;

    /* "validator.pyx":840
 *         y = y.reshape(-1, 1)
 * 
 *     if y.ndim > 1:             # <<<<<<<<<<<<<<
 *         # Check each column independently
 *         for column in y.T:
 */
  }

  /* "validator.pyx":848
 *         return True
 * 
 *     return False             # <<<<<<<<<<<<<<
 * 
 * def handle_zero_division(
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_False);
  __pyx_r = Py_False;
  goto __pyx_L0;

  /* "validator.pyx":798
 *     return arr
 * 
 * def is_binary_class(y, accept_multioutput=False):             # <<<<<<<<<<<<<<
 *     """
 *     Check whether the target array represents binary classification. Optionally,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_XDECREF(__pyx_t_12);
  __Pyx_AddTraceback("validator.is_binary_class", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_unique_values);
  __Pyx_XDECREF(__pyx_v_column);
  __Pyx_XDECREF(__pyx_v_y);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":850
 *     return False
 * 
 * def handle_zero_division(             # <<<<<<<<<<<<<<
 *     y_true,
 *     zero_division='warn',
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_23handle_zero_division(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_22handle_zero_division[] = "\n    Preprocess input arrays to handle cases where zero could cause division errors\n    in subsequent metric computations.\n\n    Parameters\n    ----------\n    y_true : array-like\n        The input data array where zeros might cause division errors.\n    zero_division : {'warn', 'raise', 'ignore'}, default 'warn'\n        Determines the action to perform when a zero is encountered:\n        - 'warn': Issues a warning and replaces zeros with `replace_with` or `epsilon`.\n        - 'raise': Raises an error if a zero is found in the input data.\n        - 'ignore': Leaves the zeros as they are, useful when the metric calculation\n          can handle zeros natively.\n    metric_name : str, optional\n        Name of the metric for which this preprocessing is being done, to be included\n        in warnings or error messages for better context.\n    epsilon : float, optional\n        Small value to use as default replacement if `replace_with` is None,\n        default is 1e-15.\n    replace_with : float or None, optional\n        A specific value to replace zeros with, if None, `epsilon` is used.\n\n    Returns\n    -------\n    numpy.ndarray\n        The processed array with modifications based on the zero_division strategy.\n    \n    Raises\n    ------\n    ValueError\n        If `zero_division` is 'raise' and zero is found in `y_true`.\n\n    Notes\n    -----\n    Using `replace_with` allows for custom behavior when handling zeros, which can\n    be tailored to the specific requirements of different metric computations.\n    \n    Examples \n    ---------\n    >>> from gofast.tools.validator import handle_zero_division \n    >>> y_true = [0, 1, 2, 3, 0]\n    >>> processed_y_true = handle_zero_division(\n        y_true, replace_with=0.001, zero_division='warn')\n    >>> print(processed_y_true)\n\n    ";
static PyMethodDef __pyx_mdef_9validator_23handle_zero_division = {"handle_zero_division", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_23handle_zero_division, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_22handle_zero_division};
static PyObject *__pyx_pw_9validator_23handle_zero_division(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_y_true = 0;
  PyObject *__pyx_v_zero_division = 0;
  PyObject *__pyx_v_metric_name = 0;
  PyObject *__pyx_v_epsilon = 0;
  PyObject *__pyx_v_replace_with = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("handle_zero_division (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_y_true,&__pyx_n_s_zero_division,&__pyx_n_s_metric_name,&__pyx_n_s_epsilon,&__pyx_n_s_replace_with,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[1] = ((PyObject *)__pyx_n_u_warn);
    values[2] = ((PyObject *)__pyx_kp_u_metric_computation);
    values[3] = ((PyObject *)__pyx_float_1eneg_15);

    /* "validator.pyx":855
 *     metric_name='metric computation',
 *     epsilon=1e-15,
 *     replace_with=None             # <<<<<<<<<<<<<<
 * ):
 *     """
 */
    values[4] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y_true)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_zero_division);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_metric_name);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_epsilon);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_replace_with);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "handle_zero_division") < 0)) __PYX_ERR(0, 850, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_y_true = values[0];
    __pyx_v_zero_division = values[1];
    __pyx_v_metric_name = values[2];
    __pyx_v_epsilon = values[3];
    __pyx_v_replace_with = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("handle_zero_division", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 850, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.handle_zero_division", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_22handle_zero_division(__pyx_self, __pyx_v_y_true, __pyx_v_zero_division, __pyx_v_metric_name, __pyx_v_epsilon, __pyx_v_replace_with);

  /* "validator.pyx":850
 *     return False
 * 
 * def handle_zero_division(             # <<<<<<<<<<<<<<
 *     y_true,
 *     zero_division='warn',
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_22handle_zero_division(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y_true, PyObject *__pyx_v_zero_division, PyObject *__pyx_v_metric_name, PyObject *__pyx_v_epsilon, PyObject *__pyx_v_replace_with) {
  PyObject *__pyx_v_y_true_processed = NULL;
  PyObject *__pyx_v_zeros_mask = NULL;
  PyObject *__pyx_v_replacement_value = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  Py_ssize_t __pyx_t_6;
  Py_UCS4 __pyx_t_7;
  int __pyx_t_8;
  PyObject *__pyx_t_9 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("handle_zero_division", 0);
  __Pyx_INCREF(__pyx_v_zero_division);

  /* "validator.pyx":904
 * 
 *     """
 *     y_true_processed = np.asarray(y_true, dtype=float)             # <<<<<<<<<<<<<<
 *     zero_division = parameter_validator(
 *         "zero_division", target_strs=["warn", "raise", "ignore"]) (
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 904, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_asarray); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 904, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 904, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_v_y_true);
  __Pyx_GIVEREF(__pyx_v_y_true);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_y_true);
  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 904, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 904, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_1, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 904, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_y_true_processed = __pyx_t_4;
  __pyx_t_4 = 0;

  /* "validator.pyx":905
 *     """
 *     y_true_processed = np.asarray(y_true, dtype=float)
 *     zero_division = parameter_validator(             # <<<<<<<<<<<<<<
 *         "zero_division", target_strs=["warn", "raise", "ignore"]) (
 *             zero_division)
 */
  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_parameter_validator); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 905, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);

  /* "validator.pyx":906
 *     y_true_processed = np.asarray(y_true, dtype=float)
 *     zero_division = parameter_validator(
 *         "zero_division", target_strs=["warn", "raise", "ignore"]) (             # <<<<<<<<<<<<<<
 *             zero_division)
 * 
 */
  __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 906, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyList_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 906, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_n_u_warn);
  __Pyx_GIVEREF(__pyx_n_u_warn);
  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_u_warn);
  __Pyx_INCREF(__pyx_n_u_raise);
  __Pyx_GIVEREF(__pyx_n_u_raise);
  PyList_SET_ITEM(__pyx_t_2, 1, __pyx_n_u_raise);
  __Pyx_INCREF(__pyx_n_u_ignore);
  __Pyx_GIVEREF(__pyx_n_u_ignore);
  PyList_SET_ITEM(__pyx_t_2, 2, __pyx_n_u_ignore);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_target_strs, __pyx_t_2) < 0) __PYX_ERR(0, 906, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":905
 *     """
 *     y_true_processed = np.asarray(y_true, dtype=float)
 *     zero_division = parameter_validator(             # <<<<<<<<<<<<<<
 *         "zero_division", target_strs=["warn", "raise", "ignore"]) (
 *             zero_division)
 */
  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__26, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 905, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":907
 *     zero_division = parameter_validator(
 *         "zero_division", target_strs=["warn", "raise", "ignore"]) (
 *             zero_division)             # <<<<<<<<<<<<<<
 * 
 *     zeros_mask = y_true_processed == 0
 */
  __pyx_t_1 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_1)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_1);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_4 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_1, __pyx_v_zero_division) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_zero_division);
  __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 906, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF_SET(__pyx_v_zero_division, __pyx_t_4);
  __pyx_t_4 = 0;

  /* "validator.pyx":909
 *             zero_division)
 * 
 *     zeros_mask = y_true_processed == 0             # <<<<<<<<<<<<<<
 *     if np.any(zeros_mask):
 *         if zero_division == 'warn':
 */
  __pyx_t_4 = __Pyx_PyInt_EqObjC(__pyx_v_y_true_processed, __pyx_int_0, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 909, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_v_zeros_mask = __pyx_t_4;
  __pyx_t_4 = 0;

  /* "validator.pyx":910
 * 
 *     zeros_mask = y_true_processed == 0
 *     if np.any(zeros_mask):             # <<<<<<<<<<<<<<
 *         if zero_division == 'warn':
 *             warnings.warn(f"Encountered zero in y_true, which may lead to"
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 910, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_any); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 910, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  __pyx_t_4 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_2, __pyx_v_zeros_mask) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_zeros_mask);
  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 910, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 910, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (__pyx_t_5) {

    /* "validator.pyx":911
 *     zeros_mask = y_true_processed == 0
 *     if np.any(zeros_mask):
 *         if zero_division == 'warn':             # <<<<<<<<<<<<<<
 *             warnings.warn(f"Encountered zero in y_true, which may lead to"
 *                           f" infinite values or NaNs in {metric_name}.",
 */
    __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_zero_division, __pyx_n_u_warn, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 911, __pyx_L1_error)
    if (__pyx_t_5) {

      /* "validator.pyx":912
 *     if np.any(zeros_mask):
 *         if zero_division == 'warn':
 *             warnings.warn(f"Encountered zero in y_true, which may lead to"             # <<<<<<<<<<<<<<
 *                           f" infinite values or NaNs in {metric_name}.",
 *                           RuntimeWarning)
 */
      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_warnings); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 912, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_warn); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 912, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 912, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_6 = 0;
      __pyx_t_7 = 127;
      __Pyx_INCREF(__pyx_kp_u_Encountered_zero_in_y_true_which);
      __pyx_t_6 += 73;
      __Pyx_GIVEREF(__pyx_kp_u_Encountered_zero_in_y_true_which);
      PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_Encountered_zero_in_y_true_which);

      /* "validator.pyx":913
 *         if zero_division == 'warn':
 *             warnings.warn(f"Encountered zero in y_true, which may lead to"
 *                           f" infinite values or NaNs in {metric_name}.",             # <<<<<<<<<<<<<<
 *                           RuntimeWarning)
 *             replacement_value = replace_with if replace_with is not None else epsilon
 */
      __pyx_t_3 = __Pyx_PyObject_FormatSimple(__pyx_v_metric_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 913, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_7 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) > __pyx_t_7) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) : __pyx_t_7;
      __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_3);
      __Pyx_GIVEREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_3);
      __pyx_t_3 = 0;
      __Pyx_INCREF(__pyx_kp_u__16);
      __pyx_t_6 += 1;
      __Pyx_GIVEREF(__pyx_kp_u__16);
      PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u__16);

      /* "validator.pyx":912
 *     if np.any(zeros_mask):
 *         if zero_division == 'warn':
 *             warnings.warn(f"Encountered zero in y_true, which may lead to"             # <<<<<<<<<<<<<<
 *                           f" infinite values or NaNs in {metric_name}.",
 *                           RuntimeWarning)
 */
      __pyx_t_3 = __Pyx_PyUnicode_Join(__pyx_t_1, 3, __pyx_t_6, __pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 912, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "validator.pyx":914
 *             warnings.warn(f"Encountered zero in y_true, which may lead to"
 *                           f" infinite values or NaNs in {metric_name}.",
 *                           RuntimeWarning)             # <<<<<<<<<<<<<<
 *             replacement_value = replace_with if replace_with is not None else epsilon
 *             y_true_processed[zeros_mask] = replacement_value
 */
      __pyx_t_1 = NULL;
      __pyx_t_8 = 0;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
        __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
        if (likely(__pyx_t_1)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
          __Pyx_INCREF(__pyx_t_1);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_2, function);
          __pyx_t_8 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_2)) {
        PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_t_3, __pyx_builtin_RuntimeWarning};
        __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 912, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
        PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_t_3, __pyx_builtin_RuntimeWarning};
        __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 912, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      } else
      #endif
      {
        __pyx_t_9 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 912, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_9);
        if (__pyx_t_1) {
          __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_1); __pyx_t_1 = NULL;
        }
        __Pyx_GIVEREF(__pyx_t_3);
        PyTuple_SET_ITEM(__pyx_t_9, 0+__pyx_t_8, __pyx_t_3);
        __Pyx_INCREF(__pyx_builtin_RuntimeWarning);
        __Pyx_GIVEREF(__pyx_builtin_RuntimeWarning);
        PyTuple_SET_ITEM(__pyx_t_9, 1+__pyx_t_8, __pyx_builtin_RuntimeWarning);
        __pyx_t_3 = 0;
        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_9, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 912, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      }
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

      /* "validator.pyx":915
 *                           f" infinite values or NaNs in {metric_name}.",
 *                           RuntimeWarning)
 *             replacement_value = replace_with if replace_with is not None else epsilon             # <<<<<<<<<<<<<<
 *             y_true_processed[zeros_mask] = replacement_value
 *         elif zero_division == 'raise':
 */
      __pyx_t_5 = (__pyx_v_replace_with != Py_None);
      if ((__pyx_t_5 != 0)) {
        __Pyx_INCREF(__pyx_v_replace_with);
        __pyx_t_4 = __pyx_v_replace_with;
      } else {
        __Pyx_INCREF(__pyx_v_epsilon);
        __pyx_t_4 = __pyx_v_epsilon;
      }
      __pyx_v_replacement_value = __pyx_t_4;
      __pyx_t_4 = 0;

      /* "validator.pyx":916
 *                           RuntimeWarning)
 *             replacement_value = replace_with if replace_with is not None else epsilon
 *             y_true_processed[zeros_mask] = replacement_value             # <<<<<<<<<<<<<<
 *         elif zero_division == 'raise':
 *             raise ValueError(f"Encountered zero in y_true, leading to division"
 */
      if (unlikely(PyObject_SetItem(__pyx_v_y_true_processed, __pyx_v_zeros_mask, __pyx_v_replacement_value) < 0)) __PYX_ERR(0, 916, __pyx_L1_error)

      /* "validator.pyx":911
 *     zeros_mask = y_true_processed == 0
 *     if np.any(zeros_mask):
 *         if zero_division == 'warn':             # <<<<<<<<<<<<<<
 *             warnings.warn(f"Encountered zero in y_true, which may lead to"
 *                           f" infinite values or NaNs in {metric_name}.",
 */
      goto __pyx_L4;
    }

    /* "validator.pyx":917
 *             replacement_value = replace_with if replace_with is not None else epsilon
 *             y_true_processed[zeros_mask] = replacement_value
 *         elif zero_division == 'raise':             # <<<<<<<<<<<<<<
 *             raise ValueError(f"Encountered zero in y_true, leading to division"
 *                              f" by zero in {metric_name} computation.")
 */
    __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_zero_division, __pyx_n_u_raise, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 917, __pyx_L1_error)
    if (unlikely(__pyx_t_5)) {

      /* "validator.pyx":918
 *             y_true_processed[zeros_mask] = replacement_value
 *         elif zero_division == 'raise':
 *             raise ValueError(f"Encountered zero in y_true, leading to division"             # <<<<<<<<<<<<<<
 *                              f" by zero in {metric_name} computation.")
 *         elif zero_division == 'ignore':
 */
      __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 918, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_6 = 0;
      __pyx_t_7 = 127;
      __Pyx_INCREF(__pyx_kp_u_Encountered_zero_in_y_true_leadi);
      __pyx_t_6 += 59;
      __Pyx_GIVEREF(__pyx_kp_u_Encountered_zero_in_y_true_leadi);
      PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_kp_u_Encountered_zero_in_y_true_leadi);

      /* "validator.pyx":919
 *         elif zero_division == 'raise':
 *             raise ValueError(f"Encountered zero in y_true, leading to division"
 *                              f" by zero in {metric_name} computation.")             # <<<<<<<<<<<<<<
 *         elif zero_division == 'ignore':
 *             pass  # Do nothing, let the calling function handle zeros natively.
 */
      __pyx_t_2 = __Pyx_PyObject_FormatSimple(__pyx_v_metric_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 919, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_7 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) > __pyx_t_7) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) : __pyx_t_7;
      __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_2);
      __Pyx_GIVEREF(__pyx_t_2);
      PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);
      __pyx_t_2 = 0;
      __Pyx_INCREF(__pyx_kp_u_computation);
      __pyx_t_6 += 13;
      __Pyx_GIVEREF(__pyx_kp_u_computation);
      PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_kp_u_computation);

      /* "validator.pyx":918
 *             y_true_processed[zeros_mask] = replacement_value
 *         elif zero_division == 'raise':
 *             raise ValueError(f"Encountered zero in y_true, leading to division"             # <<<<<<<<<<<<<<
 *                              f" by zero in {metric_name} computation.")
 *         elif zero_division == 'ignore':
 */
      __pyx_t_2 = __Pyx_PyUnicode_Join(__pyx_t_4, 3, __pyx_t_6, __pyx_t_7); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 918, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 918, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __PYX_ERR(0, 918, __pyx_L1_error)

      /* "validator.pyx":917
 *             replacement_value = replace_with if replace_with is not None else epsilon
 *             y_true_processed[zeros_mask] = replacement_value
 *         elif zero_division == 'raise':             # <<<<<<<<<<<<<<
 *             raise ValueError(f"Encountered zero in y_true, leading to division"
 *                              f" by zero in {metric_name} computation.")
 */
    }

    /* "validator.pyx":920
 *             raise ValueError(f"Encountered zero in y_true, leading to division"
 *                              f" by zero in {metric_name} computation.")
 *         elif zero_division == 'ignore':             # <<<<<<<<<<<<<<
 *             pass  # Do nothing, let the calling function handle zeros natively.
 * 
 */
    __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_zero_division, __pyx_n_u_ignore, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 920, __pyx_L1_error)
    if (__pyx_t_5) {
    }
    __pyx_L4:;

    /* "validator.pyx":910
 * 
 *     zeros_mask = y_true_processed == 0
 *     if np.any(zeros_mask):             # <<<<<<<<<<<<<<
 *         if zero_division == 'warn':
 *             warnings.warn(f"Encountered zero in y_true, which may lead to"
 */
  }

  /* "validator.pyx":923
 *             pass  # Do nothing, let the calling function handle zeros natively.
 * 
 *     return y_true_processed             # <<<<<<<<<<<<<<
 * 
 * def validate_comparison_data(df,  alignment="auto"):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_y_true_processed);
  __pyx_r = __pyx_v_y_true_processed;
  goto __pyx_L0;

  /* "validator.pyx":850
 *     return False
 * 
 * def handle_zero_division(             # <<<<<<<<<<<<<<
 *     y_true,
 *     zero_division='warn',
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("validator.handle_zero_division", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_y_true_processed);
  __Pyx_XDECREF(__pyx_v_zeros_mask);
  __Pyx_XDECREF(__pyx_v_replacement_value);
  __Pyx_XDECREF(__pyx_v_zero_division);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":925
 *     return y_true_processed
 * 
 * def validate_comparison_data(df,  alignment="auto"):             # <<<<<<<<<<<<<<
 *     """
 *     Validates a DataFrame to ensure it is a square matrix and that the index
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_25validate_comparison_data(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_24validate_comparison_data[] = "\n    Validates a DataFrame to ensure it is a square matrix and that the index \n    and column names match. Optionally aligns the index names to the column \n    names or vice versa based on the alignment parameter.\n\n    Parameters\n    ----------\n    df : pandas.DataFrame\n        The DataFrame to validate.\n    alignment : str, default 'auto'\n        Controls how the DataFrame's index and columns are aligned if they d\n        o not match.\n        Options are 'auto', 'index_to_columns', and 'columns_to_index'.\n    \n    Returns\n    -------\n    pandas.DataFrame\n        The validated and potentially modified DataFrame.\n    \n    Raises\n    ------\n    ValueError\n        If the DataFrame is not square or if index and column names do not match\n        and no suitable alignment option is specified.\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import validate_comparison_data\n    >>> data = pd.DataFrame({\n    ...     'A': [1, 0.9, 0.8],\n    ...     'B': [0.9, 1, 0.85],\n    ...     'C': [0.8, 0.85, 1]\n    ... }, index=['A', 'B', 'X'])\n    >>> print(validate_comparison_data(data, alignment='index_to_columns'))\n    \n    >>> data = pd.DataFrame({\n    ...     1: [1, 0.9, 0.8],\n    ...     2: [0.9, 1, 0.85],\n    ...     3: [0.8, 0.85, 1]\n    ... }, index=[1, 2, 'X'])\n    >>> print(validate_comparison_data(data, alignment='auto'))\n    ";
static PyMethodDef __pyx_mdef_9validator_25validate_comparison_data = {"validate_comparison_data", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_25validate_comparison_data, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_24validate_comparison_data};
static PyObject *__pyx_pw_9validator_25validate_comparison_data(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_df = 0;
  PyObject *__pyx_v_alignment = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validate_comparison_data (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_df,&__pyx_n_s_alignment,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_n_u_auto);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_df)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_alignment);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "validate_comparison_data") < 0)) __PYX_ERR(0, 925, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_df = values[0];
    __pyx_v_alignment = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("validate_comparison_data", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 925, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.validate_comparison_data", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_24validate_comparison_data(__pyx_self, __pyx_v_df, __pyx_v_alignment);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_24validate_comparison_data(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_df, PyObject *__pyx_v_alignment) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validate_comparison_data", 0);

  /* "validator.pyx":968
 *     >>> print(validate_comparison_data(data, alignment='auto'))
 *     """
 *     if not isinstance ( df, pd.DataFrame):             # <<<<<<<<<<<<<<
 *         raise TypeError(f"Performance data expects a DataFrame; got {type(df).__name__!r}")
 *     # Check if DataFrame is square
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pd); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 968, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_DataFrame); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 968, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = PyObject_IsInstance(__pyx_v_df, __pyx_t_2); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 968, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = ((!(__pyx_t_3 != 0)) != 0);
  if (unlikely(__pyx_t_4)) {

    /* "validator.pyx":969
 *     """
 *     if not isinstance ( df, pd.DataFrame):
 *         raise TypeError(f"Performance data expects a DataFrame; got {type(df).__name__!r}")             # <<<<<<<<<<<<<<
 *     # Check if DataFrame is square
 *     if df.shape[0] != df.shape[1]:
 */
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_df)), __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 969, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_t_2), __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 969, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Performance_data_expects_a_DataF, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 969, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 969, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 969, __pyx_L1_error)

    /* "validator.pyx":968
 *     >>> print(validate_comparison_data(data, alignment='auto'))
 *     """
 *     if not isinstance ( df, pd.DataFrame):             # <<<<<<<<<<<<<<
 *         raise TypeError(f"Performance data expects a DataFrame; got {type(df).__name__!r}")
 *     # Check if DataFrame is square
 */
  }

  /* "validator.pyx":971
 *         raise TypeError(f"Performance data expects a DataFrame; got {type(df).__name__!r}")
 *     # Check if DataFrame is square
 *     if df.shape[0] != df.shape[1]:             # <<<<<<<<<<<<<<
 *         raise ValueError("DataFrame must be square (equal number of rows and columns).")
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_df, __pyx_n_s_shape); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 971, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_GetItemInt(__pyx_t_1, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 971, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_df, __pyx_n_s_shape); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 971, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_5 = __Pyx_GetItemInt(__pyx_t_1, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 971, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyObject_RichCompare(__pyx_t_2, __pyx_t_5, Py_NE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 971, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 971, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (unlikely(__pyx_t_4)) {

    /* "validator.pyx":972
 *     # Check if DataFrame is square
 *     if df.shape[0] != df.shape[1]:
 *         raise ValueError("DataFrame must be square (equal number of rows and columns).")             # <<<<<<<<<<<<<<
 * 
 *     # Check if indices and columns match
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__27, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 972, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 972, __pyx_L1_error)

    /* "validator.pyx":971
 *         raise TypeError(f"Performance data expects a DataFrame; got {type(df).__name__!r}")
 *     # Check if DataFrame is square
 *     if df.shape[0] != df.shape[1]:             # <<<<<<<<<<<<<<
 *         raise ValueError("DataFrame must be square (equal number of rows and columns).")
 * 
 */
  }

  /* "validator.pyx":975
 * 
 *     # Check if indices and columns match
 *     if not df.index.equals(df.columns):             # <<<<<<<<<<<<<<
 *         if alignment == 'index_to_columns':
 *             df.index = df.columns
 */
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_df, __pyx_n_s_index); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 975, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_equals); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 975, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_df, __pyx_n_s_columns); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 975, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_6, __pyx_t_5) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 975, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 975, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = ((!__pyx_t_4) != 0);
  if (__pyx_t_3) {

    /* "validator.pyx":976
 *     # Check if indices and columns match
 *     if not df.index.equals(df.columns):
 *         if alignment == 'index_to_columns':             # <<<<<<<<<<<<<<
 *             df.index = df.columns
 *         elif alignment == 'columns_to_index':
 */
    __pyx_t_3 = (__Pyx_PyUnicode_Equals(__pyx_v_alignment, __pyx_n_u_index_to_columns, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 976, __pyx_L1_error)
    if (__pyx_t_3) {

      /* "validator.pyx":977
 *     if not df.index.equals(df.columns):
 *         if alignment == 'index_to_columns':
 *             df.index = df.columns             # <<<<<<<<<<<<<<
 *         elif alignment == 'columns_to_index':
 *             df.columns = df.index
 */
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_df, __pyx_n_s_columns); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 977, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (__Pyx_PyObject_SetAttrStr(__pyx_v_df, __pyx_n_s_index, __pyx_t_1) < 0) __PYX_ERR(0, 977, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "validator.pyx":976
 *     # Check if indices and columns match
 *     if not df.index.equals(df.columns):
 *         if alignment == 'index_to_columns':             # <<<<<<<<<<<<<<
 *             df.index = df.columns
 *         elif alignment == 'columns_to_index':
 */
      goto __pyx_L6;
    }

    /* "validator.pyx":978
 *         if alignment == 'index_to_columns':
 *             df.index = df.columns
 *         elif alignment == 'columns_to_index':             # <<<<<<<<<<<<<<
 *             df.columns = df.index
 *         elif alignment == 'auto':
 */
    __pyx_t_3 = (__Pyx_PyUnicode_Equals(__pyx_v_alignment, __pyx_n_u_columns_to_index, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 978, __pyx_L1_error)
    if (__pyx_t_3) {

      /* "validator.pyx":979
 *             df.index = df.columns
 *         elif alignment == 'columns_to_index':
 *             df.columns = df.index             # <<<<<<<<<<<<<<
 *         elif alignment == 'auto':
 *             # Automatically decide which one to use based on data types
 */
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_df, __pyx_n_s_index); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 979, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (__Pyx_PyObject_SetAttrStr(__pyx_v_df, __pyx_n_s_columns, __pyx_t_1) < 0) __PYX_ERR(0, 979, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "validator.pyx":978
 *         if alignment == 'index_to_columns':
 *             df.index = df.columns
 *         elif alignment == 'columns_to_index':             # <<<<<<<<<<<<<<
 *             df.columns = df.index
 *         elif alignment == 'auto':
 */
      goto __pyx_L6;
    }

    /* "validator.pyx":980
 *         elif alignment == 'columns_to_index':
 *             df.columns = df.index
 *         elif alignment == 'auto':             # <<<<<<<<<<<<<<
 *             # Automatically decide which one to use based on data types
 *             if df.index.dtype == 'object' and df.columns.dtype == 'int64':
 */
    __pyx_t_3 = (__Pyx_PyUnicode_Equals(__pyx_v_alignment, __pyx_n_u_auto, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 980, __pyx_L1_error)
    if (likely(__pyx_t_3)) {

      /* "validator.pyx":982
 *         elif alignment == 'auto':
 *             # Automatically decide which one to use based on data types
 *             if df.index.dtype == 'object' and df.columns.dtype == 'int64':             # <<<<<<<<<<<<<<
 *                 df.index = df.columns
 *             elif df.columns.dtype == 'object' and df.index.dtype == 'int64':
 */
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_df, __pyx_n_s_index); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 982, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_dtype); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 982, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_t_2, __pyx_n_u_object, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 982, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      if (__pyx_t_4) {
      } else {
        __pyx_t_3 = __pyx_t_4;
        goto __pyx_L8_bool_binop_done;
      }
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_df, __pyx_n_s_columns); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 982, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_dtype); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 982, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_t_1, __pyx_n_u_int64, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 982, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_3 = __pyx_t_4;
      __pyx_L8_bool_binop_done:;
      if (__pyx_t_3) {

        /* "validator.pyx":983
 *             # Automatically decide which one to use based on data types
 *             if df.index.dtype == 'object' and df.columns.dtype == 'int64':
 *                 df.index = df.columns             # <<<<<<<<<<<<<<
 *             elif df.columns.dtype == 'object' and df.index.dtype == 'int64':
 *                 df.columns = df.index
 */
        __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_df, __pyx_n_s_columns); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 983, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        if (__Pyx_PyObject_SetAttrStr(__pyx_v_df, __pyx_n_s_index, __pyx_t_1) < 0) __PYX_ERR(0, 983, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "validator.pyx":982
 *         elif alignment == 'auto':
 *             # Automatically decide which one to use based on data types
 *             if df.index.dtype == 'object' and df.columns.dtype == 'int64':             # <<<<<<<<<<<<<<
 *                 df.index = df.columns
 *             elif df.columns.dtype == 'object' and df.index.dtype == 'int64':
 */
        goto __pyx_L7;
      }

      /* "validator.pyx":984
 *             if df.index.dtype == 'object' and df.columns.dtype == 'int64':
 *                 df.index = df.columns
 *             elif df.columns.dtype == 'object' and df.index.dtype == 'int64':             # <<<<<<<<<<<<<<
 *                 df.columns = df.index
 *             else:
 */
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_df, __pyx_n_s_columns); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 984, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_dtype); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 984, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_t_2, __pyx_n_u_object, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 984, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      if (__pyx_t_4) {
      } else {
        __pyx_t_3 = __pyx_t_4;
        goto __pyx_L10_bool_binop_done;
      }
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_df, __pyx_n_s_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 984, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_dtype); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 984, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_t_1, __pyx_n_u_int64, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 984, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_3 = __pyx_t_4;
      __pyx_L10_bool_binop_done:;
      if (likely(__pyx_t_3)) {

        /* "validator.pyx":985
 *                 df.index = df.columns
 *             elif df.columns.dtype == 'object' and df.index.dtype == 'int64':
 *                 df.columns = df.index             # <<<<<<<<<<<<<<
 *             else:
 *                 raise ValueError(
 */
        __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_df, __pyx_n_s_index); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 985, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        if (__Pyx_PyObject_SetAttrStr(__pyx_v_df, __pyx_n_s_columns, __pyx_t_1) < 0) __PYX_ERR(0, 985, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "validator.pyx":984
 *             if df.index.dtype == 'object' and df.columns.dtype == 'int64':
 *                 df.index = df.columns
 *             elif df.columns.dtype == 'object' and df.index.dtype == 'int64':             # <<<<<<<<<<<<<<
 *                 df.columns = df.index
 *             else:
 */
        goto __pyx_L7;
      }

      /* "validator.pyx":987
 *                 df.columns = df.index
 *             else:
 *                 raise ValueError(             # <<<<<<<<<<<<<<
 *                     "Automatic alignment failed. Index and column names do not match "
 *                     "and are of the same type. Please specify alignment explicitly."
 */
      /*else*/ {
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__28, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 987, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_Raise(__pyx_t_1, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __PYX_ERR(0, 987, __pyx_L1_error)
      }
      __pyx_L7:;

      /* "validator.pyx":980
 *         elif alignment == 'columns_to_index':
 *             df.columns = df.index
 *         elif alignment == 'auto':             # <<<<<<<<<<<<<<
 *             # Automatically decide which one to use based on data types
 *             if df.index.dtype == 'object' and df.columns.dtype == 'int64':
 */
      goto __pyx_L6;
    }

    /* "validator.pyx":992
 *                 )
 *         else:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "Invalid alignment option provided. Please choose from 'index_to_columns', "
 *                 "'columns_to_index', or 'auto'."
 */
    /*else*/ {
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__29, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 992, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 992, __pyx_L1_error)
    }
    __pyx_L6:;

    /* "validator.pyx":975
 * 
 *     # Check if indices and columns match
 *     if not df.index.equals(df.columns):             # <<<<<<<<<<<<<<
 *         if alignment == 'index_to_columns':
 *             df.index = df.columns
 */
  }

  /* "validator.pyx":997
 *             )
 * 
 *     return df             # <<<<<<<<<<<<<<
 * 
 * def validate_data_types(
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_df);
  __pyx_r = __pyx_v_df;
  goto __pyx_L0;

  /* "validator.pyx":925
 *     return y_true_processed
 * 
 * def validate_comparison_data(df,  alignment="auto"):             # <<<<<<<<<<<<<<
 *     """
 *     Validates a DataFrame to ensure it is a square matrix and that the index
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("validator.validate_comparison_data", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":999
 *     return df
 * 
 * def validate_data_types(             # <<<<<<<<<<<<<<
 *     data, expected_type='numeric',
 *     nan_policy='omit',
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_27validate_data_types(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_26validate_data_types[] = "\n    Checks for mixed data types in a pandas Series or DataFrame and handles\n    according to the specified policies. This function is designed to ensure \n    data consistency by verifying that data matches expected type criteria,\n    offering options to manage and report any discrepancies.\n\n    Parameters\n    ----------\n    data : pd.Series or pd.DataFrame\n        The data to be checked. This can be a pandas Series or DataFrame.\n    expected_type : {'numeric', 'categoric', 'both'}, default 'numeric'\n        Specifies the type of data expected:\n        \n        - 'numeric': All data should be of numeric types (int, float).\n        - 'categoric': All data should be categorical, typically strings\n          or pandas Categorical datatype.\n        - 'both': Any mix of numeric and categorical data is considered valid.\n        \n    nan_policy : {'raise', 'omit', 'propagate'}, default 'omit'\n        Determines how NaN values are handled:\n        \n        - 'raise': Raises an error if NaN values are found.\n        - 'warn': Issues a warning if NaN values are found but proceeds.\n        - 'propagate': Continues execution without addressing NaNs.\n        \n    return_data : bool, default False\n        If True, returns a DataFrame or Series (depending on the input) that \n        only includes data rows that conform to the expected_type. If False,\n        returns None.\n        \n    error : {'raise', 'warn'}, default 'raise'\n        Configures the error handling behavior when data types do not conform \n        to the expected_type:\n        \n        - 'raise': Raises a TypeError if mixed types are detected.\n        - 'warn': Emits a warning but attempts to continue by filtering \n          non-conforming data if `return_data` is True.\n\n    Returns\n    -------\n    pd.Series or pd.DataFrame or None\n        Depending on `return_data`, this function may return a filtered version\n        of `data` that conforms to the `expected_type` or None if ""`return_data` \n        is False.\n\n    Raises\n    ------\n    ValueError\n        If NaN values are present and `nan_policy` is set to 'error'.\n    TypeError\n        If data types do not conform to `expected_type` and `error` is set to 'raise'.\n\n    Examples\n    --------\n    >>> import pandas as pd \n    >>> from gofast.tools.validator import validate_data_types \n    >>> df = pd.DataFrame({'A': [1, 2, 'a', 3.5, np.nan], 'B': ['x', 'y', 'z', None, 't']})\n    >>> validate_data_types(df, expected_type='numeric', nan_policy='warn', \n    ...                  return_data=True, error='warn')\n    UserWarning: NaN values found in the data, but processing will continue.\n    UserWarning: Expected numeric types but found mixed types. \n    Non-numeric data will be ignored.\n       A\n    0  1.0\n    1  2.0\n    3  3.5\n\n    Notes\n    -----\n    The `check_data_types` function is useful in data preprocessing steps,\n    particularly when you need to ensure that data fed into a machine learning\n    algorithm meets certain type requirements. Handling mixed data types early\n    on can prevent issues in model training and evaluation.\n    ";
static PyMethodDef __pyx_mdef_9validator_27validate_data_types = {"validate_data_types", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_27validate_data_types, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_26validate_data_types};
static PyObject *__pyx_pw_9validator_27validate_data_types(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_data = 0;
  PyObject *__pyx_v_expected_type = 0;
  PyObject *__pyx_v_nan_policy = 0;
  PyObject *__pyx_v_return_data = 0;
  PyObject *__pyx_v_error = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validate_data_types (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_data,&__pyx_n_s_expected_type,&__pyx_n_s_nan_policy,&__pyx_n_s_return_data,&__pyx_n_s_error,0};
    PyObject* values[5] = {0,0,0,0,0};
    values[1] = ((PyObject *)__pyx_n_u_numeric);
    values[2] = ((PyObject *)__pyx_n_u_omit);

    /* "validator.pyx":1002
 *     data, expected_type='numeric',
 *     nan_policy='omit',
 *     return_data=False,             # <<<<<<<<<<<<<<
 *     error='raise'
 *     ):
 */
    values[3] = ((PyObject *)Py_False);
    values[4] = ((PyObject *)__pyx_n_u_raise);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_expected_type);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_nan_policy);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_return_data);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_error);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "validate_data_types") < 0)) __PYX_ERR(0, 999, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_data = values[0];
    __pyx_v_expected_type = values[1];
    __pyx_v_nan_policy = values[2];
    __pyx_v_return_data = values[3];
    __pyx_v_error = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("validate_data_types", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 999, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.validate_data_types", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_26validate_data_types(__pyx_self, __pyx_v_data, __pyx_v_expected_type, __pyx_v_nan_policy, __pyx_v_return_data, __pyx_v_error);

  /* "validator.pyx":999
 *     return df
 * 
 * def validate_data_types(             # <<<<<<<<<<<<<<
 *     data, expected_type='numeric',
 *     nan_policy='omit',
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1097
 *         warnings.warn("NaN values found in the data, but processing will continue.")
 * 
 *     def _handle_numeric(data, return_data):             # <<<<<<<<<<<<<<
 *         is_numeric = pd.to_numeric(data, errors='coerce').notna()
 *         if not is_numeric.all():
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_19validate_data_types_1_handle_numeric(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyMethodDef __pyx_mdef_9validator_19validate_data_types_1_handle_numeric = {"_handle_numeric", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_19validate_data_types_1_handle_numeric, METH_VARARGS|METH_KEYWORDS, 0};
static PyObject *__pyx_pw_9validator_19validate_data_types_1_handle_numeric(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_data = 0;
  PyObject *__pyx_v_return_data = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_handle_numeric (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_data,&__pyx_n_s_return_data,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_return_data)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_handle_numeric", 1, 2, 2, 1); __PYX_ERR(0, 1097, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_handle_numeric") < 0)) __PYX_ERR(0, 1097, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_data = values[0];
    __pyx_v_return_data = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_handle_numeric", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1097, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.validate_data_types._handle_numeric", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_19validate_data_types__handle_numeric(__pyx_self, __pyx_v_data, __pyx_v_return_data);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_19validate_data_types__handle_numeric(PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_return_data) {
  struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types *__pyx_cur_scope;
  struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types *__pyx_outer_scope;
  PyObject *__pyx_v_is_numeric = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_t_7;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_handle_numeric", 0);
  __pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types *) __Pyx_CyFunction_GetClosure(__pyx_self);
  __pyx_cur_scope = __pyx_outer_scope;

  /* "validator.pyx":1098
 * 
 *     def _handle_numeric(data, return_data):
 *         is_numeric = pd.to_numeric(data, errors='coerce').notna()             # <<<<<<<<<<<<<<
 *         if not is_numeric.all():
 *             if error == 'raise':
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_pd); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1098, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_to_numeric); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1098, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1098, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_data);
  __Pyx_GIVEREF(__pyx_v_data);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_data);
  __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1098, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_errors, __pyx_n_u_coerce) < 0) __PYX_ERR(0, 1098, __pyx_L1_error)
  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1098, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_notna); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1098, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1098, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_v_is_numeric = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":1099
 *     def _handle_numeric(data, return_data):
 *         is_numeric = pd.to_numeric(data, errors='coerce').notna()
 *         if not is_numeric.all():             # <<<<<<<<<<<<<<
 *             if error == 'raise':
 *                 raise TypeError(
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_is_numeric, __pyx_n_s_all); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1099, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1099, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 1099, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_7 = ((!__pyx_t_6) != 0);
  if (__pyx_t_7) {

    /* "validator.pyx":1100
 *         is_numeric = pd.to_numeric(data, errors='coerce').notna()
 *         if not is_numeric.all():
 *             if error == 'raise':             # <<<<<<<<<<<<<<
 *                 raise TypeError(
 *                     "Mixed types detected. Please encode categorical variables first.")
 */
    if (unlikely(!__pyx_cur_scope->__pyx_v_error)) { __Pyx_RaiseClosureNameError("error"); __PYX_ERR(0, 1100, __pyx_L1_error) }
    __pyx_t_7 = (__Pyx_PyUnicode_Equals(__pyx_cur_scope->__pyx_v_error, __pyx_n_u_raise, Py_EQ)); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 1100, __pyx_L1_error)
    if (unlikely(__pyx_t_7)) {

      /* "validator.pyx":1101
 *         if not is_numeric.all():
 *             if error == 'raise':
 *                 raise TypeError(             # <<<<<<<<<<<<<<
 *                     "Mixed types detected. Please encode categorical variables first.")
 *             elif error == 'warn':
 */
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__30, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1101, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 1101, __pyx_L1_error)

      /* "validator.pyx":1100
 *         is_numeric = pd.to_numeric(data, errors='coerce').notna()
 *         if not is_numeric.all():
 *             if error == 'raise':             # <<<<<<<<<<<<<<
 *                 raise TypeError(
 *                     "Mixed types detected. Please encode categorical variables first.")
 */
    }

    /* "validator.pyx":1103
 *                 raise TypeError(
 *                     "Mixed types detected. Please encode categorical variables first.")
 *             elif error == 'warn':             # <<<<<<<<<<<<<<
 *                 warnings.warn(
 *                     "Expected numeric types but found mixed types."
 */
    if (unlikely(!__pyx_cur_scope->__pyx_v_error)) { __Pyx_RaiseClosureNameError("error"); __PYX_ERR(0, 1103, __pyx_L1_error) }
    __pyx_t_7 = (__Pyx_PyUnicode_Equals(__pyx_cur_scope->__pyx_v_error, __pyx_n_u_warn, Py_EQ)); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 1103, __pyx_L1_error)
    if (__pyx_t_7) {

      /* "validator.pyx":1104
 *                     "Mixed types detected. Please encode categorical variables first.")
 *             elif error == 'warn':
 *                 warnings.warn(             # <<<<<<<<<<<<<<
 *                     "Expected numeric types but found mixed types."
 *                     " Non-numeric data will be ignored.")
 */
      __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_warnings); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1104, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_warn); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1104, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_5, function);
        }
      }
      __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_kp_u_Expected_numeric_types_but_found) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_kp_u_Expected_numeric_types_but_found);
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1104, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "validator.pyx":1107
 *                     "Expected numeric types but found mixed types."
 *                     " Non-numeric data will be ignored.")
 *                 if return_data:             # <<<<<<<<<<<<<<
 *                     return data.loc[is_numeric]
 *         return data[is_numeric] if return_data else None
 */
      __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_return_data); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 1107, __pyx_L1_error)
      if (__pyx_t_7) {

        /* "validator.pyx":1108
 *                     " Non-numeric data will be ignored.")
 *                 if return_data:
 *                     return data.loc[is_numeric]             # <<<<<<<<<<<<<<
 *         return data[is_numeric] if return_data else None
 * 
 */
        __Pyx_XDECREF(__pyx_r);
        __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_loc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1108, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_5 = __Pyx_PyObject_GetItem(__pyx_t_1, __pyx_v_is_numeric); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1108, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __pyx_r = __pyx_t_5;
        __pyx_t_5 = 0;
        goto __pyx_L0;

        /* "validator.pyx":1107
 *                     "Expected numeric types but found mixed types."
 *                     " Non-numeric data will be ignored.")
 *                 if return_data:             # <<<<<<<<<<<<<<
 *                     return data.loc[is_numeric]
 *         return data[is_numeric] if return_data else None
 */
      }

      /* "validator.pyx":1103
 *                 raise TypeError(
 *                     "Mixed types detected. Please encode categorical variables first.")
 *             elif error == 'warn':             # <<<<<<<<<<<<<<
 *                 warnings.warn(
 *                     "Expected numeric types but found mixed types."
 */
    }

    /* "validator.pyx":1099
 *     def _handle_numeric(data, return_data):
 *         is_numeric = pd.to_numeric(data, errors='coerce').notna()
 *         if not is_numeric.all():             # <<<<<<<<<<<<<<
 *             if error == 'raise':
 *                 raise TypeError(
 */
  }

  /* "validator.pyx":1109
 *                 if return_data:
 *                     return data.loc[is_numeric]
 *         return data[is_numeric] if return_data else None             # <<<<<<<<<<<<<<
 * 
 *     def _handle_categoric(data, return_data):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_return_data); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 1109, __pyx_L1_error)
  if (__pyx_t_7) {
    __pyx_t_1 = __Pyx_PyObject_GetItem(__pyx_v_data, __pyx_v_is_numeric); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1109, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_5 = __pyx_t_1;
    __pyx_t_1 = 0;
  } else {
    __Pyx_INCREF(Py_None);
    __pyx_t_5 = Py_None;
  }
  __pyx_r = __pyx_t_5;
  __pyx_t_5 = 0;
  goto __pyx_L0;

  /* "validator.pyx":1097
 *         warnings.warn("NaN values found in the data, but processing will continue.")
 * 
 *     def _handle_numeric(data, return_data):             # <<<<<<<<<<<<<<
 *         is_numeric = pd.to_numeric(data, errors='coerce').notna()
 *         if not is_numeric.all():
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("validator.validate_data_types._handle_numeric", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_is_numeric);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1111
 *         return data[is_numeric] if return_data else None
 * 
 *     def _handle_categoric(data, return_data):             # <<<<<<<<<<<<<<
 *         is_categoric = data.apply(lambda x: isinstance(x, (str, pd.CategoricalDtype)))
 *         if not is_categoric.all():
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_19validate_data_types_3_handle_categoric(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyMethodDef __pyx_mdef_9validator_19validate_data_types_3_handle_categoric = {"_handle_categoric", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_19validate_data_types_3_handle_categoric, METH_VARARGS|METH_KEYWORDS, 0};
static PyObject *__pyx_pw_9validator_19validate_data_types_3_handle_categoric(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_data = 0;
  PyObject *__pyx_v_return_data = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_handle_categoric (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_data,&__pyx_n_s_return_data,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_return_data)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_handle_categoric", 1, 2, 2, 1); __PYX_ERR(0, 1111, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_handle_categoric") < 0)) __PYX_ERR(0, 1111, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_data = values[0];
    __pyx_v_return_data = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_handle_categoric", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1111, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.validate_data_types._handle_categoric", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_19validate_data_types_2_handle_categoric(__pyx_self, __pyx_v_data, __pyx_v_return_data);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1112
 * 
 *     def _handle_categoric(data, return_data):
 *         is_categoric = data.apply(lambda x: isinstance(x, (str, pd.CategoricalDtype)))             # <<<<<<<<<<<<<<
 *         if not is_categoric.all():
 *             if error == 'raise':
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_19validate_data_types_17_handle_categoric_lambda1(PyObject *__pyx_self, PyObject *__pyx_v_x); /*proto*/
static PyMethodDef __pyx_mdef_9validator_19validate_data_types_17_handle_categoric_lambda1 = {"lambda1", (PyCFunction)__pyx_pw_9validator_19validate_data_types_17_handle_categoric_lambda1, METH_O, 0};
static PyObject *__pyx_pw_9validator_19validate_data_types_17_handle_categoric_lambda1(PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("lambda1 (wrapper)", 0);
  __pyx_r = __pyx_lambda_funcdef_lambda1(__pyx_self, ((PyObject *)__pyx_v_x));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_lambda_funcdef_lambda1(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("lambda1", 0);
  __Pyx_XDECREF(__pyx_r);
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pd); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1112, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_CategoricalDtype); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1112, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_4 = PyUnicode_Check(__pyx_v_x); 
  __pyx_t_5 = (__pyx_t_4 != 0);
  if (!__pyx_t_5) {
  } else {
    __pyx_t_3 = __pyx_t_5;
    goto __pyx_L3_bool_binop_done;
  }
  __pyx_t_5 = PyObject_IsInstance(__pyx_v_x, __pyx_t_2); 
  __pyx_t_4 = (__pyx_t_5 != 0);
  __pyx_t_3 = __pyx_t_4;
  __pyx_L3_bool_binop_done:;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1112, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("validator.validate_data_types._handle_categoric.lambda1", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1111
 *         return data[is_numeric] if return_data else None
 * 
 *     def _handle_categoric(data, return_data):             # <<<<<<<<<<<<<<
 *         is_categoric = data.apply(lambda x: isinstance(x, (str, pd.CategoricalDtype)))
 *         if not is_categoric.all():
 */

static PyObject *__pyx_pf_9validator_19validate_data_types_2_handle_categoric(PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_return_data) {
  struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types *__pyx_cur_scope;
  struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types *__pyx_outer_scope;
  PyObject *__pyx_v_is_categoric = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_handle_categoric", 0);
  __pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types *) __Pyx_CyFunction_GetClosure(__pyx_self);
  __pyx_cur_scope = __pyx_outer_scope;

  /* "validator.pyx":1112
 * 
 *     def _handle_categoric(data, return_data):
 *         is_categoric = data.apply(lambda x: isinstance(x, (str, pd.CategoricalDtype)))             # <<<<<<<<<<<<<<
 *         if not is_categoric.all():
 *             if error == 'raise':
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_apply); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1112, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_CyFunction_New(&__pyx_mdef_9validator_19validate_data_types_17_handle_categoric_lambda1, 0, __pyx_n_s_validate_data_types_locals__hand, NULL, __pyx_n_s_validator, __pyx_d, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1112, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1112, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_is_categoric = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":1113
 *     def _handle_categoric(data, return_data):
 *         is_categoric = data.apply(lambda x: isinstance(x, (str, pd.CategoricalDtype)))
 *         if not is_categoric.all():             # <<<<<<<<<<<<<<
 *             if error == 'raise':
 *                 raise TypeError("Mixed types detected with unexpected numeric data.")
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_is_categoric, __pyx_n_s_all); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1113, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1113, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1113, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_6 = ((!__pyx_t_5) != 0);
  if (__pyx_t_6) {

    /* "validator.pyx":1114
 *         is_categoric = data.apply(lambda x: isinstance(x, (str, pd.CategoricalDtype)))
 *         if not is_categoric.all():
 *             if error == 'raise':             # <<<<<<<<<<<<<<
 *                 raise TypeError("Mixed types detected with unexpected numeric data.")
 *             elif error == 'warn':
 */
    if (unlikely(!__pyx_cur_scope->__pyx_v_error)) { __Pyx_RaiseClosureNameError("error"); __PYX_ERR(0, 1114, __pyx_L1_error) }
    __pyx_t_6 = (__Pyx_PyUnicode_Equals(__pyx_cur_scope->__pyx_v_error, __pyx_n_u_raise, Py_EQ)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 1114, __pyx_L1_error)
    if (unlikely(__pyx_t_6)) {

      /* "validator.pyx":1115
 *         if not is_categoric.all():
 *             if error == 'raise':
 *                 raise TypeError("Mixed types detected with unexpected numeric data.")             # <<<<<<<<<<<<<<
 *             elif error == 'warn':
 *                 warnings.warn("Expected categoric types but found numeric data.")
 */
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__31, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1115, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 1115, __pyx_L1_error)

      /* "validator.pyx":1114
 *         is_categoric = data.apply(lambda x: isinstance(x, (str, pd.CategoricalDtype)))
 *         if not is_categoric.all():
 *             if error == 'raise':             # <<<<<<<<<<<<<<
 *                 raise TypeError("Mixed types detected with unexpected numeric data.")
 *             elif error == 'warn':
 */
    }

    /* "validator.pyx":1116
 *             if error == 'raise':
 *                 raise TypeError("Mixed types detected with unexpected numeric data.")
 *             elif error == 'warn':             # <<<<<<<<<<<<<<
 *                 warnings.warn("Expected categoric types but found numeric data.")
 *                 if return_data:
 */
    if (unlikely(!__pyx_cur_scope->__pyx_v_error)) { __Pyx_RaiseClosureNameError("error"); __PYX_ERR(0, 1116, __pyx_L1_error) }
    __pyx_t_6 = (__Pyx_PyUnicode_Equals(__pyx_cur_scope->__pyx_v_error, __pyx_n_u_warn, Py_EQ)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 1116, __pyx_L1_error)
    if (__pyx_t_6) {

      /* "validator.pyx":1117
 *                 raise TypeError("Mixed types detected with unexpected numeric data.")
 *             elif error == 'warn':
 *                 warnings.warn("Expected categoric types but found numeric data.")             # <<<<<<<<<<<<<<
 *                 if return_data:
 *                     return data[is_categoric]
 */
      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_warnings); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1117, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_warn); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1117, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_2 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_2)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_2);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_kp_u_Expected_categoric_types_but_fou) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_u_Expected_categoric_types_but_fou);
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1117, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "validator.pyx":1118
 *             elif error == 'warn':
 *                 warnings.warn("Expected categoric types but found numeric data.")
 *                 if return_data:             # <<<<<<<<<<<<<<
 *                     return data[is_categoric]
 *         return data[is_categoric] if return_data else None
 */
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_return_data); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 1118, __pyx_L1_error)
      if (__pyx_t_6) {

        /* "validator.pyx":1119
 *                 warnings.warn("Expected categoric types but found numeric data.")
 *                 if return_data:
 *                     return data[is_categoric]             # <<<<<<<<<<<<<<
 *         return data[is_categoric] if return_data else None
 * 
 */
        __Pyx_XDECREF(__pyx_r);
        __pyx_t_1 = __Pyx_PyObject_GetItem(__pyx_v_data, __pyx_v_is_categoric); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1119, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_r = __pyx_t_1;
        __pyx_t_1 = 0;
        goto __pyx_L0;

        /* "validator.pyx":1118
 *             elif error == 'warn':
 *                 warnings.warn("Expected categoric types but found numeric data.")
 *                 if return_data:             # <<<<<<<<<<<<<<
 *                     return data[is_categoric]
 *         return data[is_categoric] if return_data else None
 */
      }

      /* "validator.pyx":1116
 *             if error == 'raise':
 *                 raise TypeError("Mixed types detected with unexpected numeric data.")
 *             elif error == 'warn':             # <<<<<<<<<<<<<<
 *                 warnings.warn("Expected categoric types but found numeric data.")
 *                 if return_data:
 */
    }

    /* "validator.pyx":1113
 *     def _handle_categoric(data, return_data):
 *         is_categoric = data.apply(lambda x: isinstance(x, (str, pd.CategoricalDtype)))
 *         if not is_categoric.all():             # <<<<<<<<<<<<<<
 *             if error == 'raise':
 *                 raise TypeError("Mixed types detected with unexpected numeric data.")
 */
  }

  /* "validator.pyx":1120
 *                 if return_data:
 *                     return data[is_categoric]
 *         return data[is_categoric] if return_data else None             # <<<<<<<<<<<<<<
 * 
 *     results = pd.DataFrame()
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_return_data); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 1120, __pyx_L1_error)
  if (__pyx_t_6) {
    __pyx_t_3 = __Pyx_PyObject_GetItem(__pyx_v_data, __pyx_v_is_categoric); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1120, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_1 = __pyx_t_3;
    __pyx_t_3 = 0;
  } else {
    __Pyx_INCREF(Py_None);
    __pyx_t_1 = Py_None;
  }
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "validator.pyx":1111
 *         return data[is_numeric] if return_data else None
 * 
 *     def _handle_categoric(data, return_data):             # <<<<<<<<<<<<<<
 *         is_categoric = data.apply(lambda x: isinstance(x, (str, pd.CategoricalDtype)))
 *         if not is_categoric.all():
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("validator.validate_data_types._handle_categoric", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_is_categoric);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":999
 *     return df
 * 
 * def validate_data_types(             # <<<<<<<<<<<<<<
 *     data, expected_type='numeric',
 *     nan_policy='omit',
 */

static PyObject *__pyx_pf_9validator_26validate_data_types(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_expected_type, PyObject *__pyx_v_nan_policy, PyObject *__pyx_v_return_data, PyObject *__pyx_v_error) {
  struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types *__pyx_cur_scope;
  PyObject *__pyx_v__handle_numeric = 0;
  PyObject *__pyx_v__handle_categoric = 0;
  PyObject *__pyx_v_results = NULL;
  PyObject *__pyx_v_column = NULL;
  PyObject *__pyx_v_col_data = NULL;
  PyObject *__pyx_v_result = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  Py_ssize_t __pyx_t_9;
  PyObject *(*__pyx_t_10)(PyObject *);
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validate_data_types", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types *)__pyx_tp_new_9validator___pyx_scope_struct_2_validate_data_types(__pyx_ptype_9validator___pyx_scope_struct_2_validate_data_types, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 999, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_v_error = __pyx_v_error;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_error);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_error);
  __Pyx_INCREF(__pyx_v_data);
  __Pyx_INCREF(__pyx_v_expected_type);
  __Pyx_INCREF(__pyx_v_nan_policy);

  /* "validator.pyx":1079
 *     on can prevent issues in model training and evaluation.
 *     """
 *     expected_type= parameter_validator(             # <<<<<<<<<<<<<<
 *         "expected_type", target_strs={"numeric", "categoric", "both"},
 *         )(expected_type)
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_parameter_validator); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1079, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);

  /* "validator.pyx":1080
 *     """
 *     expected_type= parameter_validator(
 *         "expected_type", target_strs={"numeric", "categoric", "both"},             # <<<<<<<<<<<<<<
 *         )(expected_type)
 * 
 */
  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1080, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = PySet_New(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1080, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PySet_Add(__pyx_t_4, __pyx_n_u_numeric) < 0) __PYX_ERR(0, 1080, __pyx_L1_error)
  if (PySet_Add(__pyx_t_4, __pyx_n_u_categoric) < 0) __PYX_ERR(0, 1080, __pyx_L1_error)
  if (PySet_Add(__pyx_t_4, __pyx_n_u_both) < 0) __PYX_ERR(0, 1080, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_target_strs, __pyx_t_4) < 0) __PYX_ERR(0, 1080, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "validator.pyx":1079
 *     on can prevent issues in model training and evaluation.
 *     """
 *     expected_type= parameter_validator(             # <<<<<<<<<<<<<<
 *         "expected_type", target_strs={"numeric", "categoric", "both"},
 *         )(expected_type)
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__32, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1079, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "validator.pyx":1081
 *     expected_type= parameter_validator(
 *         "expected_type", target_strs={"numeric", "categoric", "both"},
 *         )(expected_type)             # <<<<<<<<<<<<<<
 * 
 *     if not isinstance ( data, (pd.Series, pd.DataFrame)):
 */
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_3, __pyx_v_expected_type) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_expected_type);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1081, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF_SET(__pyx_v_expected_type, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":1083
 *         )(expected_type)
 * 
 *     if not isinstance ( data, (pd.Series, pd.DataFrame)):             # <<<<<<<<<<<<<<
 *         data = build_data_if(data, raise_exception=True, force=True,
 *                              input_name="feature")
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pd); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1083, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_Series); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1083, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pd); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1083, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_DataFrame); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1083, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_6 = PyObject_IsInstance(__pyx_v_data, __pyx_t_4); 
  __pyx_t_7 = (__pyx_t_6 != 0);
  if (!__pyx_t_7) {
  } else {
    __pyx_t_5 = __pyx_t_7;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_7 = PyObject_IsInstance(__pyx_v_data, __pyx_t_3); 
  __pyx_t_6 = (__pyx_t_7 != 0);
  __pyx_t_5 = __pyx_t_6;
  __pyx_L4_bool_binop_done:;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_6 = ((!(__pyx_t_5 != 0)) != 0);
  if (__pyx_t_6) {

    /* "validator.pyx":1084
 * 
 *     if not isinstance ( data, (pd.Series, pd.DataFrame)):
 *         data = build_data_if(data, raise_exception=True, force=True,             # <<<<<<<<<<<<<<
 *                              input_name="feature")
 * 
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_build_data_if); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1084, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1084, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_v_data);
    __Pyx_GIVEREF(__pyx_v_data);
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_data);
    __pyx_t_1 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1084, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_raise_exception, Py_True) < 0) __PYX_ERR(0, 1084, __pyx_L1_error)
    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_force, Py_True) < 0) __PYX_ERR(0, 1084, __pyx_L1_error)
    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_input_name, __pyx_n_u_feature) < 0) __PYX_ERR(0, 1084, __pyx_L1_error)
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_3, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1084, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_2);
    __pyx_t_2 = 0;

    /* "validator.pyx":1083
 *         )(expected_type)
 * 
 *     if not isinstance ( data, (pd.Series, pd.DataFrame)):             # <<<<<<<<<<<<<<
 *         data = build_data_if(data, raise_exception=True, force=True,
 *                              input_name="feature")
 */
  }

  /* "validator.pyx":1087
 *                              input_name="feature")
 * 
 *     if isinstance(data, pd.Series):             # <<<<<<<<<<<<<<
 *         data = data.to_frame()
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_pd); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1087, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_Series); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1087, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_6 = PyObject_IsInstance(__pyx_v_data, __pyx_t_1); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(0, 1087, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = (__pyx_t_6 != 0);
  if (__pyx_t_5) {

    /* "validator.pyx":1088
 * 
 *     if isinstance(data, pd.Series):
 *         data = data.to_frame()             # <<<<<<<<<<<<<<
 * 
 *     # Handle NaN values according to the nan_policy
 */
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_to_frame); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1088, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1088, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "validator.pyx":1087
 *                              input_name="feature")
 * 
 *     if isinstance(data, pd.Series):             # <<<<<<<<<<<<<<
 *         data = data.to_frame()
 * 
 */
  }

  /* "validator.pyx":1091
 * 
 *     # Handle NaN values according to the nan_policy
 *     nan_policy= is_valid_policies(nan_policy)             # <<<<<<<<<<<<<<
 *     if nan_policy == 'raise' and data.isnull().any().any():
 *         raise ValueError("NaN values found in the data.")
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_is_valid_policies); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1091, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_nan_policy) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_nan_policy);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1091, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF_SET(__pyx_v_nan_policy, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":1092
 *     # Handle NaN values according to the nan_policy
 *     nan_policy= is_valid_policies(nan_policy)
 *     if nan_policy == 'raise' and data.isnull().any().any():             # <<<<<<<<<<<<<<
 *         raise ValueError("NaN values found in the data.")
 *     elif nan_policy == 'propagate' and data.isnull().any().any():
 */
  __pyx_t_6 = (__Pyx_PyUnicode_Equals(__pyx_v_nan_policy, __pyx_n_u_raise, Py_EQ)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 1092, __pyx_L1_error)
  if (__pyx_t_6) {
  } else {
    __pyx_t_5 = __pyx_t_6;
    goto __pyx_L8_bool_binop_done;
  }
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_isnull); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1092, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_8 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_8)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_8);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  __pyx_t_3 = (__pyx_t_8) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_8) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1092, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_any); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1092, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1092, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_any); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1092, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_2) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1092, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 1092, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = __pyx_t_6;
  __pyx_L8_bool_binop_done:;
  if (unlikely(__pyx_t_5)) {

    /* "validator.pyx":1093
 *     nan_policy= is_valid_policies(nan_policy)
 *     if nan_policy == 'raise' and data.isnull().any().any():
 *         raise ValueError("NaN values found in the data.")             # <<<<<<<<<<<<<<
 *     elif nan_policy == 'propagate' and data.isnull().any().any():
 *         warnings.warn("NaN values found in the data, but processing will continue.")
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__33, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1093, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 1093, __pyx_L1_error)

    /* "validator.pyx":1092
 *     # Handle NaN values according to the nan_policy
 *     nan_policy= is_valid_policies(nan_policy)
 *     if nan_policy == 'raise' and data.isnull().any().any():             # <<<<<<<<<<<<<<
 *         raise ValueError("NaN values found in the data.")
 *     elif nan_policy == 'propagate' and data.isnull().any().any():
 */
  }

  /* "validator.pyx":1094
 *     if nan_policy == 'raise' and data.isnull().any().any():
 *         raise ValueError("NaN values found in the data.")
 *     elif nan_policy == 'propagate' and data.isnull().any().any():             # <<<<<<<<<<<<<<
 *         warnings.warn("NaN values found in the data, but processing will continue.")
 * 
 */
  __pyx_t_6 = (__Pyx_PyUnicode_Equals(__pyx_v_nan_policy, __pyx_n_u_propagate, Py_EQ)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 1094, __pyx_L1_error)
  if (__pyx_t_6) {
  } else {
    __pyx_t_5 = __pyx_t_6;
    goto __pyx_L10_bool_binop_done;
  }
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_isnull); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1094, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_8 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_8)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_8);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_2 = (__pyx_t_8) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_8) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1094, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_any); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1094, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_4 = (__pyx_t_2) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1094, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_any); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1094, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1094, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 1094, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = __pyx_t_6;
  __pyx_L10_bool_binop_done:;
  if (__pyx_t_5) {

    /* "validator.pyx":1095
 *         raise ValueError("NaN values found in the data.")
 *     elif nan_policy == 'propagate' and data.isnull().any().any():
 *         warnings.warn("NaN values found in the data, but processing will continue.")             # <<<<<<<<<<<<<<
 * 
 *     def _handle_numeric(data, return_data):
 */
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_warnings); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1095, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_warn); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1095, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_3, __pyx_kp_u_NaN_values_found_in_the_data_but) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_kp_u_NaN_values_found_in_the_data_but);
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1095, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "validator.pyx":1094
 *     if nan_policy == 'raise' and data.isnull().any().any():
 *         raise ValueError("NaN values found in the data.")
 *     elif nan_policy == 'propagate' and data.isnull().any().any():             # <<<<<<<<<<<<<<
 *         warnings.warn("NaN values found in the data, but processing will continue.")
 * 
 */
  }

  /* "validator.pyx":1097
 *         warnings.warn("NaN values found in the data, but processing will continue.")
 * 
 *     def _handle_numeric(data, return_data):             # <<<<<<<<<<<<<<
 *         is_numeric = pd.to_numeric(data, errors='coerce').notna()
 *         if not is_numeric.all():
 */
  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_9validator_19validate_data_types_1_handle_numeric, 0, __pyx_n_s_validate_data_types_locals__hand_2, ((PyObject*)__pyx_cur_scope), __pyx_n_s_validator, __pyx_d, ((PyObject *)__pyx_codeobj__35)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1097, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v__handle_numeric = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":1111
 *         return data[is_numeric] if return_data else None
 * 
 *     def _handle_categoric(data, return_data):             # <<<<<<<<<<<<<<
 *         is_categoric = data.apply(lambda x: isinstance(x, (str, pd.CategoricalDtype)))
 *         if not is_categoric.all():
 */
  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_9validator_19validate_data_types_3_handle_categoric, 0, __pyx_n_s_validate_data_types_locals__hand_3, ((PyObject*)__pyx_cur_scope), __pyx_n_s_validator, __pyx_d, ((PyObject *)__pyx_codeobj__37)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1111, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v__handle_categoric = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":1122
 *         return data[is_categoric] if return_data else None
 * 
 *     results = pd.DataFrame()             # <<<<<<<<<<<<<<
 * 
 *     for column in data.columns:
 */
  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_pd); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1122, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_DataFrame); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1122, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1122, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_results = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":1124
 *     results = pd.DataFrame()
 * 
 *     for column in data.columns:             # <<<<<<<<<<<<<<
 *         col_data = data[column]
 *         if expected_type == 'numeric':
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_columns); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1124, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (likely(PyList_CheckExact(__pyx_t_1)) || PyTuple_CheckExact(__pyx_t_1)) {
    __pyx_t_3 = __pyx_t_1; __Pyx_INCREF(__pyx_t_3); __pyx_t_9 = 0;
    __pyx_t_10 = NULL;
  } else {
    __pyx_t_9 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1124, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_10 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 1124, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  for (;;) {
    if (likely(!__pyx_t_10)) {
      if (likely(PyList_CheckExact(__pyx_t_3))) {
        if (__pyx_t_9 >= PyList_GET_SIZE(__pyx_t_3)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_1 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_9); __Pyx_INCREF(__pyx_t_1); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 1124, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_3, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1124, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      } else {
        if (__pyx_t_9 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_9); __Pyx_INCREF(__pyx_t_1); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 1124, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_3, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1124, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      }
    } else {
      __pyx_t_1 = __pyx_t_10(__pyx_t_3);
      if (unlikely(!__pyx_t_1)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 1124, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_1);
    }
    __Pyx_XDECREF_SET(__pyx_v_column, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "validator.pyx":1125
 * 
 *     for column in data.columns:
 *         col_data = data[column]             # <<<<<<<<<<<<<<
 *         if expected_type == 'numeric':
 *             result = _handle_numeric(col_data, return_data)
 */
    __pyx_t_1 = __Pyx_PyObject_GetItem(__pyx_v_data, __pyx_v_column); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1125, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_XDECREF_SET(__pyx_v_col_data, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "validator.pyx":1126
 *     for column in data.columns:
 *         col_data = data[column]
 *         if expected_type == 'numeric':             # <<<<<<<<<<<<<<
 *             result = _handle_numeric(col_data, return_data)
 *         elif expected_type == 'categoric':
 */
    __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_expected_type, __pyx_n_u_numeric, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1126, __pyx_L1_error)
    if (__pyx_t_5) {

      /* "validator.pyx":1127
 *         col_data = data[column]
 *         if expected_type == 'numeric':
 *             result = _handle_numeric(col_data, return_data)             # <<<<<<<<<<<<<<
 *         elif expected_type == 'categoric':
 *             result = _handle_categoric(col_data, return_data)
 */
      __pyx_t_1 = __pyx_pf_9validator_19validate_data_types__handle_numeric(__pyx_v__handle_numeric, __pyx_v_col_data, __pyx_v_return_data); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1127, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_XDECREF_SET(__pyx_v_result, __pyx_t_1);
      __pyx_t_1 = 0;

      /* "validator.pyx":1126
 *     for column in data.columns:
 *         col_data = data[column]
 *         if expected_type == 'numeric':             # <<<<<<<<<<<<<<
 *             result = _handle_numeric(col_data, return_data)
 *         elif expected_type == 'categoric':
 */
      goto __pyx_L14;
    }

    /* "validator.pyx":1128
 *         if expected_type == 'numeric':
 *             result = _handle_numeric(col_data, return_data)
 *         elif expected_type == 'categoric':             # <<<<<<<<<<<<<<
 *             result = _handle_categoric(col_data, return_data)
 *         elif expected_type == 'both':
 */
    __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_expected_type, __pyx_n_u_categoric, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1128, __pyx_L1_error)
    if (__pyx_t_5) {

      /* "validator.pyx":1129
 *             result = _handle_numeric(col_data, return_data)
 *         elif expected_type == 'categoric':
 *             result = _handle_categoric(col_data, return_data)             # <<<<<<<<<<<<<<
 *         elif expected_type == 'both':
 *             if error == 'warn':
 */
      __pyx_t_1 = __pyx_pf_9validator_19validate_data_types_2_handle_categoric(__pyx_v__handle_categoric, __pyx_v_col_data, __pyx_v_return_data); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1129, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_XDECREF_SET(__pyx_v_result, __pyx_t_1);
      __pyx_t_1 = 0;

      /* "validator.pyx":1128
 *         if expected_type == 'numeric':
 *             result = _handle_numeric(col_data, return_data)
 *         elif expected_type == 'categoric':             # <<<<<<<<<<<<<<
 *             result = _handle_categoric(col_data, return_data)
 *         elif expected_type == 'both':
 */
      goto __pyx_L14;
    }

    /* "validator.pyx":1130
 *         elif expected_type == 'categoric':
 *             result = _handle_categoric(col_data, return_data)
 *         elif expected_type == 'both':             # <<<<<<<<<<<<<<
 *             if error == 'warn':
 *                 warnings.warn(
 */
    __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_expected_type, __pyx_n_u_both, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1130, __pyx_L1_error)
    if (likely(__pyx_t_5)) {

      /* "validator.pyx":1131
 *             result = _handle_categoric(col_data, return_data)
 *         elif expected_type == 'both':
 *             if error == 'warn':             # <<<<<<<<<<<<<<
 *                 warnings.warn(
 *                     "Mixed data types found. Be cautious of unintended data type issues.")
 */
      __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_cur_scope->__pyx_v_error, __pyx_n_u_warn, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1131, __pyx_L1_error)
      if (__pyx_t_5) {

        /* "validator.pyx":1132
 *         elif expected_type == 'both':
 *             if error == 'warn':
 *                 warnings.warn(             # <<<<<<<<<<<<<<
 *                     "Mixed data types found. Be cautious of unintended data type issues.")
 *             result = col_data if return_data else None
 */
        __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_warnings); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1132, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_warn); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1132, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_2, function);
          }
        }
        __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_kp_u_Mixed_data_types_found_Be_cautio) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_kp_u_Mixed_data_types_found_Be_cautio);
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1132, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "validator.pyx":1131
 *             result = _handle_categoric(col_data, return_data)
 *         elif expected_type == 'both':
 *             if error == 'warn':             # <<<<<<<<<<<<<<
 *                 warnings.warn(
 *                     "Mixed data types found. Be cautious of unintended data type issues.")
 */
      }

      /* "validator.pyx":1134
 *                 warnings.warn(
 *                     "Mixed data types found. Be cautious of unintended data type issues.")
 *             result = col_data if return_data else None             # <<<<<<<<<<<<<<
 *         else:
 *             raise ValueError("Unsupported expected_type provided. Choose"
 */
      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_v_return_data); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1134, __pyx_L1_error)
      if (__pyx_t_5) {
        __Pyx_INCREF(__pyx_v_col_data);
        __pyx_t_1 = __pyx_v_col_data;
      } else {
        __Pyx_INCREF(Py_None);
        __pyx_t_1 = Py_None;
      }
      __Pyx_XDECREF_SET(__pyx_v_result, __pyx_t_1);
      __pyx_t_1 = 0;

      /* "validator.pyx":1130
 *         elif expected_type == 'categoric':
 *             result = _handle_categoric(col_data, return_data)
 *         elif expected_type == 'both':             # <<<<<<<<<<<<<<
 *             if error == 'warn':
 *                 warnings.warn(
 */
      goto __pyx_L14;
    }

    /* "validator.pyx":1136
 *             result = col_data if return_data else None
 *         else:
 *             raise ValueError("Unsupported expected_type provided. Choose"             # <<<<<<<<<<<<<<
 *                              " 'numeric', 'categoric', or 'both'.")
 * 
 */
    /*else*/ {
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__38, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1136, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 1136, __pyx_L1_error)
    }
    __pyx_L14:;

    /* "validator.pyx":1139
 *                              " 'numeric', 'categoric', or 'both'.")
 * 
 *         if return_data and result is not None:             # <<<<<<<<<<<<<<
 *             results[column] = result
 * 
 */
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_return_data); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 1139, __pyx_L1_error)
    if (__pyx_t_6) {
    } else {
      __pyx_t_5 = __pyx_t_6;
      goto __pyx_L17_bool_binop_done;
    }
    __pyx_t_6 = (__pyx_v_result != Py_None);
    __pyx_t_7 = (__pyx_t_6 != 0);
    __pyx_t_5 = __pyx_t_7;
    __pyx_L17_bool_binop_done:;
    if (__pyx_t_5) {

      /* "validator.pyx":1140
 * 
 *         if return_data and result is not None:
 *             results[column] = result             # <<<<<<<<<<<<<<
 * 
 *     return results if not results.empty else None
 */
      if (unlikely(PyObject_SetItem(__pyx_v_results, __pyx_v_column, __pyx_v_result) < 0)) __PYX_ERR(0, 1140, __pyx_L1_error)

      /* "validator.pyx":1139
 *                              " 'numeric', 'categoric', or 'both'.")
 * 
 *         if return_data and result is not None:             # <<<<<<<<<<<<<<
 *             results[column] = result
 * 
 */
    }

    /* "validator.pyx":1124
 *     results = pd.DataFrame()
 * 
 *     for column in data.columns:             # <<<<<<<<<<<<<<
 *         col_data = data[column]
 *         if expected_type == 'numeric':
 */
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "validator.pyx":1142
 *             results[column] = result
 * 
 *     return results if not results.empty else None             # <<<<<<<<<<<<<<
 * 
 * def ensure_2d(X, output_format="auto"):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_results, __pyx_n_s_empty); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1142, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1142, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (((!__pyx_t_5) != 0)) {
    __Pyx_INCREF(__pyx_v_results);
    __pyx_t_3 = __pyx_v_results;
  } else {
    __Pyx_INCREF(Py_None);
    __pyx_t_3 = Py_None;
  }
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "validator.pyx":999
 *     return df
 * 
 * def validate_data_types(             # <<<<<<<<<<<<<<
 *     data, expected_type='numeric',
 *     nan_policy='omit',
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("validator.validate_data_types", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v__handle_numeric);
  __Pyx_XDECREF(__pyx_v__handle_categoric);
  __Pyx_XDECREF(__pyx_v_results);
  __Pyx_XDECREF(__pyx_v_column);
  __Pyx_XDECREF(__pyx_v_col_data);
  __Pyx_XDECREF(__pyx_v_result);
  __Pyx_XDECREF(__pyx_v_data);
  __Pyx_XDECREF(__pyx_v_expected_type);
  __Pyx_XDECREF(__pyx_v_nan_policy);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1144
 *     return results if not results.empty else None
 * 
 * def ensure_2d(X, output_format="auto"):             # <<<<<<<<<<<<<<
 *     """
 *     Ensure that the input X is converted to a 2-dimensional structure.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_29ensure_2d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_28ensure_2d[] = "\n    Ensure that the input X is converted to a 2-dimensional structure.\n    \n    Parameters\n    ----------\n    X : array-like or pandas.DataFrame\n        The input data to convert. Can be a list, numpy array, or DataFrame.\n    output_format : str, optional\n        The format of the returned object. Options are \"auto\", \"array\", or \"frame\".\n        \"auto\" returns a DataFrame if X is a DataFrame, otherwise a numpy array.\n        \"array\" always returns a numpy array.\n        \"frame\" always returns a pandas DataFrame.\n        \n    Returns\n    -------\n    ndarray or DataFrame\n        The converted 2-dimensional structure, either as a numpy array or DataFrame.\n    \n    Raises\n    ------\n    ValueError\n        If the `output_format` is not one of the allowed values.\n    \n    Examples\n    --------\n    >>> import numpy as np \n    >>> from gofast.tools.validator import ensure_2d\n    >>> X = np.array([1, 2, 3])\n    >>> ensure_2d(X, output_format=\"array\")\n    array([[1],\n           [2],\n           [3]])\n    >>> df = pd.DataFrame([1, 2, 3])\n    >>> ensure_2d(df, output_format=\"frame\")\n       0\n    0  1\n    1  2\n    2  3\n    ";
static PyMethodDef __pyx_mdef_9validator_29ensure_2d = {"ensure_2d", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_29ensure_2d, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_28ensure_2d};
static PyObject *__pyx_pw_9validator_29ensure_2d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_X = 0;
  PyObject *__pyx_v_output_format = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ensure_2d (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_X,&__pyx_n_s_output_format,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_n_u_auto);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_X)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_output_format);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "ensure_2d") < 0)) __PYX_ERR(0, 1144, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_X = values[0];
    __pyx_v_output_format = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ensure_2d", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1144, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.ensure_2d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_28ensure_2d(__pyx_self, __pyx_v_X, __pyx_v_output_format);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_28ensure_2d(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X, PyObject *__pyx_v_output_format) {
  int __pyx_v_is_dataframe;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ensure_2d", 0);
  __Pyx_INCREF(__pyx_v_X);
  __Pyx_INCREF(__pyx_v_output_format);

  /* "validator.pyx":1185
 *     """
 *     # Check for allowed output_format values
 *     output_format= parameter_validator(             # <<<<<<<<<<<<<<
 *         "output_format", target_strs=["auto", "array", "frame"]
 *         ) (output_format)
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_parameter_validator); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1185, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);

  /* "validator.pyx":1186
 *     # Check for allowed output_format values
 *     output_format= parameter_validator(
 *         "output_format", target_strs=["auto", "array", "frame"]             # <<<<<<<<<<<<<<
 *         ) (output_format)
 * 
 */
  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1186, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = PyList_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1186, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_INCREF(__pyx_n_u_auto);
  __Pyx_GIVEREF(__pyx_n_u_auto);
  PyList_SET_ITEM(__pyx_t_4, 0, __pyx_n_u_auto);
  __Pyx_INCREF(__pyx_n_u_array);
  __Pyx_GIVEREF(__pyx_n_u_array);
  PyList_SET_ITEM(__pyx_t_4, 1, __pyx_n_u_array);
  __Pyx_INCREF(__pyx_n_u_frame);
  __Pyx_GIVEREF(__pyx_n_u_frame);
  PyList_SET_ITEM(__pyx_t_4, 2, __pyx_n_u_frame);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_target_strs, __pyx_t_4) < 0) __PYX_ERR(0, 1186, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "validator.pyx":1185
 *     """
 *     # Check for allowed output_format values
 *     output_format= parameter_validator(             # <<<<<<<<<<<<<<
 *         "output_format", target_strs=["auto", "array", "frame"]
 *         ) (output_format)
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__39, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1185, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "validator.pyx":1187
 *     output_format= parameter_validator(
 *         "output_format", target_strs=["auto", "array", "frame"]
 *         ) (output_format)             # <<<<<<<<<<<<<<
 * 
 *     # Detect if the input is a DataFrame
 */
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_3, __pyx_v_output_format) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_output_format);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1187, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF_SET(__pyx_v_output_format, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":1190
 * 
 *     # Detect if the input is a DataFrame
 *     is_dataframe = isinstance(X, pd.DataFrame)             # <<<<<<<<<<<<<<
 * 
 *     # Ensure X is at least 2-dimensional
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pd); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1190, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_DataFrame); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1190, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = PyObject_IsInstance(__pyx_v_X, __pyx_t_4); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(0, 1190, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_v_is_dataframe = __pyx_t_5;

  /* "validator.pyx":1193
 * 
 *     # Ensure X is at least 2-dimensional
 *     if isinstance(X, np.ndarray):             # <<<<<<<<<<<<<<
 *         if X.ndim == 1:
 *             X = X[:, np.newaxis]
 */
  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1193, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_ndarray); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1193, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_5 = PyObject_IsInstance(__pyx_v_X, __pyx_t_1); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(0, 1193, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_6 = (__pyx_t_5 != 0);
  if (__pyx_t_6) {

    /* "validator.pyx":1194
 *     # Ensure X is at least 2-dimensional
 *     if isinstance(X, np.ndarray):
 *         if X.ndim == 1:             # <<<<<<<<<<<<<<
 *             X = X[:, np.newaxis]
 *     elif isinstance(X, pd.DataFrame):
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1194, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = __Pyx_PyInt_EqObjC(__pyx_t_1, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1194, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 1194, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (__pyx_t_6) {

      /* "validator.pyx":1195
 *     if isinstance(X, np.ndarray):
 *         if X.ndim == 1:
 *             X = X[:, np.newaxis]             # <<<<<<<<<<<<<<
 *     elif isinstance(X, pd.DataFrame):
 *         if X.shape[1] == 0:  # Implies an empty DataFrame or misshapen
 */
      __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1195, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_newaxis); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1195, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1195, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_INCREF(__pyx_slice__40);
      __Pyx_GIVEREF(__pyx_slice__40);
      PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_slice__40);
      __Pyx_GIVEREF(__pyx_t_1);
      PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_1);
      __pyx_t_1 = 0;
      __pyx_t_1 = __Pyx_PyObject_GetItem(__pyx_v_X, __pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1195, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_1);
      __pyx_t_1 = 0;

      /* "validator.pyx":1194
 *     # Ensure X is at least 2-dimensional
 *     if isinstance(X, np.ndarray):
 *         if X.ndim == 1:             # <<<<<<<<<<<<<<
 *             X = X[:, np.newaxis]
 *     elif isinstance(X, pd.DataFrame):
 */
    }

    /* "validator.pyx":1193
 * 
 *     # Ensure X is at least 2-dimensional
 *     if isinstance(X, np.ndarray):             # <<<<<<<<<<<<<<
 *         if X.ndim == 1:
 *             X = X[:, np.newaxis]
 */
    goto __pyx_L3;
  }

  /* "validator.pyx":1196
 *         if X.ndim == 1:
 *             X = X[:, np.newaxis]
 *     elif isinstance(X, pd.DataFrame):             # <<<<<<<<<<<<<<
 *         if X.shape[1] == 0:  # Implies an empty DataFrame or misshapen
 *             X = X.values.reshape(-1, 1)  # reshape and handle as array
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pd); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1196, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_DataFrame); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1196, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_6 = PyObject_IsInstance(__pyx_v_X, __pyx_t_4); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(0, 1196, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_5 = (__pyx_t_6 != 0);
  if (__pyx_t_5) {

    /* "validator.pyx":1197
 *             X = X[:, np.newaxis]
 *     elif isinstance(X, pd.DataFrame):
 *         if X.shape[1] == 0:  # Implies an empty DataFrame or misshapen             # <<<<<<<<<<<<<<
 *             X = X.values.reshape(-1, 1)  # reshape and handle as array
 *             is_dataframe = False
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1197, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_1 = __Pyx_GetItemInt(__pyx_t_4, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1197, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyInt_EqObjC(__pyx_t_1, __pyx_int_0, 0, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1197, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1197, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (__pyx_t_5) {

      /* "validator.pyx":1198
 *     elif isinstance(X, pd.DataFrame):
 *         if X.shape[1] == 0:  # Implies an empty DataFrame or misshapen
 *             X = X.values.reshape(-1, 1)  # reshape and handle as array             # <<<<<<<<<<<<<<
 *             is_dataframe = False
 *     else:
 */
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_values); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1198, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_reshape); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1198, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1198, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_4);
      __pyx_t_4 = 0;

      /* "validator.pyx":1199
 *         if X.shape[1] == 0:  # Implies an empty DataFrame or misshapen
 *             X = X.values.reshape(-1, 1)  # reshape and handle as array
 *             is_dataframe = False             # <<<<<<<<<<<<<<
 *     else:
 *         X = np.array(X)  # Convert other types like lists to np.array
 */
      __pyx_v_is_dataframe = 0;

      /* "validator.pyx":1197
 *             X = X[:, np.newaxis]
 *     elif isinstance(X, pd.DataFrame):
 *         if X.shape[1] == 0:  # Implies an empty DataFrame or misshapen             # <<<<<<<<<<<<<<
 *             X = X.values.reshape(-1, 1)  # reshape and handle as array
 *             is_dataframe = False
 */
    }

    /* "validator.pyx":1196
 *         if X.ndim == 1:
 *             X = X[:, np.newaxis]
 *     elif isinstance(X, pd.DataFrame):             # <<<<<<<<<<<<<<
 *         if X.shape[1] == 0:  # Implies an empty DataFrame or misshapen
 *             X = X.values.reshape(-1, 1)  # reshape and handle as array
 */
    goto __pyx_L3;
  }

  /* "validator.pyx":1201
 *             is_dataframe = False
 *     else:
 *         X = np.array(X)  # Convert other types like lists to np.array             # <<<<<<<<<<<<<<
 *         if X.ndim == 1:
 *             X = X[:, np.newaxis]
 */
  /*else*/ {
    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1201, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_array); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1201, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_1)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    __pyx_t_4 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_1, __pyx_v_X) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_X);
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1201, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "validator.pyx":1202
 *     else:
 *         X = np.array(X)  # Convert other types like lists to np.array
 *         if X.ndim == 1:             # <<<<<<<<<<<<<<
 *             X = X[:, np.newaxis]
 * 
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_ndim); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1202, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = __Pyx_PyInt_EqObjC(__pyx_t_4, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1202, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1202, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (__pyx_t_5) {

      /* "validator.pyx":1203
 *         X = np.array(X)  # Convert other types like lists to np.array
 *         if X.ndim == 1:
 *             X = X[:, np.newaxis]             # <<<<<<<<<<<<<<
 * 
 *     # Decide on return type based on output_format
 */
      __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1203, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_newaxis); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1203, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1203, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_INCREF(__pyx_slice__40);
      __Pyx_GIVEREF(__pyx_slice__40);
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_slice__40);
      __Pyx_GIVEREF(__pyx_t_4);
      PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_4);
      __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyObject_GetItem(__pyx_v_X, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1203, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_4);
      __pyx_t_4 = 0;

      /* "validator.pyx":1202
 *     else:
 *         X = np.array(X)  # Convert other types like lists to np.array
 *         if X.ndim == 1:             # <<<<<<<<<<<<<<
 *             X = X[:, np.newaxis]
 * 
 */
    }
  }
  __pyx_L3:;

  /* "validator.pyx":1206
 * 
 *     # Decide on return type based on output_format
 *     if output_format == "array":             # <<<<<<<<<<<<<<
 *         return X if isinstance(X, np.ndarray) else X.values
 *     elif output_format == "frame":
 */
  __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_output_format, __pyx_n_u_array, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1206, __pyx_L1_error)
  if (__pyx_t_5) {

    /* "validator.pyx":1207
 *     # Decide on return type based on output_format
 *     if output_format == "array":
 *         return X if isinstance(X, np.ndarray) else X.values             # <<<<<<<<<<<<<<
 *     elif output_format == "frame":
 *         return pd.DataFrame(X) if not is_dataframe else X
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1207, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_ndarray); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1207, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_5 = PyObject_IsInstance(__pyx_v_X, __pyx_t_1); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(0, 1207, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if ((__pyx_t_5 != 0)) {
      __Pyx_INCREF(__pyx_v_X);
      __pyx_t_4 = __pyx_v_X;
    } else {
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_values); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1207, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_4 = __pyx_t_1;
      __pyx_t_1 = 0;
    }
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "validator.pyx":1206
 * 
 *     # Decide on return type based on output_format
 *     if output_format == "array":             # <<<<<<<<<<<<<<
 *         return X if isinstance(X, np.ndarray) else X.values
 *     elif output_format == "frame":
 */
  }

  /* "validator.pyx":1208
 *     if output_format == "array":
 *         return X if isinstance(X, np.ndarray) else X.values
 *     elif output_format == "frame":             # <<<<<<<<<<<<<<
 *         return pd.DataFrame(X) if not is_dataframe else X
 *     else:  # auto handling
 */
  __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_output_format, __pyx_n_u_frame, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1208, __pyx_L1_error)
  if (__pyx_t_5) {

    /* "validator.pyx":1209
 *         return X if isinstance(X, np.ndarray) else X.values
 *     elif output_format == "frame":
 *         return pd.DataFrame(X) if not is_dataframe else X             # <<<<<<<<<<<<<<
 *     else:  # auto handling
 *         if is_dataframe:
 */
    __Pyx_XDECREF(__pyx_r);
    if (((!(__pyx_v_is_dataframe != 0)) != 0)) {
      __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_pd); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1209, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_DataFrame); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1209, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
        __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
        if (likely(__pyx_t_3)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
          __Pyx_INCREF(__pyx_t_3);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_2, function);
        }
      }
      __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_X) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_X);
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1209, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_4 = __pyx_t_1;
      __pyx_t_1 = 0;
    } else {
      __Pyx_INCREF(__pyx_v_X);
      __pyx_t_4 = __pyx_v_X;
    }
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "validator.pyx":1208
 *     if output_format == "array":
 *         return X if isinstance(X, np.ndarray) else X.values
 *     elif output_format == "frame":             # <<<<<<<<<<<<<<
 *         return pd.DataFrame(X) if not is_dataframe else X
 *     else:  # auto handling
 */
  }

  /* "validator.pyx":1211
 *         return pd.DataFrame(X) if not is_dataframe else X
 *     else:  # auto handling
 *         if is_dataframe:             # <<<<<<<<<<<<<<
 *             return X
 *         return pd.DataFrame(X) if is_dataframe else X
 */
  /*else*/ {
    __pyx_t_5 = (__pyx_v_is_dataframe != 0);
    if (__pyx_t_5) {

      /* "validator.pyx":1212
 *     else:  # auto handling
 *         if is_dataframe:
 *             return X             # <<<<<<<<<<<<<<
 *         return pd.DataFrame(X) if is_dataframe else X
 * 
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_v_X);
      __pyx_r = __pyx_v_X;
      goto __pyx_L0;

      /* "validator.pyx":1211
 *         return pd.DataFrame(X) if not is_dataframe else X
 *     else:  # auto handling
 *         if is_dataframe:             # <<<<<<<<<<<<<<
 *             return X
 *         return pd.DataFrame(X) if is_dataframe else X
 */
    }

    /* "validator.pyx":1213
 *         if is_dataframe:
 *             return X
 *         return pd.DataFrame(X) if is_dataframe else X             # <<<<<<<<<<<<<<
 * 
 * def is_categorical(data, column, strict=False, error='raise'):
 */
    __Pyx_XDECREF(__pyx_r);
    if ((__pyx_v_is_dataframe != 0)) {
      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_pd); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1213, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_DataFrame); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1213, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_2 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_2)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_2);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_v_X) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_X);
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1213, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_4 = __pyx_t_1;
      __pyx_t_1 = 0;
    } else {
      __Pyx_INCREF(__pyx_v_X);
      __pyx_t_4 = __pyx_v_X;
    }
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;
  }

  /* "validator.pyx":1144
 *     return results if not results.empty else None
 * 
 * def ensure_2d(X, output_format="auto"):             # <<<<<<<<<<<<<<
 *     """
 *     Ensure that the input X is converted to a 2-dimensional structure.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("validator.ensure_2d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_X);
  __Pyx_XDECREF(__pyx_v_output_format);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1215
 *         return pd.DataFrame(X) if is_dataframe else X
 * 
 * def is_categorical(data, column, strict=False, error='raise'):             # <<<<<<<<<<<<<<
 *     """
 *     Checks if a specified column in a DataFrame or Series is of
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_31is_categorical(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_30is_categorical[] = "\n    Checks if a specified column in a DataFrame or Series is of \n    a categorical type.\n    \n    Parameters\n    ----------\n    data : DataFrame or Series\n        The DataFrame or Series to check.\n    column : str\n        The name of the column to check.\n    strict : bool, optional\n        If True, only considers pandas CategoricalDtype as categorical. If False,\n        also considers object dtype that often represents categorical data.\n        Default is False.\n    error : str, optional\n        Specifies how to handle situations when the column does not exist.\n        Options are 'raise', 'warn', or 'ignore'. Default is 'raise'.\n\n    Returns\n    -------\n    bool\n        True if the column is categorical, otherwise False.\n\n    Raises\n    ------\n    ValueError\n        If the column does not exist and error is set to 'raise'.\n\n    Examples\n    --------\n    >>> import pandas as pd \n    >>> from gofast.tools.validator import is_categorical\n    >>> df = pd.DataFrame({\n    ...     'fruit': ['Apple', 'Banana', 'Cherry'],\n    ...     'count': [10, 20, 15]\n    ... })\n    >>> df['fruit'] = df['fruit'].astype('category')\n    >>> print(is_categorical(df, 'fruit'))\n    True\n    >>> print(is_categorical(df, 'count'))\n    False\n    >>> print(is_categorical(df, 'non_existent', error='warn'))\n    Warning: Column 'non_existent' not found in the dataframe.\n    False\n    ";
static PyMethodDef __pyx_mdef_9validator_31is_categorical = {"is_categorical", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_31is_categorical, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_30is_categorical};
static PyObject *__pyx_pw_9validator_31is_categorical(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_data = 0;
  PyObject *__pyx_v_column = 0;
  PyObject *__pyx_v_strict = 0;
  PyObject *__pyx_v_error = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("is_categorical (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_data,&__pyx_n_s_column,&__pyx_n_s_strict,&__pyx_n_s_error,0};
    PyObject* values[4] = {0,0,0,0};
    values[2] = ((PyObject *)Py_False);
    values[3] = ((PyObject *)__pyx_n_u_raise);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_column)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("is_categorical", 0, 2, 4, 1); __PYX_ERR(0, 1215, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_strict);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_error);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "is_categorical") < 0)) __PYX_ERR(0, 1215, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_data = values[0];
    __pyx_v_column = values[1];
    __pyx_v_strict = values[2];
    __pyx_v_error = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("is_categorical", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1215, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.is_categorical", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_30is_categorical(__pyx_self, __pyx_v_data, __pyx_v_column, __pyx_v_strict, __pyx_v_error);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_30is_categorical(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_column, PyObject *__pyx_v_strict, PyObject *__pyx_v_error) {
  PyObject *__pyx_v_message = NULL;
  PyObject *__pyx_v_col_type = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  Py_ssize_t __pyx_t_4;
  Py_UCS4 __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("is_categorical", 0);

  /* "validator.pyx":1261
 *     False
 *     """
 *     if column not in data.columns:             # <<<<<<<<<<<<<<
 *         message = f"Column '{column}' not found in the dataframe."
 *         if error == 'raise':
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_columns); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1261, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_v_column, __pyx_t_1, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 1261, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (__pyx_t_3) {

    /* "validator.pyx":1262
 *     """
 *     if column not in data.columns:
 *         message = f"Column '{column}' not found in the dataframe."             # <<<<<<<<<<<<<<
 *         if error == 'raise':
 *             raise ValueError(message)
 */
    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1262, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = 0;
    __pyx_t_5 = 127;
    __Pyx_INCREF(__pyx_kp_u_Column);
    __pyx_t_4 += 8;
    __Pyx_GIVEREF(__pyx_kp_u_Column);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_Column);
    __pyx_t_6 = __Pyx_PyObject_FormatSimple(__pyx_v_column, __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1262, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_5 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) > __pyx_t_5) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) : __pyx_t_5;
    __pyx_t_4 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_6);
    __pyx_t_6 = 0;
    __Pyx_INCREF(__pyx_kp_u_not_found_in_the_dataframe);
    __pyx_t_4 += 29;
    __Pyx_GIVEREF(__pyx_kp_u_not_found_in_the_dataframe);
    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_not_found_in_the_dataframe);
    __pyx_t_6 = __Pyx_PyUnicode_Join(__pyx_t_1, 3, __pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1262, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_v_message = ((PyObject*)__pyx_t_6);
    __pyx_t_6 = 0;

    /* "validator.pyx":1263
 *     if column not in data.columns:
 *         message = f"Column '{column}' not found in the dataframe."
 *         if error == 'raise':             # <<<<<<<<<<<<<<
 *             raise ValueError(message)
 *         elif error == 'warn':
 */
    __pyx_t_3 = (__Pyx_PyUnicode_Equals(__pyx_v_error, __pyx_n_u_raise, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 1263, __pyx_L1_error)
    if (unlikely(__pyx_t_3)) {

      /* "validator.pyx":1264
 *         message = f"Column '{column}' not found in the dataframe."
 *         if error == 'raise':
 *             raise ValueError(message)             # <<<<<<<<<<<<<<
 *         elif error == 'warn':
 *             warnings.warn(message)
 */
      __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_v_message); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1264, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_Raise(__pyx_t_6, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __PYX_ERR(0, 1264, __pyx_L1_error)

      /* "validator.pyx":1263
 *     if column not in data.columns:
 *         message = f"Column '{column}' not found in the dataframe."
 *         if error == 'raise':             # <<<<<<<<<<<<<<
 *             raise ValueError(message)
 *         elif error == 'warn':
 */
    }

    /* "validator.pyx":1265
 *         if error == 'raise':
 *             raise ValueError(message)
 *         elif error == 'warn':             # <<<<<<<<<<<<<<
 *             warnings.warn(message)
 *         return False  # Return False if error is 'ignore' or 'warn' and column is not found
 */
    __pyx_t_3 = (__Pyx_PyUnicode_Equals(__pyx_v_error, __pyx_n_u_warn, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 1265, __pyx_L1_error)
    if (__pyx_t_3) {

      /* "validator.pyx":1266
 *             raise ValueError(message)
 *         elif error == 'warn':
 *             warnings.warn(message)             # <<<<<<<<<<<<<<
 *         return False  # Return False if error is 'ignore' or 'warn' and column is not found
 * 
 */
      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_warnings); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1266, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_warn); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1266, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_1 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
        __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_7);
        if (likely(__pyx_t_1)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
          __Pyx_INCREF(__pyx_t_1);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_7, function);
        }
      }
      __pyx_t_6 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_1, __pyx_v_message) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_v_message);
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1266, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

      /* "validator.pyx":1265
 *         if error == 'raise':
 *             raise ValueError(message)
 *         elif error == 'warn':             # <<<<<<<<<<<<<<
 *             warnings.warn(message)
 *         return False  # Return False if error is 'ignore' or 'warn' and column is not found
 */
    }

    /* "validator.pyx":1267
 *         elif error == 'warn':
 *             warnings.warn(message)
 *         return False  # Return False if error is 'ignore' or 'warn' and column is not found             # <<<<<<<<<<<<<<
 * 
 *     col_type = data[column].dtype
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    goto __pyx_L0;

    /* "validator.pyx":1261
 *     False
 *     """
 *     if column not in data.columns:             # <<<<<<<<<<<<<<
 *         message = f"Column '{column}' not found in the dataframe."
 *         if error == 'raise':
 */
  }

  /* "validator.pyx":1269
 *         return False  # Return False if error is 'ignore' or 'warn' and column is not found
 * 
 *     col_type = data[column].dtype             # <<<<<<<<<<<<<<
 *     if strict:
 *         return pd.api.types.is_categorical_dtype(col_type)
 */
  __pyx_t_6 = __Pyx_PyObject_GetItem(__pyx_v_data, __pyx_v_column); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1269, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_dtype); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1269, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_v_col_type = __pyx_t_7;
  __pyx_t_7 = 0;

  /* "validator.pyx":1270
 * 
 *     col_type = data[column].dtype
 *     if strict:             # <<<<<<<<<<<<<<
 *         return pd.api.types.is_categorical_dtype(col_type)
 *     else:
 */
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_strict); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 1270, __pyx_L1_error)
  if (__pyx_t_3) {

    /* "validator.pyx":1271
 *     col_type = data[column].dtype
 *     if strict:
 *         return pd.api.types.is_categorical_dtype(col_type)             # <<<<<<<<<<<<<<
 *     else:
 *         return pd.api.types.is_categorical_dtype(col_type) or pd.api.types.is_object_dtype(col_type)
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_pd); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1271, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_api); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1271, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_types); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1271, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_is_categorical_dtype); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1271, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    __pyx_t_7 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_6, __pyx_v_col_type) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_col_type);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1271, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_r = __pyx_t_7;
    __pyx_t_7 = 0;
    goto __pyx_L0;

    /* "validator.pyx":1270
 * 
 *     col_type = data[column].dtype
 *     if strict:             # <<<<<<<<<<<<<<
 *         return pd.api.types.is_categorical_dtype(col_type)
 *     else:
 */
  }

  /* "validator.pyx":1273
 *         return pd.api.types.is_categorical_dtype(col_type)
 *     else:
 *         return pd.api.types.is_categorical_dtype(col_type) or pd.api.types.is_object_dtype(col_type)             # <<<<<<<<<<<<<<
 * 
 * def parameter_validator(
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_pd); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1273, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_api); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1273, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_types); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1273, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_is_categorical_dtype); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1273, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_8))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_8);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_8, function);
      }
    }
    __pyx_t_1 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_8, __pyx_t_6, __pyx_v_col_type) : __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_v_col_type);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1273, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 1273, __pyx_L1_error)
    if (!__pyx_t_3) {
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    } else {
      __Pyx_INCREF(__pyx_t_1);
      __pyx_t_7 = __pyx_t_1;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L6_bool_binop_done;
    }
    __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_pd); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1273, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_api); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1273, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_types); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1273, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_is_object_dtype); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1273, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_8 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_6);
      if (likely(__pyx_t_8)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
        __Pyx_INCREF(__pyx_t_8);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_6, function);
      }
    }
    __pyx_t_1 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_8, __pyx_v_col_type) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_col_type);
    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1273, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_INCREF(__pyx_t_1);
    __pyx_t_7 = __pyx_t_1;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_L6_bool_binop_done:;
    __pyx_r = __pyx_t_7;
    __pyx_t_7 = 0;
    goto __pyx_L0;
  }

  /* "validator.pyx":1215
 *         return pd.DataFrame(X) if is_dataframe else X
 * 
 * def is_categorical(data, column, strict=False, error='raise'):             # <<<<<<<<<<<<<<
 *     """
 *     Checks if a specified column in a DataFrame or Series is of
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("validator.is_categorical", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_message);
  __Pyx_XDECREF(__pyx_v_col_type);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1275
 *         return pd.api.types.is_categorical_dtype(col_type) or pd.api.types.is_object_dtype(col_type)
 * 
 * def parameter_validator(             # <<<<<<<<<<<<<<
 *         param_name, target_strs, match_method='contains',
 *         raise_exception=True, **kws):
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_33parameter_validator(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_32parameter_validator[] = "\n    Creates a validator function for ensuring a parameter's value matches one \n    of the allowed target strings, optionally applying normalization.\n\n    This higher-order function returns a validator that can be used to check \n    if a given parameter value matches allowed criteria, optionally raising \n    an exception or normalizing the input.\n\n    Parameters\n    ----------\n    param_name : str\n        Name of the parameter to be validated. Used in error messages to \n        indicate which parameter failed validation.\n    target_strs : list of str\n        A list of acceptable string values for the parameter.\n    match_method : str, optional\n        The method used to match the input string against the target strings. \n        The default method is 'contains', which checks if the input string \n        contains any of the target strings.\n    raise_exception : bool, optional\n        Specifies whether an exception should be raised if validation fails. \n        Defaults to True, raising an exception on failure.\n    **kws: dict, \n       Keyword arguments passed to :func:`gofast.tools.coreutils.normalize_string`. \n    Returns\n    -------\n    function\n        A closure that takes a single string argument (the parameter value) \n        and returns a normalized version of it if the parameter matches the \n        target criteria. If the parameter does not match and `raise_exception` \n        is True, it raises an exception; otherwise, it returns the original value.\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import parameter_validator\n    >>> validate_outlier_method = parameter_validator(\n    ...  'outlier_method', ['z_score', 'iqr'])\n    >>> outlier_method = \"z_score\"\n    >>> print(validate_outlier_method(outlier_method))\n    'z_score'\n\n    >>> validate_fill_missing = parameter_validator(\n    ...  'fill_missing', ['median', 'mean', 'mode'], raise_exception=False)\n    >>> fill_missing = \"average\"  # This does"" not match but won't raise an exception.\n    >>> print(validate_fill_missing(fill_missing))\n    'average'\n\n    Notes\n    -----\n    - The function leverages a custom utility function `normalize_string` \n      from a module named `.coreutils`. This utility is assumed to handle \n      string normalization and matching based on the provided `match_method`.\n    - If `raise_exception` is set to False and the input does not match any \n      target string, the input string is returned unchanged. This behavior \n      allows for optional enforcement of the validation rules.\n    - The primary use case for this function is to validate and optionally \n      normalize parameters for configuration settings or function arguments \n      where only specific values are allowed.\n    ";
static PyMethodDef __pyx_mdef_9validator_33parameter_validator = {"parameter_validator", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_33parameter_validator, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_32parameter_validator};
static PyObject *__pyx_pw_9validator_33parameter_validator(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_param_name = 0;
  PyObject *__pyx_v_target_strs = 0;
  PyObject *__pyx_v_match_method = 0;
  PyObject *__pyx_v_raise_exception = 0;
  PyObject *__pyx_v_kws = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("parameter_validator (wrapper)", 0);
  __pyx_v_kws = PyDict_New(); if (unlikely(!__pyx_v_kws)) return NULL;
  __Pyx_GOTREF(__pyx_v_kws);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_param_name,&__pyx_n_s_target_strs,&__pyx_n_s_match_method,&__pyx_n_s_raise_exception,0};
    PyObject* values[4] = {0,0,0,0};
    values[2] = ((PyObject *)__pyx_n_u_contains);

    /* "validator.pyx":1277
 * def parameter_validator(
 *         param_name, target_strs, match_method='contains',
 *         raise_exception=True, **kws):             # <<<<<<<<<<<<<<
 *     """
 *     Creates a validator function for ensuring a parameter's value matches one
 */
    values[3] = ((PyObject *)Py_True);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_param_name)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_target_strs)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("parameter_validator", 0, 2, 4, 1); __PYX_ERR(0, 1275, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_match_method);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_raise_exception);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kws, values, pos_args, "parameter_validator") < 0)) __PYX_ERR(0, 1275, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_param_name = values[0];
    __pyx_v_target_strs = values[1];
    __pyx_v_match_method = values[2];
    __pyx_v_raise_exception = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("parameter_validator", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1275, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_CLEAR(__pyx_v_kws);
  __Pyx_AddTraceback("validator.parameter_validator", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_32parameter_validator(__pyx_self, __pyx_v_param_name, __pyx_v_target_strs, __pyx_v_match_method, __pyx_v_raise_exception, __pyx_v_kws);

  /* "validator.pyx":1275
 *         return pd.api.types.is_categorical_dtype(col_type) or pd.api.types.is_object_dtype(col_type)
 * 
 * def parameter_validator(             # <<<<<<<<<<<<<<
 *         param_name, target_strs, match_method='contains',
 *         raise_exception=True, **kws):
 */

  /* function exit code */
  __Pyx_XDECREF(__pyx_v_kws);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1339
 *     from .coreutils import normalize_string
 * 
 *     def validator(param_value):             # <<<<<<<<<<<<<<
 *         """Validate param value from :func:`~normalize_string`"""
 *         if param_value:
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_19parameter_validator_1validator(PyObject *__pyx_self, PyObject *__pyx_v_param_value); /*proto*/
static char __pyx_doc_9validator_19parameter_validator_validator[] = "Validate param value from :func:`~normalize_string`";
static PyMethodDef __pyx_mdef_9validator_19parameter_validator_1validator = {"validator", (PyCFunction)__pyx_pw_9validator_19parameter_validator_1validator, METH_O, __pyx_doc_9validator_19parameter_validator_validator};
static PyObject *__pyx_pw_9validator_19parameter_validator_1validator(PyObject *__pyx_self, PyObject *__pyx_v_param_value) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validator (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_19parameter_validator_validator(__pyx_self, ((PyObject *)__pyx_v_param_value));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_19parameter_validator_validator(PyObject *__pyx_self, PyObject *__pyx_v_param_value) {
  struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator *__pyx_cur_scope;
  struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator *__pyx_outer_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validator", 0);
  __pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator *) __Pyx_CyFunction_GetClosure(__pyx_self);
  __pyx_cur_scope = __pyx_outer_scope;

  /* "validator.pyx":1341
 *     def validator(param_value):
 *         """Validate param value from :func:`~normalize_string`"""
 *         if param_value:             # <<<<<<<<<<<<<<
 *             return normalize_string(
 *                 param_value, target_strs=target_strs,
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_param_value); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 1341, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "validator.pyx":1342
 *         """Validate param value from :func:`~normalize_string`"""
 *         if param_value:
 *             return normalize_string(             # <<<<<<<<<<<<<<
 *                 param_value, target_strs=target_strs,
 *                 return_target_only=True,
 */
    __Pyx_XDECREF(__pyx_r);
    if (unlikely(!__pyx_cur_scope->__pyx_v_normalize_string)) { __Pyx_RaiseClosureNameError("normalize_string"); __PYX_ERR(0, 1342, __pyx_L1_error) }

    /* "validator.pyx":1343
 *         if param_value:
 *             return normalize_string(
 *                 param_value, target_strs=target_strs,             # <<<<<<<<<<<<<<
 *                 return_target_only=True,
 *                 match_method=match_method, raise_exception=raise_exception,
 */
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1342, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_v_param_value);
    __Pyx_GIVEREF(__pyx_v_param_value);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_param_value);

    /* "validator.pyx":1342
 *         """Validate param value from :func:`~normalize_string`"""
 *         if param_value:
 *             return normalize_string(             # <<<<<<<<<<<<<<
 *                 param_value, target_strs=target_strs,
 *                 return_target_only=True,
 */
    __pyx_t_4 = __Pyx_PyDict_NewPresized(4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1343, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);

    /* "validator.pyx":1343
 *         if param_value:
 *             return normalize_string(
 *                 param_value, target_strs=target_strs,             # <<<<<<<<<<<<<<
 *                 return_target_only=True,
 *                 match_method=match_method, raise_exception=raise_exception,
 */
    if (unlikely(!__pyx_cur_scope->__pyx_v_target_strs)) { __Pyx_RaiseClosureNameError("target_strs"); __PYX_ERR(0, 1343, __pyx_L1_error) }
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_target_strs, __pyx_cur_scope->__pyx_v_target_strs) < 0) __PYX_ERR(0, 1343, __pyx_L1_error)

    /* "validator.pyx":1344
 *             return normalize_string(
 *                 param_value, target_strs=target_strs,
 *                 return_target_only=True,             # <<<<<<<<<<<<<<
 *                 match_method=match_method, raise_exception=raise_exception,
 *                 **kws
 */
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_return_target_only, Py_True) < 0) __PYX_ERR(0, 1343, __pyx_L1_error)

    /* "validator.pyx":1345
 *                 param_value, target_strs=target_strs,
 *                 return_target_only=True,
 *                 match_method=match_method, raise_exception=raise_exception,             # <<<<<<<<<<<<<<
 *                 **kws
 *             )
 */
    if (unlikely(!__pyx_cur_scope->__pyx_v_match_method)) { __Pyx_RaiseClosureNameError("match_method"); __PYX_ERR(0, 1345, __pyx_L1_error) }
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_match_method, __pyx_cur_scope->__pyx_v_match_method) < 0) __PYX_ERR(0, 1343, __pyx_L1_error)
    if (unlikely(!__pyx_cur_scope->__pyx_v_raise_exception)) { __Pyx_RaiseClosureNameError("raise_exception"); __PYX_ERR(0, 1345, __pyx_L1_error) }
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_raise_exception, __pyx_cur_scope->__pyx_v_raise_exception) < 0) __PYX_ERR(0, 1343, __pyx_L1_error)
    __pyx_t_3 = __pyx_t_4;
    __pyx_t_4 = 0;

    /* "validator.pyx":1346
 *                 return_target_only=True,
 *                 match_method=match_method, raise_exception=raise_exception,
 *                 **kws             # <<<<<<<<<<<<<<
 *             )
 *         return param_value  # Return the original value if it's None or empty
 */
    if (unlikely(!__pyx_cur_scope->__pyx_v_kws)) { __Pyx_RaiseClosureNameError("kws"); __PYX_ERR(0, 1346, __pyx_L1_error) }
    if (unlikely(__pyx_cur_scope->__pyx_v_kws == Py_None)) {
      PyErr_SetString(PyExc_TypeError, "argument after ** must be a mapping, not NoneType");
      __PYX_ERR(0, 1346, __pyx_L1_error)
    }
    if (__Pyx_MergeKeywords(__pyx_t_3, __pyx_cur_scope->__pyx_v_kws) < 0) __PYX_ERR(0, 1346, __pyx_L1_error)

    /* "validator.pyx":1342
 *         """Validate param value from :func:`~normalize_string`"""
 *         if param_value:
 *             return normalize_string(             # <<<<<<<<<<<<<<
 *                 param_value, target_strs=target_strs,
 *                 return_target_only=True,
 */
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_cur_scope->__pyx_v_normalize_string, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1342, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "validator.pyx":1341
 *     def validator(param_value):
 *         """Validate param value from :func:`~normalize_string`"""
 *         if param_value:             # <<<<<<<<<<<<<<
 *             return normalize_string(
 *                 param_value, target_strs=target_strs,
 */
  }

  /* "validator.pyx":1348
 *                 **kws
 *             )
 *         return param_value  # Return the original value if it's None or empty             # <<<<<<<<<<<<<<
 * 
 *     return validator
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_param_value);
  __pyx_r = __pyx_v_param_value;
  goto __pyx_L0;

  /* "validator.pyx":1339
 *     from .coreutils import normalize_string
 * 
 *     def validator(param_value):             # <<<<<<<<<<<<<<
 *         """Validate param value from :func:`~normalize_string`"""
 *         if param_value:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("validator.parameter_validator.validator", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1275
 *         return pd.api.types.is_categorical_dtype(col_type) or pd.api.types.is_object_dtype(col_type)
 * 
 * def parameter_validator(             # <<<<<<<<<<<<<<
 *         param_name, target_strs, match_method='contains',
 *         raise_exception=True, **kws):
 */

static PyObject *__pyx_pf_9validator_32parameter_validator(CYTHON_UNUSED PyObject *__pyx_self, CYTHON_UNUSED PyObject *__pyx_v_param_name, PyObject *__pyx_v_target_strs, PyObject *__pyx_v_match_method, PyObject *__pyx_v_raise_exception, PyObject *__pyx_v_kws) {
  struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator *__pyx_cur_scope;
  PyObject *__pyx_v_validator = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("parameter_validator", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator *)__pyx_tp_new_9validator___pyx_scope_struct_3_parameter_validator(__pyx_ptype_9validator___pyx_scope_struct_3_parameter_validator, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 1275, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_v_target_strs = __pyx_v_target_strs;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_target_strs);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_target_strs);
  __pyx_cur_scope->__pyx_v_match_method = __pyx_v_match_method;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_match_method);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_match_method);
  __pyx_cur_scope->__pyx_v_raise_exception = __pyx_v_raise_exception;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_raise_exception);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_raise_exception);
  __pyx_cur_scope->__pyx_v_kws = __pyx_v_kws;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_kws);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_kws);

  /* "validator.pyx":1337
 *       where only specific values are allowed.
 *     """
 *     from .coreutils import normalize_string             # <<<<<<<<<<<<<<
 * 
 *     def validator(param_value):
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1337, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_normalize_string);
  __Pyx_GIVEREF(__pyx_n_s_normalize_string);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_normalize_string);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_coreutils, __pyx_t_1, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1337, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_normalize_string); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1337, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_cur_scope->__pyx_v_normalize_string = __pyx_t_1;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":1339
 *     from .coreutils import normalize_string
 * 
 *     def validator(param_value):             # <<<<<<<<<<<<<<
 *         """Validate param value from :func:`~normalize_string`"""
 *         if param_value:
 */
  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_9validator_19parameter_validator_1validator, 0, __pyx_n_s_parameter_validator_locals_valid, ((PyObject*)__pyx_cur_scope), __pyx_n_s_validator, __pyx_d, ((PyObject *)__pyx_codeobj__42)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1339, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_v_validator = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "validator.pyx":1350
 *         return param_value  # Return the original value if it's None or empty
 * 
 *     return validator             # <<<<<<<<<<<<<<
 * 
 * def validate_distribution(distribution, elements=None):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_validator);
  __pyx_r = __pyx_v_validator;
  goto __pyx_L0;

  /* "validator.pyx":1275
 *         return pd.api.types.is_categorical_dtype(col_type) or pd.api.types.is_object_dtype(col_type)
 * 
 * def parameter_validator(             # <<<<<<<<<<<<<<
 *         param_name, target_strs, match_method='contains',
 *         raise_exception=True, **kws):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("validator.parameter_validator", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_validator);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1352
 *     return validator
 * 
 * def validate_distribution(distribution, elements=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates or generates distributions for given elements ensuring the
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_35validate_distribution(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_34validate_distribution[] = "\n    Validates or generates distributions for given elements ensuring the \n    sum equals 1.\n\n    Parameters:\n    ----------\n    distribution : str, tuple, list\n        The distribution to be validated or generated. If 'auto',\n        generates a random distribution for the specified number of elements. \n        Can also be a tuple or list representing an explicit distribution.\n    elements : int, list of str, optional\n        Defines how many elements the distribution should be generated for \n        when 'auto' is used. If a list of strings is provided, its length \n        is used to determine the number of elements.\n\n    Returns:\n    -------\n    tuple\n        A tuple representing the validated or generated distribution.\n\n    Raises:\n    ------\n    ValueError\n        If the provided distribution does not sum to 1 or contains invalid values.\n        \n    Examples \n    ---------\n    >>> from gofast.tools.validator import validate_distribution\n    >>> validate_distribution (\"auto\", elements= [ 'positive', 'neutral', 'negative'])\n    (0.1450318690603951, 0.5660028611331361, 0.2889652698064687)\n    ";
static PyMethodDef __pyx_mdef_9validator_35validate_distribution = {"validate_distribution", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_35validate_distribution, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_34validate_distribution};
static PyObject *__pyx_pw_9validator_35validate_distribution(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_distribution = 0;
  PyObject *__pyx_v_elements = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validate_distribution (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_distribution,&__pyx_n_s_elements,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_distribution)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_elements);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "validate_distribution") < 0)) __PYX_ERR(0, 1352, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_distribution = values[0];
    __pyx_v_elements = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("validate_distribution", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1352, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.validate_distribution", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_34validate_distribution(__pyx_self, __pyx_v_distribution, __pyx_v_elements);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_34validate_distribution(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_distribution, PyObject *__pyx_v_elements) {
  PyObject *__pyx_v_distributed_elements = NULL;
  PyObject *__pyx_v_random_values = NULL;
  PyObject *__pyx_v_validated_distribution = NULL;
  PyObject *__pyx_v_value = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  Py_ssize_t __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  Py_UCS4 __pyx_t_8;
  PyObject *(*__pyx_t_9)(PyObject *);
  int __pyx_t_10;
  PyObject *__pyx_t_11 = NULL;
  int __pyx_t_12;
  PyObject *__pyx_t_13 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validate_distribution", 0);
  __Pyx_INCREF(__pyx_v_distribution);

  /* "validator.pyx":1385
 *     """
 *     # Determine the number of elements if a list is provided
 *     if isinstance(elements, list):             # <<<<<<<<<<<<<<
 *         distributed_elements = len(elements)
 *     elif isinstance(elements, ( float, int, np.integer, np.floating)):
 */
  __pyx_t_1 = PyList_Check(__pyx_v_elements); 
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "validator.pyx":1386
 *     # Determine the number of elements if a list is provided
 *     if isinstance(elements, list):
 *         distributed_elements = len(elements)             # <<<<<<<<<<<<<<
 *     elif isinstance(elements, ( float, int, np.integer, np.floating)):
 *         distributed_elements = int (elements)
 */
    __pyx_t_3 = PyObject_Length(__pyx_v_elements); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 1386, __pyx_L1_error)
    __pyx_t_4 = PyInt_FromSsize_t(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1386, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_v_distributed_elements = __pyx_t_4;
    __pyx_t_4 = 0;

    /* "validator.pyx":1385
 *     """
 *     # Determine the number of elements if a list is provided
 *     if isinstance(elements, list):             # <<<<<<<<<<<<<<
 *         distributed_elements = len(elements)
 *     elif isinstance(elements, ( float, int, np.integer, np.floating)):
 */
    goto __pyx_L3;
  }

  /* "validator.pyx":1387
 *     if isinstance(elements, list):
 *         distributed_elements = len(elements)
 *     elif isinstance(elements, ( float, int, np.integer, np.floating)):             # <<<<<<<<<<<<<<
 *         distributed_elements = int (elements)
 *     else:
 */
  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1387, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_integer); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1387, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1387, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_floating); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1387, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_1 = PyFloat_Check(__pyx_v_elements); 
  __pyx_t_7 = (__pyx_t_1 != 0);
  if (!__pyx_t_7) {
  } else {
    __pyx_t_2 = __pyx_t_7;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_7 = PyInt_Check(__pyx_v_elements); 
  __pyx_t_1 = (__pyx_t_7 != 0);
  if (!__pyx_t_1) {
  } else {
    __pyx_t_2 = __pyx_t_1;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_1 = PyObject_IsInstance(__pyx_v_elements, __pyx_t_5); 
  __pyx_t_7 = (__pyx_t_1 != 0);
  if (!__pyx_t_7) {
  } else {
    __pyx_t_2 = __pyx_t_7;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_7 = PyObject_IsInstance(__pyx_v_elements, __pyx_t_6); 
  __pyx_t_1 = (__pyx_t_7 != 0);
  __pyx_t_2 = __pyx_t_1;
  __pyx_L4_bool_binop_done:;
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (likely(__pyx_t_1)) {

    /* "validator.pyx":1388
 *         distributed_elements = len(elements)
 *     elif isinstance(elements, ( float, int, np.integer, np.floating)):
 *         distributed_elements = int (elements)             # <<<<<<<<<<<<<<
 *     else:
 *         raise ValueError("'elements' must be an integer or a list of strings.")
 */
    __pyx_t_5 = __Pyx_PyNumber_Int(__pyx_v_elements); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1388, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_v_distributed_elements = __pyx_t_5;
    __pyx_t_5 = 0;

    /* "validator.pyx":1387
 *     if isinstance(elements, list):
 *         distributed_elements = len(elements)
 *     elif isinstance(elements, ( float, int, np.integer, np.floating)):             # <<<<<<<<<<<<<<
 *         distributed_elements = int (elements)
 *     else:
 */
    goto __pyx_L3;
  }

  /* "validator.pyx":1390
 *         distributed_elements = int (elements)
 *     else:
 *         raise ValueError("'elements' must be an integer or a list of strings.")             # <<<<<<<<<<<<<<
 * 
 *     if str(distribution).lower() == 'auto':
 */
  /*else*/ {
    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__43, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1390, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __PYX_ERR(0, 1390, __pyx_L1_error)
  }
  __pyx_L3:;

  /* "validator.pyx":1392
 *         raise ValueError("'elements' must be an integer or a list of strings.")
 * 
 *     if str(distribution).lower() == 'auto':             # <<<<<<<<<<<<<<
 *         if distributed_elements is None:
 *             raise ValueError("'distributed_elements' must be specified when"
 */
  __pyx_t_6 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyUnicode_Type)), __pyx_v_distribution); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1392, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_lower); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1392, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_6 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  __pyx_t_5 = (__pyx_t_6) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_6) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
  if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1392, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_t_5, __pyx_n_u_auto, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 1392, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  if (__pyx_t_1) {

    /* "validator.pyx":1393
 * 
 *     if str(distribution).lower() == 'auto':
 *         if distributed_elements is None:             # <<<<<<<<<<<<<<
 *             raise ValueError("'distributed_elements' must be specified when"
 *                              " using 'auto' distribution.")
 */
    __pyx_t_1 = (__pyx_v_distributed_elements == Py_None);
    __pyx_t_2 = (__pyx_t_1 != 0);
    if (unlikely(__pyx_t_2)) {

      /* "validator.pyx":1394
 *     if str(distribution).lower() == 'auto':
 *         if distributed_elements is None:
 *             raise ValueError("'distributed_elements' must be specified when"             # <<<<<<<<<<<<<<
 *                              " using 'auto' distribution.")
 *         # Generate a random distribution
 */
      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__44, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1394, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __PYX_ERR(0, 1394, __pyx_L1_error)

      /* "validator.pyx":1393
 * 
 *     if str(distribution).lower() == 'auto':
 *         if distributed_elements is None:             # <<<<<<<<<<<<<<
 *             raise ValueError("'distributed_elements' must be specified when"
 *                              " using 'auto' distribution.")
 */
    }

    /* "validator.pyx":1397
 *                              " using 'auto' distribution.")
 *         # Generate a random distribution
 *         random_values = np.random.rand(distributed_elements)             # <<<<<<<<<<<<<<
 *         distribution = tuple(random_values / np.sum(random_values))
 *     else:
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1397, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_random); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1397, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_rand); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1397, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_5 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_6, __pyx_v_distributed_elements) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_distributed_elements);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1397, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_v_random_values = __pyx_t_5;
    __pyx_t_5 = 0;

    /* "validator.pyx":1398
 *         # Generate a random distribution
 *         random_values = np.random.rand(distributed_elements)
 *         distribution = tuple(random_values / np.sum(random_values))             # <<<<<<<<<<<<<<
 *     else:
 *         if not hasattr(distribution, '__iter__') or isinstance(distribution, str):
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1398, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_sum); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1398, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_6);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_6, function);
      }
    }
    __pyx_t_5 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_4, __pyx_v_random_values) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_random_values);
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1398, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = __Pyx_PyNumber_Divide(__pyx_v_random_values, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1398, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_PySequence_Tuple(__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1398, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_DECREF_SET(__pyx_v_distribution, __pyx_t_5);
    __pyx_t_5 = 0;

    /* "validator.pyx":1392
 *         raise ValueError("'elements' must be an integer or a list of strings.")
 * 
 *     if str(distribution).lower() == 'auto':             # <<<<<<<<<<<<<<
 *         if distributed_elements is None:
 *             raise ValueError("'distributed_elements' must be specified when"
 */
    goto __pyx_L8;
  }

  /* "validator.pyx":1400
 *         distribution = tuple(random_values / np.sum(random_values))
 *     else:
 *         if not hasattr(distribution, '__iter__') or isinstance(distribution, str):             # <<<<<<<<<<<<<<
 *             # If distribution is not iterable (or a single string), raise an error
 *             raise ValueError(
 */
  /*else*/ {
    __pyx_t_1 = __Pyx_HasAttr(__pyx_v_distribution, __pyx_n_u_iter); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 1400, __pyx_L1_error)
    __pyx_t_7 = ((!(__pyx_t_1 != 0)) != 0);
    if (!__pyx_t_7) {
    } else {
      __pyx_t_2 = __pyx_t_7;
      goto __pyx_L11_bool_binop_done;
    }
    __pyx_t_7 = PyUnicode_Check(__pyx_v_distribution); 
    __pyx_t_1 = (__pyx_t_7 != 0);
    __pyx_t_2 = __pyx_t_1;
    __pyx_L11_bool_binop_done:;
    if (unlikely(__pyx_t_2)) {

      /* "validator.pyx":1402
 *         if not hasattr(distribution, '__iter__') or isinstance(distribution, str):
 *             # If distribution is not iterable (or a single string), raise an error
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "distribution must be 'auto', a tuple, or a list of distributions")
 * 
 */
      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__45, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1402, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __PYX_ERR(0, 1402, __pyx_L1_error)

      /* "validator.pyx":1400
 *         distribution = tuple(random_values / np.sum(random_values))
 *     else:
 *         if not hasattr(distribution, '__iter__') or isinstance(distribution, str):             # <<<<<<<<<<<<<<
 *             # If distribution is not iterable (or a single string), raise an error
 *             raise ValueError(
 */
    }

    /* "validator.pyx":1405
 *                 "distribution must be 'auto', a tuple, or a list of distributions")
 * 
 *         distribution = tuple(distribution)             # <<<<<<<<<<<<<<
 * 
 *         if distributed_elements is not None and len(distribution) != distributed_elements:
 */
    __pyx_t_5 = __Pyx_PySequence_Tuple(__pyx_v_distribution); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1405, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF_SET(__pyx_v_distribution, __pyx_t_5);
    __pyx_t_5 = 0;

    /* "validator.pyx":1407
 *         distribution = tuple(distribution)
 * 
 *         if distributed_elements is not None and len(distribution) != distributed_elements:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 f"The distribution must have exactly {distributed_elements} elements")
 */
    __pyx_t_1 = (__pyx_v_distributed_elements != Py_None);
    __pyx_t_7 = (__pyx_t_1 != 0);
    if (__pyx_t_7) {
    } else {
      __pyx_t_2 = __pyx_t_7;
      goto __pyx_L14_bool_binop_done;
    }
    __pyx_t_3 = PyObject_Length(__pyx_v_distribution); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 1407, __pyx_L1_error)
    __pyx_t_5 = PyInt_FromSsize_t(__pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1407, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = PyObject_RichCompare(__pyx_t_5, __pyx_v_distributed_elements, Py_NE); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1407, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 1407, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_2 = __pyx_t_7;
    __pyx_L14_bool_binop_done:;
    if (unlikely(__pyx_t_2)) {

      /* "validator.pyx":1409
 *         if distributed_elements is not None and len(distribution) != distributed_elements:
 *             raise ValueError(
 *                 f"The distribution must have exactly {distributed_elements} elements")             # <<<<<<<<<<<<<<
 * 
 *         validated_distribution = []
 */
      __pyx_t_6 = PyTuple_New(3); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1409, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_3 = 0;
      __pyx_t_8 = 127;
      __Pyx_INCREF(__pyx_kp_u_The_distribution_must_have_exact);
      __pyx_t_3 += 35;
      __Pyx_GIVEREF(__pyx_kp_u_The_distribution_must_have_exact);
      PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_kp_u_The_distribution_must_have_exact);
      __pyx_t_5 = __Pyx_PyObject_FormatSimple(__pyx_v_distributed_elements, __pyx_empty_unicode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1409, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_8 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) > __pyx_t_8) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) : __pyx_t_8;
      __pyx_t_3 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_5);
      __Pyx_GIVEREF(__pyx_t_5);
      PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_5);
      __pyx_t_5 = 0;
      __Pyx_INCREF(__pyx_kp_u_elements_2);
      __pyx_t_3 += 9;
      __Pyx_GIVEREF(__pyx_kp_u_elements_2);
      PyTuple_SET_ITEM(__pyx_t_6, 2, __pyx_kp_u_elements_2);
      __pyx_t_5 = __Pyx_PyUnicode_Join(__pyx_t_6, 3, __pyx_t_3, __pyx_t_8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1409, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

      /* "validator.pyx":1408
 * 
 *         if distributed_elements is not None and len(distribution) != distributed_elements:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 f"The distribution must have exactly {distributed_elements} elements")
 * 
 */
      __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1408, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_Raise(__pyx_t_6, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __PYX_ERR(0, 1408, __pyx_L1_error)

      /* "validator.pyx":1407
 *         distribution = tuple(distribution)
 * 
 *         if distributed_elements is not None and len(distribution) != distributed_elements:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 f"The distribution must have exactly {distributed_elements} elements")
 */
    }

    /* "validator.pyx":1411
 *                 f"The distribution must have exactly {distributed_elements} elements")
 * 
 *         validated_distribution = []             # <<<<<<<<<<<<<<
 *         for value in distribution:
 *             if not isinstance(value, (int, float)):
 */
    __pyx_t_6 = PyList_New(0); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1411, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_v_validated_distribution = ((PyObject*)__pyx_t_6);
    __pyx_t_6 = 0;

    /* "validator.pyx":1412
 * 
 *         validated_distribution = []
 *         for value in distribution:             # <<<<<<<<<<<<<<
 *             if not isinstance(value, (int, float)):
 *                 raise ValueError("All distribution values must be numeric")
 */
    if (likely(PyList_CheckExact(__pyx_v_distribution)) || PyTuple_CheckExact(__pyx_v_distribution)) {
      __pyx_t_6 = __pyx_v_distribution; __Pyx_INCREF(__pyx_t_6); __pyx_t_3 = 0;
      __pyx_t_9 = NULL;
    } else {
      __pyx_t_3 = -1; __pyx_t_6 = PyObject_GetIter(__pyx_v_distribution); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1412, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_9 = Py_TYPE(__pyx_t_6)->tp_iternext; if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1412, __pyx_L1_error)
    }
    for (;;) {
      if (likely(!__pyx_t_9)) {
        if (likely(PyList_CheckExact(__pyx_t_6))) {
          if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_6)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_5 = PyList_GET_ITEM(__pyx_t_6, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 1412, __pyx_L1_error)
          #else
          __pyx_t_5 = PySequence_ITEM(__pyx_t_6, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1412, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_5);
          #endif
        } else {
          if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_6)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_6, __pyx_t_3); __Pyx_INCREF(__pyx_t_5); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 1412, __pyx_L1_error)
          #else
          __pyx_t_5 = PySequence_ITEM(__pyx_t_6, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1412, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_5);
          #endif
        }
      } else {
        __pyx_t_5 = __pyx_t_9(__pyx_t_6);
        if (unlikely(!__pyx_t_5)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else __PYX_ERR(0, 1412, __pyx_L1_error)
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_5);
      }
      __Pyx_XDECREF_SET(__pyx_v_value, __pyx_t_5);
      __pyx_t_5 = 0;

      /* "validator.pyx":1413
 *         validated_distribution = []
 *         for value in distribution:
 *             if not isinstance(value, (int, float)):             # <<<<<<<<<<<<<<
 *                 raise ValueError("All distribution values must be numeric")
 *             validated_distribution.append(float(value))
 */
      __pyx_t_7 = PyInt_Check(__pyx_v_value); 
      __pyx_t_1 = (__pyx_t_7 != 0);
      if (!__pyx_t_1) {
      } else {
        __pyx_t_2 = __pyx_t_1;
        goto __pyx_L19_bool_binop_done;
      }
      __pyx_t_1 = PyFloat_Check(__pyx_v_value); 
      __pyx_t_7 = (__pyx_t_1 != 0);
      __pyx_t_2 = __pyx_t_7;
      __pyx_L19_bool_binop_done:;
      __pyx_t_7 = ((!(__pyx_t_2 != 0)) != 0);
      if (unlikely(__pyx_t_7)) {

        /* "validator.pyx":1414
 *         for value in distribution:
 *             if not isinstance(value, (int, float)):
 *                 raise ValueError("All distribution values must be numeric")             # <<<<<<<<<<<<<<
 *             validated_distribution.append(float(value))
 * 
 */
        __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__46, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1414, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_Raise(__pyx_t_5, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __PYX_ERR(0, 1414, __pyx_L1_error)

        /* "validator.pyx":1413
 *         validated_distribution = []
 *         for value in distribution:
 *             if not isinstance(value, (int, float)):             # <<<<<<<<<<<<<<
 *                 raise ValueError("All distribution values must be numeric")
 *             validated_distribution.append(float(value))
 */
      }

      /* "validator.pyx":1415
 *             if not isinstance(value, (int, float)):
 *                 raise ValueError("All distribution values must be numeric")
 *             validated_distribution.append(float(value))             # <<<<<<<<<<<<<<
 * 
 *         if not np.isclose(sum(validated_distribution), 1):
 */
      __pyx_t_5 = __Pyx_PyNumber_Float(__pyx_v_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1415, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_10 = __Pyx_PyList_Append(__pyx_v_validated_distribution, __pyx_t_5); if (unlikely(__pyx_t_10 == ((int)-1))) __PYX_ERR(0, 1415, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

      /* "validator.pyx":1412
 * 
 *         validated_distribution = []
 *         for value in distribution:             # <<<<<<<<<<<<<<
 *             if not isinstance(value, (int, float)):
 *                 raise ValueError("All distribution values must be numeric")
 */
    }
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

    /* "validator.pyx":1417
 *             validated_distribution.append(float(value))
 * 
 *         if not np.isclose(sum(validated_distribution), 1):             # <<<<<<<<<<<<<<
 *             raise ValueError("The sum of the distribution values must be equal to 1")
 * 
 */
    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1417, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_isclose); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1417, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_sum, __pyx_v_validated_distribution); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1417, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_11 = NULL;
    __pyx_t_12 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_11 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_11)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_11);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
        __pyx_t_12 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[3] = {__pyx_t_11, __pyx_t_5, __pyx_int_1};
      __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_12, 2+__pyx_t_12); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1417, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[3] = {__pyx_t_11, __pyx_t_5, __pyx_int_1};
      __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_12, 2+__pyx_t_12); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1417, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    } else
    #endif
    {
      __pyx_t_13 = PyTuple_New(2+__pyx_t_12); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 1417, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_13);
      if (__pyx_t_11) {
        __Pyx_GIVEREF(__pyx_t_11); PyTuple_SET_ITEM(__pyx_t_13, 0, __pyx_t_11); __pyx_t_11 = NULL;
      }
      __Pyx_GIVEREF(__pyx_t_5);
      PyTuple_SET_ITEM(__pyx_t_13, 0+__pyx_t_12, __pyx_t_5);
      __Pyx_INCREF(__pyx_int_1);
      __Pyx_GIVEREF(__pyx_int_1);
      PyTuple_SET_ITEM(__pyx_t_13, 1+__pyx_t_12, __pyx_int_1);
      __pyx_t_5 = 0;
      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_13, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1417, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 1417, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_2 = ((!__pyx_t_7) != 0);
    if (unlikely(__pyx_t_2)) {

      /* "validator.pyx":1418
 * 
 *         if not np.isclose(sum(validated_distribution), 1):
 *             raise ValueError("The sum of the distribution values must be equal to 1")             # <<<<<<<<<<<<<<
 * 
 *         distribution = tuple(validated_distribution)
 */
      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__47, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1418, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_Raise(__pyx_t_6, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __PYX_ERR(0, 1418, __pyx_L1_error)

      /* "validator.pyx":1417
 *             validated_distribution.append(float(value))
 * 
 *         if not np.isclose(sum(validated_distribution), 1):             # <<<<<<<<<<<<<<
 *             raise ValueError("The sum of the distribution values must be equal to 1")
 * 
 */
    }

    /* "validator.pyx":1420
 *             raise ValueError("The sum of the distribution values must be equal to 1")
 * 
 *         distribution = tuple(validated_distribution)             # <<<<<<<<<<<<<<
 * 
 *     return distribution
 */
    __pyx_t_6 = PyList_AsTuple(__pyx_v_validated_distribution); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1420, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF_SET(__pyx_v_distribution, __pyx_t_6);
    __pyx_t_6 = 0;
  }
  __pyx_L8:;

  /* "validator.pyx":1422
 *         distribution = tuple(validated_distribution)
 * 
 *     return distribution             # <<<<<<<<<<<<<<
 * 
 * def validate_length_range(length_range, sorted_values=True, param_name=None):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_distribution);
  __pyx_r = __pyx_v_distribution;
  goto __pyx_L0;

  /* "validator.pyx":1352
 *     return validator
 * 
 * def validate_distribution(distribution, elements=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates or generates distributions for given elements ensuring the
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_11);
  __Pyx_XDECREF(__pyx_t_13);
  __Pyx_AddTraceback("validator.validate_distribution", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_distributed_elements);
  __Pyx_XDECREF(__pyx_v_random_values);
  __Pyx_XDECREF(__pyx_v_validated_distribution);
  __Pyx_XDECREF(__pyx_v_value);
  __Pyx_XDECREF(__pyx_v_distribution);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1424
 *     return distribution
 * 
 * def validate_length_range(length_range, sorted_values=True, param_name=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates the review length range ensuring it's a tuple with two integers
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_37validate_length_range(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_36validate_length_range[] = "\n    Validates the review length range ensuring it's a tuple with two integers \n    where the first value is less than the second.\n\n    Parameters:\n    ----------\n    length_range : tuple\n        A tuple containing two integers that represent the minimum and maximum\n        lengths of reviews.\n    sorted_values: bool, default=True \n        If True, the function expects the input length range to be sorted in \n        ascending order and will automatically sort it if not. If False, the \n        input length range is not expected to be sorted, and it will remain \n        as provided.\n    param_name : str, optional\n        The name of the parameter being validated. If None, the default name \n        'length_range' will be used in error messages.\n        \n    Returns\n    -------\n    tuple\n        The validated length range.\n\n    Raise\n    ------\n    ValueError\n        If the length range does not meet the requirements.\n        \n    Examples \n    --------\n    >>> from gofast.tools.validator import validate_length_range\n    >>> validate_length_range ( (202, 25) )\n    (25, 202)\n    >>> validate_length_range ( (202,) )\n    ValueError: length_range must be a tuple with two elements.\n    ";
static PyMethodDef __pyx_mdef_9validator_37validate_length_range = {"validate_length_range", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_37validate_length_range, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_36validate_length_range};
static PyObject *__pyx_pw_9validator_37validate_length_range(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_length_range = 0;
  PyObject *__pyx_v_sorted_values = 0;
  PyObject *__pyx_v_param_name = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validate_length_range (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_length_range,&__pyx_n_s_sorted_values,&__pyx_n_s_param_name,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_True);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_length_range)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sorted_values);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_param_name);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "validate_length_range") < 0)) __PYX_ERR(0, 1424, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_length_range = values[0];
    __pyx_v_sorted_values = values[1];
    __pyx_v_param_name = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("validate_length_range", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1424, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.validate_length_range", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_36validate_length_range(__pyx_self, __pyx_v_length_range, __pyx_v_sorted_values, __pyx_v_param_name);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9validator_21validate_length_range_2generator1(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */

/* "validator.pyx":1467
 *     min_length, max_length = length_range
 * 
 *     if not all(isinstance(x, ( float, int, np.integer, np.floating)             # <<<<<<<<<<<<<<
 *                           ) for x in length_range):
 *         raise ValueError(f"Both elements in {param_name} must be integers.")
 */

static PyObject *__pyx_pf_9validator_21validate_length_range_genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_9validator___pyx_scope_struct_5_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_5_genexpr *)__pyx_tp_new_9validator___pyx_scope_struct_5_genexpr(__pyx_ptype_9validator___pyx_scope_struct_5_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_5_genexpr *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 1467, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_4_validate_length_range *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9validator_21validate_length_range_2generator1, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_validate_length_range_locals_gen, __pyx_n_s_validator); if (unlikely(!gen)) __PYX_ERR(0, 1467, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("validator.validate_length_range.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9validator_21validate_length_range_2generator1(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9validator___pyx_scope_struct_5_genexpr *__pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_5_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *(*__pyx_t_3)(PyObject *);
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  int __pyx_t_8;
  int __pyx_t_9;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genexpr", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 1467, __pyx_L1_error)

  /* "validator.pyx":1468
 * 
 *     if not all(isinstance(x, ( float, int, np.integer, np.floating)
 *                           ) for x in length_range):             # <<<<<<<<<<<<<<
 *         raise ValueError(f"Both elements in {param_name} must be integers.")
 * 
 */
  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_length_range)) { __Pyx_RaiseClosureNameError("length_range"); __PYX_ERR(0, 1468, __pyx_L1_error) }
  if (likely(PyList_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_length_range)) || PyTuple_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_length_range)) {
    __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_length_range; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
    __pyx_t_3 = NULL;
  } else {
    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_length_range); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1468, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1468, __pyx_L1_error)
  }
  for (;;) {
    if (likely(!__pyx_t_3)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 1468, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1468, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 1468, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1468, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_3(__pyx_t_1);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 1468, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_x);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_x, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;

    /* "validator.pyx":1467
 *     min_length, max_length = length_range
 * 
 *     if not all(isinstance(x, ( float, int, np.integer, np.floating)             # <<<<<<<<<<<<<<
 *                           ) for x in length_range):
 *         raise ValueError(f"Both elements in {param_name} must be integers.")
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1467, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_integer); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1467, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1467, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_floating); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1467, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_8 = PyFloat_Check(__pyx_cur_scope->__pyx_v_x); 
    __pyx_t_9 = (__pyx_t_8 != 0);
    if (!__pyx_t_9) {
    } else {
      __pyx_t_7 = __pyx_t_9;
      goto __pyx_L7_bool_binop_done;
    }
    __pyx_t_9 = PyInt_Check(__pyx_cur_scope->__pyx_v_x); 
    __pyx_t_8 = (__pyx_t_9 != 0);
    if (!__pyx_t_8) {
    } else {
      __pyx_t_7 = __pyx_t_8;
      goto __pyx_L7_bool_binop_done;
    }
    __pyx_t_8 = PyObject_IsInstance(__pyx_cur_scope->__pyx_v_x, __pyx_t_5); 
    __pyx_t_9 = (__pyx_t_8 != 0);
    if (!__pyx_t_9) {
    } else {
      __pyx_t_7 = __pyx_t_9;
      goto __pyx_L7_bool_binop_done;
    }
    __pyx_t_9 = PyObject_IsInstance(__pyx_cur_scope->__pyx_v_x, __pyx_t_6); 
    __pyx_t_8 = (__pyx_t_9 != 0);
    __pyx_t_7 = __pyx_t_8;
    __pyx_L7_bool_binop_done:;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_8 = ((!(__pyx_t_7 != 0)) != 0);
    if (__pyx_t_8) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_False);
      __pyx_r = Py_False;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }

    /* "validator.pyx":1468
 * 
 *     if not all(isinstance(x, ( float, int, np.integer, np.floating)
 *                           ) for x in length_range):             # <<<<<<<<<<<<<<
 *         raise ValueError(f"Both elements in {param_name} must be integers.")
 * 
 */
  }
  /*else*/ {

    /* "validator.pyx":1467
 *     min_length, max_length = length_range
 * 
 *     if not all(isinstance(x, ( float, int, np.integer, np.floating)             # <<<<<<<<<<<<<<
 *                           ) for x in length_range):
 *         raise ValueError(f"Both elements in {param_name} must be integers.")
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_True);
    __pyx_r = Py_True;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    goto __pyx_L0;
  }

  /* "validator.pyx":1468
 * 
 *     if not all(isinstance(x, ( float, int, np.integer, np.floating)
 *                           ) for x in length_range):             # <<<<<<<<<<<<<<
 *         raise ValueError(f"Both elements in {param_name} must be integers.")
 * 
 */
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* "validator.pyx":1467
 *     min_length, max_length = length_range
 * 
 *     if not all(isinstance(x, ( float, int, np.integer, np.floating)             # <<<<<<<<<<<<<<
 *                           ) for x in length_range):
 *         raise ValueError(f"Both elements in {param_name} must be integers.")
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  #if !CYTHON_USE_EXC_INFO_STACK
  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
  #endif
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1424
 *     return distribution
 * 
 * def validate_length_range(length_range, sorted_values=True, param_name=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates the review length range ensuring it's a tuple with two integers
 */

static PyObject *__pyx_pf_9validator_36validate_length_range(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_length_range, PyObject *__pyx_v_sorted_values, PyObject *__pyx_v_param_name) {
  struct __pyx_obj_9validator___pyx_scope_struct_4_validate_length_range *__pyx_cur_scope;
  PyObject *__pyx_v_min_length = NULL;
  PyObject *__pyx_v_max_length = NULL;
  PyObject *__pyx_gb_9validator_21validate_length_range_2generator1 = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  Py_ssize_t __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *(*__pyx_t_9)(PyObject *);
  Py_UCS4 __pyx_t_10;
  int __pyx_t_11;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validate_length_range", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_4_validate_length_range *)__pyx_tp_new_9validator___pyx_scope_struct_4_validate_length_range(__pyx_ptype_9validator___pyx_scope_struct_4_validate_length_range, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_4_validate_length_range *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 1424, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_v_length_range = __pyx_v_length_range;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_length_range);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_length_range);
  __Pyx_INCREF(__pyx_v_param_name);

  /* "validator.pyx":1461
 *     ValueError: length_range must be a tuple with two elements.
 *     """
 *     param_name = param_name or "length_range"             # <<<<<<<<<<<<<<
 *     if not isinstance(length_range, ( list, tuple) ) or len(length_range) != 2:
 *         raise ValueError(f"{param_name} must be a tuple with two elements.")
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_param_name); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 1461, __pyx_L1_error)
  if (!__pyx_t_2) {
  } else {
    __Pyx_INCREF(__pyx_v_param_name);
    __pyx_t_1 = __pyx_v_param_name;
    goto __pyx_L3_bool_binop_done;
  }
  __Pyx_INCREF(__pyx_n_u_length_range);
  __pyx_t_1 = __pyx_n_u_length_range;
  __pyx_L3_bool_binop_done:;
  __Pyx_DECREF_SET(__pyx_v_param_name, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":1462
 *     """
 *     param_name = param_name or "length_range"
 *     if not isinstance(length_range, ( list, tuple) ) or len(length_range) != 2:             # <<<<<<<<<<<<<<
 *         raise ValueError(f"{param_name} must be a tuple with two elements.")
 * 
 */
  __pyx_t_1 = __pyx_cur_scope->__pyx_v_length_range;
  __Pyx_INCREF(__pyx_t_1);
  __pyx_t_4 = PyList_Check(__pyx_t_1); 
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = (__pyx_t_4 != 0);
  if (!__pyx_t_5) {
  } else {
    __pyx_t_3 = __pyx_t_5;
    goto __pyx_L8_bool_binop_done;
  }
  __pyx_t_1 = __pyx_cur_scope->__pyx_v_length_range;
  __Pyx_INCREF(__pyx_t_1);
  __pyx_t_5 = PyTuple_Check(__pyx_t_1); 
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_4 = (__pyx_t_5 != 0);
  __pyx_t_3 = __pyx_t_4;
  __pyx_L8_bool_binop_done:;
  __pyx_t_4 = ((!(__pyx_t_3 != 0)) != 0);
  if (!__pyx_t_4) {
  } else {
    __pyx_t_2 = __pyx_t_4;
    goto __pyx_L6_bool_binop_done;
  }
  __pyx_t_1 = __pyx_cur_scope->__pyx_v_length_range;
  __Pyx_INCREF(__pyx_t_1);
  __pyx_t_6 = PyObject_Length(__pyx_t_1); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 1462, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_4 = ((__pyx_t_6 != 2) != 0);
  __pyx_t_2 = __pyx_t_4;
  __pyx_L6_bool_binop_done:;
  if (unlikely(__pyx_t_2)) {

    /* "validator.pyx":1463
 *     param_name = param_name or "length_range"
 *     if not isinstance(length_range, ( list, tuple) ) or len(length_range) != 2:
 *         raise ValueError(f"{param_name} must be a tuple with two elements.")             # <<<<<<<<<<<<<<
 * 
 *     min_length, max_length = length_range
 */
    __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_param_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1463, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_7 = __Pyx_PyUnicode_Concat(__pyx_t_1, __pyx_kp_u_must_be_a_tuple_with_two_elemen); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1463, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1463, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 1463, __pyx_L1_error)

    /* "validator.pyx":1462
 *     """
 *     param_name = param_name or "length_range"
 *     if not isinstance(length_range, ( list, tuple) ) or len(length_range) != 2:             # <<<<<<<<<<<<<<
 *         raise ValueError(f"{param_name} must be a tuple with two elements.")
 * 
 */
  }

  /* "validator.pyx":1465
 *         raise ValueError(f"{param_name} must be a tuple with two elements.")
 * 
 *     min_length, max_length = length_range             # <<<<<<<<<<<<<<
 * 
 *     if not all(isinstance(x, ( float, int, np.integer, np.floating)
 */
  if ((likely(PyTuple_CheckExact(__pyx_cur_scope->__pyx_v_length_range))) || (PyList_CheckExact(__pyx_cur_scope->__pyx_v_length_range))) {
    PyObject* sequence = __pyx_cur_scope->__pyx_v_length_range;
    Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
    if (unlikely(size != 2)) {
      if (size > 2) __Pyx_RaiseTooManyValuesError(2);
      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
      __PYX_ERR(0, 1465, __pyx_L1_error)
    }
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    if (likely(PyTuple_CheckExact(sequence))) {
      __pyx_t_1 = PyTuple_GET_ITEM(sequence, 0); 
      __pyx_t_7 = PyTuple_GET_ITEM(sequence, 1); 
    } else {
      __pyx_t_1 = PyList_GET_ITEM(sequence, 0); 
      __pyx_t_7 = PyList_GET_ITEM(sequence, 1); 
    }
    __Pyx_INCREF(__pyx_t_1);
    __Pyx_INCREF(__pyx_t_7);
    #else
    __pyx_t_1 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1465, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_7 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1465, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    #endif
  } else {
    Py_ssize_t index = -1;
    __pyx_t_8 = PyObject_GetIter(__pyx_cur_scope->__pyx_v_length_range); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1465, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_9 = Py_TYPE(__pyx_t_8)->tp_iternext;
    index = 0; __pyx_t_1 = __pyx_t_9(__pyx_t_8); if (unlikely(!__pyx_t_1)) goto __pyx_L10_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_1);
    index = 1; __pyx_t_7 = __pyx_t_9(__pyx_t_8); if (unlikely(!__pyx_t_7)) goto __pyx_L10_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_7);
    if (__Pyx_IternextUnpackEndCheck(__pyx_t_9(__pyx_t_8), 2) < 0) __PYX_ERR(0, 1465, __pyx_L1_error)
    __pyx_t_9 = NULL;
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    goto __pyx_L11_unpacking_done;
    __pyx_L10_unpacking_failed:;
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_9 = NULL;
    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
    __PYX_ERR(0, 1465, __pyx_L1_error)
    __pyx_L11_unpacking_done:;
  }
  __pyx_v_min_length = __pyx_t_1;
  __pyx_t_1 = 0;
  __pyx_v_max_length = __pyx_t_7;
  __pyx_t_7 = 0;

  /* "validator.pyx":1467
 *     min_length, max_length = length_range
 * 
 *     if not all(isinstance(x, ( float, int, np.integer, np.floating)             # <<<<<<<<<<<<<<
 *                           ) for x in length_range):
 *         raise ValueError(f"Both elements in {param_name} must be integers.")
 */
  __pyx_t_7 = __pyx_pf_9validator_21validate_length_range_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1467, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __pyx_t_1 = __Pyx_Generator_Next(__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1467, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 1467, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_4 = ((!__pyx_t_2) != 0);
  if (unlikely(__pyx_t_4)) {

    /* "validator.pyx":1469
 *     if not all(isinstance(x, ( float, int, np.integer, np.floating)
 *                           ) for x in length_range):
 *         raise ValueError(f"Both elements in {param_name} must be integers.")             # <<<<<<<<<<<<<<
 * 
 *     if sorted_values:
 */
    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1469, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_6 = 0;
    __pyx_t_10 = 127;
    __Pyx_INCREF(__pyx_kp_u_Both_elements_in);
    __pyx_t_6 += 17;
    __Pyx_GIVEREF(__pyx_kp_u_Both_elements_in);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_Both_elements_in);
    __pyx_t_7 = __Pyx_PyObject_FormatSimple(__pyx_v_param_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1469, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_10 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) > __pyx_t_10) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) : __pyx_t_10;
    __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_7);
    __Pyx_GIVEREF(__pyx_t_7);
    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_7);
    __pyx_t_7 = 0;
    __Pyx_INCREF(__pyx_kp_u_must_be_integers);
    __pyx_t_6 += 18;
    __Pyx_GIVEREF(__pyx_kp_u_must_be_integers);
    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_must_be_integers);
    __pyx_t_7 = __Pyx_PyUnicode_Join(__pyx_t_1, 3, __pyx_t_6, __pyx_t_10); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1469, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1469, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 1469, __pyx_L1_error)

    /* "validator.pyx":1467
 *     min_length, max_length = length_range
 * 
 *     if not all(isinstance(x, ( float, int, np.integer, np.floating)             # <<<<<<<<<<<<<<
 *                           ) for x in length_range):
 *         raise ValueError(f"Both elements in {param_name} must be integers.")
 */
  }

  /* "validator.pyx":1471
 *         raise ValueError(f"Both elements in {param_name} must be integers.")
 * 
 *     if sorted_values:             # <<<<<<<<<<<<<<
 *         length_range  = tuple  (sorted ( [min_length, max_length] ))
 *         if length_range[0] >= length_range[1]:
 */
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_sorted_values); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1471, __pyx_L1_error)
  if (__pyx_t_4) {

    /* "validator.pyx":1472
 * 
 *     if sorted_values:
 *         length_range  = tuple  (sorted ( [min_length, max_length] ))             # <<<<<<<<<<<<<<
 *         if length_range[0] >= length_range[1]:
 *             raise ValueError(
 */
    __pyx_t_7 = PyList_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1472, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_INCREF(__pyx_v_min_length);
    __Pyx_GIVEREF(__pyx_v_min_length);
    PyList_SET_ITEM(__pyx_t_7, 0, __pyx_v_min_length);
    __Pyx_INCREF(__pyx_v_max_length);
    __Pyx_GIVEREF(__pyx_v_max_length);
    PyList_SET_ITEM(__pyx_t_7, 1, __pyx_v_max_length);
    __pyx_t_1 = ((PyObject*)__pyx_t_7);
    __pyx_t_7 = 0;
    __pyx_t_11 = PyList_Sort(__pyx_t_1); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(0, 1472, __pyx_L1_error)
    if (unlikely(__pyx_t_1 == Py_None)) {
      PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
      __PYX_ERR(0, 1472, __pyx_L1_error)
    }
    __pyx_t_7 = PyList_AsTuple(__pyx_t_1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1472, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_GOTREF(__pyx_cur_scope->__pyx_v_length_range);
    __Pyx_DECREF_SET(__pyx_cur_scope->__pyx_v_length_range, __pyx_t_7);
    __Pyx_GIVEREF(__pyx_t_7);
    __pyx_t_7 = 0;

    /* "validator.pyx":1473
 *     if sorted_values:
 *         length_range  = tuple  (sorted ( [min_length, max_length] ))
 *         if length_range[0] >= length_range[1]:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 f"The first element in {param_name} must be less than the second.")
 */
    __pyx_t_7 = __Pyx_GetItemInt(__pyx_cur_scope->__pyx_v_length_range, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1473, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_1 = __Pyx_GetItemInt(__pyx_cur_scope->__pyx_v_length_range, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1473, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_8 = PyObject_RichCompare(__pyx_t_7, __pyx_t_1, Py_GE); __Pyx_XGOTREF(__pyx_t_8); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1473, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_8); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1473, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    if (unlikely(__pyx_t_4)) {

      /* "validator.pyx":1475
 *         if length_range[0] >= length_range[1]:
 *             raise ValueError(
 *                 f"The first element in {param_name} must be less than the second.")             # <<<<<<<<<<<<<<
 *     else :
 *         length_range = tuple ([min_length, max_length] )
 */
      __pyx_t_8 = PyTuple_New(3); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1475, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_6 = 0;
      __pyx_t_10 = 127;
      __Pyx_INCREF(__pyx_kp_u_The_first_element_in);
      __pyx_t_6 += 21;
      __Pyx_GIVEREF(__pyx_kp_u_The_first_element_in);
      PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_kp_u_The_first_element_in);
      __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_param_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1475, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_10 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) > __pyx_t_10) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) : __pyx_t_10;
      __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_1);
      __Pyx_GIVEREF(__pyx_t_1);
      PyTuple_SET_ITEM(__pyx_t_8, 1, __pyx_t_1);
      __pyx_t_1 = 0;
      __Pyx_INCREF(__pyx_kp_u_must_be_less_than_the_second);
      __pyx_t_6 += 30;
      __Pyx_GIVEREF(__pyx_kp_u_must_be_less_than_the_second);
      PyTuple_SET_ITEM(__pyx_t_8, 2, __pyx_kp_u_must_be_less_than_the_second);
      __pyx_t_1 = __Pyx_PyUnicode_Join(__pyx_t_8, 3, __pyx_t_6, __pyx_t_10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1475, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;

      /* "validator.pyx":1474
 *         length_range  = tuple  (sorted ( [min_length, max_length] ))
 *         if length_range[0] >= length_range[1]:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 f"The first element in {param_name} must be less than the second.")
 *     else :
 */
      __pyx_t_8 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1474, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_Raise(__pyx_t_8, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __PYX_ERR(0, 1474, __pyx_L1_error)

      /* "validator.pyx":1473
 *     if sorted_values:
 *         length_range  = tuple  (sorted ( [min_length, max_length] ))
 *         if length_range[0] >= length_range[1]:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 f"The first element in {param_name} must be less than the second.")
 */
    }

    /* "validator.pyx":1471
 *         raise ValueError(f"Both elements in {param_name} must be integers.")
 * 
 *     if sorted_values:             # <<<<<<<<<<<<<<
 *         length_range  = tuple  (sorted ( [min_length, max_length] ))
 *         if length_range[0] >= length_range[1]:
 */
    goto __pyx_L13;
  }

  /* "validator.pyx":1477
 *                 f"The first element in {param_name} must be less than the second.")
 *     else :
 *         length_range = tuple ([min_length, max_length] )             # <<<<<<<<<<<<<<
 * 
 *     return length_range
 */
  /*else*/ {
    __pyx_t_8 = PyList_New(2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1477, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_INCREF(__pyx_v_min_length);
    __Pyx_GIVEREF(__pyx_v_min_length);
    PyList_SET_ITEM(__pyx_t_8, 0, __pyx_v_min_length);
    __Pyx_INCREF(__pyx_v_max_length);
    __Pyx_GIVEREF(__pyx_v_max_length);
    PyList_SET_ITEM(__pyx_t_8, 1, __pyx_v_max_length);
    __pyx_t_1 = PyList_AsTuple(((PyObject*)__pyx_t_8)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1477, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __Pyx_GOTREF(__pyx_cur_scope->__pyx_v_length_range);
    __Pyx_DECREF_SET(__pyx_cur_scope->__pyx_v_length_range, __pyx_t_1);
    __Pyx_GIVEREF(__pyx_t_1);
    __pyx_t_1 = 0;
  }
  __pyx_L13:;

  /* "validator.pyx":1479
 *         length_range = tuple ([min_length, max_length] )
 * 
 *     return length_range             # <<<<<<<<<<<<<<
 * 
 * def contains_nested_objects(lst, strict=False, allowed_types=None):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_length_range);
  __pyx_r = __pyx_cur_scope->__pyx_v_length_range;
  goto __pyx_L0;

  /* "validator.pyx":1424
 *     return distribution
 * 
 * def validate_length_range(length_range, sorted_values=True, param_name=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates the review length range ensuring it's a tuple with two integers
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("validator.validate_length_range", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_min_length);
  __Pyx_XDECREF(__pyx_v_max_length);
  __Pyx_XDECREF(__pyx_gb_9validator_21validate_length_range_2generator1);
  __Pyx_XDECREF(__pyx_v_param_name);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1481
 *     return length_range
 * 
 * def contains_nested_objects(lst, strict=False, allowed_types=None):             # <<<<<<<<<<<<<<
 *     """
 *     Determines whether a list contains nested objects.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_39contains_nested_objects(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_38contains_nested_objects[] = "\n    Determines whether a list contains nested objects.\n\n    Parameters\n    ----------\n    lst : list\n        The list to be checked for nested objects.\n    strict : bool, optional\n        If True, all items in the list must be nested objects. If False, the function\n        returns True if any item is a nested object. Default is False.\n    allowed_types : tuple of types, optional\n        A tuple of types to consider as nested objects. If None, common nested types\n        like list, set, dict, and tuple are checked. Default is None.\n\n    Returns\n    -------\n    bool\n        True if the list contains nested objects according to the given parameters,\n        otherwise False.\n\n    Notes\n    -----\n    A nested object is defined as any item within the list that is not a primitive\n    data type (e.g., int, float, str) or is a complex structure like lists, sets,\n    dictionaries, etc. The function can be customized to check for specific types\n    using the `allowed_types` parameter.\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import contains_nested_objects\n    >>> example_list1 = [{1, 2}, [3, 4], {'key': 'value'}]\n    >>> example_list2 = [1, 2, 3, [4]]\n    >>> example_list3 = [1, 2, 3, 4]\n    >>> contains_nested_objects(example_list1)\n    True  # non-strict, contains nested objects\n    >>> contains_nested_objects(example_list1, strict=True)\n    True  # strict, all are nested objects\n    >>> contains_nested_objects(example_list2)\n    True  # non-strict, contains at least one nested object\n    >>> contains_nested_objects(example_list2, strict=True)\n    False  # strict, not all are nested objects\n    >>> contains_nested_objects(example_list3)\n    False  # non-strict, no nested objects\n    >>> contains_nested_objects(example_list3, strict=True)\n    False  # strict, no nested objects\n    ";
static PyMethodDef __pyx_mdef_9validator_39contains_nested_objects = {"contains_nested_objects", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_39contains_nested_objects, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_38contains_nested_objects};
static PyObject *__pyx_pw_9validator_39contains_nested_objects(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_lst = 0;
  PyObject *__pyx_v_strict = 0;
  PyObject *__pyx_v_allowed_types = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("contains_nested_objects (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_lst,&__pyx_n_s_strict,&__pyx_n_s_allowed_types,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_False);
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_lst)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_strict);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_allowed_types);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "contains_nested_objects") < 0)) __PYX_ERR(0, 1481, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_lst = values[0];
    __pyx_v_strict = values[1];
    __pyx_v_allowed_types = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("contains_nested_objects", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1481, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.contains_nested_objects", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_38contains_nested_objects(__pyx_self, __pyx_v_lst, __pyx_v_strict, __pyx_v_allowed_types);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1532
 * 
 *     # Function to check if an item is a nested type
 *     def is_nested(item):             # <<<<<<<<<<<<<<
 *         return isinstance(item, allowed_types)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_23contains_nested_objects_1is_nested(PyObject *__pyx_self, PyObject *__pyx_v_item); /*proto*/
static PyMethodDef __pyx_mdef_9validator_23contains_nested_objects_1is_nested = {"is_nested", (PyCFunction)__pyx_pw_9validator_23contains_nested_objects_1is_nested, METH_O, 0};
static PyObject *__pyx_pw_9validator_23contains_nested_objects_1is_nested(PyObject *__pyx_self, PyObject *__pyx_v_item) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("is_nested (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_23contains_nested_objects_is_nested(__pyx_self, ((PyObject *)__pyx_v_item));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_23contains_nested_objects_is_nested(PyObject *__pyx_self, PyObject *__pyx_v_item) {
  struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects *__pyx_cur_scope;
  struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects *__pyx_outer_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("is_nested", 0);
  __pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects *) __Pyx_CyFunction_GetClosure(__pyx_self);
  __pyx_cur_scope = __pyx_outer_scope;

  /* "validator.pyx":1533
 *     # Function to check if an item is a nested type
 *     def is_nested(item):
 *         return isinstance(item, allowed_types)             # <<<<<<<<<<<<<<
 * 
 *     if strict:
 */
  __Pyx_XDECREF(__pyx_r);
  if (unlikely(!__pyx_cur_scope->__pyx_v_allowed_types)) { __Pyx_RaiseClosureNameError("allowed_types"); __PYX_ERR(0, 1533, __pyx_L1_error) }
  __pyx_t_1 = __pyx_cur_scope->__pyx_v_allowed_types;
  __Pyx_INCREF(__pyx_t_1);
  __pyx_t_2 = PyObject_IsInstance(__pyx_v_item, __pyx_t_1); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 1533, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1533, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "validator.pyx":1532
 * 
 *     # Function to check if an item is a nested type
 *     def is_nested(item):             # <<<<<<<<<<<<<<
 *         return isinstance(item, allowed_types)
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("validator.contains_nested_objects.is_nested", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9validator_23contains_nested_objects_4generator2(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */

/* "validator.pyx":1537
 *     if strict:
 *         # Check if all items are nested objects
 *         return all(is_nested(item) for item in lst)             # <<<<<<<<<<<<<<
 *     else:
 *         # Check if any item is a nested object
 */

static PyObject *__pyx_pf_9validator_23contains_nested_objects_2genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_9validator___pyx_scope_struct_7_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_7_genexpr *)__pyx_tp_new_9validator___pyx_scope_struct_7_genexpr(__pyx_ptype_9validator___pyx_scope_struct_7_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_7_genexpr *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 1537, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9validator_23contains_nested_objects_4generator2, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_contains_nested_objects_locals_g, __pyx_n_s_validator); if (unlikely(!gen)) __PYX_ERR(0, 1537, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("validator.contains_nested_objects.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9validator_23contains_nested_objects_4generator2(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9validator___pyx_scope_struct_7_genexpr *__pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_7_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *(*__pyx_t_3)(PyObject *);
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genexpr", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 1537, __pyx_L1_error)
  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_lst)) { __Pyx_RaiseClosureNameError("lst"); __PYX_ERR(0, 1537, __pyx_L1_error) }
  if (likely(PyList_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_lst)) || PyTuple_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_lst)) {
    __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_lst; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
    __pyx_t_3 = NULL;
  } else {
    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_lst); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1537, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1537, __pyx_L1_error)
  }
  for (;;) {
    if (likely(!__pyx_t_3)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 1537, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1537, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 1537, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1537, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_3(__pyx_t_1);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 1537, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_item);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_item, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_is_nested)) { __Pyx_RaiseClosureNameError("is_nested"); __PYX_ERR(0, 1537, __pyx_L1_error) }
    __pyx_t_4 = __pyx_pf_9validator_23contains_nested_objects_is_nested(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_is_nested, __pyx_cur_scope->__pyx_v_item); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1537, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1537, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_6 = ((!__pyx_t_5) != 0);
    if (__pyx_t_6) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_False);
      __pyx_r = Py_False;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
  }
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_True);
    __pyx_r = Py_True;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    goto __pyx_L0;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  #if !CYTHON_USE_EXC_INFO_STACK
  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
  #endif
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9validator_23contains_nested_objects_7generator3(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */

/* "validator.pyx":1540
 *     else:
 *         # Check if any item is a nested object
 *         return any(is_nested(item) for item in lst)             # <<<<<<<<<<<<<<
 * 
 * def validate_nan_policy(nan_policy, *arrays, sample_weights=None):
 */

static PyObject *__pyx_pf_9validator_23contains_nested_objects_5genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_9validator___pyx_scope_struct_8_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_8_genexpr *)__pyx_tp_new_9validator___pyx_scope_struct_8_genexpr(__pyx_ptype_9validator___pyx_scope_struct_8_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_8_genexpr *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 1540, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9validator_23contains_nested_objects_7generator3, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_contains_nested_objects_locals_g, __pyx_n_s_validator); if (unlikely(!gen)) __PYX_ERR(0, 1540, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("validator.contains_nested_objects.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9validator_23contains_nested_objects_7generator3(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9validator___pyx_scope_struct_8_genexpr *__pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_8_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *(*__pyx_t_3)(PyObject *);
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genexpr", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 1540, __pyx_L1_error)
  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_lst)) { __Pyx_RaiseClosureNameError("lst"); __PYX_ERR(0, 1540, __pyx_L1_error) }
  if (likely(PyList_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_lst)) || PyTuple_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_lst)) {
    __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_lst; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
    __pyx_t_3 = NULL;
  } else {
    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_lst); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1540, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1540, __pyx_L1_error)
  }
  for (;;) {
    if (likely(!__pyx_t_3)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 1540, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1540, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 1540, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1540, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_3(__pyx_t_1);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 1540, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_item);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_item, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_is_nested)) { __Pyx_RaiseClosureNameError("is_nested"); __PYX_ERR(0, 1540, __pyx_L1_error) }
    __pyx_t_4 = __pyx_pf_9validator_23contains_nested_objects_is_nested(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_is_nested, __pyx_cur_scope->__pyx_v_item); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1540, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1540, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (__pyx_t_5) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_True);
      __pyx_r = Py_True;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
  }
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    goto __pyx_L0;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  #if !CYTHON_USE_EXC_INFO_STACK
  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
  #endif
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1481
 *     return length_range
 * 
 * def contains_nested_objects(lst, strict=False, allowed_types=None):             # <<<<<<<<<<<<<<
 *     """
 *     Determines whether a list contains nested objects.
 */

static PyObject *__pyx_pf_9validator_38contains_nested_objects(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_lst, PyObject *__pyx_v_strict, PyObject *__pyx_v_allowed_types) {
  struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects *__pyx_cur_scope;
  PyObject *__pyx_gb_9validator_23contains_nested_objects_4generator2 = 0;
  PyObject *__pyx_gb_9validator_23contains_nested_objects_7generator3 = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("contains_nested_objects", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects *)__pyx_tp_new_9validator___pyx_scope_struct_6_contains_nested_objects(__pyx_ptype_9validator___pyx_scope_struct_6_contains_nested_objects, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 1481, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_v_lst = __pyx_v_lst;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_lst);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_lst);
  __pyx_cur_scope->__pyx_v_allowed_types = __pyx_v_allowed_types;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_allowed_types);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_allowed_types);

  /* "validator.pyx":1528
 *     False  # strict, no nested objects
 *     """
 *     if allowed_types is None:             # <<<<<<<<<<<<<<
 *         allowed_types = (list, set, dict, tuple)  # Default nested types
 * 
 */
  __pyx_t_1 = (__pyx_cur_scope->__pyx_v_allowed_types == Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "validator.pyx":1529
 *     """
 *     if allowed_types is None:
 *         allowed_types = (list, set, dict, tuple)  # Default nested types             # <<<<<<<<<<<<<<
 * 
 *     # Function to check if an item is a nested type
 */
    __pyx_t_3 = PyTuple_New(4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1529, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_INCREF(((PyObject *)(&PyList_Type)));
    __Pyx_GIVEREF(((PyObject *)(&PyList_Type)));
    PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)(&PyList_Type)));
    __Pyx_INCREF(((PyObject *)(&PySet_Type)));
    __Pyx_GIVEREF(((PyObject *)(&PySet_Type)));
    PyTuple_SET_ITEM(__pyx_t_3, 1, ((PyObject *)(&PySet_Type)));
    __Pyx_INCREF(((PyObject *)(&PyDict_Type)));
    __Pyx_GIVEREF(((PyObject *)(&PyDict_Type)));
    PyTuple_SET_ITEM(__pyx_t_3, 2, ((PyObject *)(&PyDict_Type)));
    __Pyx_INCREF(((PyObject *)(&PyTuple_Type)));
    __Pyx_GIVEREF(((PyObject *)(&PyTuple_Type)));
    PyTuple_SET_ITEM(__pyx_t_3, 3, ((PyObject *)(&PyTuple_Type)));
    __Pyx_GOTREF(__pyx_cur_scope->__pyx_v_allowed_types);
    __Pyx_DECREF_SET(__pyx_cur_scope->__pyx_v_allowed_types, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;

    /* "validator.pyx":1528
 *     False  # strict, no nested objects
 *     """
 *     if allowed_types is None:             # <<<<<<<<<<<<<<
 *         allowed_types = (list, set, dict, tuple)  # Default nested types
 * 
 */
  }

  /* "validator.pyx":1532
 * 
 *     # Function to check if an item is a nested type
 *     def is_nested(item):             # <<<<<<<<<<<<<<
 *         return isinstance(item, allowed_types)
 * 
 */
  __pyx_t_3 = __Pyx_CyFunction_New(&__pyx_mdef_9validator_23contains_nested_objects_1is_nested, 0, __pyx_n_s_contains_nested_objects_locals_i, ((PyObject*)__pyx_cur_scope), __pyx_n_s_validator, __pyx_d, ((PyObject *)__pyx_codeobj__49)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1532, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  __pyx_cur_scope->__pyx_v_is_nested = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "validator.pyx":1535
 *         return isinstance(item, allowed_types)
 * 
 *     if strict:             # <<<<<<<<<<<<<<
 *         # Check if all items are nested objects
 *         return all(is_nested(item) for item in lst)
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_strict); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 1535, __pyx_L1_error)
  if (__pyx_t_2) {

    /* "validator.pyx":1537
 *     if strict:
 *         # Check if all items are nested objects
 *         return all(is_nested(item) for item in lst)             # <<<<<<<<<<<<<<
 *     else:
 *         # Check if any item is a nested object
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_3 = __pyx_pf_9validator_23contains_nested_objects_2genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1537, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_Generator_Next(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1537, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "validator.pyx":1535
 *         return isinstance(item, allowed_types)
 * 
 *     if strict:             # <<<<<<<<<<<<<<
 *         # Check if all items are nested objects
 *         return all(is_nested(item) for item in lst)
 */
  }

  /* "validator.pyx":1540
 *     else:
 *         # Check if any item is a nested object
 *         return any(is_nested(item) for item in lst)             # <<<<<<<<<<<<<<
 * 
 * def validate_nan_policy(nan_policy, *arrays, sample_weights=None):
 */
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_4 = __pyx_pf_9validator_23contains_nested_objects_5genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1540, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = __Pyx_Generator_Next(__pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1540, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;
  }

  /* "validator.pyx":1481
 *     return length_range
 * 
 * def contains_nested_objects(lst, strict=False, allowed_types=None):             # <<<<<<<<<<<<<<
 *     """
 *     Determines whether a list contains nested objects.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("validator.contains_nested_objects", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_gb_9validator_23contains_nested_objects_4generator2);
  __Pyx_XDECREF(__pyx_gb_9validator_23contains_nested_objects_7generator3);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1542
 *         return any(is_nested(item) for item in lst)
 * 
 * def validate_nan_policy(nan_policy, *arrays, sample_weights=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates and applies a specified nan_policy to input arrays and
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_41validate_nan_policy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_40validate_nan_policy[] = "\n    Validates and applies a specified nan_policy to input arrays and\n    optionally to sample weights. This utility is essential for pre-processing\n    data prior to statistical analyses or model training, where appropriate\n    handling of NaN values is critical to ensure accurate and reliable outcomes.\n\n    Parameters\n    ----------\n    nan_policy : {'propagate', 'raise', 'omit'}\n        Defines how to handle NaNs in the input arrays. 'propagate' returns the\n        input data without changes. 'raise' throws an error if NaNs are detected.\n        'omit' removes rows with NaNs across all input arrays and sample weights.\n    *arrays : array-like\n        Variable number of input arrays to be validated and adjusted based on\n        the specified nan_policy.\n    sample_weights : array-like, optional\n        Sample weights array to be validated and adjusted in tandem with the\n        input arrays according to nan_policy. Defaults to None.\n\n    Returns\n    -------\n    arrays : tuple of np.ndarray\n        Adjusted input arrays, with modifications applied based on nan_policy.\n        The order of arrays in the tuple corresponds to the order of input.\n    sample_weights : np.ndarray or None\n        Adjusted sample weights, modified according to nan_policy if provided.\n        Returns None if no sample_weights were provided.\n\n    Raises\n    ------\n    ValueError\n        If `nan_policy` is not among the valid options ('propagate', 'raise',\n        'omit') or if NaNs are detected when `nan_policy` is set to 'raise'.\n\n    Notes\n    -----\n    Handling NaN values is a critical step in data preprocessing, especially\n    in datasets with missing values. The choice of nan_policy can significantly\n    impact subsequent statistical analysis or predictive modeling by either\n    including, excluding, or signaling errors for observations with missing\n    values. This function ensures consistent application of the chosen policy\n    across multiple ""datasets, facilitating robust and error-free analyses.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from gofast.tools.validator import validate_nan_policy\n    >>> y_true = np.array([1, np.nan, 3])\n    >>> y_pred = np.array([1, 2, 3])\n    >>> sample_weights = np.array([0.5, 0.5, 1.0])\n    >>> arrays, sw = validate_nan_policy('omit', y_true, y_pred, \n    ...                                  sample_weights=sample_weights)\n    >>> arrays\n    (array([1., 3.]), array([1., 3.]))\n    >>> sw\n    array([0.5, 1. ])\n    ";
static PyMethodDef __pyx_mdef_9validator_41validate_nan_policy = {"validate_nan_policy", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_41validate_nan_policy, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_40validate_nan_policy};
static PyObject *__pyx_pw_9validator_41validate_nan_policy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_nan_policy = 0;
  PyObject *__pyx_v_sample_weights = 0;
  PyObject *__pyx_v_arrays = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validate_nan_policy (wrapper)", 0);
  if (PyTuple_GET_SIZE(__pyx_args) > 1) {
    __pyx_v_arrays = PyTuple_GetSlice(__pyx_args, 1, PyTuple_GET_SIZE(__pyx_args));
    if (unlikely(!__pyx_v_arrays)) {
      __Pyx_RefNannyFinishContext();
      return NULL;
    }
    __Pyx_GOTREF(__pyx_v_arrays);
  } else {
    __pyx_v_arrays = __pyx_empty_tuple; __Pyx_INCREF(__pyx_empty_tuple);
  }
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_nan_policy,&__pyx_n_s_sample_weights,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        default:
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_nan_policy)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (kw_args == 1) {
        const Py_ssize_t index = 1;
        PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
        if (value) { values[index] = value; kw_args--; }
      }
      if (unlikely(kw_args > 0)) {
        const Py_ssize_t used_pos_args = (pos_args < 1) ? pos_args : 1;
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, used_pos_args, "validate_nan_policy") < 0)) __PYX_ERR(0, 1542, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) < 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_nan_policy = values[0];
    __pyx_v_sample_weights = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("validate_nan_policy", 0, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1542, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_CLEAR(__pyx_v_arrays);
  __Pyx_AddTraceback("validator.validate_nan_policy", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_40validate_nan_policy(__pyx_self, __pyx_v_nan_policy, __pyx_v_sample_weights, __pyx_v_arrays);

  /* function exit code */
  __Pyx_XDECREF(__pyx_v_arrays);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9validator_19validate_nan_policy_2generator4(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */

/* "validator.pyx":1613
 * 
 *         # Filter out NaNs from all arrays and sample_weights
 *         arrays = tuple(array[not_nan_mask] for array in arrays)             # <<<<<<<<<<<<<<
 *         if sample_weights is not None:
 *             sample_weights = sample_weights[not_nan_mask]
 */

static PyObject *__pyx_pf_9validator_19validate_nan_policy_genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_9validator___pyx_scope_struct_10_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_10_genexpr *)__pyx_tp_new_9validator___pyx_scope_struct_10_genexpr(__pyx_ptype_9validator___pyx_scope_struct_10_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_10_genexpr *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 1613, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9validator_19validate_nan_policy_2generator4, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_validate_nan_policy_locals_genex, __pyx_n_s_validator); if (unlikely(!gen)) __PYX_ERR(0, 1613, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("validator.validate_nan_policy.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9validator_19validate_nan_policy_2generator4(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9validator___pyx_scope_struct_10_genexpr *__pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_10_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genexpr", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    case 1: goto __pyx_L6_resume_from_yield;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 1613, __pyx_L1_error)
  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_arrays)) { __Pyx_RaiseClosureNameError("arrays"); __PYX_ERR(0, 1613, __pyx_L1_error) }
  if (unlikely(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_arrays == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
    __PYX_ERR(0, 1613, __pyx_L1_error)
  }
  __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_arrays; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
  for (;;) {
    if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 1613, __pyx_L1_error)
    #else
    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1613, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    #endif
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_array);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_array, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;
    if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_not_nan_mask)) { __Pyx_RaiseClosureNameError("not_nan_mask"); __PYX_ERR(0, 1613, __pyx_L1_error) }
    __pyx_t_3 = __Pyx_PyObject_GetItem(__pyx_cur_scope->__pyx_v_array, __pyx_cur_scope->__pyx_outer_scope->__pyx_v_not_nan_mask); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1613, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    __Pyx_XGIVEREF(__pyx_t_1);
    __pyx_cur_scope->__pyx_t_0 = __pyx_t_1;
    __pyx_cur_scope->__pyx_t_1 = __pyx_t_2;
    __Pyx_XGIVEREF(__pyx_r);
    __Pyx_RefNannyFinishContext();
    __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
    /* return from generator, yielding value */
    __pyx_generator->resume_label = 1;
    return __pyx_r;
    __pyx_L6_resume_from_yield:;
    __pyx_t_1 = __pyx_cur_scope->__pyx_t_0;
    __pyx_cur_scope->__pyx_t_0 = 0;
    __Pyx_XGOTREF(__pyx_t_1);
    __pyx_t_2 = __pyx_cur_scope->__pyx_t_1;
    if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 1613, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* function exit code */
  PyErr_SetNone(PyExc_StopIteration);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_r); __pyx_r = 0;
  #if !CYTHON_USE_EXC_INFO_STACK
  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
  #endif
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9validator_19validate_nan_policy_5generator5(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */

/* "validator.pyx":1619
 *     elif nan_policy == 'raise':
 *         # Check for NaNs in any of the arrays or sample_weights
 *         if any(np.isnan(array).any() for array in arrays) or (             # <<<<<<<<<<<<<<
 *                 sample_weights is not None and np.isnan(sample_weights).any()):
 *             raise ValueError("Input values contain NaNs and nan_policy is 'raise'.")
 */

static PyObject *__pyx_pf_9validator_19validate_nan_policy_3genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_9validator___pyx_scope_struct_11_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_11_genexpr *)__pyx_tp_new_9validator___pyx_scope_struct_11_genexpr(__pyx_ptype_9validator___pyx_scope_struct_11_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_11_genexpr *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 1619, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9validator_19validate_nan_policy_5generator5, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_validate_nan_policy_locals_genex, __pyx_n_s_validator); if (unlikely(!gen)) __PYX_ERR(0, 1619, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("validator.validate_nan_policy.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9validator_19validate_nan_policy_5generator5(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9validator___pyx_scope_struct_11_genexpr *__pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_11_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genexpr", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 1619, __pyx_L1_error)
  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_arrays)) { __Pyx_RaiseClosureNameError("arrays"); __PYX_ERR(0, 1619, __pyx_L1_error) }
  if (unlikely(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_arrays == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
    __PYX_ERR(0, 1619, __pyx_L1_error)
  }
  __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_arrays; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
  for (;;) {
    if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 1619, __pyx_L1_error)
    #else
    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1619, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    #endif
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_array);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_array, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1619, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_isnan); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1619, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_6);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_6, function);
      }
    }
    __pyx_t_4 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_5, __pyx_cur_scope->__pyx_v_array) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_cur_scope->__pyx_v_array);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1619, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_any); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1619, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_6);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_6, function);
      }
    }
    __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_6);
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1619, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 1619, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (__pyx_t_7) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_True);
      __pyx_r = Py_True;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
  }
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    goto __pyx_L0;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  #if !CYTHON_USE_EXC_INFO_STACK
  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
  #endif
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1542
 *         return any(is_nested(item) for item in lst)
 * 
 * def validate_nan_policy(nan_policy, *arrays, sample_weights=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates and applies a specified nan_policy to input arrays and
 */

static PyObject *__pyx_pf_9validator_40validate_nan_policy(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_nan_policy, PyObject *__pyx_v_sample_weights, PyObject *__pyx_v_arrays) {
  struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy *__pyx_cur_scope;
  PyObject *__pyx_v_valid_policies = NULL;
  PyObject *__pyx_gb_9validator_19validate_nan_policy_2generator4 = 0;
  PyObject *__pyx_gb_9validator_19validate_nan_policy_5generator5 = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  Py_ssize_t __pyx_t_6;
  Py_UCS4 __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  int __pyx_t_10;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validate_nan_policy", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy *)__pyx_tp_new_9validator___pyx_scope_struct_9_validate_nan_policy(__pyx_ptype_9validator___pyx_scope_struct_9_validate_nan_policy, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 1542, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_v_arrays = __pyx_v_arrays;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_arrays);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_arrays);
  __Pyx_INCREF(__pyx_v_nan_policy);
  __Pyx_INCREF(__pyx_v_sample_weights);

  /* "validator.pyx":1600
 *     array([0.5, 1. ])
 *     """
 *     nan_policy= str(nan_policy).lower()             # <<<<<<<<<<<<<<
 *     valid_policies = ['propagate', 'raise', 'omit']
 *     if nan_policy not in valid_policies:
 */
  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyUnicode_Type)), __pyx_v_nan_policy); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1600, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_lower); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1600, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1600, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF_SET(__pyx_v_nan_policy, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":1601
 *     """
 *     nan_policy= str(nan_policy).lower()
 *     valid_policies = ['propagate', 'raise', 'omit']             # <<<<<<<<<<<<<<
 *     if nan_policy not in valid_policies:
 *         raise ValueError(
 */
  __pyx_t_1 = PyList_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1601, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_u_propagate);
  __Pyx_GIVEREF(__pyx_n_u_propagate);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_u_propagate);
  __Pyx_INCREF(__pyx_n_u_raise);
  __Pyx_GIVEREF(__pyx_n_u_raise);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_u_raise);
  __Pyx_INCREF(__pyx_n_u_omit);
  __Pyx_GIVEREF(__pyx_n_u_omit);
  PyList_SET_ITEM(__pyx_t_1, 2, __pyx_n_u_omit);
  __pyx_v_valid_policies = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":1602
 *     nan_policy= str(nan_policy).lower()
 *     valid_policies = ['propagate', 'raise', 'omit']
 *     if nan_policy not in valid_policies:             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             f"Invalid nan_policy: {nan_policy}. Valid options are {valid_policies}.")
 */
  __pyx_t_4 = (__Pyx_PySequence_ContainsTF(__pyx_v_nan_policy, __pyx_v_valid_policies, Py_NE)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1602, __pyx_L1_error)
  __pyx_t_5 = (__pyx_t_4 != 0);
  if (unlikely(__pyx_t_5)) {

    /* "validator.pyx":1604
 *     if nan_policy not in valid_policies:
 *         raise ValueError(
 *             f"Invalid nan_policy: {nan_policy}. Valid options are {valid_policies}.")             # <<<<<<<<<<<<<<
 * 
 *     if nan_policy == 'omit':
 */
    __pyx_t_1 = PyTuple_New(5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1604, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_6 = 0;
    __pyx_t_7 = 127;
    __Pyx_INCREF(__pyx_kp_u_Invalid_nan_policy);
    __pyx_t_6 += 20;
    __Pyx_GIVEREF(__pyx_kp_u_Invalid_nan_policy);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_Invalid_nan_policy);
    __pyx_t_3 = __Pyx_PyObject_FormatSimple(__pyx_v_nan_policy, __pyx_empty_unicode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1604, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_7 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) > __pyx_t_7) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) : __pyx_t_7;
    __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_3);
    __pyx_t_3 = 0;
    __Pyx_INCREF(__pyx_kp_u_Valid_options_are);
    __pyx_t_6 += 20;
    __Pyx_GIVEREF(__pyx_kp_u_Valid_options_are);
    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_Valid_options_are);
    __pyx_t_3 = __Pyx_PyObject_FormatSimple(__pyx_v_valid_policies, __pyx_empty_unicode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1604, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_7 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) > __pyx_t_7) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) : __pyx_t_7;
    __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_t_3);
    __pyx_t_3 = 0;
    __Pyx_INCREF(__pyx_kp_u__16);
    __pyx_t_6 += 1;
    __Pyx_GIVEREF(__pyx_kp_u__16);
    PyTuple_SET_ITEM(__pyx_t_1, 4, __pyx_kp_u__16);
    __pyx_t_3 = __Pyx_PyUnicode_Join(__pyx_t_1, 5, __pyx_t_6, __pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1604, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "validator.pyx":1603
 *     valid_policies = ['propagate', 'raise', 'omit']
 *     if nan_policy not in valid_policies:
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             f"Invalid nan_policy: {nan_policy}. Valid options are {valid_policies}.")
 * 
 */
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1603, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 1603, __pyx_L1_error)

    /* "validator.pyx":1602
 *     nan_policy= str(nan_policy).lower()
 *     valid_policies = ['propagate', 'raise', 'omit']
 *     if nan_policy not in valid_policies:             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             f"Invalid nan_policy: {nan_policy}. Valid options are {valid_policies}.")
 */
  }

  /* "validator.pyx":1606
 *             f"Invalid nan_policy: {nan_policy}. Valid options are {valid_policies}.")
 * 
 *     if nan_policy == 'omit':             # <<<<<<<<<<<<<<
 *         # Find indices that are not NaN in all arrays
 *         not_nan_mask = ~np.isnan(np.column_stack(arrays)).any(axis=1)
 */
  __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_nan_policy, __pyx_n_u_omit, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1606, __pyx_L1_error)
  if (__pyx_t_5) {

    /* "validator.pyx":1608
 *     if nan_policy == 'omit':
 *         # Find indices that are not NaN in all arrays
 *         not_nan_mask = ~np.isnan(np.column_stack(arrays)).any(axis=1)             # <<<<<<<<<<<<<<
 *         if sample_weights is not None:
 *             not_nan_mask &= ~np.isnan(sample_weights)
 */
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1608, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_isnan); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1608, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_np); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1608, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_column_stack); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1608, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_8 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_9))) {
      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_9);
      if (likely(__pyx_t_8)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
        __Pyx_INCREF(__pyx_t_8);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_9, function);
      }
    }
    __pyx_t_3 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_9, __pyx_t_8, __pyx_cur_scope->__pyx_v_arrays) : __Pyx_PyObject_CallOneArg(__pyx_t_9, __pyx_cur_scope->__pyx_v_arrays);
    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1608, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_t_9 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_9)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_9);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    __pyx_t_1 = (__pyx_t_9) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_9, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3);
    __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1608, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_any); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1608, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1608, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_axis, __pyx_int_1) < 0) __PYX_ERR(0, 1608, __pyx_L1_error)
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1608, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = PyNumber_Invert(__pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1608, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GIVEREF(__pyx_t_1);
    __pyx_cur_scope->__pyx_v_not_nan_mask = __pyx_t_1;
    __pyx_t_1 = 0;

    /* "validator.pyx":1609
 *         # Find indices that are not NaN in all arrays
 *         not_nan_mask = ~np.isnan(np.column_stack(arrays)).any(axis=1)
 *         if sample_weights is not None:             # <<<<<<<<<<<<<<
 *             not_nan_mask &= ~np.isnan(sample_weights)
 * 
 */
    __pyx_t_5 = (__pyx_v_sample_weights != Py_None);
    __pyx_t_4 = (__pyx_t_5 != 0);
    if (__pyx_t_4) {

      /* "validator.pyx":1610
 *         not_nan_mask = ~np.isnan(np.column_stack(arrays)).any(axis=1)
 *         if sample_weights is not None:
 *             not_nan_mask &= ~np.isnan(sample_weights)             # <<<<<<<<<<<<<<
 * 
 *         # Filter out NaNs from all arrays and sample_weights
 */
      __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1610, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_isnan); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1610, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
        __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
        if (likely(__pyx_t_3)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
          __Pyx_INCREF(__pyx_t_3);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_2, function);
        }
      }
      __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_sample_weights) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_sample_weights);
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1610, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_2 = PyNumber_Invert(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1610, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_1 = PyNumber_InPlaceAnd(__pyx_cur_scope->__pyx_v_not_nan_mask, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1610, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_cur_scope->__pyx_v_not_nan_mask);
      __Pyx_DECREF_SET(__pyx_cur_scope->__pyx_v_not_nan_mask, __pyx_t_1);
      __Pyx_GIVEREF(__pyx_t_1);
      __pyx_t_1 = 0;

      /* "validator.pyx":1609
 *         # Find indices that are not NaN in all arrays
 *         not_nan_mask = ~np.isnan(np.column_stack(arrays)).any(axis=1)
 *         if sample_weights is not None:             # <<<<<<<<<<<<<<
 *             not_nan_mask &= ~np.isnan(sample_weights)
 * 
 */
    }

    /* "validator.pyx":1613
 * 
 *         # Filter out NaNs from all arrays and sample_weights
 *         arrays = tuple(array[not_nan_mask] for array in arrays)             # <<<<<<<<<<<<<<
 *         if sample_weights is not None:
 *             sample_weights = sample_weights[not_nan_mask]
 */
    __pyx_t_1 = __pyx_pf_9validator_19validate_nan_policy_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1613, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __Pyx_PySequence_Tuple(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1613, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_GOTREF(__pyx_cur_scope->__pyx_v_arrays);
    __Pyx_DECREF_SET(__pyx_cur_scope->__pyx_v_arrays, ((PyObject*)__pyx_t_2));
    __Pyx_GIVEREF(__pyx_t_2);
    __pyx_t_2 = 0;

    /* "validator.pyx":1614
 *         # Filter out NaNs from all arrays and sample_weights
 *         arrays = tuple(array[not_nan_mask] for array in arrays)
 *         if sample_weights is not None:             # <<<<<<<<<<<<<<
 *             sample_weights = sample_weights[not_nan_mask]
 * 
 */
    __pyx_t_4 = (__pyx_v_sample_weights != Py_None);
    __pyx_t_5 = (__pyx_t_4 != 0);
    if (__pyx_t_5) {

      /* "validator.pyx":1615
 *         arrays = tuple(array[not_nan_mask] for array in arrays)
 *         if sample_weights is not None:
 *             sample_weights = sample_weights[not_nan_mask]             # <<<<<<<<<<<<<<
 * 
 *     elif nan_policy == 'raise':
 */
      __pyx_t_2 = __Pyx_PyObject_GetItem(__pyx_v_sample_weights, __pyx_cur_scope->__pyx_v_not_nan_mask); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1615, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF_SET(__pyx_v_sample_weights, __pyx_t_2);
      __pyx_t_2 = 0;

      /* "validator.pyx":1614
 *         # Filter out NaNs from all arrays and sample_weights
 *         arrays = tuple(array[not_nan_mask] for array in arrays)
 *         if sample_weights is not None:             # <<<<<<<<<<<<<<
 *             sample_weights = sample_weights[not_nan_mask]
 * 
 */
    }

    /* "validator.pyx":1606
 *             f"Invalid nan_policy: {nan_policy}. Valid options are {valid_policies}.")
 * 
 *     if nan_policy == 'omit':             # <<<<<<<<<<<<<<
 *         # Find indices that are not NaN in all arrays
 *         not_nan_mask = ~np.isnan(np.column_stack(arrays)).any(axis=1)
 */
    goto __pyx_L4;
  }

  /* "validator.pyx":1617
 *             sample_weights = sample_weights[not_nan_mask]
 * 
 *     elif nan_policy == 'raise':             # <<<<<<<<<<<<<<
 *         # Check for NaNs in any of the arrays or sample_weights
 *         if any(np.isnan(array).any() for array in arrays) or (
 */
  __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_nan_policy, __pyx_n_u_raise, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1617, __pyx_L1_error)
  if (__pyx_t_5) {

    /* "validator.pyx":1619
 *     elif nan_policy == 'raise':
 *         # Check for NaNs in any of the arrays or sample_weights
 *         if any(np.isnan(array).any() for array in arrays) or (             # <<<<<<<<<<<<<<
 *                 sample_weights is not None and np.isnan(sample_weights).any()):
 *             raise ValueError("Input values contain NaNs and nan_policy is 'raise'.")
 */
    __pyx_t_2 = __pyx_pf_9validator_19validate_nan_policy_3genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1619, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = __Pyx_Generator_Next(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1619, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1619, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (!__pyx_t_4) {
    } else {
      __pyx_t_5 = __pyx_t_4;
      goto __pyx_L8_bool_binop_done;
    }

    /* "validator.pyx":1620
 *         # Check for NaNs in any of the arrays or sample_weights
 *         if any(np.isnan(array).any() for array in arrays) or (
 *                 sample_weights is not None and np.isnan(sample_weights).any()):             # <<<<<<<<<<<<<<
 *             raise ValueError("Input values contain NaNs and nan_policy is 'raise'.")
 * 
 */
    __pyx_t_4 = (__pyx_v_sample_weights != Py_None);
    __pyx_t_10 = (__pyx_t_4 != 0);
    if (__pyx_t_10) {
    } else {
      __pyx_t_5 = __pyx_t_10;
      goto __pyx_L8_bool_binop_done;
    }
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1620, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_isnan); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1620, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_9))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_9);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_9, function);
      }
    }
    __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_9, __pyx_t_3, __pyx_v_sample_weights) : __Pyx_PyObject_CallOneArg(__pyx_t_9, __pyx_v_sample_weights);
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1620, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_any); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1620, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_9))) {
      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_9);
      if (likely(__pyx_t_2)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
        __Pyx_INCREF(__pyx_t_2);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_9, function);
      }
    }
    __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_CallOneArg(__pyx_t_9, __pyx_t_2) : __Pyx_PyObject_CallNoArg(__pyx_t_9);
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1620, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 1620, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_5 = __pyx_t_10;
    __pyx_L8_bool_binop_done:;

    /* "validator.pyx":1619
 *     elif nan_policy == 'raise':
 *         # Check for NaNs in any of the arrays or sample_weights
 *         if any(np.isnan(array).any() for array in arrays) or (             # <<<<<<<<<<<<<<
 *                 sample_weights is not None and np.isnan(sample_weights).any()):
 *             raise ValueError("Input values contain NaNs and nan_policy is 'raise'.")
 */
    if (unlikely(__pyx_t_5)) {

      /* "validator.pyx":1621
 *         if any(np.isnan(array).any() for array in arrays) or (
 *                 sample_weights is not None and np.isnan(sample_weights).any()):
 *             raise ValueError("Input values contain NaNs and nan_policy is 'raise'.")             # <<<<<<<<<<<<<<
 * 
 *     # Return adjusted arrays and sample_weights
 */
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__50, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1621, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 1621, __pyx_L1_error)

      /* "validator.pyx":1619
 *     elif nan_policy == 'raise':
 *         # Check for NaNs in any of the arrays or sample_weights
 *         if any(np.isnan(array).any() for array in arrays) or (             # <<<<<<<<<<<<<<
 *                 sample_weights is not None and np.isnan(sample_weights).any()):
 *             raise ValueError("Input values contain NaNs and nan_policy is 'raise'.")
 */
    }

    /* "validator.pyx":1617
 *             sample_weights = sample_weights[not_nan_mask]
 * 
 *     elif nan_policy == 'raise':             # <<<<<<<<<<<<<<
 *         # Check for NaNs in any of the arrays or sample_weights
 *         if any(np.isnan(array).any() for array in arrays) or (
 */
  }
  __pyx_L4:;

  /* "validator.pyx":1624
 * 
 *     # Return adjusted arrays and sample_weights
 *     if sample_weights is not None:             # <<<<<<<<<<<<<<
 *         return (*arrays, sample_weights)
 * 
 */
  __pyx_t_5 = (__pyx_v_sample_weights != Py_None);
  __pyx_t_10 = (__pyx_t_5 != 0);
  if (__pyx_t_10) {

    /* "validator.pyx":1625
 *     # Return adjusted arrays and sample_weights
 *     if sample_weights is not None:
 *         return (*arrays, sample_weights)             # <<<<<<<<<<<<<<
 * 
 *     return arrays
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = PySequence_List(__pyx_cur_scope->__pyx_v_arrays); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1625, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (__Pyx_ListComp_Append(__pyx_t_1, __pyx_v_sample_weights) < 0) __PYX_ERR(0, 1625, __pyx_L1_error)
    {
      PyObject *__pyx_temp = PyList_AsTuple(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_1);
      __pyx_t_1 = __pyx_temp; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1625, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
    }
    __pyx_r = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L0;

    /* "validator.pyx":1624
 * 
 *     # Return adjusted arrays and sample_weights
 *     if sample_weights is not None:             # <<<<<<<<<<<<<<
 *         return (*arrays, sample_weights)
 * 
 */
  }

  /* "validator.pyx":1627
 *         return (*arrays, sample_weights)
 * 
 *     return arrays             # <<<<<<<<<<<<<<
 * 
 * def validate_fit_weights(y, sample_weight=None, weighted_y=False):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_arrays);
  __pyx_r = __pyx_cur_scope->__pyx_v_arrays;
  goto __pyx_L0;

  /* "validator.pyx":1542
 *         return any(is_nested(item) for item in lst)
 * 
 * def validate_nan_policy(nan_policy, *arrays, sample_weights=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates and applies a specified nan_policy to input arrays and
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("validator.validate_nan_policy", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_valid_policies);
  __Pyx_XDECREF(__pyx_gb_9validator_19validate_nan_policy_2generator4);
  __Pyx_XDECREF(__pyx_gb_9validator_19validate_nan_policy_5generator5);
  __Pyx_XDECREF(__pyx_v_nan_policy);
  __Pyx_XDECREF(__pyx_v_sample_weights);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1629
 *     return arrays
 * 
 * def validate_fit_weights(y, sample_weight=None, weighted_y=False):             # <<<<<<<<<<<<<<
 *     """
 *     Validate and compute sample weights for fitting.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_43validate_fit_weights(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_42validate_fit_weights[] = "\n    Validate and compute sample weights for fitting.\n\n    Parameters\n    ----------\n    y : array-like of shape (n_samples,)\n        Target values.\n\n    sample_weight : array-like of shape (n_samples,), default=None\n        Sample weights. If None, then samples are equally weighted.\n\n    weighted_y : bool, default=False\n        If True, compute the weighted target values.\n\n    Returns\n    -------\n    sample_weight : array-like of shape (n_samples,)\n        Validated sample weights.\n\n    weighted_y_values : array-like of shape (n_samples,), optional\n        Weighted target values if `weighted_y` is True.\n\n    Raises\n    ------\n    ValueError\n        If `sample_weight` is not None and its length does not match the length of `y`.\n        If any value in `sample_weight` is negative.\n\n    Notes\n    -----\n    This function checks the input sample weights, ensuring they are consistent with\n    the target values `y`. If `sample_weight` is None, it returns an array of ones\n    indicating equal weighting. Otherwise, it validates and returns the given \n    sample weights. If `weighted_y` is True, it also computes and returns the \n    weighted target values.\n\n    Examples\n    --------\n    >>> import numpy as np \n    >>> y = np.array([0, 1, 1, 0, 1])\n    >>> validate_fit_weights(y)\n    array([1., 1., 1., 1., 1.])\n\n    >>> sample_weight = np.array([1, 0.5, 1, 1.5, 1])\n    >>> validate_fit_weights(y, sample_weight)\n    array([1. , 0.5, 1. , 1.5, 1. ])\n\n    >>> validate_fit_weights(y, sample_weight, weighted_y=True)\n    (array([1. , 0.5, 1. , 1.5, 1. ]), array([0. , 0.5, 1. , 0. , 1. ]))\n\n    >>> validate_fit_weights(y, weighted_y=True)\n    (array([1., 1., 1., 1., 1.]), array([0., 1., 1., 0., 1.]))\n    ";
static PyMethodDef __pyx_mdef_9validator_43validate_fit_weights = {"validate_fit_weights", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_43validate_fit_weights, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_42validate_fit_weights};
static PyObject *__pyx_pw_9validator_43validate_fit_weights(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_y = 0;
  PyObject *__pyx_v_sample_weight = 0;
  PyObject *__pyx_v_weighted_y = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validate_fit_weights (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_y,&__pyx_n_s_sample_weight,&__pyx_n_s_weighted_y,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_sample_weight);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_weighted_y);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "validate_fit_weights") < 0)) __PYX_ERR(0, 1629, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_y = values[0];
    __pyx_v_sample_weight = values[1];
    __pyx_v_weighted_y = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("validate_fit_weights", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1629, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.validate_fit_weights", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_42validate_fit_weights(__pyx_self, __pyx_v_y, __pyx_v_sample_weight, __pyx_v_weighted_y);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_42validate_fit_weights(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y, PyObject *__pyx_v_sample_weight, PyObject *__pyx_v_weighted_y) {
  PyObject *__pyx_v_weighted_y_values = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_t_7;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validate_fit_weights", 0);
  __Pyx_INCREF(__pyx_v_y);
  __Pyx_INCREF(__pyx_v_sample_weight);

  /* "validator.pyx":1683
 *     (array([1., 1., 1., 1., 1.]), array([0., 1., 1., 0., 1.]))
 *     """
 *     y = check_array(y, ensure_2d=False)             # <<<<<<<<<<<<<<
 * 
 *     if sample_weight is None:
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_check_array); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1683, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1683, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_y);
  __Pyx_GIVEREF(__pyx_v_y);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_y);
  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1683, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_ensure_2d, Py_False) < 0) __PYX_ERR(0, 1683, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1683, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF_SET(__pyx_v_y, __pyx_t_4);
  __pyx_t_4 = 0;

  /* "validator.pyx":1685
 *     y = check_array(y, ensure_2d=False)
 * 
 *     if sample_weight is None:             # <<<<<<<<<<<<<<
 *         sample_weight = np.ones_like(y, dtype=float)
 *     else:
 */
  __pyx_t_5 = (__pyx_v_sample_weight == Py_None);
  __pyx_t_6 = (__pyx_t_5 != 0);
  if (__pyx_t_6) {

    /* "validator.pyx":1686
 * 
 *     if sample_weight is None:
 *         sample_weight = np.ones_like(y, dtype=float)             # <<<<<<<<<<<<<<
 *     else:
 *         sample_weight = check_array(sample_weight, ensure_2d=False)
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1686, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_ones_like); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1686, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1686, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_INCREF(__pyx_v_y);
    __Pyx_GIVEREF(__pyx_v_y);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_y);
    __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1686, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_dtype, ((PyObject *)(&PyFloat_Type))) < 0) __PYX_ERR(0, 1686, __pyx_L1_error)
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1686, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF_SET(__pyx_v_sample_weight, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "validator.pyx":1685
 *     y = check_array(y, ensure_2d=False)
 * 
 *     if sample_weight is None:             # <<<<<<<<<<<<<<
 *         sample_weight = np.ones_like(y, dtype=float)
 *     else:
 */
    goto __pyx_L3;
  }

  /* "validator.pyx":1688
 *         sample_weight = np.ones_like(y, dtype=float)
 *     else:
 *         sample_weight = check_array(sample_weight, ensure_2d=False)             # <<<<<<<<<<<<<<
 *         check_consistent_length(y, sample_weight)
 * 
 */
  /*else*/ {
    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_check_array); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1688, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1688, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_v_sample_weight);
    __Pyx_GIVEREF(__pyx_v_sample_weight);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_sample_weight);
    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1688, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_ensure_2d, Py_False) < 0) __PYX_ERR(0, 1688, __pyx_L1_error)
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1688, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF_SET(__pyx_v_sample_weight, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "validator.pyx":1689
 *     else:
 *         sample_weight = check_array(sample_weight, ensure_2d=False)
 *         check_consistent_length(y, sample_weight)             # <<<<<<<<<<<<<<
 * 
 *         if not np.all(sample_weight >= 0):
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_check_consistent_length); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1689, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_2 = NULL;
    __pyx_t_7 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_2)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_2);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
        __pyx_t_7 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_y, __pyx_v_sample_weight};
      __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1689, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_3);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
      PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_y, __pyx_v_sample_weight};
      __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1689, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_3);
    } else
    #endif
    {
      __pyx_t_1 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1689, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (__pyx_t_2) {
        __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2); __pyx_t_2 = NULL;
      }
      __Pyx_INCREF(__pyx_v_y);
      __Pyx_GIVEREF(__pyx_v_y);
      PyTuple_SET_ITEM(__pyx_t_1, 0+__pyx_t_7, __pyx_v_y);
      __Pyx_INCREF(__pyx_v_sample_weight);
      __Pyx_GIVEREF(__pyx_v_sample_weight);
      PyTuple_SET_ITEM(__pyx_t_1, 1+__pyx_t_7, __pyx_v_sample_weight);
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_1, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1689, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "validator.pyx":1691
 *         check_consistent_length(y, sample_weight)
 * 
 *         if not np.all(sample_weight >= 0):             # <<<<<<<<<<<<<<
 *             raise ValueError("Sample weights must be non-negative")
 * 
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1691, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_all); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1691, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = PyObject_RichCompare(__pyx_v_sample_weight, __pyx_int_0, Py_GE); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1691, __pyx_L1_error)
    __pyx_t_2 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_2)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_2);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    __pyx_t_3 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_2, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_4);
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1691, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 1691, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_5 = ((!__pyx_t_6) != 0);
    if (unlikely(__pyx_t_5)) {

      /* "validator.pyx":1692
 * 
 *         if not np.all(sample_weight >= 0):
 *             raise ValueError("Sample weights must be non-negative")             # <<<<<<<<<<<<<<
 * 
 *     if weighted_y:
 */
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__51, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1692, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __PYX_ERR(0, 1692, __pyx_L1_error)

      /* "validator.pyx":1691
 *         check_consistent_length(y, sample_weight)
 * 
 *         if not np.all(sample_weight >= 0):             # <<<<<<<<<<<<<<
 *             raise ValueError("Sample weights must be non-negative")
 * 
 */
    }
  }
  __pyx_L3:;

  /* "validator.pyx":1694
 *             raise ValueError("Sample weights must be non-negative")
 * 
 *     if weighted_y:             # <<<<<<<<<<<<<<
 *         weighted_y_values = y * sample_weight
 *         return sample_weight, weighted_y_values
 */
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_v_weighted_y); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1694, __pyx_L1_error)
  if (__pyx_t_5) {

    /* "validator.pyx":1695
 * 
 *     if weighted_y:
 *         weighted_y_values = y * sample_weight             # <<<<<<<<<<<<<<
 *         return sample_weight, weighted_y_values
 * 
 */
    __pyx_t_3 = PyNumber_Multiply(__pyx_v_y, __pyx_v_sample_weight); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1695, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_v_weighted_y_values = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "validator.pyx":1696
 *     if weighted_y:
 *         weighted_y_values = y * sample_weight
 *         return sample_weight, weighted_y_values             # <<<<<<<<<<<<<<
 * 
 *     return sample_weight
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1696, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_v_sample_weight);
    __Pyx_GIVEREF(__pyx_v_sample_weight);
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_sample_weight);
    __Pyx_INCREF(__pyx_v_weighted_y_values);
    __Pyx_GIVEREF(__pyx_v_weighted_y_values);
    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_weighted_y_values);
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;

    /* "validator.pyx":1694
 *             raise ValueError("Sample weights must be non-negative")
 * 
 *     if weighted_y:             # <<<<<<<<<<<<<<
 *         weighted_y_values = y * sample_weight
 *         return sample_weight, weighted_y_values
 */
  }

  /* "validator.pyx":1698
 *         return sample_weight, weighted_y_values
 * 
 *     return sample_weight             # <<<<<<<<<<<<<<
 * 
 * def is_valid_policies(nan_policy, allowed_policies=None):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_sample_weight);
  __pyx_r = __pyx_v_sample_weight;
  goto __pyx_L0;

  /* "validator.pyx":1629
 *     return arrays
 * 
 * def validate_fit_weights(y, sample_weight=None, weighted_y=False):             # <<<<<<<<<<<<<<
 *     """
 *     Validate and compute sample weights for fitting.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("validator.validate_fit_weights", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_weighted_y_values);
  __Pyx_XDECREF(__pyx_v_y);
  __Pyx_XDECREF(__pyx_v_sample_weight);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1700
 *     return sample_weight
 * 
 * def is_valid_policies(nan_policy, allowed_policies=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates the `nan_policy` or any policy argument to ensure it is one
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_45is_valid_policies(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_44is_valid_policies[] = "\n    Validates the `nan_policy` or any policy argument to ensure it is one\n    of the acceptable options (`allowed_policies`). \n    \n    Function is used to enforce conformity to predefined NaN handling\n    strategies in data processing tasks.\n\n    Parameters\n    ----------\n    nan_policy : str\n        The NaN handling policy to validate. Acceptable values are:\n        'propagate' - NaN values are propagated, i.e., no action is taken.\n        'omit' - NaN values are omitted before proceeding with the operation.\n        'raise' - Raises an error if NaN values are present.\n\n    allowed_policies : list of str, optional\n        A list of allowable policy options. If None, \n        defaults to ['propagate', 'omit', 'raise'].\n\n    Raises\n    ------\n    ValueError\n        If `nan_policy` is not one of the valid options in `allowed_policies`.\n\n    Returns\n    -------\n    str\n        The verified `nan_policy` value, confirming it is within \n        allowed parameters.        \n\n    Examples\n    --------\n    >>> from gofast.tools.validator import is_valid_policies\n    >>> is_valid_policies('omit')  # This should pass without an error.\n    >>> is_valid_policies('ignore')  # This should raise a ValueError.\n      \n    ";
static PyMethodDef __pyx_mdef_9validator_45is_valid_policies = {"is_valid_policies", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_45is_valid_policies, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_44is_valid_policies};
static PyObject *__pyx_pw_9validator_45is_valid_policies(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_nan_policy = 0;
  PyObject *__pyx_v_allowed_policies = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("is_valid_policies (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_nan_policy,&__pyx_n_s_allowed_policies,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_nan_policy)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_allowed_policies);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "is_valid_policies") < 0)) __PYX_ERR(0, 1700, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_nan_policy = values[0];
    __pyx_v_allowed_policies = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("is_valid_policies", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1700, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.is_valid_policies", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_44is_valid_policies(__pyx_self, __pyx_v_nan_policy, __pyx_v_allowed_policies);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_44is_valid_policies(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_nan_policy, PyObject *__pyx_v_allowed_policies) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  Py_ssize_t __pyx_t_7;
  Py_UCS4 __pyx_t_8;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("is_valid_policies", 0);
  __Pyx_INCREF(__pyx_v_nan_policy);
  __Pyx_INCREF(__pyx_v_allowed_policies);

  /* "validator.pyx":1739
 *     """
 *     # Set default policies if none provided
 *     if allowed_policies is None:             # <<<<<<<<<<<<<<
 *         allowed_policies = ['propagate', 'omit', 'raise']
 * 
 */
  __pyx_t_1 = (__pyx_v_allowed_policies == Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "validator.pyx":1740
 *     # Set default policies if none provided
 *     if allowed_policies is None:
 *         allowed_policies = ['propagate', 'omit', 'raise']             # <<<<<<<<<<<<<<
 * 
 *     # Ensure allowed_policies is a list even if a single string was provided
 */
    __pyx_t_3 = PyList_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1740, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_n_u_propagate);
    __Pyx_GIVEREF(__pyx_n_u_propagate);
    PyList_SET_ITEM(__pyx_t_3, 0, __pyx_n_u_propagate);
    __Pyx_INCREF(__pyx_n_u_omit);
    __Pyx_GIVEREF(__pyx_n_u_omit);
    PyList_SET_ITEM(__pyx_t_3, 1, __pyx_n_u_omit);
    __Pyx_INCREF(__pyx_n_u_raise);
    __Pyx_GIVEREF(__pyx_n_u_raise);
    PyList_SET_ITEM(__pyx_t_3, 2, __pyx_n_u_raise);
    __Pyx_DECREF_SET(__pyx_v_allowed_policies, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "validator.pyx":1739
 *     """
 *     # Set default policies if none provided
 *     if allowed_policies is None:             # <<<<<<<<<<<<<<
 *         allowed_policies = ['propagate', 'omit', 'raise']
 * 
 */
  }

  /* "validator.pyx":1743
 * 
 *     # Ensure allowed_policies is a list even if a single string was provided
 *     if isinstance(allowed_policies, str):             # <<<<<<<<<<<<<<
 *         allowed_policies = [allowed_policies]
 * 
 */
  __pyx_t_2 = PyUnicode_Check(__pyx_v_allowed_policies); 
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "validator.pyx":1744
 *     # Ensure allowed_policies is a list even if a single string was provided
 *     if isinstance(allowed_policies, str):
 *         allowed_policies = [allowed_policies]             # <<<<<<<<<<<<<<
 * 
 *     # Normalize the input policy for comparison
 */
    __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1744, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_v_allowed_policies);
    __Pyx_GIVEREF(__pyx_v_allowed_policies);
    PyList_SET_ITEM(__pyx_t_3, 0, __pyx_v_allowed_policies);
    __Pyx_DECREF_SET(__pyx_v_allowed_policies, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "validator.pyx":1743
 * 
 *     # Ensure allowed_policies is a list even if a single string was provided
 *     if isinstance(allowed_policies, str):             # <<<<<<<<<<<<<<
 *         allowed_policies = [allowed_policies]
 * 
 */
  }

  /* "validator.pyx":1747
 * 
 *     # Normalize the input policy for comparison
 *     nan_policy = str(nan_policy).lower().strip()             # <<<<<<<<<<<<<<
 * 
 *     # Check if the provided nan_policy is in the list of allowed policies
 */
  __pyx_t_5 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyUnicode_Type)), __pyx_v_nan_policy); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1747, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_lower); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1747, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_6);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_6, function);
    }
  }
  __pyx_t_4 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1747, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_strip); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1747, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_6);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_6, function);
    }
  }
  __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1747, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __Pyx_DECREF_SET(__pyx_v_nan_policy, __pyx_t_3);
  __pyx_t_3 = 0;

  /* "validator.pyx":1750
 * 
 *     # Check if the provided nan_policy is in the list of allowed policies
 *     if nan_policy not in allowed_policies:             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             f"Invalid nan_policy {nan_policy!r}. Choose from {allowed_policies}.")
 */
  __pyx_t_1 = (__Pyx_PySequence_ContainsTF(__pyx_v_nan_policy, __pyx_v_allowed_policies, Py_NE)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 1750, __pyx_L1_error)
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (unlikely(__pyx_t_2)) {

    /* "validator.pyx":1752
 *     if nan_policy not in allowed_policies:
 *         raise ValueError(
 *             f"Invalid nan_policy {nan_policy!r}. Choose from {allowed_policies}.")             # <<<<<<<<<<<<<<
 * 
 *     return nan_policy
 */
    __pyx_t_3 = PyTuple_New(5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1752, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_7 = 0;
    __pyx_t_8 = 127;
    __Pyx_INCREF(__pyx_kp_u_Invalid_nan_policy_2);
    __pyx_t_7 += 19;
    __Pyx_GIVEREF(__pyx_kp_u_Invalid_nan_policy_2);
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_kp_u_Invalid_nan_policy_2);
    __pyx_t_6 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_v_nan_policy), __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1752, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_8 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) > __pyx_t_8) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) : __pyx_t_8;
    __pyx_t_7 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_6);
    __pyx_t_6 = 0;
    __Pyx_INCREF(__pyx_kp_u_Choose_from);
    __pyx_t_7 += 14;
    __Pyx_GIVEREF(__pyx_kp_u_Choose_from);
    PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_kp_u_Choose_from);
    __pyx_t_6 = __Pyx_PyObject_FormatSimple(__pyx_v_allowed_policies, __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1752, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_8 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) > __pyx_t_8) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) : __pyx_t_8;
    __pyx_t_7 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_3, 3, __pyx_t_6);
    __pyx_t_6 = 0;
    __Pyx_INCREF(__pyx_kp_u__16);
    __pyx_t_7 += 1;
    __Pyx_GIVEREF(__pyx_kp_u__16);
    PyTuple_SET_ITEM(__pyx_t_3, 4, __pyx_kp_u__16);
    __pyx_t_6 = __Pyx_PyUnicode_Join(__pyx_t_3, 5, __pyx_t_7, __pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1752, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "validator.pyx":1751
 *     # Check if the provided nan_policy is in the list of allowed policies
 *     if nan_policy not in allowed_policies:
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             f"Invalid nan_policy {nan_policy!r}. Choose from {allowed_policies}.")
 * 
 */
    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1751, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 1751, __pyx_L1_error)

    /* "validator.pyx":1750
 * 
 *     # Check if the provided nan_policy is in the list of allowed policies
 *     if nan_policy not in allowed_policies:             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             f"Invalid nan_policy {nan_policy!r}. Choose from {allowed_policies}.")
 */
  }

  /* "validator.pyx":1754
 *             f"Invalid nan_policy {nan_policy!r}. Choose from {allowed_policies}.")
 * 
 *     return nan_policy             # <<<<<<<<<<<<<<
 * 
 * def validate_multioutput(value, extra=''):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_nan_policy);
  __pyx_r = __pyx_v_nan_policy;
  goto __pyx_L0;

  /* "validator.pyx":1700
 *     return sample_weight
 * 
 * def is_valid_policies(nan_policy, allowed_policies=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates the `nan_policy` or any policy argument to ensure it is one
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("validator.is_valid_policies", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_nan_policy);
  __Pyx_XDECREF(__pyx_v_allowed_policies);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1756
 *     return nan_policy
 * 
 * def validate_multioutput(value, extra=''):             # <<<<<<<<<<<<<<
 *     """
 *     Validate the `multioutput` parameter value and handle special cases.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_47validate_multioutput(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_46validate_multioutput[] = "\n    Validate the `multioutput` parameter value and handle special cases.\n\n    This function checks if the provided `multioutput` value is one of the\n    accepted strings ('raw_values', 'uniform_average', 'raise', 'warn'). It\n    warns or raises an error based on the value if it's applicable.\n\n    Parameters\n    ----------\n    value : str\n        The value of the `multioutput` parameter to be validated. Accepted\n        values are 'raw_values', 'uniform_average', 'raise', 'warn'.\n    extra : str, optional\n        Additional text to include in the warning or error message if\n        `multioutput` is not applicable.\n\n    Returns\n    -------\n    str\n        The validated `multioutput` value in lowercase if it's one of the\n        accepted values. If the value is 'warn' or 'raise', the function\n        handles the case accordingly without returning a value.\n\n    Raises\n    ------\n    ValueError\n        If `value` is not one of the accepted strings and is not 'raise'.\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import validate_multioutput\n    >>> validate_multioutput('raw_values')\n    'raw_values'\n\n    >>> validate_multioutput('warn', extra=' for Dice Similarity Coefficient')\n    # This will warn that multioutput parameter is not applicable for Dice\n    # Similarity Coefficient.\n\n    >>> validate_multioutput('raise', extra=' for Gini Coefficient')\n    # This will raise a ValueError indicating that multioutput parameter\n    # is not applicable for Gini Coefficient.\n\n    >>> validate_multioutput('average')\n    # This will raise a ValueError indicating 'average' is an invalid value\n    # for multioutput parameter.\n\n    Note\n    ----\n    The function is designed to ensure API consistency across various metrics\n    functions by providing a standard way to handle `multioutput` parameter\n    values, especially in contexts where multiple outputs are not applicable.\n    ";
static PyMethodDef __pyx_mdef_9validator_47validate_multioutput = {"validate_multioutput", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_47validate_multioutput, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_46validate_multioutput};
static PyObject *__pyx_pw_9validator_47validate_multioutput(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_value = 0;
  PyObject *__pyx_v_extra = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validate_multioutput (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_value,&__pyx_n_s_extra,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_kp_u__7);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_extra);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "validate_multioutput") < 0)) __PYX_ERR(0, 1756, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_value = values[0];
    __pyx_v_extra = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("validate_multioutput", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1756, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.validate_multioutput", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_46validate_multioutput(__pyx_self, __pyx_v_value, __pyx_v_extra);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_46validate_multioutput(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value, PyObject *__pyx_v_extra) {
  PyObject *__pyx_v_valid_values = NULL;
  PyObject *__pyx_v_value_lower = NULL;
  PyObject *__pyx_v_warn_msg = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  Py_ssize_t __pyx_t_8;
  Py_UCS4 __pyx_t_9;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validate_multioutput", 0);

  /* "validator.pyx":1809
 *     values, especially in contexts where multiple outputs are not applicable.
 *     """
 *     valid_values = ['raw_values', 'uniform_average']             # <<<<<<<<<<<<<<
 *     value_lower = str(value).lower()
 *     if value_lower=="average_uniform": value_lower ="uniform_average"
 */
  __pyx_t_1 = PyList_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1809, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_u_raw_values);
  __Pyx_GIVEREF(__pyx_n_u_raw_values);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_u_raw_values);
  __Pyx_INCREF(__pyx_n_u_uniform_average);
  __Pyx_GIVEREF(__pyx_n_u_uniform_average);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_u_uniform_average);
  __pyx_v_valid_values = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":1810
 *     """
 *     valid_values = ['raw_values', 'uniform_average']
 *     value_lower = str(value).lower()             # <<<<<<<<<<<<<<
 *     if value_lower=="average_uniform": value_lower ="uniform_average"
 *     if value_lower in ['raise', 'warn']:
 */
  __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyUnicode_Type)), __pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1810, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_lower); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1810, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1810, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_value_lower = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":1811
 *     valid_values = ['raw_values', 'uniform_average']
 *     value_lower = str(value).lower()
 *     if value_lower=="average_uniform": value_lower ="uniform_average"             # <<<<<<<<<<<<<<
 *     if value_lower in ['raise', 'warn']:
 *         warn_msg = ("The `multioutput` parameter is not applicable" + extra +
 */
  __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_v_value_lower, __pyx_n_u_average_uniform, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1811, __pyx_L1_error)
  if (__pyx_t_4) {
    __Pyx_INCREF(__pyx_n_u_uniform_average);
    __Pyx_DECREF_SET(__pyx_v_value_lower, __pyx_n_u_uniform_average);
  }

  /* "validator.pyx":1812
 *     value_lower = str(value).lower()
 *     if value_lower=="average_uniform": value_lower ="uniform_average"
 *     if value_lower in ['raise', 'warn']:             # <<<<<<<<<<<<<<
 *         warn_msg = ("The `multioutput` parameter is not applicable" + extra +
 *                     " as it inherently combines outputs into a single score.")
 */
  __Pyx_INCREF(__pyx_v_value_lower);
  __pyx_t_1 = __pyx_v_value_lower;
  __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_t_1, __pyx_n_u_raise, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1812, __pyx_L1_error)
  if (!__pyx_t_5) {
  } else {
    __pyx_t_4 = __pyx_t_5;
    goto __pyx_L5_bool_binop_done;
  }
  __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_t_1, __pyx_n_u_warn, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1812, __pyx_L1_error)
  __pyx_t_4 = __pyx_t_5;
  __pyx_L5_bool_binop_done:;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = (__pyx_t_4 != 0);
  if (__pyx_t_5) {

    /* "validator.pyx":1813
 *     if value_lower=="average_uniform": value_lower ="uniform_average"
 *     if value_lower in ['raise', 'warn']:
 *         warn_msg = ("The `multioutput` parameter is not applicable" + extra +             # <<<<<<<<<<<<<<
 *                     " as it inherently combines outputs into a single score.")
 *         if value_lower == 'warn':
 */
    __pyx_t_1 = PyNumber_Add(__pyx_kp_u_The_multioutput_parameter_is_not, __pyx_v_extra); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1813, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = PyNumber_Add(__pyx_t_1, __pyx_kp_u_as_it_inherently_combines_outpu); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1813, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_v_warn_msg = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "validator.pyx":1815
 *         warn_msg = ("The `multioutput` parameter is not applicable" + extra +
 *                     " as it inherently combines outputs into a single score.")
 *         if value_lower == 'warn':             # <<<<<<<<<<<<<<
 *             warnings.warn(warn_msg, UserWarning)
 *         elif value_lower == 'raise':
 */
    __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_value_lower, __pyx_n_u_warn, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1815, __pyx_L1_error)
    if (__pyx_t_5) {

      /* "validator.pyx":1816
 *                     " as it inherently combines outputs into a single score.")
 *         if value_lower == 'warn':
 *             warnings.warn(warn_msg, UserWarning)             # <<<<<<<<<<<<<<
 *         elif value_lower == 'raise':
 *             raise ValueError(warn_msg)
 */
      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_warnings); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1816, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_warn); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1816, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_1 = NULL;
      __pyx_t_6 = 0;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
        __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
        if (likely(__pyx_t_1)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
          __Pyx_INCREF(__pyx_t_1);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_2, function);
          __pyx_t_6 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_2)) {
        PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_v_warn_msg, __pyx_builtin_UserWarning};
        __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1816, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_GOTREF(__pyx_t_3);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
        PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_v_warn_msg, __pyx_builtin_UserWarning};
        __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1816, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_GOTREF(__pyx_t_3);
      } else
      #endif
      {
        __pyx_t_7 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1816, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_7);
        if (__pyx_t_1) {
          __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_1); __pyx_t_1 = NULL;
        }
        __Pyx_INCREF(__pyx_v_warn_msg);
        __Pyx_GIVEREF(__pyx_v_warn_msg);
        PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_v_warn_msg);
        __Pyx_INCREF(__pyx_builtin_UserWarning);
        __Pyx_GIVEREF(__pyx_builtin_UserWarning);
        PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_builtin_UserWarning);
        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1816, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      }
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

      /* "validator.pyx":1815
 *         warn_msg = ("The `multioutput` parameter is not applicable" + extra +
 *                     " as it inherently combines outputs into a single score.")
 *         if value_lower == 'warn':             # <<<<<<<<<<<<<<
 *             warnings.warn(warn_msg, UserWarning)
 *         elif value_lower == 'raise':
 */
      goto __pyx_L7;
    }

    /* "validator.pyx":1817
 *         if value_lower == 'warn':
 *             warnings.warn(warn_msg, UserWarning)
 *         elif value_lower == 'raise':             # <<<<<<<<<<<<<<
 *             raise ValueError(warn_msg)
 *     elif value_lower not in valid_values:
 */
    __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_value_lower, __pyx_n_u_raise, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1817, __pyx_L1_error)
    if (unlikely(__pyx_t_5)) {

      /* "validator.pyx":1818
 *             warnings.warn(warn_msg, UserWarning)
 *         elif value_lower == 'raise':
 *             raise ValueError(warn_msg)             # <<<<<<<<<<<<<<
 *     elif value_lower not in valid_values:
 *         raise ValueError(
 */
      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_v_warn_msg); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1818, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __PYX_ERR(0, 1818, __pyx_L1_error)

      /* "validator.pyx":1817
 *         if value_lower == 'warn':
 *             warnings.warn(warn_msg, UserWarning)
 *         elif value_lower == 'raise':             # <<<<<<<<<<<<<<
 *             raise ValueError(warn_msg)
 *     elif value_lower not in valid_values:
 */
    }
    __pyx_L7:;

    /* "validator.pyx":1812
 *     value_lower = str(value).lower()
 *     if value_lower=="average_uniform": value_lower ="uniform_average"
 *     if value_lower in ['raise', 'warn']:             # <<<<<<<<<<<<<<
 *         warn_msg = ("The `multioutput` parameter is not applicable" + extra +
 *                     " as it inherently combines outputs into a single score.")
 */
    goto __pyx_L4;
  }

  /* "validator.pyx":1819
 *         elif value_lower == 'raise':
 *             raise ValueError(warn_msg)
 *     elif value_lower not in valid_values:             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             "Invalid value for multioutput parameter. Expect 'raw_values' or "
 */
  __pyx_t_5 = (__Pyx_PySequence_ContainsTF(__pyx_v_value_lower, __pyx_v_valid_values, Py_NE)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1819, __pyx_L1_error)
  __pyx_t_4 = (__pyx_t_5 != 0);
  if (unlikely(__pyx_t_4)) {

    /* "validator.pyx":1821
 *     elif value_lower not in valid_values:
 *         raise ValueError(
 *             "Invalid value for multioutput parameter. Expect 'raw_values' or "             # <<<<<<<<<<<<<<
 *             f"'uniform_average'. Got '{value}'.")
 * 
 */
    __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1821, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_8 = 0;
    __pyx_t_9 = 127;
    __Pyx_INCREF(__pyx_kp_u_Invalid_value_for_multioutput_pa);
    __pyx_t_8 += 88;
    __Pyx_GIVEREF(__pyx_kp_u_Invalid_value_for_multioutput_pa);
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_kp_u_Invalid_value_for_multioutput_pa);

    /* "validator.pyx":1822
 *         raise ValueError(
 *             "Invalid value for multioutput parameter. Expect 'raw_values' or "
 *             f"'uniform_average'. Got '{value}'.")             # <<<<<<<<<<<<<<
 * 
 *     return value_lower
 */
    __pyx_t_2 = __Pyx_PyObject_FormatSimple(__pyx_v_value, __pyx_empty_unicode); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1822, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_9 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) > __pyx_t_9) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) : __pyx_t_9;
    __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_2);
    __Pyx_GIVEREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
    __pyx_t_2 = 0;
    __Pyx_INCREF(__pyx_kp_u__52);
    __pyx_t_8 += 2;
    __Pyx_GIVEREF(__pyx_kp_u__52);
    PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_kp_u__52);

    /* "validator.pyx":1821
 *     elif value_lower not in valid_values:
 *         raise ValueError(
 *             "Invalid value for multioutput parameter. Expect 'raw_values' or "             # <<<<<<<<<<<<<<
 *             f"'uniform_average'. Got '{value}'.")
 * 
 */
    __pyx_t_2 = __Pyx_PyUnicode_Join(__pyx_t_3, 3, __pyx_t_8, __pyx_t_9); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1821, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "validator.pyx":1820
 *             raise ValueError(warn_msg)
 *     elif value_lower not in valid_values:
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             "Invalid value for multioutput parameter. Expect 'raw_values' or "
 *             f"'uniform_average'. Got '{value}'.")
 */
    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1820, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 1820, __pyx_L1_error)

    /* "validator.pyx":1819
 *         elif value_lower == 'raise':
 *             raise ValueError(warn_msg)
 *     elif value_lower not in valid_values:             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             "Invalid value for multioutput parameter. Expect 'raw_values' or "
 */
  }
  __pyx_L4:;

  /* "validator.pyx":1824
 *             f"'uniform_average'. Got '{value}'.")
 * 
 *     return value_lower             # <<<<<<<<<<<<<<
 * 
 * def ensure_non_negative(*arrays, err_msg=None):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_value_lower);
  __pyx_r = __pyx_v_value_lower;
  goto __pyx_L0;

  /* "validator.pyx":1756
 *     return nan_policy
 * 
 * def validate_multioutput(value, extra=''):             # <<<<<<<<<<<<<<
 *     """
 *     Validate the `multioutput` parameter value and handle special cases.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("validator.validate_multioutput", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_valid_values);
  __Pyx_XDECREF(__pyx_v_value_lower);
  __Pyx_XDECREF(__pyx_v_warn_msg);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1826
 *     return value_lower
 * 
 * def ensure_non_negative(*arrays, err_msg=None):             # <<<<<<<<<<<<<<
 *     """
 *     Ensure that provided arrays contain only non-negative values.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_49ensure_non_negative(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_48ensure_non_negative[] = "\n    Ensure that provided arrays contain only non-negative values.\n\n    This function checks each provided array for non-negativity. If any negative\n    values are found in any array, it raises a ValueError. This check is crucial\n    for computations or algorithms where negative values are not permissible, such\n    as logarithmic transformations.\n\n    Parameters\n    ----------\n    *arrays : array-like\n        One or more array-like structures (e.g., lists, numpy arrays). Each array\n        is checked for non-negativity.\n    err_msg: str, optional \n        Specify a custom error message if negative values are found.\n        \n    Raises\n    ------\n    ValueError\n        If any array contains negative values, a ValueError is raised with a message\n        indicating that only non-negative values are expected.\n\n    Examples\n    --------\n    >>> y_true = [0, 1, 2, 3]\n    >>> y_pred = [0.5, 2.1, 3.5, -0.1]\n    >>> ensure_non_negative(y_true, y_pred)\n    ValueError: Negative value found. Expect only non-negative values.\n\n    Note\n    ----\n    The function uses a variable number of arguments, allowing flexibility in the number\n    of arrays checked in a single call.\n    ";
static PyMethodDef __pyx_mdef_9validator_49ensure_non_negative = {"ensure_non_negative", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_49ensure_non_negative, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_48ensure_non_negative};
static PyObject *__pyx_pw_9validator_49ensure_non_negative(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_err_msg = 0;
  PyObject *__pyx_v_arrays = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("ensure_non_negative (wrapper)", 0);
  if (PyTuple_GET_SIZE(__pyx_args) > 0) {
    __pyx_v_arrays = PyTuple_GetSlice(__pyx_args, 0, PyTuple_GET_SIZE(__pyx_args));
    if (unlikely(!__pyx_v_arrays)) {
      __Pyx_RefNannyFinishContext();
      return NULL;
    }
    __Pyx_GOTREF(__pyx_v_arrays);
  } else {
    __pyx_v_arrays = __pyx_empty_tuple; __Pyx_INCREF(__pyx_empty_tuple);
  }
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_err_msg,0};
    PyObject* values[1] = {0};
    values[0] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        default:
        case  0: break;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      if (kw_args == 1) {
        const Py_ssize_t index = 0;
        PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
        if (value) { values[index] = value; kw_args--; }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, 0, "ensure_non_negative") < 0)) __PYX_ERR(0, 1826, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) < 0) {
      goto __pyx_L5_argtuple_error;
    } else {
    }
    __pyx_v_err_msg = values[0];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("ensure_non_negative", 0, 0, 0, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1826, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_DECREF(__pyx_v_arrays); __pyx_v_arrays = 0;
  __Pyx_AddTraceback("validator.ensure_non_negative", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_48ensure_non_negative(__pyx_self, __pyx_v_err_msg, __pyx_v_arrays);

  /* function exit code */
  __Pyx_XDECREF(__pyx_v_arrays);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_48ensure_non_negative(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_err_msg, PyObject *__pyx_v_arrays) {
  PyObject *__pyx_v_i = NULL;
  PyObject *__pyx_v_array = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  Py_ssize_t __pyx_t_4;
  PyObject *(*__pyx_t_5)(PyObject *);
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *(*__pyx_t_8)(PyObject *);
  PyObject *__pyx_t_9 = NULL;
  int __pyx_t_10;
  Py_ssize_t __pyx_t_11;
  Py_UCS4 __pyx_t_12;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("ensure_non_negative", 0);
  __Pyx_INCREF(__pyx_v_err_msg);

  /* "validator.pyx":1861
 *     of arrays checked in a single call.
 *     """
 *     for i, array in enumerate(arrays, start=1):             # <<<<<<<<<<<<<<
 *         if np.any(np.asarray(array) < 0):
 *             err_msg = err_msg or (
 */
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1861, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_v_arrays);
  __Pyx_GIVEREF(__pyx_v_arrays);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_arrays);
  __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1861, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_start, __pyx_int_1) < 0) __PYX_ERR(0, 1861, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_enumerate, __pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1861, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (likely(PyList_CheckExact(__pyx_t_3)) || PyTuple_CheckExact(__pyx_t_3)) {
    __pyx_t_2 = __pyx_t_3; __Pyx_INCREF(__pyx_t_2); __pyx_t_4 = 0;
    __pyx_t_5 = NULL;
  } else {
    __pyx_t_4 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1861, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_5 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1861, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  for (;;) {
    if (likely(!__pyx_t_5)) {
      if (likely(PyList_CheckExact(__pyx_t_2))) {
        if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_3 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_4); __Pyx_INCREF(__pyx_t_3); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 1861, __pyx_L1_error)
        #else
        __pyx_t_3 = PySequence_ITEM(__pyx_t_2, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1861, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        #endif
      } else {
        if (__pyx_t_4 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_4); __Pyx_INCREF(__pyx_t_3); __pyx_t_4++; if (unlikely(0 < 0)) __PYX_ERR(0, 1861, __pyx_L1_error)
        #else
        __pyx_t_3 = PySequence_ITEM(__pyx_t_2, __pyx_t_4); __pyx_t_4++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1861, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        #endif
      }
    } else {
      __pyx_t_3 = __pyx_t_5(__pyx_t_2);
      if (unlikely(!__pyx_t_3)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 1861, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_3);
    }
    if ((likely(PyTuple_CheckExact(__pyx_t_3))) || (PyList_CheckExact(__pyx_t_3))) {
      PyObject* sequence = __pyx_t_3;
      Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
      if (unlikely(size != 2)) {
        if (size > 2) __Pyx_RaiseTooManyValuesError(2);
        else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
        __PYX_ERR(0, 1861, __pyx_L1_error)
      }
      #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
      if (likely(PyTuple_CheckExact(sequence))) {
        __pyx_t_1 = PyTuple_GET_ITEM(sequence, 0); 
        __pyx_t_6 = PyTuple_GET_ITEM(sequence, 1); 
      } else {
        __pyx_t_1 = PyList_GET_ITEM(sequence, 0); 
        __pyx_t_6 = PyList_GET_ITEM(sequence, 1); 
      }
      __Pyx_INCREF(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_6);
      #else
      __pyx_t_1 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1861, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_6 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1861, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      #endif
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else {
      Py_ssize_t index = -1;
      __pyx_t_7 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1861, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_8 = Py_TYPE(__pyx_t_7)->tp_iternext;
      index = 0; __pyx_t_1 = __pyx_t_8(__pyx_t_7); if (unlikely(!__pyx_t_1)) goto __pyx_L5_unpacking_failed;
      __Pyx_GOTREF(__pyx_t_1);
      index = 1; __pyx_t_6 = __pyx_t_8(__pyx_t_7); if (unlikely(!__pyx_t_6)) goto __pyx_L5_unpacking_failed;
      __Pyx_GOTREF(__pyx_t_6);
      if (__Pyx_IternextUnpackEndCheck(__pyx_t_8(__pyx_t_7), 2) < 0) __PYX_ERR(0, 1861, __pyx_L1_error)
      __pyx_t_8 = NULL;
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      goto __pyx_L6_unpacking_done;
      __pyx_L5_unpacking_failed:;
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __pyx_t_8 = NULL;
      if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
      __PYX_ERR(0, 1861, __pyx_L1_error)
      __pyx_L6_unpacking_done:;
    }
    __Pyx_XDECREF_SET(__pyx_v_i, __pyx_t_1);
    __pyx_t_1 = 0;
    __Pyx_XDECREF_SET(__pyx_v_array, __pyx_t_6);
    __pyx_t_6 = 0;

    /* "validator.pyx":1862
 *     """
 *     for i, array in enumerate(arrays, start=1):
 *         if np.any(np.asarray(array) < 0):             # <<<<<<<<<<<<<<
 *             err_msg = err_msg or (
 *                 f"Array at index {i} contains negative values."
 */
    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1862, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_any); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1862, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1862, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_asarray); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1862, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_9))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_9);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_9, function);
      }
    }
    __pyx_t_6 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_9, __pyx_t_7, __pyx_v_array) : __Pyx_PyObject_CallOneArg(__pyx_t_9, __pyx_v_array);
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
    if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1862, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_t_9 = PyObject_RichCompare(__pyx_t_6, __pyx_int_0, Py_LT); __Pyx_XGOTREF(__pyx_t_9); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1862, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    __pyx_t_3 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_6, __pyx_t_9) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_9);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1862, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 1862, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (unlikely(__pyx_t_10)) {

      /* "validator.pyx":1863
 *     for i, array in enumerate(arrays, start=1):
 *         if np.any(np.asarray(array) < 0):
 *             err_msg = err_msg or (             # <<<<<<<<<<<<<<
 *                 f"Array at index {i} contains negative values."
 *                 " Expect only non-negative values.")
 */
      __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_v_err_msg); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 1863, __pyx_L1_error)
      if (!__pyx_t_10) {
      } else {
        __Pyx_INCREF(__pyx_v_err_msg);
        __pyx_t_3 = __pyx_v_err_msg;
        goto __pyx_L8_bool_binop_done;
      }

      /* "validator.pyx":1864
 *         if np.any(np.asarray(array) < 0):
 *             err_msg = err_msg or (
 *                 f"Array at index {i} contains negative values."             # <<<<<<<<<<<<<<
 *                 " Expect only non-negative values.")
 *             raise ValueError(err_msg)
 */
      __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1864, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_11 = 0;
      __pyx_t_12 = 127;
      __Pyx_INCREF(__pyx_kp_u_Array_at_index);
      __pyx_t_11 += 15;
      __Pyx_GIVEREF(__pyx_kp_u_Array_at_index);
      PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_Array_at_index);
      __pyx_t_9 = __Pyx_PyObject_FormatSimple(__pyx_v_i, __pyx_empty_unicode); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1864, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      __pyx_t_12 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_9) > __pyx_t_12) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_9) : __pyx_t_12;
      __pyx_t_11 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_9);
      __Pyx_GIVEREF(__pyx_t_9);
      PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_9);
      __pyx_t_9 = 0;
      __Pyx_INCREF(__pyx_kp_u_contains_negative_values_Expect);
      __pyx_t_11 += 59;
      __Pyx_GIVEREF(__pyx_kp_u_contains_negative_values_Expect);
      PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_contains_negative_values_Expect);
      __pyx_t_9 = __Pyx_PyUnicode_Join(__pyx_t_1, 3, __pyx_t_11, __pyx_t_12); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1864, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_INCREF(__pyx_t_9);
      __pyx_t_3 = __pyx_t_9;
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      __pyx_L8_bool_binop_done:;
      __Pyx_DECREF_SET(__pyx_v_err_msg, __pyx_t_3);
      __pyx_t_3 = 0;

      /* "validator.pyx":1866
 *                 f"Array at index {i} contains negative values."
 *                 " Expect only non-negative values.")
 *             raise ValueError(err_msg)             # <<<<<<<<<<<<<<
 * 
 * def check_epsilon(
 */
      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_v_err_msg); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1866, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __PYX_ERR(0, 1866, __pyx_L1_error)

      /* "validator.pyx":1862
 *     """
 *     for i, array in enumerate(arrays, start=1):
 *         if np.any(np.asarray(array) < 0):             # <<<<<<<<<<<<<<
 *             err_msg = err_msg or (
 *                 f"Array at index {i} contains negative values."
 */
    }

    /* "validator.pyx":1861
 *     of arrays checked in a single call.
 *     """
 *     for i, array in enumerate(arrays, start=1):             # <<<<<<<<<<<<<<
 *         if np.any(np.asarray(array) < 0):
 *             err_msg = err_msg or (
 */
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":1826
 *     return value_lower
 * 
 * def ensure_non_negative(*arrays, err_msg=None):             # <<<<<<<<<<<<<<
 *     """
 *     Ensure that provided arrays contain only non-negative values.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("validator.ensure_non_negative", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_i);
  __Pyx_XDECREF(__pyx_v_array);
  __Pyx_XDECREF(__pyx_v_err_msg);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1868
 *             raise ValueError(err_msg)
 * 
 * def check_epsilon(             # <<<<<<<<<<<<<<
 *     eps,
 *     y_true=None,
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_51check_epsilon(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_50check_epsilon[] = "\n    Dynamically determine or validate an epsilon value for numerical computations.\n\n    This function either validates a provided epsilon if it is a numeric value, or \n    calculates an appropriate epsilon dynamically based on the input data. The dynamic\n    calculation aims to adjust epsilon based on the scale of the input data, providing\n    flexibility and adaptability in algorithms where numerical stability is critical.\n\n    Parameters\n    ----------\n    eps : {'auto', float}\n        The epsilon value to use. If 'auto', the function dynamically determines an\n        appropriate epsilon based on `y_true` and `y_pred`. If a float, it validates\n        this as the epsilon value.\n    y_true : array-like, optional\n        True values array. Used in conjunction with `y_pred` to dynamically determine\n        epsilon if `eps` is 'auto'. If `None`, this input is ignored.\n    y_pred : array-like, optional\n        Predicted values array. Used alongside `y_true` for epsilon determination.\n        If `None`, this input is ignored.\n    base_epsilon : float, optional\n        Base epsilon value used as a starting point in dynamic determination. This\n        value is adjusted based on the `scale_factor` and the input data to compute\n        the final epsilon.\n    scale_factor : float, optional\n        Scaling factor applied to adjust the base epsilon in relation to the scale\n        of the input data. Helps tailor the epsilon to the problem's numerical scale.\n\n    Returns\n    -------\n    float\n        The determined or validated epsilon value. Ensures numerical operations\n        are conducted with an appropriate epsilon to avoid division by zero or\n        other numerical instabilities.\n\n    Examples\n    --------\n    >>> y_true = [1, 2, 3]\n    >>> y_pred = [1.1, 1.9, 3.05]\n    >>> check_epsilon('auto', y_true, y_pred)\n    0.00001  # Example output, actual value depends on `determine_epsilon` implementation.\n\n    >>> check_epsilon(1e-8)""\n    1e-8\n\n    Notes\n    -----\n    Using 'auto' for `eps` allows algorithms to adapt to different scales of data,\n    enhancing numerical stability without manually tuning the epsilon value.\n    ";
static PyMethodDef __pyx_mdef_9validator_51check_epsilon = {"check_epsilon", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_51check_epsilon, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_50check_epsilon};
static PyObject *__pyx_pw_9validator_51check_epsilon(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_eps = 0;
  PyObject *__pyx_v_y_true = 0;
  PyObject *__pyx_v_y_pred = 0;
  PyObject *__pyx_v_base_epsilon = 0;
  PyObject *__pyx_v_scale_factor = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("check_epsilon (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_eps,&__pyx_n_s_y_true,&__pyx_n_s_y_pred,&__pyx_n_s_base_epsilon,&__pyx_n_s_scale_factor,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "validator.pyx":1870
 * def check_epsilon(
 *     eps,
 *     y_true=None,             # <<<<<<<<<<<<<<
 *     y_pred=None,
 *     base_epsilon=1e-10,
 */
    values[1] = ((PyObject *)Py_None);

    /* "validator.pyx":1871
 *     eps,
 *     y_true=None,
 *     y_pred=None,             # <<<<<<<<<<<<<<
 *     base_epsilon=1e-10,
 *     scale_factor=1e-5
 */
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)__pyx_float_1eneg_10);
    values[4] = ((PyObject *)__pyx_float_1eneg_5);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_eps)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y_true);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y_pred);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_base_epsilon);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_scale_factor);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "check_epsilon") < 0)) __PYX_ERR(0, 1868, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_eps = values[0];
    __pyx_v_y_true = values[1];
    __pyx_v_y_pred = values[2];
    __pyx_v_base_epsilon = values[3];
    __pyx_v_scale_factor = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("check_epsilon", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1868, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.check_epsilon", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_50check_epsilon(__pyx_self, __pyx_v_eps, __pyx_v_y_true, __pyx_v_y_pred, __pyx_v_base_epsilon, __pyx_v_scale_factor);

  /* "validator.pyx":1868
 *             raise ValueError(err_msg)
 * 
 * def check_epsilon(             # <<<<<<<<<<<<<<
 *     eps,
 *     y_true=None,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_50check_epsilon(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_eps, PyObject *__pyx_v_y_true, PyObject *__pyx_v_y_pred, PyObject *__pyx_v_base_epsilon, PyObject *__pyx_v_scale_factor) {
  PyObject *__pyx_v_determine_epsilon = NULL;
  PyObject *__pyx_v_y_arrays = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_t_8;
  int __pyx_t_9;
  int __pyx_t_10;
  Py_ssize_t __pyx_t_11;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  Py_UCS4 __pyx_t_15;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("check_epsilon", 0);
  __Pyx_INCREF(__pyx_v_eps);
  __Pyx_INCREF(__pyx_v_y_true);
  __Pyx_INCREF(__pyx_v_y_pred);

  /* "validator.pyx":1925
 *     enhancing numerical stability without manually tuning the epsilon value.
 *     """
 *     from .mathex import determine_epsilon             # <<<<<<<<<<<<<<
 *     # Initialize a list to hold arrays for dynamic epsilon determination
 *     y_arrays = []
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1925, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_determine_epsilon);
  __Pyx_GIVEREF(__pyx_n_s_determine_epsilon);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_determine_epsilon);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_mathex, __pyx_t_1, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1925, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_determine_epsilon); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1925, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_t_1);
  __pyx_v_determine_epsilon = __pyx_t_1;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":1927
 *     from .mathex import determine_epsilon
 *     # Initialize a list to hold arrays for dynamic epsilon determination
 *     y_arrays = []             # <<<<<<<<<<<<<<
 * 
 *     # Convert inputs to numpy arrays and add to y_arrays if they are not None
 */
  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1927, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_v_y_arrays = ((PyObject*)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "validator.pyx":1930
 * 
 *     # Convert inputs to numpy arrays and add to y_arrays if they are not None
 *     if y_true is not None:             # <<<<<<<<<<<<<<
 *         y_true = np.asarray(y_true, dtype=np.float64)
 *         y_arrays.append(y_true)
 */
  __pyx_t_3 = (__pyx_v_y_true != Py_None);
  __pyx_t_4 = (__pyx_t_3 != 0);
  if (__pyx_t_4) {

    /* "validator.pyx":1931
 *     # Convert inputs to numpy arrays and add to y_arrays if they are not None
 *     if y_true is not None:
 *         y_true = np.asarray(y_true, dtype=np.float64)             # <<<<<<<<<<<<<<
 *         y_arrays.append(y_true)
 *     if y_pred is not None:
 */
    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1931, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_asarray); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1931, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1931, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_v_y_true);
    __Pyx_GIVEREF(__pyx_v_y_true);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_y_true);
    __pyx_t_5 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1931, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1931, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_float64); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1931, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_dtype, __pyx_t_7) < 0) __PYX_ERR(0, 1931, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_5); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1931, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF_SET(__pyx_v_y_true, __pyx_t_7);
    __pyx_t_7 = 0;

    /* "validator.pyx":1932
 *     if y_true is not None:
 *         y_true = np.asarray(y_true, dtype=np.float64)
 *         y_arrays.append(y_true)             # <<<<<<<<<<<<<<
 *     if y_pred is not None:
 *         y_pred = np.asarray(y_pred, dtype=np.float64)
 */
    __pyx_t_8 = __Pyx_PyList_Append(__pyx_v_y_arrays, __pyx_v_y_true); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(0, 1932, __pyx_L1_error)

    /* "validator.pyx":1930
 * 
 *     # Convert inputs to numpy arrays and add to y_arrays if they are not None
 *     if y_true is not None:             # <<<<<<<<<<<<<<
 *         y_true = np.asarray(y_true, dtype=np.float64)
 *         y_arrays.append(y_true)
 */
  }

  /* "validator.pyx":1933
 *         y_true = np.asarray(y_true, dtype=np.float64)
 *         y_arrays.append(y_true)
 *     if y_pred is not None:             # <<<<<<<<<<<<<<
 *         y_pred = np.asarray(y_pred, dtype=np.float64)
 *         y_arrays.append(y_pred)
 */
  __pyx_t_4 = (__pyx_v_y_pred != Py_None);
  __pyx_t_3 = (__pyx_t_4 != 0);
  if (__pyx_t_3) {

    /* "validator.pyx":1934
 *         y_arrays.append(y_true)
 *     if y_pred is not None:
 *         y_pred = np.asarray(y_pred, dtype=np.float64)             # <<<<<<<<<<<<<<
 *         y_arrays.append(y_pred)
 * 
 */
    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_np); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1934, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_asarray); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1934, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_7 = PyTuple_New(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1934, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_INCREF(__pyx_v_y_pred);
    __Pyx_GIVEREF(__pyx_v_y_pred);
    PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_v_y_pred);
    __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1934, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1934, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_float64); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1934, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_dtype, __pyx_t_6) < 0) __PYX_ERR(0, 1934, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_7, __pyx_t_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1934, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF_SET(__pyx_v_y_pred, __pyx_t_6);
    __pyx_t_6 = 0;

    /* "validator.pyx":1935
 *     if y_pred is not None:
 *         y_pred = np.asarray(y_pred, dtype=np.float64)
 *         y_arrays.append(y_pred)             # <<<<<<<<<<<<<<
 * 
 *     # Ensure y_true and y_pred have consistent lengths if both are provided
 */
    __pyx_t_8 = __Pyx_PyList_Append(__pyx_v_y_arrays, __pyx_v_y_pred); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(0, 1935, __pyx_L1_error)

    /* "validator.pyx":1933
 *         y_true = np.asarray(y_true, dtype=np.float64)
 *         y_arrays.append(y_true)
 *     if y_pred is not None:             # <<<<<<<<<<<<<<
 *         y_pred = np.asarray(y_pred, dtype=np.float64)
 *         y_arrays.append(y_pred)
 */
  }

  /* "validator.pyx":1938
 * 
 *     # Ensure y_true and y_pred have consistent lengths if both are provided
 *     if y_true is not None and y_pred is not None:             # <<<<<<<<<<<<<<
 *         check_consistent_length(y_true, y_pred)
 * 
 */
  __pyx_t_4 = (__pyx_v_y_true != Py_None);
  __pyx_t_9 = (__pyx_t_4 != 0);
  if (__pyx_t_9) {
  } else {
    __pyx_t_3 = __pyx_t_9;
    goto __pyx_L6_bool_binop_done;
  }
  __pyx_t_9 = (__pyx_v_y_pred != Py_None);
  __pyx_t_4 = (__pyx_t_9 != 0);
  __pyx_t_3 = __pyx_t_4;
  __pyx_L6_bool_binop_done:;
  if (__pyx_t_3) {

    /* "validator.pyx":1939
 *     # Ensure y_true and y_pred have consistent lengths if both are provided
 *     if y_true is not None and y_pred is not None:
 *         check_consistent_length(y_true, y_pred)             # <<<<<<<<<<<<<<
 * 
 *     # If both arrays are provided, concatenate them for epsilon determination
 */
    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_check_consistent_length); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1939, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_7 = NULL;
    __pyx_t_10 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
        __pyx_t_10 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_v_y_true, __pyx_v_y_pred};
      __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1939, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_GOTREF(__pyx_t_6);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_v_y_true, __pyx_v_y_pred};
      __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_10, 2+__pyx_t_10); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1939, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_GOTREF(__pyx_t_6);
    } else
    #endif
    {
      __pyx_t_5 = PyTuple_New(2+__pyx_t_10); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1939, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      if (__pyx_t_7) {
        __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_7); __pyx_t_7 = NULL;
      }
      __Pyx_INCREF(__pyx_v_y_true);
      __Pyx_GIVEREF(__pyx_v_y_true);
      PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_10, __pyx_v_y_true);
      __Pyx_INCREF(__pyx_v_y_pred);
      __Pyx_GIVEREF(__pyx_v_y_pred);
      PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_10, __pyx_v_y_pred);
      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1939, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

    /* "validator.pyx":1938
 * 
 *     # Ensure y_true and y_pred have consistent lengths if both are provided
 *     if y_true is not None and y_pred is not None:             # <<<<<<<<<<<<<<
 *         check_consistent_length(y_true, y_pred)
 * 
 */
  }

  /* "validator.pyx":1942
 * 
 *     # If both arrays are provided, concatenate them for epsilon determination
 *     if len(y_arrays) == 2:             # <<<<<<<<<<<<<<
 *         y_arrays = [np.concatenate(y_arrays)]
 * 
 */
  __pyx_t_11 = PyList_GET_SIZE(__pyx_v_y_arrays); if (unlikely(__pyx_t_11 == ((Py_ssize_t)-1))) __PYX_ERR(0, 1942, __pyx_L1_error)
  __pyx_t_3 = ((__pyx_t_11 == 2) != 0);
  if (__pyx_t_3) {

    /* "validator.pyx":1943
 *     # If both arrays are provided, concatenate them for epsilon determination
 *     if len(y_arrays) == 2:
 *         y_arrays = [np.concatenate(y_arrays)]             # <<<<<<<<<<<<<<
 * 
 *     # Dynamically determine epsilon if 'auto', else ensure it's a float
 */
    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1943, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_concatenate); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1943, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_2)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_2);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    __pyx_t_6 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_2, __pyx_v_y_arrays) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_y_arrays);
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1943, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = PyList_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1943, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_6);
    PyList_SET_ITEM(__pyx_t_5, 0, __pyx_t_6);
    __pyx_t_6 = 0;
    __Pyx_DECREF_SET(__pyx_v_y_arrays, ((PyObject*)__pyx_t_5));
    __pyx_t_5 = 0;

    /* "validator.pyx":1942
 * 
 *     # If both arrays are provided, concatenate them for epsilon determination
 *     if len(y_arrays) == 2:             # <<<<<<<<<<<<<<
 *         y_arrays = [np.concatenate(y_arrays)]
 * 
 */
  }

  /* "validator.pyx":1946
 * 
 *     # Dynamically determine epsilon if 'auto', else ensure it's a float
 *     if str(eps).lower() == 'auto' and y_arrays:             # <<<<<<<<<<<<<<
 *         eps = determine_epsilon(y_arrays[0], base_epsilon=base_epsilon,
 *                                 scale_factor=scale_factor)
 */
  __pyx_t_6 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyUnicode_Type)), __pyx_v_eps); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1946, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_lower); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1946, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_6 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_5 = (__pyx_t_6) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_6) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
  if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1946, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_t_5, __pyx_n_u_auto, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1946, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  if (__pyx_t_4) {
  } else {
    __pyx_t_3 = __pyx_t_4;
    goto __pyx_L10_bool_binop_done;
  }
  __pyx_t_4 = (PyList_GET_SIZE(__pyx_v_y_arrays) != 0);
  __pyx_t_3 = __pyx_t_4;
  __pyx_L10_bool_binop_done:;
  if (__pyx_t_3) {

    /* "validator.pyx":1947
 *     # Dynamically determine epsilon if 'auto', else ensure it's a float
 *     if str(eps).lower() == 'auto' and y_arrays:
 *         eps = determine_epsilon(y_arrays[0], base_epsilon=base_epsilon,             # <<<<<<<<<<<<<<
 *                                 scale_factor=scale_factor)
 *     else:
 */
    __pyx_t_5 = __Pyx_GetItemInt_List(__pyx_v_y_arrays, 0, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1947, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1947, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_GIVEREF(__pyx_t_5);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_5);
    __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1947, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_base_epsilon, __pyx_v_base_epsilon) < 0) __PYX_ERR(0, 1947, __pyx_L1_error)

    /* "validator.pyx":1948
 *     if str(eps).lower() == 'auto' and y_arrays:
 *         eps = determine_epsilon(y_arrays[0], base_epsilon=base_epsilon,
 *                                 scale_factor=scale_factor)             # <<<<<<<<<<<<<<
 *     else:
 *         try:
 */
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_scale_factor, __pyx_v_scale_factor) < 0) __PYX_ERR(0, 1947, __pyx_L1_error)

    /* "validator.pyx":1947
 *     # Dynamically determine epsilon if 'auto', else ensure it's a float
 *     if str(eps).lower() == 'auto' and y_arrays:
 *         eps = determine_epsilon(y_arrays[0], base_epsilon=base_epsilon,             # <<<<<<<<<<<<<<
 *                                 scale_factor=scale_factor)
 *     else:
 */
    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_v_determine_epsilon, __pyx_t_2, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1947, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF_SET(__pyx_v_eps, __pyx_t_6);
    __pyx_t_6 = 0;

    /* "validator.pyx":1946
 * 
 *     # Dynamically determine epsilon if 'auto', else ensure it's a float
 *     if str(eps).lower() == 'auto' and y_arrays:             # <<<<<<<<<<<<<<
 *         eps = determine_epsilon(y_arrays[0], base_epsilon=base_epsilon,
 *                                 scale_factor=scale_factor)
 */
    goto __pyx_L9;
  }

  /* "validator.pyx":1950
 *                                 scale_factor=scale_factor)
 *     else:
 *         try:             # <<<<<<<<<<<<<<
 *             eps = float(eps)
 *         except ValueError:
 */
  /*else*/ {
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_12, &__pyx_t_13, &__pyx_t_14);
      __Pyx_XGOTREF(__pyx_t_12);
      __Pyx_XGOTREF(__pyx_t_13);
      __Pyx_XGOTREF(__pyx_t_14);
      /*try:*/ {

        /* "validator.pyx":1951
 *     else:
 *         try:
 *             eps = float(eps)             # <<<<<<<<<<<<<<
 *         except ValueError:
 *             raise ValueError(f"Epsilon must be 'auto' or convertible to float. Got '{eps}'")
 */
        __pyx_t_6 = __Pyx_PyNumber_Float(__pyx_v_eps); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1951, __pyx_L12_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF_SET(__pyx_v_eps, __pyx_t_6);
        __pyx_t_6 = 0;

        /* "validator.pyx":1950
 *                                 scale_factor=scale_factor)
 *     else:
 *         try:             # <<<<<<<<<<<<<<
 *             eps = float(eps)
 *         except ValueError:
 */
      }
      __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
      __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
      __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
      goto __pyx_L17_try_end;
      __pyx_L12_error:;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;

      /* "validator.pyx":1952
 *         try:
 *             eps = float(eps)
 *         except ValueError:             # <<<<<<<<<<<<<<
 *             raise ValueError(f"Epsilon must be 'auto' or convertible to float. Got '{eps}'")
 * 
 */
      __pyx_t_10 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_ValueError);
      if (__pyx_t_10) {
        __Pyx_AddTraceback("validator.check_epsilon", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_6, &__pyx_t_5, &__pyx_t_2) < 0) __PYX_ERR(0, 1952, __pyx_L14_except_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_GOTREF(__pyx_t_2);

        /* "validator.pyx":1953
 *             eps = float(eps)
 *         except ValueError:
 *             raise ValueError(f"Epsilon must be 'auto' or convertible to float. Got '{eps}'")             # <<<<<<<<<<<<<<
 * 
 *     return eps
 */
        __pyx_t_7 = PyTuple_New(3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1953, __pyx_L14_except_error)
        __Pyx_GOTREF(__pyx_t_7);
        __pyx_t_11 = 0;
        __pyx_t_15 = 127;
        __Pyx_INCREF(__pyx_kp_u_Epsilon_must_be_auto_or_converti);
        __pyx_t_11 += 53;
        __Pyx_GIVEREF(__pyx_kp_u_Epsilon_must_be_auto_or_converti);
        PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_kp_u_Epsilon_must_be_auto_or_converti);
        __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_eps, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1953, __pyx_L14_except_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_15 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) > __pyx_t_15) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) : __pyx_t_15;
        __pyx_t_11 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_1);
        __Pyx_GIVEREF(__pyx_t_1);
        PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_t_1);
        __pyx_t_1 = 0;
        __Pyx_INCREF(__pyx_kp_u__53);
        __pyx_t_11 += 1;
        __Pyx_GIVEREF(__pyx_kp_u__53);
        PyTuple_SET_ITEM(__pyx_t_7, 2, __pyx_kp_u__53);
        __pyx_t_1 = __Pyx_PyUnicode_Join(__pyx_t_7, 3, __pyx_t_11, __pyx_t_15); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1953, __pyx_L14_except_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1953, __pyx_L14_except_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_Raise(__pyx_t_7, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        __PYX_ERR(0, 1953, __pyx_L14_except_error)
      }
      goto __pyx_L14_except_error;
      __pyx_L14_except_error:;

      /* "validator.pyx":1950
 *                                 scale_factor=scale_factor)
 *     else:
 *         try:             # <<<<<<<<<<<<<<
 *             eps = float(eps)
 *         except ValueError:
 */
      __Pyx_XGIVEREF(__pyx_t_12);
      __Pyx_XGIVEREF(__pyx_t_13);
      __Pyx_XGIVEREF(__pyx_t_14);
      __Pyx_ExceptionReset(__pyx_t_12, __pyx_t_13, __pyx_t_14);
      goto __pyx_L1_error;
      __pyx_L17_try_end:;
    }
  }
  __pyx_L9:;

  /* "validator.pyx":1955
 *             raise ValueError(f"Epsilon must be 'auto' or convertible to float. Got '{eps}'")
 * 
 *     return eps             # <<<<<<<<<<<<<<
 * 
 * def _ensure_y_is_valid(y_true, y_pred, **kwargs):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_eps);
  __pyx_r = __pyx_v_eps;
  goto __pyx_L0;

  /* "validator.pyx":1868
 *             raise ValueError(err_msg)
 * 
 * def check_epsilon(             # <<<<<<<<<<<<<<
 *     eps,
 *     y_true=None,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("validator.check_epsilon", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_determine_epsilon);
  __Pyx_XDECREF(__pyx_v_y_arrays);
  __Pyx_XDECREF(__pyx_v_eps);
  __Pyx_XDECREF(__pyx_v_y_true);
  __Pyx_XDECREF(__pyx_v_y_pred);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":1957
 *     return eps
 * 
 * def _ensure_y_is_valid(y_true, y_pred, **kwargs):             # <<<<<<<<<<<<<<
 *     """
 *     Validates that the true and predicted target arrays are suitable for further
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_53_ensure_y_is_valid(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_52_ensure_y_is_valid[] = "\n    Validates that the true and predicted target arrays are suitable for further\n    processing. This involves ensuring that both arrays are non-empty, of the\n    same length, and meet any additional criteria specified by keyword arguments.\n\n    Parameters\n    ----------\n    y_true : array-like\n        The true target values.\n    y_pred : array-like\n        The predicted target values.\n    **kwargs : dict\n        Additional keyword arguments to pass to the check_y function for any\n        extra validation criteria.\n\n    Returns\n    -------\n    y_true : array-like\n        Validated true target values.\n    y_pred : array-like\n        Validated predicted target values.\n\n    Raises\n    ------\n    ValueError\n        If the validation checks fail, indicating that the input arrays do not\n        meet the required criteria for processing.\n\n    Examples\n    --------\n    Suppose `check_y` validates that the input is a non-empty numpy array and\n    `check_consistent_length` ensures the arrays have the same number of elements.\n    Then, usage could be as follows:\n\n    >>> y_true = np.array([1, 2, 3])\n    >>> y_pred = np.array([1.1, 2.1, 3.1])\n    >>> y_true_valid, y_pred_valid = _ensure_y_is_valid(y_true, y_pred)\n    >>> print(y_true_valid, y_pred_valid)\n    [1 2 3] [1.1 2.1 3.1]\n    ";
static PyMethodDef __pyx_mdef_9validator_53_ensure_y_is_valid = {"_ensure_y_is_valid", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_53_ensure_y_is_valid, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_52_ensure_y_is_valid};
static PyObject *__pyx_pw_9validator_53_ensure_y_is_valid(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_y_true = 0;
  PyObject *__pyx_v_y_pred = 0;
  PyObject *__pyx_v_kwargs = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_ensure_y_is_valid (wrapper)", 0);
  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return NULL;
  __Pyx_GOTREF(__pyx_v_kwargs);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_y_true,&__pyx_n_s_y_pred,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y_true)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y_pred)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_ensure_y_is_valid", 1, 2, 2, 1); __PYX_ERR(0, 1957, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "_ensure_y_is_valid") < 0)) __PYX_ERR(0, 1957, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_y_true = values[0];
    __pyx_v_y_pred = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_ensure_y_is_valid", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1957, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
  __Pyx_AddTraceback("validator._ensure_y_is_valid", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_52_ensure_y_is_valid(__pyx_self, __pyx_v_y_true, __pyx_v_y_pred, __pyx_v_kwargs);

  /* function exit code */
  __Pyx_XDECREF(__pyx_v_kwargs);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_52_ensure_y_is_valid(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y_true, PyObject *__pyx_v_y_pred, PyObject *__pyx_v_kwargs) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_ensure_y_is_valid", 0);
  __Pyx_INCREF(__pyx_v_y_true);
  __Pyx_INCREF(__pyx_v_y_pred);

  /* "validator.pyx":1999
 *     """
 *     # Convert y_true and y_pred to numpy arrays if they are not already
 *     y_true = np.asarray(y_true)             # <<<<<<<<<<<<<<
 *     y_pred = np.asarray(y_pred)
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1999, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_asarray); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1999, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_v_y_true) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_y_true);
  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1999, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF_SET(__pyx_v_y_true, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":2000
 *     # Convert y_true and y_pred to numpy arrays if they are not already
 *     y_true = np.asarray(y_true)
 *     y_pred = np.asarray(y_pred)             # <<<<<<<<<<<<<<
 * 
 *     # Ensure individual array validity
 */
  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2000, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_asarray); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2000, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_y_pred) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_y_pred);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2000, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF_SET(__pyx_v_y_pred, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":2003
 * 
 *     # Ensure individual array validity
 *     y_true = check_y(y_true, **kwargs)             # <<<<<<<<<<<<<<
 *     y_pred = check_y(y_pred, **kwargs)
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_check_y); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2003, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2003, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_y_true);
  __Pyx_GIVEREF(__pyx_v_y_true);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_y_true);
  __pyx_t_3 = PyDict_Copy(__pyx_v_kwargs); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2003, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2003, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF_SET(__pyx_v_y_true, __pyx_t_4);
  __pyx_t_4 = 0;

  /* "validator.pyx":2004
 *     # Ensure individual array validity
 *     y_true = check_y(y_true, **kwargs)
 *     y_pred = check_y(y_pred, **kwargs)             # <<<<<<<<<<<<<<
 * 
 *     # Check if the arrays have consistent lengths
 */
  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_check_y); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2004, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2004, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_v_y_pred);
  __Pyx_GIVEREF(__pyx_v_y_pred);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_y_pred);
  __pyx_t_2 = PyDict_Copy(__pyx_v_kwargs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2004, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2004, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF_SET(__pyx_v_y_pred, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":2007
 * 
 *     # Check if the arrays have consistent lengths
 *     check_consistent_length(y_true, y_pred)             # <<<<<<<<<<<<<<
 * 
 *     return y_true, y_pred
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_check_consistent_length); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2007, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  __pyx_t_5 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_5 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_y_true, __pyx_v_y_pred};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2007, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_y_true, __pyx_v_y_pred};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2007, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  {
    __pyx_t_4 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2007, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    if (__pyx_t_3) {
      __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3); __pyx_t_3 = NULL;
    }
    __Pyx_INCREF(__pyx_v_y_true);
    __Pyx_GIVEREF(__pyx_v_y_true);
    PyTuple_SET_ITEM(__pyx_t_4, 0+__pyx_t_5, __pyx_v_y_true);
    __Pyx_INCREF(__pyx_v_y_pred);
    __Pyx_GIVEREF(__pyx_v_y_pred);
    PyTuple_SET_ITEM(__pyx_t_4, 1+__pyx_t_5, __pyx_v_y_pred);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2007, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":2009
 *     check_consistent_length(y_true, y_pred)
 * 
 *     return y_true, y_pred             # <<<<<<<<<<<<<<
 * 
 * def check_classification_targets(
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2009, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_v_y_true);
  __Pyx_GIVEREF(__pyx_v_y_true);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_y_true);
  __Pyx_INCREF(__pyx_v_y_pred);
  __Pyx_GIVEREF(__pyx_v_y_pred);
  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_y_pred);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "validator.pyx":1957
 *     return eps
 * 
 * def _ensure_y_is_valid(y_true, y_pred, **kwargs):             # <<<<<<<<<<<<<<
 *     """
 *     Validates that the true and predicted target arrays are suitable for further
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("validator._ensure_y_is_valid", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_y_true);
  __Pyx_XDECREF(__pyx_v_y_pred);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2011
 *     return y_true, y_pred
 * 
 * def check_classification_targets(             # <<<<<<<<<<<<<<
 *     *y,
 *     target_type='numeric',
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_55check_classification_targets(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_54check_classification_targets[] = "\n    Validate that the target arrays are suitable for classification tasks. \n    \n    This function is designed to ensure that target arrays (`y`) contain only \n    finite, categorical values, and it raises a ValueError if the targets do \n    not meet the criteria necessary for classification tasks, such as the \n    presence of continuous values, NaNs, or infinite values.\n    \n    This validation is crucial for preprocessing steps in machine learning \n    pipelines to ensure that the data is appropriate for classification \n    algorithms.\n\n    Parameters\n    ----------\n    *y : array-like\n        One or more target arrays to be validated. The input can be in the \n        form of lists, numpy arrays, or pandas series. Each array is checked \n        individually to ensure it  meets the criteria for classification targets.\n        \n    target_type : str, optional\n        The expected data type of the target arrays. Supported values are \n        'numeric' and 'object'. If 'numeric', the function attempts to \n        convert the target arrays to integers, raising an error if conversion \n        is not possible due to non-numeric values. If 'object', the target \n        arrays are left as numpy arrays of dtype `object`, suitable for \n        categorical classification without conversion. Default is 'numeric'.\n        \n    strategy : str, optional\n        Defines the approach for evaluating if the target arrays are suitable \n        for classification based on their unique values and data types. The \n        'auto' strategy uses heuristic or automatic detection to decide whether \n        target data should be treated as categorical, which is useful for most \n        cases. Custom strategies can be defined to enforce specific validation \n        rules or preprocessing steps based on the nature of the target data \n        (e.g., 'continuous', 'multilabel-indicator', 'unknown'). These custom \n        strategies should align with the outcomes"" of a predefined \n        `type_of_target` function, allowing for nuanced handling of different \n        target data scenarios. The default value is ``'auto'``, which applies \n        general rules for categorization and numeric conversion where applicable.\n        \n        If a strategy other than ``'auto'`` is specified, it directly influences \n        how the data is validated and potentially converted, based on the \n        expected or detected type of target data:\n\n        - If 'continuous', the function checks if the data can be used for \n          regression tasks and raises an error for classification use without \n          explicit binning.\n        - If 'multilabel-indicator', it validates the data for multilabel \n          classification tasks and ensures appropriate format.\n        - If 'unknown', it attempts to validate the data with generic checks, \n          raising errors for any unclear or unsupported data formats.\n\n    verbose : bool, optional\n        If set to True, the function prints a message for each target array \n        checked, confirming that it is suitable for classification. This \n        is helpful for debugging and when validating multiple target arrays \n        simultaneously.\n\n    Raises\n    ------\n    ValueError\n        If any of the target arrays contain values unsuitable for classification. This\n        includes arrays with continuous values, NaNs, infinite values, or arrays that do\n        not represent categorical data properly.\n\n    Examples\n    --------\n    Using the function with a single array of integer labels:\n    \n    >>> from gofast.tools.validator import check_classification_targets\n    >>> y = [1, 2, 3, 2, 1]\n    >>> check_classification_targets(y)\n    [array([1, 2, 3, 2, 1], dtype=object)]\n\n    Using the function with multiple arrays, including a mix of integer and \n    string labels:\n\n    >>> y1 = [0, 1, 0, 1]\n    >>> y2 = [\"spam\", \"ham\", \"spam\", \"ham\"]\n    >>> check""_classification_targets(y1, y2, verbose=True)\n    Targets are suitable for classification.\n    Targets are suitable for classification.\n    [array([0, 1, 0, 1], dtype=object), array(['spam', 'ham', 'spam', 'ham'], dtype=object)]\n\n    Attempting to use the function with an array containing NaN values:\n\n    >>> y_with_nan = [1, np.nan, 2, 1]\n    >>> check_classification_targets(y_with_nan)\n    ValueError: Target values contain NaN or infinite numbers, which are not \n    suitable for classification.\n\n    Attempting to use the function with a continuous target array:\n\n    >>> y_continuous = np.linspace(0, 1, 10)\n    >>> check_classification_targets(y_continuous)\n    ValueError: The number of unique values is too high for a classification task.\n    Validating and converting a mixed-type target array to numeric:\n\n    >>> y_mixed = [1, '2', 3.0, '4', 5]\n    >>> check_classification_targets(y_mixed, target_type='numeric')\n    ValueError: Target array at index 0 contains non-numeric values, which \n    cannot be converted to integers: ['2', '4']...\n\n    Validating object target arrays without attempting conversion:\n\n    >>> y_str = [\"apple\", \"banana\", \"cherry\"]\n    >>> check_classification_targets(y_str, target_type='object')\n    [array(['apple', 'banana', 'cherry'], dtype=object)]\n    \n    ";
static PyMethodDef __pyx_mdef_9validator_55check_classification_targets = {"check_classification_targets", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_55check_classification_targets, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_54check_classification_targets};
static PyObject *__pyx_pw_9validator_55check_classification_targets(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_target_type = 0;
  PyObject *__pyx_v_strategy = 0;
  PyObject *__pyx_v_verbose = 0;
  PyObject *__pyx_v_y = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("check_classification_targets (wrapper)", 0);
  if (PyTuple_GET_SIZE(__pyx_args) > 0) {
    __pyx_v_y = PyTuple_GetSlice(__pyx_args, 0, PyTuple_GET_SIZE(__pyx_args));
    if (unlikely(!__pyx_v_y)) {
      __Pyx_RefNannyFinishContext();
      return NULL;
    }
    __Pyx_GOTREF(__pyx_v_y);
  } else {
    __pyx_v_y = __pyx_empty_tuple; __Pyx_INCREF(__pyx_empty_tuple);
  }
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_target_type,&__pyx_n_s_strategy,&__pyx_n_s_verbose,0};
    PyObject* values[3] = {0,0,0};
    values[0] = ((PyObject *)__pyx_n_u_numeric);
    values[1] = ((PyObject *)__pyx_n_u_auto);

    /* "validator.pyx":2015
 *     target_type='numeric',
 *     strategy='auto',
 *     verbose=False             # <<<<<<<<<<<<<<
 *     ):
 *     """
 */
    values[2] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        default:
        case  0: break;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      if (kw_args > 0 && likely(kw_args <= 3)) {
        Py_ssize_t index;
        for (index = 0; index < 3 && kw_args > 0; index++) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
          if (value) { values[index] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, 0, "check_classification_targets") < 0)) __PYX_ERR(0, 2011, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) < 0) {
      goto __pyx_L5_argtuple_error;
    } else {
    }
    __pyx_v_target_type = values[0];
    __pyx_v_strategy = values[1];
    __pyx_v_verbose = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("check_classification_targets", 0, 0, 0, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2011, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_DECREF(__pyx_v_y); __pyx_v_y = 0;
  __Pyx_AddTraceback("validator.check_classification_targets", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_54check_classification_targets(__pyx_self, __pyx_v_target_type, __pyx_v_strategy, __pyx_v_verbose, __pyx_v_y);

  /* "validator.pyx":2011
 *     return y_true, y_pred
 * 
 * def check_classification_targets(             # <<<<<<<<<<<<<<
 *     *y,
 *     target_type='numeric',
 */

  /* function exit code */
  __Pyx_XDECREF(__pyx_v_y);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9validator_28check_classification_targets_2generator6(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */

/* "validator.pyx":2132
 *         # Try to convert validated targets to numeric (integer), if possible
 *         for i, target in enumerate(validated_targets):
 *             if all(isinstance(item, (int, float, np.integer, np.floating)) for item in target):             # <<<<<<<<<<<<<<
 *                 try:
 *                     # Attempt conversion to integer
 */

static PyObject *__pyx_pf_9validator_28check_classification_targets_genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_9validator___pyx_scope_struct_13_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_13_genexpr *)__pyx_tp_new_9validator___pyx_scope_struct_13_genexpr(__pyx_ptype_9validator___pyx_scope_struct_13_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_13_genexpr *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 2132, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_12_check_classification_targets *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9validator_28check_classification_targets_2generator6, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_check_classification_targets_loc, __pyx_n_s_validator); if (unlikely(!gen)) __PYX_ERR(0, 2132, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("validator.check_classification_targets.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9validator_28check_classification_targets_2generator6(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9validator___pyx_scope_struct_13_genexpr *__pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_13_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *(*__pyx_t_3)(PyObject *);
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  int __pyx_t_8;
  int __pyx_t_9;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genexpr", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 2132, __pyx_L1_error)
  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_target)) { __Pyx_RaiseClosureNameError("target"); __PYX_ERR(0, 2132, __pyx_L1_error) }
  if (likely(PyList_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_target)) || PyTuple_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_target)) {
    __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_target; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
    __pyx_t_3 = NULL;
  } else {
    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_target); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2132, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2132, __pyx_L1_error)
  }
  for (;;) {
    if (likely(!__pyx_t_3)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 2132, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2132, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 2132, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2132, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_3(__pyx_t_1);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 2132, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_item);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_item, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2132, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_integer); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2132, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2132, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_floating); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2132, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_8 = PyInt_Check(__pyx_cur_scope->__pyx_v_item); 
    __pyx_t_9 = (__pyx_t_8 != 0);
    if (!__pyx_t_9) {
    } else {
      __pyx_t_7 = __pyx_t_9;
      goto __pyx_L7_bool_binop_done;
    }
    __pyx_t_9 = PyFloat_Check(__pyx_cur_scope->__pyx_v_item); 
    __pyx_t_8 = (__pyx_t_9 != 0);
    if (!__pyx_t_8) {
    } else {
      __pyx_t_7 = __pyx_t_8;
      goto __pyx_L7_bool_binop_done;
    }
    __pyx_t_8 = PyObject_IsInstance(__pyx_cur_scope->__pyx_v_item, __pyx_t_5); 
    __pyx_t_9 = (__pyx_t_8 != 0);
    if (!__pyx_t_9) {
    } else {
      __pyx_t_7 = __pyx_t_9;
      goto __pyx_L7_bool_binop_done;
    }
    __pyx_t_9 = PyObject_IsInstance(__pyx_cur_scope->__pyx_v_item, __pyx_t_6); 
    __pyx_t_8 = (__pyx_t_9 != 0);
    __pyx_t_7 = __pyx_t_8;
    __pyx_L7_bool_binop_done:;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_8 = ((!(__pyx_t_7 != 0)) != 0);
    if (__pyx_t_8) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_False);
      __pyx_r = Py_False;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
  }
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_True);
    __pyx_r = Py_True;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    goto __pyx_L0;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  #if !CYTHON_USE_EXC_INFO_STACK
  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
  #endif
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2011
 *     return y_true, y_pred
 * 
 * def check_classification_targets(             # <<<<<<<<<<<<<<
 *     *y,
 *     target_type='numeric',
 */

static PyObject *__pyx_pf_9validator_54check_classification_targets(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_target_type, PyObject *__pyx_v_strategy, PyObject *__pyx_v_verbose, PyObject *__pyx_v_y) {
  struct __pyx_obj_9validator___pyx_scope_struct_12_check_classification_targets *__pyx_cur_scope;
  PyObject *__pyx_v_validated_targets = NULL;
  PyObject *__pyx_v_i = NULL;
  PyObject *__pyx_v_e = NULL;
  PyObject *__pyx_v_non_numeric = NULL;
  PyObject *__pyx_8genexpr7__pyx_v_target = NULL;
  PyObject *__pyx_gb_9validator_28check_classification_targets_2generator6 = 0;
  PyObject *__pyx_8genexpr9__pyx_v_item = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  Py_ssize_t __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_t_8;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  int __pyx_t_12;
  Py_ssize_t __pyx_t_13;
  Py_UCS4 __pyx_t_14;
  PyObject *__pyx_t_15 = NULL;
  int __pyx_t_16;
  char const *__pyx_t_17;
  PyObject *__pyx_t_18 = NULL;
  PyObject *__pyx_t_19 = NULL;
  PyObject *__pyx_t_20 = NULL;
  PyObject *__pyx_t_21 = NULL;
  PyObject *__pyx_t_22 = NULL;
  PyObject *__pyx_t_23 = NULL;
  PyObject *(*__pyx_t_24)(PyObject *);
  int __pyx_t_25;
  int __pyx_t_26;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("check_classification_targets", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_12_check_classification_targets *)__pyx_tp_new_9validator___pyx_scope_struct_12_check_classification_targets(__pyx_ptype_9validator___pyx_scope_struct_12_check_classification_targets, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_12_check_classification_targets *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 2011, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }

  /* "validator.pyx":2127
 * 
 *     """
 *     validated_targets = [_check_y(target, strategy=strategy ) for target in y]             # <<<<<<<<<<<<<<
 * 
 *     if target_type == 'numeric':
 */
  { /* enter inner scope */
    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2127, __pyx_L5_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __pyx_v_y; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
    for (;;) {
      if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
      #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
      __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_4); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 2127, __pyx_L5_error)
      #else
      __pyx_t_4 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2127, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_4);
      #endif
      __Pyx_XDECREF_SET(__pyx_8genexpr7__pyx_v_target, __pyx_t_4);
      __pyx_t_4 = 0;
      __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_check_y_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2127, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2127, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_INCREF(__pyx_8genexpr7__pyx_v_target);
      __Pyx_GIVEREF(__pyx_8genexpr7__pyx_v_target);
      PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_8genexpr7__pyx_v_target);
      __pyx_t_6 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2127, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_6);
      if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_strategy, __pyx_v_strategy) < 0) __PYX_ERR(0, 2127, __pyx_L5_error)
      __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2127, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_7))) __PYX_ERR(0, 2127, __pyx_L5_error)
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_8genexpr7__pyx_v_target); __pyx_8genexpr7__pyx_v_target = 0;
    goto __pyx_L8_exit_scope;
    __pyx_L5_error:;
    __Pyx_XDECREF(__pyx_8genexpr7__pyx_v_target); __pyx_8genexpr7__pyx_v_target = 0;
    goto __pyx_L1_error;
    __pyx_L8_exit_scope:;
  } /* exit inner scope */
  __pyx_v_validated_targets = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":2129
 *     validated_targets = [_check_y(target, strategy=strategy ) for target in y]
 * 
 *     if target_type == 'numeric':             # <<<<<<<<<<<<<<
 *         # Try to convert validated targets to numeric (integer), if possible
 *         for i, target in enumerate(validated_targets):
 */
  __pyx_t_8 = (__Pyx_PyUnicode_Equals(__pyx_v_target_type, __pyx_n_u_numeric, Py_EQ)); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 2129, __pyx_L1_error)
  if (__pyx_t_8) {

    /* "validator.pyx":2131
 *     if target_type == 'numeric':
 *         # Try to convert validated targets to numeric (integer), if possible
 *         for i, target in enumerate(validated_targets):             # <<<<<<<<<<<<<<
 *             if all(isinstance(item, (int, float, np.integer, np.floating)) for item in target):
 *                 try:
 */
    __Pyx_INCREF(__pyx_int_0);
    __pyx_t_1 = __pyx_int_0;
    __pyx_t_2 = __pyx_v_validated_targets; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
    for (;;) {
      if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
      #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
      __pyx_t_7 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_7); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 2131, __pyx_L1_error)
      #else
      __pyx_t_7 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2131, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      #endif
      __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_target);
      __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_target, __pyx_t_7);
      __Pyx_GIVEREF(__pyx_t_7);
      __pyx_t_7 = 0;
      __Pyx_INCREF(__pyx_t_1);
      __Pyx_XDECREF_SET(__pyx_v_i, __pyx_t_1);
      __pyx_t_7 = __Pyx_PyInt_AddObjC(__pyx_t_1, __pyx_int_1, 1, 0, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2131, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_1);
      __pyx_t_1 = __pyx_t_7;
      __pyx_t_7 = 0;

      /* "validator.pyx":2132
 *         # Try to convert validated targets to numeric (integer), if possible
 *         for i, target in enumerate(validated_targets):
 *             if all(isinstance(item, (int, float, np.integer, np.floating)) for item in target):             # <<<<<<<<<<<<<<
 *                 try:
 *                     # Attempt conversion to integer
 */
      __pyx_t_7 = __pyx_pf_9validator_28check_classification_targets_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2132, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_6 = __Pyx_Generator_Next(__pyx_t_7); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2132, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 2132, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      if (likely(__pyx_t_8)) {

        /* "validator.pyx":2133
 *         for i, target in enumerate(validated_targets):
 *             if all(isinstance(item, (int, float, np.integer, np.floating)) for item in target):
 *                 try:             # <<<<<<<<<<<<<<
 *                     # Attempt conversion to integer
 *                     validated_targets[i] = target.astype(np.int64)
 */
        {
          __Pyx_PyThreadState_declare
          __Pyx_PyThreadState_assign
          __Pyx_ExceptionSave(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11);
          __Pyx_XGOTREF(__pyx_t_9);
          __Pyx_XGOTREF(__pyx_t_10);
          __Pyx_XGOTREF(__pyx_t_11);
          /*try:*/ {

            /* "validator.pyx":2135
 *                 try:
 *                     # Attempt conversion to integer
 *                     validated_targets[i] = target.astype(np.int64)             # <<<<<<<<<<<<<<
 *                 except ValueError as e:
 *                     raise ValueError(f"Error converting target array at index {i} to integers. "
 */
            __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_target, __pyx_n_s_astype); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2135, __pyx_L13_error)
            __Pyx_GOTREF(__pyx_t_7);
            __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2135, __pyx_L13_error)
            __Pyx_GOTREF(__pyx_t_5);
            __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_int64); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2135, __pyx_L13_error)
            __Pyx_GOTREF(__pyx_t_4);
            __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
            __pyx_t_5 = NULL;
            if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
              __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_7);
              if (likely(__pyx_t_5)) {
                PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
                __Pyx_INCREF(__pyx_t_5);
                __Pyx_INCREF(function);
                __Pyx_DECREF_SET(__pyx_t_7, function);
              }
            }
            __pyx_t_6 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_4);
            __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
            __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
            if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2135, __pyx_L13_error)
            __Pyx_GOTREF(__pyx_t_6);
            __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
            if (unlikely(PyObject_SetItem(__pyx_v_validated_targets, __pyx_v_i, __pyx_t_6) < 0)) __PYX_ERR(0, 2135, __pyx_L13_error)
            __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

            /* "validator.pyx":2133
 *         for i, target in enumerate(validated_targets):
 *             if all(isinstance(item, (int, float, np.integer, np.floating)) for item in target):
 *                 try:             # <<<<<<<<<<<<<<
 *                     # Attempt conversion to integer
 *                     validated_targets[i] = target.astype(np.int64)
 */
          }
          __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
          __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
          __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
          goto __pyx_L20_try_end;
          __pyx_L13_error:;
          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
          __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
          __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;

          /* "validator.pyx":2136
 *                     # Attempt conversion to integer
 *                     validated_targets[i] = target.astype(np.int64)
 *                 except ValueError as e:             # <<<<<<<<<<<<<<
 *                     raise ValueError(f"Error converting target array at index {i} to integers. "
 *                                      "Ensure all values are numeric and representable as integers. "
 */
          __pyx_t_12 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_ValueError);
          if (__pyx_t_12) {
            __Pyx_AddTraceback("validator.check_classification_targets", __pyx_clineno, __pyx_lineno, __pyx_filename);
            if (__Pyx_GetException(&__pyx_t_6, &__pyx_t_7, &__pyx_t_4) < 0) __PYX_ERR(0, 2136, __pyx_L15_except_error)
            __Pyx_GOTREF(__pyx_t_6);
            __Pyx_GOTREF(__pyx_t_7);
            __Pyx_GOTREF(__pyx_t_4);
            __Pyx_INCREF(__pyx_t_7);
            __pyx_v_e = __pyx_t_7;
            /*try:*/ {

              /* "validator.pyx":2137
 *                     validated_targets[i] = target.astype(np.int64)
 *                 except ValueError as e:
 *                     raise ValueError(f"Error converting target array at index {i} to integers. "             # <<<<<<<<<<<<<<
 *                                      "Ensure all values are numeric and representable as integers. "
 *                                      f"Original error: {e}")
 */
              __pyx_t_5 = PyTuple_New(4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2137, __pyx_L26_error)
              __Pyx_GOTREF(__pyx_t_5);
              __pyx_t_13 = 0;
              __pyx_t_14 = 127;
              __Pyx_INCREF(__pyx_kp_u_Error_converting_target_array_at);
              __pyx_t_13 += 39;
              __Pyx_GIVEREF(__pyx_kp_u_Error_converting_target_array_at);
              PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_kp_u_Error_converting_target_array_at);
              __pyx_t_15 = __Pyx_PyObject_FormatSimple(__pyx_v_i, __pyx_empty_unicode); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 2137, __pyx_L26_error)
              __Pyx_GOTREF(__pyx_t_15);
              __pyx_t_14 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_15) > __pyx_t_14) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_15) : __pyx_t_14;
              __pyx_t_13 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_15);
              __Pyx_GIVEREF(__pyx_t_15);
              PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_15);
              __pyx_t_15 = 0;
              __Pyx_INCREF(__pyx_kp_u_to_integers_Ensure_all_values_a);
              __pyx_t_13 += 91;
              __Pyx_GIVEREF(__pyx_kp_u_to_integers_Ensure_all_values_a);
              PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_kp_u_to_integers_Ensure_all_values_a);

              /* "validator.pyx":2139
 *                     raise ValueError(f"Error converting target array at index {i} to integers. "
 *                                      "Ensure all values are numeric and representable as integers. "
 *                                      f"Original error: {e}")             # <<<<<<<<<<<<<<
 *             else:
 *                 non_numeric = [item for item in target if not isinstance(
 */
              __pyx_t_15 = __Pyx_PyObject_FormatSimple(__pyx_v_e, __pyx_empty_unicode); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 2139, __pyx_L26_error)
              __Pyx_GOTREF(__pyx_t_15);
              __pyx_t_14 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_15) > __pyx_t_14) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_15) : __pyx_t_14;
              __pyx_t_13 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_15);
              __Pyx_GIVEREF(__pyx_t_15);
              PyTuple_SET_ITEM(__pyx_t_5, 3, __pyx_t_15);
              __pyx_t_15 = 0;

              /* "validator.pyx":2137
 *                     validated_targets[i] = target.astype(np.int64)
 *                 except ValueError as e:
 *                     raise ValueError(f"Error converting target array at index {i} to integers. "             # <<<<<<<<<<<<<<
 *                                      "Ensure all values are numeric and representable as integers. "
 *                                      f"Original error: {e}")
 */
              __pyx_t_15 = __Pyx_PyUnicode_Join(__pyx_t_5, 4, __pyx_t_13, __pyx_t_14); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 2137, __pyx_L26_error)
              __Pyx_GOTREF(__pyx_t_15);
              __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
              __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_15); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2137, __pyx_L26_error)
              __Pyx_GOTREF(__pyx_t_5);
              __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
              __Pyx_Raise(__pyx_t_5, 0, 0, 0);
              __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
              __PYX_ERR(0, 2137, __pyx_L26_error)
            }

            /* "validator.pyx":2136
 *                     # Attempt conversion to integer
 *                     validated_targets[i] = target.astype(np.int64)
 *                 except ValueError as e:             # <<<<<<<<<<<<<<
 *                     raise ValueError(f"Error converting target array at index {i} to integers. "
 *                                      "Ensure all values are numeric and representable as integers. "
 */
            /*finally:*/ {
              __pyx_L26_error:;
              /*exception exit:*/{
                __Pyx_PyThreadState_declare
                __Pyx_PyThreadState_assign
                __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0; __pyx_t_22 = 0; __pyx_t_23 = 0;
                __Pyx_XDECREF(__pyx_t_15); __pyx_t_15 = 0;
                __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
                if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_21, &__pyx_t_22, &__pyx_t_23);
                if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_18, &__pyx_t_19, &__pyx_t_20) < 0)) __Pyx_ErrFetch(&__pyx_t_18, &__pyx_t_19, &__pyx_t_20);
                __Pyx_XGOTREF(__pyx_t_18);
                __Pyx_XGOTREF(__pyx_t_19);
                __Pyx_XGOTREF(__pyx_t_20);
                __Pyx_XGOTREF(__pyx_t_21);
                __Pyx_XGOTREF(__pyx_t_22);
                __Pyx_XGOTREF(__pyx_t_23);
                __pyx_t_12 = __pyx_lineno; __pyx_t_16 = __pyx_clineno; __pyx_t_17 = __pyx_filename;
                {
                  __Pyx_DECREF(__pyx_v_e);
                  __pyx_v_e = NULL;
                }
                if (PY_MAJOR_VERSION >= 3) {
                  __Pyx_XGIVEREF(__pyx_t_21);
                  __Pyx_XGIVEREF(__pyx_t_22);
                  __Pyx_XGIVEREF(__pyx_t_23);
                  __Pyx_ExceptionReset(__pyx_t_21, __pyx_t_22, __pyx_t_23);
                }
                __Pyx_XGIVEREF(__pyx_t_18);
                __Pyx_XGIVEREF(__pyx_t_19);
                __Pyx_XGIVEREF(__pyx_t_20);
                __Pyx_ErrRestore(__pyx_t_18, __pyx_t_19, __pyx_t_20);
                __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0; __pyx_t_22 = 0; __pyx_t_23 = 0;
                __pyx_lineno = __pyx_t_12; __pyx_clineno = __pyx_t_16; __pyx_filename = __pyx_t_17;
                goto __pyx_L15_except_error;
              }
            }
          }
          goto __pyx_L15_except_error;
          __pyx_L15_except_error:;

          /* "validator.pyx":2133
 *         for i, target in enumerate(validated_targets):
 *             if all(isinstance(item, (int, float, np.integer, np.floating)) for item in target):
 *                 try:             # <<<<<<<<<<<<<<
 *                     # Attempt conversion to integer
 *                     validated_targets[i] = target.astype(np.int64)
 */
          __Pyx_XGIVEREF(__pyx_t_9);
          __Pyx_XGIVEREF(__pyx_t_10);
          __Pyx_XGIVEREF(__pyx_t_11);
          __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_10, __pyx_t_11);
          goto __pyx_L1_error;
          __pyx_L20_try_end:;
        }

        /* "validator.pyx":2132
 *         # Try to convert validated targets to numeric (integer), if possible
 *         for i, target in enumerate(validated_targets):
 *             if all(isinstance(item, (int, float, np.integer, np.floating)) for item in target):             # <<<<<<<<<<<<<<
 *                 try:
 *                     # Attempt conversion to integer
 */
        goto __pyx_L12;
      }

      /* "validator.pyx":2141
 *                                      f"Original error: {e}")
 *             else:
 *                 non_numeric = [item for item in target if not isinstance(             # <<<<<<<<<<<<<<
 *                     item, (int, float, np.integer, np.floating))]
 *                 raise ValueError(f"Target array at index {i} contains non-numeric values, "
 */
      /*else*/ {
        { /* enter inner scope */
          __pyx_t_4 = PyList_New(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2141, __pyx_L34_error)
          __Pyx_GOTREF(__pyx_t_4);
          if (likely(PyList_CheckExact(__pyx_cur_scope->__pyx_v_target)) || PyTuple_CheckExact(__pyx_cur_scope->__pyx_v_target)) {
            __pyx_t_7 = __pyx_cur_scope->__pyx_v_target; __Pyx_INCREF(__pyx_t_7); __pyx_t_13 = 0;
            __pyx_t_24 = NULL;
          } else {
            __pyx_t_13 = -1; __pyx_t_7 = PyObject_GetIter(__pyx_cur_scope->__pyx_v_target); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2141, __pyx_L34_error)
            __Pyx_GOTREF(__pyx_t_7);
            __pyx_t_24 = Py_TYPE(__pyx_t_7)->tp_iternext; if (unlikely(!__pyx_t_24)) __PYX_ERR(0, 2141, __pyx_L34_error)
          }
          for (;;) {
            if (likely(!__pyx_t_24)) {
              if (likely(PyList_CheckExact(__pyx_t_7))) {
                if (__pyx_t_13 >= PyList_GET_SIZE(__pyx_t_7)) break;
                #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
                __pyx_t_6 = PyList_GET_ITEM(__pyx_t_7, __pyx_t_13); __Pyx_INCREF(__pyx_t_6); __pyx_t_13++; if (unlikely(0 < 0)) __PYX_ERR(0, 2141, __pyx_L34_error)
                #else
                __pyx_t_6 = PySequence_ITEM(__pyx_t_7, __pyx_t_13); __pyx_t_13++; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2141, __pyx_L34_error)
                __Pyx_GOTREF(__pyx_t_6);
                #endif
              } else {
                if (__pyx_t_13 >= PyTuple_GET_SIZE(__pyx_t_7)) break;
                #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
                __pyx_t_6 = PyTuple_GET_ITEM(__pyx_t_7, __pyx_t_13); __Pyx_INCREF(__pyx_t_6); __pyx_t_13++; if (unlikely(0 < 0)) __PYX_ERR(0, 2141, __pyx_L34_error)
                #else
                __pyx_t_6 = PySequence_ITEM(__pyx_t_7, __pyx_t_13); __pyx_t_13++; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2141, __pyx_L34_error)
                __Pyx_GOTREF(__pyx_t_6);
                #endif
              }
            } else {
              __pyx_t_6 = __pyx_t_24(__pyx_t_7);
              if (unlikely(!__pyx_t_6)) {
                PyObject* exc_type = PyErr_Occurred();
                if (exc_type) {
                  if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
                  else __PYX_ERR(0, 2141, __pyx_L34_error)
                }
                break;
              }
              __Pyx_GOTREF(__pyx_t_6);
            }
            __Pyx_XDECREF_SET(__pyx_8genexpr9__pyx_v_item, __pyx_t_6);
            __pyx_t_6 = 0;

            /* "validator.pyx":2142
 *             else:
 *                 non_numeric = [item for item in target if not isinstance(
 *                     item, (int, float, np.integer, np.floating))]             # <<<<<<<<<<<<<<
 *                 raise ValueError(f"Target array at index {i} contains non-numeric values, "
 *                                  f"which cannot be converted to integers: {non_numeric[:5]}...")
 */
            __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2142, __pyx_L34_error)
            __Pyx_GOTREF(__pyx_t_6);
            __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_integer); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2142, __pyx_L34_error)
            __Pyx_GOTREF(__pyx_t_5);
            __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
            __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_np); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2142, __pyx_L34_error)
            __Pyx_GOTREF(__pyx_t_6);
            __pyx_t_15 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_floating); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 2142, __pyx_L34_error)
            __Pyx_GOTREF(__pyx_t_15);
            __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

            /* "validator.pyx":2141
 *                                      f"Original error: {e}")
 *             else:
 *                 non_numeric = [item for item in target if not isinstance(             # <<<<<<<<<<<<<<
 *                     item, (int, float, np.integer, np.floating))]
 *                 raise ValueError(f"Target array at index {i} contains non-numeric values, "
 */
            __pyx_t_25 = PyInt_Check(__pyx_8genexpr9__pyx_v_item); 

            /* "validator.pyx":2142
 *             else:
 *                 non_numeric = [item for item in target if not isinstance(
 *                     item, (int, float, np.integer, np.floating))]             # <<<<<<<<<<<<<<
 *                 raise ValueError(f"Target array at index {i} contains non-numeric values, "
 *                                  f"which cannot be converted to integers: {non_numeric[:5]}...")
 */
            __pyx_t_26 = (__pyx_t_25 != 0);
            if (!__pyx_t_26) {
            } else {
              __pyx_t_8 = __pyx_t_26;
              goto __pyx_L38_bool_binop_done;
            }
            __pyx_t_26 = PyFloat_Check(__pyx_8genexpr9__pyx_v_item); 
            __pyx_t_25 = (__pyx_t_26 != 0);
            if (!__pyx_t_25) {
            } else {
              __pyx_t_8 = __pyx_t_25;
              goto __pyx_L38_bool_binop_done;
            }
            __pyx_t_25 = PyObject_IsInstance(__pyx_8genexpr9__pyx_v_item, __pyx_t_5); 
            __pyx_t_26 = (__pyx_t_25 != 0);
            if (!__pyx_t_26) {
            } else {
              __pyx_t_8 = __pyx_t_26;
              goto __pyx_L38_bool_binop_done;
            }
            __pyx_t_26 = PyObject_IsInstance(__pyx_8genexpr9__pyx_v_item, __pyx_t_15); 
            __pyx_t_25 = (__pyx_t_26 != 0);
            __pyx_t_8 = __pyx_t_25;
            __pyx_L38_bool_binop_done:;
            __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
            __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

            /* "validator.pyx":2141
 *                                      f"Original error: {e}")
 *             else:
 *                 non_numeric = [item for item in target if not isinstance(             # <<<<<<<<<<<<<<
 *                     item, (int, float, np.integer, np.floating))]
 *                 raise ValueError(f"Target array at index {i} contains non-numeric values, "
 */
            __pyx_t_25 = ((!(__pyx_t_8 != 0)) != 0);
            if (__pyx_t_25) {
              if (unlikely(__Pyx_ListComp_Append(__pyx_t_4, (PyObject*)__pyx_8genexpr9__pyx_v_item))) __PYX_ERR(0, 2141, __pyx_L34_error)
            }
          }
          __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
          __Pyx_XDECREF(__pyx_8genexpr9__pyx_v_item); __pyx_8genexpr9__pyx_v_item = 0;
          goto __pyx_L42_exit_scope;
          __pyx_L34_error:;
          __Pyx_XDECREF(__pyx_8genexpr9__pyx_v_item); __pyx_8genexpr9__pyx_v_item = 0;
          goto __pyx_L1_error;
          __pyx_L42_exit_scope:;
        } /* exit inner scope */
        __pyx_v_non_numeric = ((PyObject*)__pyx_t_4);
        __pyx_t_4 = 0;

        /* "validator.pyx":2143
 *                 non_numeric = [item for item in target if not isinstance(
 *                     item, (int, float, np.integer, np.floating))]
 *                 raise ValueError(f"Target array at index {i} contains non-numeric values, "             # <<<<<<<<<<<<<<
 *                                  f"which cannot be converted to integers: {non_numeric[:5]}...")
 *     elif target_type == 'object':
 */
        __pyx_t_4 = PyTuple_New(5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2143, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __pyx_t_13 = 0;
        __pyx_t_14 = 127;
        __Pyx_INCREF(__pyx_kp_u_Target_array_at_index);
        __pyx_t_13 += 22;
        __Pyx_GIVEREF(__pyx_kp_u_Target_array_at_index);
        PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_kp_u_Target_array_at_index);
        __pyx_t_7 = __Pyx_PyObject_FormatSimple(__pyx_v_i, __pyx_empty_unicode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2143, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_7);
        __pyx_t_14 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) > __pyx_t_14) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) : __pyx_t_14;
        __pyx_t_13 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_7);
        __Pyx_GIVEREF(__pyx_t_7);
        PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_7);
        __pyx_t_7 = 0;
        __Pyx_INCREF(__pyx_kp_u_contains_non_numeric_values_whi);
        __pyx_t_13 += 69;
        __Pyx_GIVEREF(__pyx_kp_u_contains_non_numeric_values_whi);
        PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_kp_u_contains_non_numeric_values_whi);

        /* "validator.pyx":2144
 *                     item, (int, float, np.integer, np.floating))]
 *                 raise ValueError(f"Target array at index {i} contains non-numeric values, "
 *                                  f"which cannot be converted to integers: {non_numeric[:5]}...")             # <<<<<<<<<<<<<<
 *     elif target_type == 'object':
 *         # If target_type is 'object', no conversion is needed
 */
        __pyx_t_7 = __Pyx_PyList_GetSlice(__pyx_v_non_numeric, 0, 5); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2144, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_7);
        __pyx_t_5 = __Pyx_PyObject_FormatSimple(__pyx_t_7, __pyx_empty_unicode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2144, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        __pyx_t_14 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) > __pyx_t_14) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) : __pyx_t_14;
        __pyx_t_13 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_5);
        __Pyx_GIVEREF(__pyx_t_5);
        PyTuple_SET_ITEM(__pyx_t_4, 3, __pyx_t_5);
        __pyx_t_5 = 0;
        __Pyx_INCREF(__pyx_kp_u__54);
        __pyx_t_13 += 3;
        __Pyx_GIVEREF(__pyx_kp_u__54);
        PyTuple_SET_ITEM(__pyx_t_4, 4, __pyx_kp_u__54);

        /* "validator.pyx":2143
 *                 non_numeric = [item for item in target if not isinstance(
 *                     item, (int, float, np.integer, np.floating))]
 *                 raise ValueError(f"Target array at index {i} contains non-numeric values, "             # <<<<<<<<<<<<<<
 *                                  f"which cannot be converted to integers: {non_numeric[:5]}...")
 *     elif target_type == 'object':
 */
        __pyx_t_5 = __Pyx_PyUnicode_Join(__pyx_t_4, 5, __pyx_t_13, __pyx_t_14); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2143, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2143, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_Raise(__pyx_t_4, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __PYX_ERR(0, 2143, __pyx_L1_error)
      }
      __pyx_L12:;

      /* "validator.pyx":2131
 *     if target_type == 'numeric':
 *         # Try to convert validated targets to numeric (integer), if possible
 *         for i, target in enumerate(validated_targets):             # <<<<<<<<<<<<<<
 *             if all(isinstance(item, (int, float, np.integer, np.floating)) for item in target):
 *                 try:
 */
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "validator.pyx":2129
 *     validated_targets = [_check_y(target, strategy=strategy ) for target in y]
 * 
 *     if target_type == 'numeric':             # <<<<<<<<<<<<<<
 *         # Try to convert validated targets to numeric (integer), if possible
 *         for i, target in enumerate(validated_targets):
 */
    goto __pyx_L9;
  }

  /* "validator.pyx":2145
 *                 raise ValueError(f"Target array at index {i} contains non-numeric values, "
 *                                  f"which cannot be converted to integers: {non_numeric[:5]}...")
 *     elif target_type == 'object':             # <<<<<<<<<<<<<<
 *         # If target_type is 'object', no conversion is needed
 *         # The function ensures they are numpy arrays, which might already suffice
 */
  __pyx_t_25 = (__Pyx_PyUnicode_Equals(__pyx_v_target_type, __pyx_n_u_object, Py_EQ)); if (unlikely(__pyx_t_25 < 0)) __PYX_ERR(0, 2145, __pyx_L1_error)
  if (likely(__pyx_t_25)) {
    goto __pyx_L9;
  }

  /* "validator.pyx":2151
 *     else:
 *         # In case an unsupported target_type is provided
 *         raise ValueError(f"Unsupported target_type '{target_type}'. Use 'numeric' or 'object'.")             # <<<<<<<<<<<<<<
 * 
 *     if verbose:
 */
  /*else*/ {
    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2151, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = 0;
    __pyx_t_14 = 127;
    __Pyx_INCREF(__pyx_kp_u_Unsupported_target_type);
    __pyx_t_3 += 25;
    __Pyx_GIVEREF(__pyx_kp_u_Unsupported_target_type);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_Unsupported_target_type);
    __pyx_t_2 = __Pyx_PyObject_FormatSimple(__pyx_v_target_type, __pyx_empty_unicode); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2151, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_14 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) > __pyx_t_14) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) : __pyx_t_14;
    __pyx_t_3 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_2);
    __Pyx_GIVEREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_2);
    __pyx_t_2 = 0;
    __Pyx_INCREF(__pyx_kp_u_Use_numeric_or_object);
    __pyx_t_3 += 29;
    __Pyx_GIVEREF(__pyx_kp_u_Use_numeric_or_object);
    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_Use_numeric_or_object);
    __pyx_t_2 = __Pyx_PyUnicode_Join(__pyx_t_1, 3, __pyx_t_3, __pyx_t_14); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2151, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2151, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 2151, __pyx_L1_error)
  }
  __pyx_L9:;

  /* "validator.pyx":2153
 *         raise ValueError(f"Unsupported target_type '{target_type}'. Use 'numeric' or 'object'.")
 * 
 *     if verbose:             # <<<<<<<<<<<<<<
 *         print("Targets are suitable for classification.")
 * 
 */
  __pyx_t_25 = __Pyx_PyObject_IsTrue(__pyx_v_verbose); if (unlikely(__pyx_t_25 < 0)) __PYX_ERR(0, 2153, __pyx_L1_error)
  if (__pyx_t_25) {

    /* "validator.pyx":2154
 * 
 *     if verbose:
 *         print("Targets are suitable for classification.")             # <<<<<<<<<<<<<<
 * 
 *     return validated_targets
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_print, __pyx_tuple__55, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2154, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "validator.pyx":2153
 *         raise ValueError(f"Unsupported target_type '{target_type}'. Use 'numeric' or 'object'.")
 * 
 *     if verbose:             # <<<<<<<<<<<<<<
 *         print("Targets are suitable for classification.")
 * 
 */
  }

  /* "validator.pyx":2156
 *         print("Targets are suitable for classification.")
 * 
 *     return validated_targets             # <<<<<<<<<<<<<<
 * 
 * def _check_y(y, strategy='auto'):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_validated_targets);
  __pyx_r = __pyx_v_validated_targets;
  goto __pyx_L0;

  /* "validator.pyx":2011
 *     return y_true, y_pred
 * 
 * def check_classification_targets(             # <<<<<<<<<<<<<<
 *     *y,
 *     target_type='numeric',
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_15);
  __Pyx_AddTraceback("validator.check_classification_targets", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_validated_targets);
  __Pyx_XDECREF(__pyx_v_i);
  __Pyx_XDECREF(__pyx_v_e);
  __Pyx_XDECREF(__pyx_v_non_numeric);
  __Pyx_XDECREF(__pyx_8genexpr7__pyx_v_target);
  __Pyx_XDECREF(__pyx_gb_9validator_28check_classification_targets_2generator6);
  __Pyx_XDECREF(__pyx_8genexpr9__pyx_v_item);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2158
 *     return validated_targets
 * 
 * def _check_y(y, strategy='auto'):             # <<<<<<<<<<<<<<
 *     """
 *     Validates the target array `y`, ensuring it is suitable for classification
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_57_check_y(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_56_check_y[] = "\n    Validates the target array `y`, ensuring it is suitable for classification \n    or regression tasks based on its content and the specified strategy.\n\n    Parameters:\n    - y: array-like, the target array to be validated.\n    - strategy: str, specifies how to determine if `y` is categorical or continuous.\n      'auto' for automatic detection based on unique values or explicitly using\n      `type_of_target` for more nuanced determination.\n    ";
static PyMethodDef __pyx_mdef_9validator_57_check_y = {"_check_y", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_57_check_y, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_56_check_y};
static PyObject *__pyx_pw_9validator_57_check_y(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_y = 0;
  PyObject *__pyx_v_strategy = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_check_y (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_y,&__pyx_n_s_strategy,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_n_u_auto);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_strategy);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_check_y") < 0)) __PYX_ERR(0, 2158, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_y = values[0];
    __pyx_v_strategy = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_check_y", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2158, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator._check_y", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_56_check_y(__pyx_self, __pyx_v_y, __pyx_v_strategy);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9validator_8_check_y_2generator7(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */

/* "validator.pyx":2182
 *     else:
 *         # For non-numeric data, ensure no elements are None or equivalent to np.nan
 *         if any(el is None or el is np.nan for el in y):             # <<<<<<<<<<<<<<
 *             raise ValueError("Non-numeric target values contain None or NaN,"
 *                              " not suitable for classification.")
 */

static PyObject *__pyx_pf_9validator_8_check_y_genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_9validator___pyx_scope_struct_15_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_15_genexpr *)__pyx_tp_new_9validator___pyx_scope_struct_15_genexpr(__pyx_ptype_9validator___pyx_scope_struct_15_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_15_genexpr *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 2182, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_14__check_y *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9validator_8_check_y_2generator7, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_check_y_locals_genexpr, __pyx_n_s_validator); if (unlikely(!gen)) __PYX_ERR(0, 2182, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("validator._check_y.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9validator_8_check_y_2generator7(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9validator___pyx_scope_struct_15_genexpr *__pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_15_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *(*__pyx_t_3)(PyObject *);
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genexpr", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 2182, __pyx_L1_error)
  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_y)) { __Pyx_RaiseClosureNameError("y"); __PYX_ERR(0, 2182, __pyx_L1_error) }
  if (likely(PyList_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_y)) || PyTuple_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_y)) {
    __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_y; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
    __pyx_t_3 = NULL;
  } else {
    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_y); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2182, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2182, __pyx_L1_error)
  }
  for (;;) {
    if (likely(!__pyx_t_3)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 2182, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2182, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 2182, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2182, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_3(__pyx_t_1);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 2182, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_el);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_el, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_t_6 = (__pyx_cur_scope->__pyx_v_el == Py_None);
    __pyx_t_7 = (__pyx_t_6 != 0);
    if (!__pyx_t_7) {
    } else {
      __pyx_t_5 = __pyx_t_7;
      goto __pyx_L7_bool_binop_done;
    }
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2182, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_nan); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 2182, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_7 = (__pyx_cur_scope->__pyx_v_el == __pyx_t_8);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_6 = (__pyx_t_7 != 0);
    __pyx_t_5 = __pyx_t_6;
    __pyx_L7_bool_binop_done:;
    if (__pyx_t_5) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_True);
      __pyx_r = Py_True;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
  }
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    goto __pyx_L0;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  #if !CYTHON_USE_EXC_INFO_STACK
  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
  #endif
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9validator_8_check_y_5generator8(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */

/* "validator.pyx":2207
 *     # Check for non-numeric data convertibility to categorical if not already checked
 *     if y.dtype.kind not in numeric_types:
 *         if not all(isinstance(val, (str, bool, int)) for val in unique_values):             # <<<<<<<<<<<<<<
 *             raise ValueError("Target values must be categorical, numeric,"
 *                              " or convertible to categories.")
 */

static PyObject *__pyx_pf_9validator_8_check_y_3genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_9validator___pyx_scope_struct_16_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_16_genexpr *)__pyx_tp_new_9validator___pyx_scope_struct_16_genexpr(__pyx_ptype_9validator___pyx_scope_struct_16_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_16_genexpr *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 2207, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_14__check_y *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9validator_8_check_y_5generator8, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_check_y_locals_genexpr, __pyx_n_s_validator); if (unlikely(!gen)) __PYX_ERR(0, 2207, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("validator._check_y.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9validator_8_check_y_5generator8(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9validator___pyx_scope_struct_16_genexpr *__pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_16_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *(*__pyx_t_3)(PyObject *);
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_t_7;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genexpr", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 2207, __pyx_L1_error)
  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_unique_values)) { __Pyx_RaiseClosureNameError("unique_values"); __PYX_ERR(0, 2207, __pyx_L1_error) }
  if (likely(PyList_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_unique_values)) || PyTuple_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_unique_values)) {
    __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_unique_values; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
    __pyx_t_3 = NULL;
  } else {
    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_unique_values); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2207, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2207, __pyx_L1_error)
  }
  for (;;) {
    if (likely(!__pyx_t_3)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 2207, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2207, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 2207, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2207, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_3(__pyx_t_1);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 2207, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_val);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_val, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    __Pyx_INCREF(((PyObject*)&PyBool_Type));
    __pyx_t_4 = ((PyObject*)&PyBool_Type);
    __pyx_t_6 = PyUnicode_Check(__pyx_cur_scope->__pyx_v_val); 
    __pyx_t_7 = (__pyx_t_6 != 0);
    if (!__pyx_t_7) {
    } else {
      __pyx_t_5 = __pyx_t_7;
      goto __pyx_L7_bool_binop_done;
    }
    __pyx_t_7 = PyObject_IsInstance(__pyx_cur_scope->__pyx_v_val, __pyx_t_4); 
    __pyx_t_6 = (__pyx_t_7 != 0);
    if (!__pyx_t_6) {
    } else {
      __pyx_t_5 = __pyx_t_6;
      goto __pyx_L7_bool_binop_done;
    }
    __pyx_t_6 = PyInt_Check(__pyx_cur_scope->__pyx_v_val); 
    __pyx_t_7 = (__pyx_t_6 != 0);
    __pyx_t_5 = __pyx_t_7;
    __pyx_L7_bool_binop_done:;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_7 = ((!(__pyx_t_5 != 0)) != 0);
    if (__pyx_t_7) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_False);
      __pyx_r = Py_False;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
  }
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_True);
    __pyx_r = Py_True;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    goto __pyx_L0;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  #if !CYTHON_USE_EXC_INFO_STACK
  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
  #endif
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2158
 *     return validated_targets
 * 
 * def _check_y(y, strategy='auto'):             # <<<<<<<<<<<<<<
 *     """
 *     Validates the target array `y`, ensuring it is suitable for classification
 */

static PyObject *__pyx_pf_9validator_56_check_y(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y, PyObject *__pyx_v_strategy) {
  struct __pyx_obj_9validator___pyx_scope_struct_14__check_y *__pyx_cur_scope;
  PyObject *__pyx_v_type_of_target = NULL;
  PyObject *__pyx_v_numeric_types = NULL;
  PyObject *__pyx_v_numeric_y = NULL;
  PyObject *__pyx_v_target_type = NULL;
  PyObject *__pyx_gb_9validator_8_check_y_2generator7 = 0;
  PyObject *__pyx_gb_9validator_8_check_y_5generator8 = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  Py_ssize_t __pyx_t_8;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_check_y", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_14__check_y *)__pyx_tp_new_9validator___pyx_scope_struct_14__check_y(__pyx_ptype_9validator___pyx_scope_struct_14__check_y, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_14__check_y *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 2158, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_v_y = __pyx_v_y;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_y);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_y);

  /* "validator.pyx":2169
 *       `type_of_target` for more nuanced determination.
 *     """
 *     from .coreutils import type_of_target             # <<<<<<<<<<<<<<
 *     # Convert y to a numpy array of objects to handle mixed types
 *     y = np.array(y, dtype=object)
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2169, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_type_of_target);
  __Pyx_GIVEREF(__pyx_n_s_type_of_target);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_type_of_target);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_coreutils, __pyx_t_1, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2169, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_type_of_target); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2169, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_t_1);
  __pyx_v_type_of_target = __pyx_t_1;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":2171
 *     from .coreutils import type_of_target
 *     # Convert y to a numpy array of objects to handle mixed types
 *     y = np.array(y, dtype=object)             # <<<<<<<<<<<<<<
 * 
 *     # Check for NaN or infinite values in numeric data
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2171, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_array); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2171, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2171, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_y);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_y);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_cur_scope->__pyx_v_y);
  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2171, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, __pyx_builtin_object) < 0) __PYX_ERR(0, 2171, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2171, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_GOTREF(__pyx_cur_scope->__pyx_v_y);
  __Pyx_DECREF_SET(__pyx_cur_scope->__pyx_v_y, __pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_4);
  __pyx_t_4 = 0;

  /* "validator.pyx":2174
 * 
 *     # Check for NaN or infinite values in numeric data
 *     numeric_types = 'biufc'  # Numeric types             # <<<<<<<<<<<<<<
 *     if y.dtype.kind in numeric_types:
 *         numeric_y = y.astype(float, casting='safe')  # Safely cast numeric types to float
 */
  __Pyx_INCREF(__pyx_n_u_biufc);
  __pyx_v_numeric_types = __pyx_n_u_biufc;

  /* "validator.pyx":2175
 *     # Check for NaN or infinite values in numeric data
 *     numeric_types = 'biufc'  # Numeric types
 *     if y.dtype.kind in numeric_types:             # <<<<<<<<<<<<<<
 *         numeric_y = y.astype(float, casting='safe')  # Safely cast numeric types to float
 *         if not np.all(np.isfinite(numeric_y)):
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_y, __pyx_n_s_dtype); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2175, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_kind); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2175, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_5 = (__Pyx_PyUnicode_ContainsTF(__pyx_t_3, __pyx_v_numeric_types, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 2175, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_6 = (__pyx_t_5 != 0);
  if (__pyx_t_6) {

    /* "validator.pyx":2176
 *     numeric_types = 'biufc'  # Numeric types
 *     if y.dtype.kind in numeric_types:
 *         numeric_y = y.astype(float, casting='safe')  # Safely cast numeric types to float             # <<<<<<<<<<<<<<
 *         if not np.all(np.isfinite(numeric_y)):
 *             raise ValueError("Numeric target values contain NaN or infinite numbers,"
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_y, __pyx_n_s_astype); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2176, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2176, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_INCREF(((PyObject *)(&PyFloat_Type)));
    __Pyx_GIVEREF(((PyObject *)(&PyFloat_Type)));
    PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)(&PyFloat_Type)));
    __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2176, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_casting, __pyx_n_u_safe) < 0) __PYX_ERR(0, 2176, __pyx_L1_error)
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2176, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_v_numeric_y = __pyx_t_1;
    __pyx_t_1 = 0;

    /* "validator.pyx":2177
 *     if y.dtype.kind in numeric_types:
 *         numeric_y = y.astype(float, casting='safe')  # Safely cast numeric types to float
 *         if not np.all(np.isfinite(numeric_y)):             # <<<<<<<<<<<<<<
 *             raise ValueError("Numeric target values contain NaN or infinite numbers,"
 *                              " not suitable for classification.")
 */
    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2177, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_all); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2177, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2177, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_isfinite); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2177, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_7);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_7, function);
      }
    }
    __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_3, __pyx_v_numeric_y) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_v_numeric_y);
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2177, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_1 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_7, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_2);
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2177, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 2177, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_5 = ((!__pyx_t_6) != 0);
    if (unlikely(__pyx_t_5)) {

      /* "validator.pyx":2178
 *         numeric_y = y.astype(float, casting='safe')  # Safely cast numeric types to float
 *         if not np.all(np.isfinite(numeric_y)):
 *             raise ValueError("Numeric target values contain NaN or infinite numbers,"             # <<<<<<<<<<<<<<
 *                              " not suitable for classification.")
 *     else:
 */
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__56, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2178, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 2178, __pyx_L1_error)

      /* "validator.pyx":2177
 *     if y.dtype.kind in numeric_types:
 *         numeric_y = y.astype(float, casting='safe')  # Safely cast numeric types to float
 *         if not np.all(np.isfinite(numeric_y)):             # <<<<<<<<<<<<<<
 *             raise ValueError("Numeric target values contain NaN or infinite numbers,"
 *                              " not suitable for classification.")
 */
    }

    /* "validator.pyx":2175
 *     # Check for NaN or infinite values in numeric data
 *     numeric_types = 'biufc'  # Numeric types
 *     if y.dtype.kind in numeric_types:             # <<<<<<<<<<<<<<
 *         numeric_y = y.astype(float, casting='safe')  # Safely cast numeric types to float
 *         if not np.all(np.isfinite(numeric_y)):
 */
    goto __pyx_L3;
  }

  /* "validator.pyx":2182
 *     else:
 *         # For non-numeric data, ensure no elements are None or equivalent to np.nan
 *         if any(el is None or el is np.nan for el in y):             # <<<<<<<<<<<<<<
 *             raise ValueError("Non-numeric target values contain None or NaN,"
 *                              " not suitable for classification.")
 */
  /*else*/ {
    __pyx_t_1 = __pyx_pf_9validator_8_check_y_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2182, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = __Pyx_Generator_Next(__pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2182, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 2182, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(__pyx_t_5)) {

      /* "validator.pyx":2183
 *         # For non-numeric data, ensure no elements are None or equivalent to np.nan
 *         if any(el is None or el is np.nan for el in y):
 *             raise ValueError("Non-numeric target values contain None or NaN,"             # <<<<<<<<<<<<<<
 *                              " not suitable for classification.")
 *     unique_values = np.unique(y)
 */
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__57, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2183, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __PYX_ERR(0, 2183, __pyx_L1_error)

      /* "validator.pyx":2182
 *     else:
 *         # For non-numeric data, ensure no elements are None or equivalent to np.nan
 *         if any(el is None or el is np.nan for el in y):             # <<<<<<<<<<<<<<
 *             raise ValueError("Non-numeric target values contain None or NaN,"
 *                              " not suitable for classification.")
 */
    }
  }
  __pyx_L3:;

  /* "validator.pyx":2185
 *             raise ValueError("Non-numeric target values contain None or NaN,"
 *                              " not suitable for classification.")
 *     unique_values = np.unique(y)             # <<<<<<<<<<<<<<
 *     # Apply specific strategy for determining categorization
 *     if strategy != 'auto':
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2185, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_unique); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2185, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_1)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_1);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_4 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_1, __pyx_cur_scope->__pyx_v_y) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_cur_scope->__pyx_v_y);
  __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2185, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_GIVEREF(__pyx_t_4);
  __pyx_cur_scope->__pyx_v_unique_values = __pyx_t_4;
  __pyx_t_4 = 0;

  /* "validator.pyx":2187
 *     unique_values = np.unique(y)
 *     # Apply specific strategy for determining categorization
 *     if strategy != 'auto':             # <<<<<<<<<<<<<<
 *         # Implement custom logic based on `type_of_target` outcomes
 *         target_type = type_of_target(y)
 */
  __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_strategy, __pyx_n_u_auto, Py_NE)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 2187, __pyx_L1_error)
  if (__pyx_t_5) {

    /* "validator.pyx":2189
 *     if strategy != 'auto':
 *         # Implement custom logic based on `type_of_target` outcomes
 *         target_type = type_of_target(y)             # <<<<<<<<<<<<<<
 *         if target_type == 'continuous':
 *             raise ValueError("Continuous data not suitable for classification"
 */
    __Pyx_INCREF(__pyx_v_type_of_target);
    __pyx_t_2 = __pyx_v_type_of_target; __pyx_t_1 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_1)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    __pyx_t_4 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_1, __pyx_cur_scope->__pyx_v_y) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_cur_scope->__pyx_v_y);
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2189, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_v_target_type = __pyx_t_4;
    __pyx_t_4 = 0;

    /* "validator.pyx":2190
 *         # Implement custom logic based on `type_of_target` outcomes
 *         target_type = type_of_target(y)
 *         if target_type == 'continuous':             # <<<<<<<<<<<<<<
 *             raise ValueError("Continuous data not suitable for classification"
 *                              " without explicit binning.")
 */
    __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_target_type, __pyx_n_u_continuous, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 2190, __pyx_L1_error)
    if (unlikely(__pyx_t_5)) {

      /* "validator.pyx":2191
 *         target_type = type_of_target(y)
 *         if target_type == 'continuous':
 *             raise ValueError("Continuous data not suitable for classification"             # <<<<<<<<<<<<<<
 *                              " without explicit binning.")
 *         elif target_type == "multilabel-indicator":
 */
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__58, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2191, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __PYX_ERR(0, 2191, __pyx_L1_error)

      /* "validator.pyx":2190
 *         # Implement custom logic based on `type_of_target` outcomes
 *         target_type = type_of_target(y)
 *         if target_type == 'continuous':             # <<<<<<<<<<<<<<
 *             raise ValueError("Continuous data not suitable for classification"
 *                              " without explicit binning.")
 */
    }

    /* "validator.pyx":2193
 *             raise ValueError("Continuous data not suitable for classification"
 *                              " without explicit binning.")
 *         elif target_type == "multilabel-indicator":             # <<<<<<<<<<<<<<
 *             raise ValueError("Multilabel-indicator format detected,"
 *                              " requiring different handling.")
 */
    __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_target_type, __pyx_kp_u_multilabel_indicator, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 2193, __pyx_L1_error)
    if (unlikely(__pyx_t_5)) {

      /* "validator.pyx":2194
 *                              " without explicit binning.")
 *         elif target_type == "multilabel-indicator":
 *             raise ValueError("Multilabel-indicator format detected,"             # <<<<<<<<<<<<<<
 *                              " requiring different handling.")
 *         elif target_type == 'unknown':
 */
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__59, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2194, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __PYX_ERR(0, 2194, __pyx_L1_error)

      /* "validator.pyx":2193
 *             raise ValueError("Continuous data not suitable for classification"
 *                              " without explicit binning.")
 *         elif target_type == "multilabel-indicator":             # <<<<<<<<<<<<<<
 *             raise ValueError("Multilabel-indicator format detected,"
 *                              " requiring different handling.")
 */
    }

    /* "validator.pyx":2196
 *             raise ValueError("Multilabel-indicator format detected,"
 *                              " requiring different handling.")
 *         elif target_type == 'unknown':             # <<<<<<<<<<<<<<
 *             raise ValueError("Unable to determine the target type,"
 *                              " please check the input data.")
 */
    __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_target_type, __pyx_n_u_unknown, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 2196, __pyx_L1_error)
    if (unlikely(__pyx_t_5)) {

      /* "validator.pyx":2197
 *                              " requiring different handling.")
 *         elif target_type == 'unknown':
 *             raise ValueError("Unable to determine the target type,"             # <<<<<<<<<<<<<<
 *                              " please check the input data.")
 *     else:
 */
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__60, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2197, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __PYX_ERR(0, 2197, __pyx_L1_error)

      /* "validator.pyx":2196
 *             raise ValueError("Multilabel-indicator format detected,"
 *                              " requiring different handling.")
 *         elif target_type == 'unknown':             # <<<<<<<<<<<<<<
 *             raise ValueError("Unable to determine the target type,"
 *                              " please check the input data.")
 */
    }

    /* "validator.pyx":2187
 *     unique_values = np.unique(y)
 *     # Apply specific strategy for determining categorization
 *     if strategy != 'auto':             # <<<<<<<<<<<<<<
 *         # Implement custom logic based on `type_of_target` outcomes
 *         target_type = type_of_target(y)
 */
    goto __pyx_L6;
  }

  /* "validator.pyx":2201
 *     else:
 *         # Auto detection based on unique values count
 *         if unique_values.shape[0] > np.sqrt(len(y)):             # <<<<<<<<<<<<<<
 *             raise ValueError("Automatic strategy detected too many unique values"
 *                              " for a classification task.")
 */
  /*else*/ {
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_unique_values, __pyx_n_s_shape); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2201, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_2 = __Pyx_GetItemInt(__pyx_t_4, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2201, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2201, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_sqrt); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2201, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = __pyx_cur_scope->__pyx_v_y;
    __Pyx_INCREF(__pyx_t_1);
    __pyx_t_8 = PyObject_Length(__pyx_t_1); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 2201, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = PyInt_FromSsize_t(__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2201, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_7);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_7, function);
      }
    }
    __pyx_t_4 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_3, __pyx_t_1) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_1);
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2201, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_7 = PyObject_RichCompare(__pyx_t_2, __pyx_t_4, Py_GT); __Pyx_XGOTREF(__pyx_t_7); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2201, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_7); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 2201, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    if (unlikely(__pyx_t_5)) {

      /* "validator.pyx":2202
 *         # Auto detection based on unique values count
 *         if unique_values.shape[0] > np.sqrt(len(y)):
 *             raise ValueError("Automatic strategy detected too many unique values"             # <<<<<<<<<<<<<<
 *                              " for a classification task.")
 * 
 */
      __pyx_t_7 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__61, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2202, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_Raise(__pyx_t_7, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __PYX_ERR(0, 2202, __pyx_L1_error)

      /* "validator.pyx":2201
 *     else:
 *         # Auto detection based on unique values count
 *         if unique_values.shape[0] > np.sqrt(len(y)):             # <<<<<<<<<<<<<<
 *             raise ValueError("Automatic strategy detected too many unique values"
 *                              " for a classification task.")
 */
    }
  }
  __pyx_L6:;

  /* "validator.pyx":2206
 * 
 *     # Check for non-numeric data convertibility to categorical if not already checked
 *     if y.dtype.kind not in numeric_types:             # <<<<<<<<<<<<<<
 *         if not all(isinstance(val, (str, bool, int)) for val in unique_values):
 *             raise ValueError("Target values must be categorical, numeric,"
 */
  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_y, __pyx_n_s_dtype); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2206, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_kind); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2206, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __pyx_t_5 = (__Pyx_PyUnicode_ContainsTF(__pyx_t_4, __pyx_v_numeric_types, Py_NE)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 2206, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_6 = (__pyx_t_5 != 0);
  if (__pyx_t_6) {

    /* "validator.pyx":2207
 *     # Check for non-numeric data convertibility to categorical if not already checked
 *     if y.dtype.kind not in numeric_types:
 *         if not all(isinstance(val, (str, bool, int)) for val in unique_values):             # <<<<<<<<<<<<<<
 *             raise ValueError("Target values must be categorical, numeric,"
 *                              " or convertible to categories.")
 */
    __pyx_t_4 = __pyx_pf_9validator_8_check_y_3genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2207, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_7 = __Pyx_Generator_Next(__pyx_t_4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2207, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_7); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 2207, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_5 = ((!__pyx_t_6) != 0);
    if (unlikely(__pyx_t_5)) {

      /* "validator.pyx":2208
 *     if y.dtype.kind not in numeric_types:
 *         if not all(isinstance(val, (str, bool, int)) for val in unique_values):
 *             raise ValueError("Target values must be categorical, numeric,"             # <<<<<<<<<<<<<<
 *                              " or convertible to categories.")
 * 
 */
      __pyx_t_7 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__62, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2208, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_Raise(__pyx_t_7, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __PYX_ERR(0, 2208, __pyx_L1_error)

      /* "validator.pyx":2207
 *     # Check for non-numeric data convertibility to categorical if not already checked
 *     if y.dtype.kind not in numeric_types:
 *         if not all(isinstance(val, (str, bool, int)) for val in unique_values):             # <<<<<<<<<<<<<<
 *             raise ValueError("Target values must be categorical, numeric,"
 *                              " or convertible to categories.")
 */
    }

    /* "validator.pyx":2206
 * 
 *     # Check for non-numeric data convertibility to categorical if not already checked
 *     if y.dtype.kind not in numeric_types:             # <<<<<<<<<<<<<<
 *         if not all(isinstance(val, (str, bool, int)) for val in unique_values):
 *             raise ValueError("Target values must be categorical, numeric,"
 */
  }

  /* "validator.pyx":2211
 *                              " or convertible to categories.")
 * 
 *     return y             # <<<<<<<<<<<<<<
 * 
 * def validate_yy(
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_y);
  __pyx_r = __pyx_cur_scope->__pyx_v_y;
  goto __pyx_L0;

  /* "validator.pyx":2158
 *     return validated_targets
 * 
 * def _check_y(y, strategy='auto'):             # <<<<<<<<<<<<<<
 *     """
 *     Validates the target array `y`, ensuring it is suitable for classification
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("validator._check_y", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_type_of_target);
  __Pyx_XDECREF(__pyx_v_numeric_types);
  __Pyx_XDECREF(__pyx_v_numeric_y);
  __Pyx_XDECREF(__pyx_v_target_type);
  __Pyx_XDECREF(__pyx_gb_9validator_8_check_y_2generator7);
  __Pyx_XDECREF(__pyx_gb_9validator_8_check_y_5generator8);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2213
 *     return y
 * 
 * def validate_yy(             # <<<<<<<<<<<<<<
 *     y_true, y_pred,
 *     expected_type=None, *,
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_59validate_yy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_58validate_yy[] = "\n    Validates the shapes and types of actual and predicted target arrays, \n    ensuring they are compatible for further analysis or metrics calculation.\n\n    Parameters\n    ----------\n    y_true : array-like\n        True target values.\n    y_pred : array-like\n        Predicted target values.\n    expected_type : str, optional\n        The expected sklearn type of the target ('binary', 'multiclass', etc.).\n    validation_mode : str, optional\n        Validation strictness. Currently, only 'strict' is implemented,\n        which requires y_true and y_pred to have the same shape and match the \n        expected_type.\n    flatten : bool, optional\n        If True, both y_true and y_pred are flattened to one-dimensional arrays.\n\n    Raises\n    ------\n    ValueError\n        If y_true and y_pred do not meet the validation criteria.\n\n    Returns\n    -------\n    tuple\n        The validated y_true and y_pred arrays, potentially flattened.\n    ";
static PyMethodDef __pyx_mdef_9validator_59validate_yy = {"validate_yy", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_59validate_yy, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_58validate_yy};
static PyObject *__pyx_pw_9validator_59validate_yy(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_y_true = 0;
  PyObject *__pyx_v_y_pred = 0;
  PyObject *__pyx_v_expected_type = 0;
  PyObject *__pyx_v_validation_mode = 0;
  PyObject *__pyx_v_flatten = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validate_yy (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_y_true,&__pyx_n_s_y_pred,&__pyx_n_s_expected_type,&__pyx_n_s_validation_mode,&__pyx_n_s_flatten,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "validator.pyx":2215
 * def validate_yy(
 *     y_true, y_pred,
 *     expected_type=None, *,             # <<<<<<<<<<<<<<
 *     validation_mode='strict',
 *     flatten=False
 */
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)__pyx_n_u_strict);

    /* "validator.pyx":2217
 *     expected_type=None, *,
 *     validation_mode='strict',
 *     flatten=False             # <<<<<<<<<<<<<<
 *     ):
 *     """
 */
    values[4] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y_true)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y_pred)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("validate_yy", 0, 2, 3, 1); __PYX_ERR(0, 2213, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_expected_type);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (kw_args > 0 && likely(kw_args <= 2)) {
        Py_ssize_t index;
        for (index = 3; index < 5 && kw_args > 0; index++) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
          if (value) { values[index] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "validate_yy") < 0)) __PYX_ERR(0, 2213, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_y_true = values[0];
    __pyx_v_y_pred = values[1];
    __pyx_v_expected_type = values[2];
    __pyx_v_validation_mode = values[3];
    __pyx_v_flatten = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("validate_yy", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2213, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.validate_yy", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_58validate_yy(__pyx_self, __pyx_v_y_true, __pyx_v_y_pred, __pyx_v_expected_type, __pyx_v_validation_mode, __pyx_v_flatten);

  /* "validator.pyx":2213
 *     return y
 * 
 * def validate_yy(             # <<<<<<<<<<<<<<
 *     y_true, y_pred,
 *     expected_type=None, *,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_58validate_yy(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y_true, PyObject *__pyx_v_y_pred, PyObject *__pyx_v_expected_type, PyObject *__pyx_v_validation_mode, PyObject *__pyx_v_flatten) {
  PyObject *__pyx_v_type_of_target = NULL;
  PyObject *__pyx_v_msg = NULL;
  PyObject *__pyx_v_actual_type_y_true = NULL;
  PyObject *__pyx_v_actual_type_y_pred = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  Py_ssize_t __pyx_t_8;
  Py_UCS4 __pyx_t_9;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validate_yy", 0);
  __Pyx_INCREF(__pyx_v_y_true);
  __Pyx_INCREF(__pyx_v_y_pred);

  /* "validator.pyx":2248
 *         The validated y_true and y_pred arrays, potentially flattened.
 *     """
 *     from .coreutils import type_of_target             # <<<<<<<<<<<<<<
 * 
 *     y_true = np.asarray(y_true)
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2248, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_type_of_target);
  __Pyx_GIVEREF(__pyx_n_s_type_of_target);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_type_of_target);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_coreutils, __pyx_t_1, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2248, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_type_of_target); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2248, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_t_1);
  __pyx_v_type_of_target = __pyx_t_1;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":2250
 *     from .coreutils import type_of_target
 * 
 *     y_true = np.asarray(y_true)             # <<<<<<<<<<<<<<
 *     y_pred = np.asarray(y_pred)
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2250, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_asarray); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2250, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_1)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_1);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_2 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_1, __pyx_v_y_true) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_y_true);
  __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2250, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF_SET(__pyx_v_y_true, __pyx_t_2);
  __pyx_t_2 = 0;

  /* "validator.pyx":2251
 * 
 *     y_true = np.asarray(y_true)
 *     y_pred = np.asarray(y_pred)             # <<<<<<<<<<<<<<
 * 
 *     if flatten:
 */
  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2251, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_asarray); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2251, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_3, __pyx_v_y_pred) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_y_pred);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2251, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF_SET(__pyx_v_y_pred, __pyx_t_2);
  __pyx_t_2 = 0;

  /* "validator.pyx":2253
 *     y_pred = np.asarray(y_pred)
 * 
 *     if flatten:             # <<<<<<<<<<<<<<
 *         y_true = y_true.ravel()
 *         y_pred = y_pred.ravel()
 */
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_flatten); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 2253, __pyx_L1_error)
  if (__pyx_t_4) {

    /* "validator.pyx":2254
 * 
 *     if flatten:
 *         y_true = y_true.ravel()             # <<<<<<<<<<<<<<
 *         y_pred = y_pred.ravel()
 * 
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_y_true, __pyx_n_s_ravel); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2254, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_1);
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2254, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF_SET(__pyx_v_y_true, __pyx_t_2);
    __pyx_t_2 = 0;

    /* "validator.pyx":2255
 *     if flatten:
 *         y_true = y_true.ravel()
 *         y_pred = y_pred.ravel()             # <<<<<<<<<<<<<<
 * 
 *     if y_true.ndim != 1 or y_pred.ndim != 1:
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_y_pred, __pyx_n_s_ravel); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2255, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_1);
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2255, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF_SET(__pyx_v_y_pred, __pyx_t_2);
    __pyx_t_2 = 0;

    /* "validator.pyx":2253
 *     y_pred = np.asarray(y_pred)
 * 
 *     if flatten:             # <<<<<<<<<<<<<<
 *         y_true = y_true.ravel()
 *         y_pred = y_pred.ravel()
 */
  }

  /* "validator.pyx":2257
 *         y_pred = y_pred.ravel()
 * 
 *     if y_true.ndim != 1 or y_pred.ndim != 1:             # <<<<<<<<<<<<<<
 *         msg = "Both y_true and y_pred must be one-dimensional arrays after optional flattening."
 *         raise ValueError(msg)
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_y_true, __pyx_n_s_ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2257, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_PyInt_NeObjC(__pyx_t_2, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2257, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 2257, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (!__pyx_t_5) {
  } else {
    __pyx_t_4 = __pyx_t_5;
    goto __pyx_L5_bool_binop_done;
  }
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_y_pred, __pyx_n_s_ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2257, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyInt_NeObjC(__pyx_t_1, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2257, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 2257, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __pyx_t_5;
  __pyx_L5_bool_binop_done:;
  if (unlikely(__pyx_t_4)) {

    /* "validator.pyx":2258
 * 
 *     if y_true.ndim != 1 or y_pred.ndim != 1:
 *         msg = "Both y_true and y_pred must be one-dimensional arrays after optional flattening."             # <<<<<<<<<<<<<<
 *         raise ValueError(msg)
 * 
 */
    __Pyx_INCREF(__pyx_kp_u_Both_y_true_and_y_pred_must_be_o);
    __pyx_v_msg = __pyx_kp_u_Both_y_true_and_y_pred_must_be_o;

    /* "validator.pyx":2259
 *     if y_true.ndim != 1 or y_pred.ndim != 1:
 *         msg = "Both y_true and y_pred must be one-dimensional arrays after optional flattening."
 *         raise ValueError(msg)             # <<<<<<<<<<<<<<
 * 
 *     check_consistent_length(y_true, y_pred)
 */
    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_v_msg); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2259, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 2259, __pyx_L1_error)

    /* "validator.pyx":2257
 *         y_pred = y_pred.ravel()
 * 
 *     if y_true.ndim != 1 or y_pred.ndim != 1:             # <<<<<<<<<<<<<<
 *         msg = "Both y_true and y_pred must be one-dimensional arrays after optional flattening."
 *         raise ValueError(msg)
 */
  }

  /* "validator.pyx":2261
 *         raise ValueError(msg)
 * 
 *     check_consistent_length(y_true, y_pred)             # <<<<<<<<<<<<<<
 * 
 *     if expected_type is not None:
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_check_consistent_length); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2261, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = NULL;
  __pyx_t_6 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
      __pyx_t_6 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_1)) {
    PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_y_true, __pyx_v_y_pred};
    __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2261, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_2);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
    PyObject *__pyx_temp[3] = {__pyx_t_3, __pyx_v_y_true, __pyx_v_y_pred};
    __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2261, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_t_2);
  } else
  #endif
  {
    __pyx_t_7 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2261, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    if (__pyx_t_3) {
      __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_3); __pyx_t_3 = NULL;
    }
    __Pyx_INCREF(__pyx_v_y_true);
    __Pyx_GIVEREF(__pyx_v_y_true);
    PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_v_y_true);
    __Pyx_INCREF(__pyx_v_y_pred);
    __Pyx_GIVEREF(__pyx_v_y_pred);
    PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_v_y_pred);
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_7, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2261, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":2263
 *     check_consistent_length(y_true, y_pred)
 * 
 *     if expected_type is not None:             # <<<<<<<<<<<<<<
 *         actual_type_y_true = type_of_target(y_true)
 *         actual_type_y_pred = type_of_target(y_pred)
 */
  __pyx_t_4 = (__pyx_v_expected_type != Py_None);
  __pyx_t_5 = (__pyx_t_4 != 0);
  if (__pyx_t_5) {

    /* "validator.pyx":2264
 * 
 *     if expected_type is not None:
 *         actual_type_y_true = type_of_target(y_true)             # <<<<<<<<<<<<<<
 *         actual_type_y_pred = type_of_target(y_pred)
 *         if validation_mode == 'strict' and (
 */
    __Pyx_INCREF(__pyx_v_type_of_target);
    __pyx_t_1 = __pyx_v_type_of_target; __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    __pyx_t_2 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_7, __pyx_v_y_true) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_y_true);
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2264, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_v_actual_type_y_true = __pyx_t_2;
    __pyx_t_2 = 0;

    /* "validator.pyx":2265
 *     if expected_type is not None:
 *         actual_type_y_true = type_of_target(y_true)
 *         actual_type_y_pred = type_of_target(y_pred)             # <<<<<<<<<<<<<<
 *         if validation_mode == 'strict' and (
 *                 actual_type_y_true != expected_type or actual_type_y_pred != expected_type
 */
    __Pyx_INCREF(__pyx_v_type_of_target);
    __pyx_t_1 = __pyx_v_type_of_target; __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    __pyx_t_2 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_7, __pyx_v_y_pred) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_y_pred);
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2265, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_v_actual_type_y_pred = __pyx_t_2;
    __pyx_t_2 = 0;

    /* "validator.pyx":2266
 *         actual_type_y_true = type_of_target(y_true)
 *         actual_type_y_pred = type_of_target(y_pred)
 *         if validation_mode == 'strict' and (             # <<<<<<<<<<<<<<
 *                 actual_type_y_true != expected_type or actual_type_y_pred != expected_type
 *                 ):
 */
    __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_v_validation_mode, __pyx_n_u_strict, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 2266, __pyx_L1_error)
    if (__pyx_t_4) {
    } else {
      __pyx_t_5 = __pyx_t_4;
      goto __pyx_L9_bool_binop_done;
    }

    /* "validator.pyx":2267
 *         actual_type_y_pred = type_of_target(y_pred)
 *         if validation_mode == 'strict' and (
 *                 actual_type_y_true != expected_type or actual_type_y_pred != expected_type             # <<<<<<<<<<<<<<
 *                 ):
 *             msg = (f"Validation failed in strict mode. Expected type '{expected_type}'"
 */
    __pyx_t_2 = PyObject_RichCompare(__pyx_v_actual_type_y_true, __pyx_v_expected_type, Py_NE); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2267, __pyx_L1_error)
    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 2267, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (!__pyx_t_4) {
    } else {
      __pyx_t_5 = __pyx_t_4;
      goto __pyx_L9_bool_binop_done;
    }
    __pyx_t_2 = PyObject_RichCompare(__pyx_v_actual_type_y_pred, __pyx_v_expected_type, Py_NE); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2267, __pyx_L1_error)
    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 2267, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_5 = __pyx_t_4;
    __pyx_L9_bool_binop_done:;

    /* "validator.pyx":2266
 *         actual_type_y_true = type_of_target(y_true)
 *         actual_type_y_pred = type_of_target(y_pred)
 *         if validation_mode == 'strict' and (             # <<<<<<<<<<<<<<
 *                 actual_type_y_true != expected_type or actual_type_y_pred != expected_type
 *                 ):
 */
    if (unlikely(__pyx_t_5)) {

      /* "validator.pyx":2269
 *                 actual_type_y_true != expected_type or actual_type_y_pred != expected_type
 *                 ):
 *             msg = (f"Validation failed in strict mode. Expected type '{expected_type}'"             # <<<<<<<<<<<<<<
 *                    f" for both y_true and y_pred, but got '{actual_type_y_true}'"
 *                   f" and '{actual_type_y_pred}' respectively.")
 */
      __pyx_t_2 = PyTuple_New(7); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2269, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_8 = 0;
      __pyx_t_9 = 127;
      __Pyx_INCREF(__pyx_kp_u_Validation_failed_in_strict_mode);
      __pyx_t_8 += 49;
      __Pyx_GIVEREF(__pyx_kp_u_Validation_failed_in_strict_mode);
      PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_kp_u_Validation_failed_in_strict_mode);
      __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_expected_type, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2269, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_9 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) > __pyx_t_9) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) : __pyx_t_9;
      __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_1);
      __Pyx_GIVEREF(__pyx_t_1);
      PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_1);
      __pyx_t_1 = 0;
      __Pyx_INCREF(__pyx_kp_u_for_both_y_true_and_y_pred_but);
      __pyx_t_8 += 39;
      __Pyx_GIVEREF(__pyx_kp_u_for_both_y_true_and_y_pred_but);
      PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_kp_u_for_both_y_true_and_y_pred_but);

      /* "validator.pyx":2270
 *                 ):
 *             msg = (f"Validation failed in strict mode. Expected type '{expected_type}'"
 *                    f" for both y_true and y_pred, but got '{actual_type_y_true}'"             # <<<<<<<<<<<<<<
 *                   f" and '{actual_type_y_pred}' respectively.")
 *             raise ValueError(msg)
 */
      __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_actual_type_y_true, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2270, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_9 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) > __pyx_t_9) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) : __pyx_t_9;
      __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_1);
      __Pyx_GIVEREF(__pyx_t_1);
      PyTuple_SET_ITEM(__pyx_t_2, 3, __pyx_t_1);
      __pyx_t_1 = 0;
      __Pyx_INCREF(__pyx_kp_u_and_2);
      __pyx_t_8 += 7;
      __Pyx_GIVEREF(__pyx_kp_u_and_2);
      PyTuple_SET_ITEM(__pyx_t_2, 4, __pyx_kp_u_and_2);

      /* "validator.pyx":2271
 *             msg = (f"Validation failed in strict mode. Expected type '{expected_type}'"
 *                    f" for both y_true and y_pred, but got '{actual_type_y_true}'"
 *                   f" and '{actual_type_y_pred}' respectively.")             # <<<<<<<<<<<<<<
 *             raise ValueError(msg)
 * 
 */
      __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_actual_type_y_pred, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2271, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_9 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) > __pyx_t_9) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) : __pyx_t_9;
      __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_1);
      __Pyx_GIVEREF(__pyx_t_1);
      PyTuple_SET_ITEM(__pyx_t_2, 5, __pyx_t_1);
      __pyx_t_1 = 0;
      __Pyx_INCREF(__pyx_kp_u_respectively);
      __pyx_t_8 += 15;
      __Pyx_GIVEREF(__pyx_kp_u_respectively);
      PyTuple_SET_ITEM(__pyx_t_2, 6, __pyx_kp_u_respectively);

      /* "validator.pyx":2269
 *                 actual_type_y_true != expected_type or actual_type_y_pred != expected_type
 *                 ):
 *             msg = (f"Validation failed in strict mode. Expected type '{expected_type}'"             # <<<<<<<<<<<<<<
 *                    f" for both y_true and y_pred, but got '{actual_type_y_true}'"
 *                   f" and '{actual_type_y_pred}' respectively.")
 */
      __pyx_t_1 = __Pyx_PyUnicode_Join(__pyx_t_2, 7, __pyx_t_8, __pyx_t_9); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2269, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_v_msg = ((PyObject*)__pyx_t_1);
      __pyx_t_1 = 0;

      /* "validator.pyx":2272
 *                    f" for both y_true and y_pred, but got '{actual_type_y_true}'"
 *                   f" and '{actual_type_y_pred}' respectively.")
 *             raise ValueError(msg)             # <<<<<<<<<<<<<<
 * 
 *     return y_true, y_pred
 */
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_v_msg); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2272, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 2272, __pyx_L1_error)

      /* "validator.pyx":2266
 *         actual_type_y_true = type_of_target(y_true)
 *         actual_type_y_pred = type_of_target(y_pred)
 *         if validation_mode == 'strict' and (             # <<<<<<<<<<<<<<
 *                 actual_type_y_true != expected_type or actual_type_y_pred != expected_type
 *                 ):
 */
    }

    /* "validator.pyx":2263
 *     check_consistent_length(y_true, y_pred)
 * 
 *     if expected_type is not None:             # <<<<<<<<<<<<<<
 *         actual_type_y_true = type_of_target(y_true)
 *         actual_type_y_pred = type_of_target(y_pred)
 */
  }

  /* "validator.pyx":2274
 *             raise ValueError(msg)
 * 
 *     return y_true, y_pred             # <<<<<<<<<<<<<<
 * 
 * def check_mixed_data_types(data ) -> bool:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2274, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_v_y_true);
  __Pyx_GIVEREF(__pyx_v_y_true);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_y_true);
  __Pyx_INCREF(__pyx_v_y_pred);
  __Pyx_GIVEREF(__pyx_v_y_pred);
  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_y_pred);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "validator.pyx":2213
 *     return y
 * 
 * def validate_yy(             # <<<<<<<<<<<<<<
 *     y_true, y_pred,
 *     expected_type=None, *,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("validator.validate_yy", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_type_of_target);
  __Pyx_XDECREF(__pyx_v_msg);
  __Pyx_XDECREF(__pyx_v_actual_type_y_true);
  __Pyx_XDECREF(__pyx_v_actual_type_y_pred);
  __Pyx_XDECREF(__pyx_v_y_true);
  __Pyx_XDECREF(__pyx_v_y_pred);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2276
 *     return y_true, y_pred
 * 
 * def check_mixed_data_types(data ) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Checks if the given data (DataFrame or numpy array) contains both numerical
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_61check_mixed_data_types(PyObject *__pyx_self, PyObject *__pyx_v_data); /*proto*/
static char __pyx_doc_9validator_60check_mixed_data_types[] = "\n    Checks if the given data (DataFrame or numpy array) contains both numerical \n    and categorical columns.\n\n    Parameters\n    ----------\n    data : pd.DataFrame or np.ndarray\n        The data to check. Can be a pandas DataFrame or a numpy array. If `data`\n        is a numpy array, it is temporarily converted to a DataFrame for type \n        checking.\n\n    Returns\n    -------\n    bool\n        True if the data contains both numerical and categorical columns, False\n        otherwise.\n\n    Examples\n    --------\n    Using with a pandas DataFrame:\n        \n    >>> import numpy as np \n    >>> import pandas as pd \n    >>> from gofast.tools.validator import check_mixed_data_types\n    >>> df = pd.DataFrame({'A': [1, 2, 3], 'B': ['a', 'b', 'c']})\n    >>> print(check_mixed_data_types(df))\n    True\n\n    Using with a numpy array:\n\n    >>> array = np.array([[1, 'a'], [2, 'b'], [3, 'c']])\n    >>> print(check_mixed_data_types(array))\n    True\n\n    With data containing only numerical values:\n\n    >>> df_numeric_only = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})\n    >>> print(check_mixed_data_types(df_numeric_only))\n    False\n\n    With data containing only categorical values:\n\n    >>> df_categorical_only = pd.DataFrame({'A': ['a', 'b', 'c'], 'B': ['d', 'e', 'f']})\n    >>> print(check_mixed_data_types(df_categorical_only))\n    False\n    ";
static PyMethodDef __pyx_mdef_9validator_61check_mixed_data_types = {"check_mixed_data_types", (PyCFunction)__pyx_pw_9validator_61check_mixed_data_types, METH_O, __pyx_doc_9validator_60check_mixed_data_types};
static PyObject *__pyx_pw_9validator_61check_mixed_data_types(PyObject *__pyx_self, PyObject *__pyx_v_data) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("check_mixed_data_types (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_60check_mixed_data_types(__pyx_self, ((PyObject *)__pyx_v_data));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2328
 * 
 *     # Check for the presence of numerical and categorical data types
 *     has_numerical = any(data.dtypes.apply(lambda dtype: np.issubdtype(dtype, np.number)))             # <<<<<<<<<<<<<<
 *     has_categorical = any(data.dtypes.apply(
 *         lambda dtype: dtype == 'object' or dtype.name == 'category' or dtype == 'bool'))
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_22check_mixed_data_types_lambda10(PyObject *__pyx_self, PyObject *__pyx_v_dtype); /*proto*/
static PyMethodDef __pyx_mdef_9validator_22check_mixed_data_types_lambda10 = {"lambda10", (PyCFunction)__pyx_pw_9validator_22check_mixed_data_types_lambda10, METH_O, 0};
static PyObject *__pyx_pw_9validator_22check_mixed_data_types_lambda10(PyObject *__pyx_self, PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("lambda10 (wrapper)", 0);
  __pyx_r = __pyx_lambda_funcdef_lambda10(__pyx_self, ((PyObject *)__pyx_v_dtype));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_lambda_funcdef_lambda10(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("lambda10", 0);
  __Pyx_XDECREF(__pyx_r);
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2328, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_issubdtype); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2328, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2328, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_number); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2328, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  __pyx_t_5 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
      __pyx_t_5 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_dtype, __pyx_t_4};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2328, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
    PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_dtype, __pyx_t_4};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_5, 2+__pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2328, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  } else
  #endif
  {
    __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2328, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    if (__pyx_t_2) {
      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_2); __pyx_t_2 = NULL;
    }
    __Pyx_INCREF(__pyx_v_dtype);
    __Pyx_GIVEREF(__pyx_v_dtype);
    PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_v_dtype);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2328, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("validator.check_mixed_data_types.lambda10", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2330
 *     has_numerical = any(data.dtypes.apply(lambda dtype: np.issubdtype(dtype, np.number)))
 *     has_categorical = any(data.dtypes.apply(
 *         lambda dtype: dtype == 'object' or dtype.name == 'category' or dtype == 'bool'))             # <<<<<<<<<<<<<<
 * 
 *     return has_numerical and has_categorical
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_22check_mixed_data_types_1lambda11(PyObject *__pyx_self, PyObject *__pyx_v_dtype); /*proto*/
static PyMethodDef __pyx_mdef_9validator_22check_mixed_data_types_1lambda11 = {"lambda11", (PyCFunction)__pyx_pw_9validator_22check_mixed_data_types_1lambda11, METH_O, 0};
static PyObject *__pyx_pw_9validator_22check_mixed_data_types_1lambda11(PyObject *__pyx_self, PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("lambda11 (wrapper)", 0);
  __pyx_r = __pyx_lambda_funcdef_lambda11(__pyx_self, ((PyObject *)__pyx_v_dtype));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_lambda_funcdef_lambda11(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_dtype) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("lambda11", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = PyObject_RichCompare(__pyx_v_dtype, __pyx_n_u_object, Py_EQ); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2330, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 2330, __pyx_L1_error)
  if (!__pyx_t_3) {
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  } else {
    __Pyx_INCREF(__pyx_t_2);
    __pyx_t_1 = __pyx_t_2;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    goto __pyx_L3_bool_binop_done;
  }
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_dtype, __pyx_n_s_name_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2330, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = PyObject_RichCompare(__pyx_t_2, __pyx_n_u_category, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2330, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 2330, __pyx_L1_error)
  if (!__pyx_t_3) {
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  } else {
    __Pyx_INCREF(__pyx_t_4);
    __pyx_t_1 = __pyx_t_4;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    goto __pyx_L3_bool_binop_done;
  }
  __pyx_t_4 = PyObject_RichCompare(__pyx_v_dtype, __pyx_n_u_bool, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2330, __pyx_L1_error)
  __Pyx_INCREF(__pyx_t_4);
  __pyx_t_1 = __pyx_t_4;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_L3_bool_binop_done:;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("validator.check_mixed_data_types.lambda11", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2276
 *     return y_true, y_pred
 * 
 * def check_mixed_data_types(data ) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Checks if the given data (DataFrame or numpy array) contains both numerical
 */

static PyObject *__pyx_pf_9validator_60check_mixed_data_types(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_data) {
  PyObject *__pyx_v_has_numerical = NULL;
  PyObject *__pyx_v_has_categorical = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("check_mixed_data_types", 0);
  __Pyx_INCREF(__pyx_v_data);

  /* "validator.pyx":2324
 *     """
 *     # Convert numpy array to DataFrame if necessary
 *     if isinstance(data, np.ndarray):             # <<<<<<<<<<<<<<
 *         data = pd.DataFrame(data)
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2324, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_ndarray); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2324, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = PyObject_IsInstance(__pyx_v_data, __pyx_t_2); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 2324, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = (__pyx_t_3 != 0);
  if (__pyx_t_4) {

    /* "validator.pyx":2325
 *     # Convert numpy array to DataFrame if necessary
 *     if isinstance(data, np.ndarray):
 *         data = pd.DataFrame(data)             # <<<<<<<<<<<<<<
 * 
 *     # Check for the presence of numerical and categorical data types
 */
    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pd); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2325, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_DataFrame); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2325, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_1)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    __pyx_t_2 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_1, __pyx_v_data) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_data);
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2325, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_2);
    __pyx_t_2 = 0;

    /* "validator.pyx":2324
 *     """
 *     # Convert numpy array to DataFrame if necessary
 *     if isinstance(data, np.ndarray):             # <<<<<<<<<<<<<<
 *         data = pd.DataFrame(data)
 * 
 */
  }

  /* "validator.pyx":2328
 * 
 *     # Check for the presence of numerical and categorical data types
 *     has_numerical = any(data.dtypes.apply(lambda dtype: np.issubdtype(dtype, np.number)))             # <<<<<<<<<<<<<<
 *     has_categorical = any(data.dtypes.apply(
 *         lambda dtype: dtype == 'object' or dtype.name == 'category' or dtype == 'bool'))
 */
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_dtypes); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2328, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_apply); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2328, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_CyFunction_New(&__pyx_mdef_9validator_22check_mixed_data_types_lambda10, 0, __pyx_n_s_check_mixed_data_types_locals_la, NULL, __pyx_n_s_validator, __pyx_d, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2328, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_6, __pyx_t_5) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2328, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_any, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2328, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_has_numerical = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":2329
 *     # Check for the presence of numerical and categorical data types
 *     has_numerical = any(data.dtypes.apply(lambda dtype: np.issubdtype(dtype, np.number)))
 *     has_categorical = any(data.dtypes.apply(             # <<<<<<<<<<<<<<
 *         lambda dtype: dtype == 'object' or dtype.name == 'category' or dtype == 'bool'))
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_dtypes); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2329, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_apply); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2329, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":2330
 *     has_numerical = any(data.dtypes.apply(lambda dtype: np.issubdtype(dtype, np.number)))
 *     has_categorical = any(data.dtypes.apply(
 *         lambda dtype: dtype == 'object' or dtype.name == 'category' or dtype == 'bool'))             # <<<<<<<<<<<<<<
 * 
 *     return has_numerical and has_categorical
 */
  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_9validator_22check_mixed_data_types_1lambda11, 0, __pyx_n_s_check_mixed_data_types_locals_la, NULL, __pyx_n_s_validator, __pyx_d, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2330, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_6 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
    }
  }
  __pyx_t_1 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_2);
  __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2329, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

  /* "validator.pyx":2329
 *     # Check for the presence of numerical and categorical data types
 *     has_numerical = any(data.dtypes.apply(lambda dtype: np.issubdtype(dtype, np.number)))
 *     has_categorical = any(data.dtypes.apply(             # <<<<<<<<<<<<<<
 *         lambda dtype: dtype == 'object' or dtype.name == 'category' or dtype == 'bool'))
 * 
 */
  __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_any, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2329, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_has_categorical = __pyx_t_5;
  __pyx_t_5 = 0;

  /* "validator.pyx":2332
 *         lambda dtype: dtype == 'object' or dtype.name == 'category' or dtype == 'bool'))
 * 
 *     return has_numerical and has_categorical             # <<<<<<<<<<<<<<
 * 
 * def is_keras_model(model: Any) -> bool:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_has_numerical); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 2332, __pyx_L1_error)
  if (__pyx_t_4) {
  } else {
    __Pyx_INCREF(__pyx_v_has_numerical);
    __pyx_t_5 = __pyx_v_has_numerical;
    goto __pyx_L4_bool_binop_done;
  }
  __Pyx_INCREF(__pyx_v_has_categorical);
  __pyx_t_5 = __pyx_v_has_categorical;
  __pyx_L4_bool_binop_done:;
  __pyx_r = __pyx_t_5;
  __pyx_t_5 = 0;
  goto __pyx_L0;

  /* "validator.pyx":2276
 *     return y_true, y_pred
 * 
 * def check_mixed_data_types(data ) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Checks if the given data (DataFrame or numpy array) contains both numerical
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("validator.check_mixed_data_types", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_has_numerical);
  __Pyx_XDECREF(__pyx_v_has_categorical);
  __Pyx_XDECREF(__pyx_v_data);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2334
 *     return has_numerical and has_categorical
 * 
 * def is_keras_model(model: Any) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Determine whether the provided object is an instance of a Keras model.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_63is_keras_model(PyObject *__pyx_self, PyObject *__pyx_v_model); /*proto*/
static char __pyx_doc_9validator_62is_keras_model[] = "\n    Determine whether the provided object is an instance of a Keras model.\n\n    Parameters\n    ----------\n    model : Any\n        The object to be checked.\n\n    Returns\n    -------\n    bool\n        True if the object is an instance of `tf.keras.models.Model` or \n        `tf.keras.Sequential`,False otherwise.\n    ";
static PyMethodDef __pyx_mdef_9validator_63is_keras_model = {"is_keras_model", (PyCFunction)__pyx_pw_9validator_63is_keras_model, METH_O, __pyx_doc_9validator_62is_keras_model};
static PyObject *__pyx_pw_9validator_63is_keras_model(PyObject *__pyx_self, PyObject *__pyx_v_model) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("is_keras_model (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_62is_keras_model(__pyx_self, ((PyObject *)__pyx_v_model));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_62is_keras_model(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_model) {
  PyObject *__pyx_v_import_optional_dependency = NULL;
  PyObject *__pyx_v_tf = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("is_keras_model", 0);

  /* "validator.pyx":2349
 *         `tf.keras.Sequential`,False otherwise.
 *     """
 *     from ._dependency import import_optional_dependency             # <<<<<<<<<<<<<<
 *     import_optional_dependency("tensorflow")
 *     import tensorflow as tf
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2349, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_import_optional_dependency);
  __Pyx_GIVEREF(__pyx_n_s_import_optional_dependency);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_import_optional_dependency);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_dependency, __pyx_t_1, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2349, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_import_optional_dependency); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2349, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_t_1);
  __pyx_v_import_optional_dependency = __pyx_t_1;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":2350
 *     """
 *     from ._dependency import import_optional_dependency
 *     import_optional_dependency("tensorflow")             # <<<<<<<<<<<<<<
 *     import tensorflow as tf
 *     return isinstance(model, (tf.keras.models.Model, tf.keras.Sequential))
 */
  __Pyx_INCREF(__pyx_v_import_optional_dependency);
  __pyx_t_1 = __pyx_v_import_optional_dependency; __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_3, __pyx_n_u_tensorflow) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_n_u_tensorflow);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2350, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":2351
 *     from ._dependency import import_optional_dependency
 *     import_optional_dependency("tensorflow")
 *     import tensorflow as tf             # <<<<<<<<<<<<<<
 *     return isinstance(model, (tf.keras.models.Model, tf.keras.Sequential))
 * 
 */
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_tensorflow, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2351, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_v_tf = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "validator.pyx":2352
 *     import_optional_dependency("tensorflow")
 *     import tensorflow as tf
 *     return isinstance(model, (tf.keras.models.Model, tf.keras.Sequential))             # <<<<<<<<<<<<<<
 * 
 * def has_required_attributes(model: Any, attributes: list[str]) -> bool:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_tf, __pyx_n_s_keras); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2352, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_models); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2352, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_Model); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2352, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_tf, __pyx_n_s_keras); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2352, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_Sequential); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2352, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = PyObject_IsInstance(__pyx_v_model, __pyx_t_2); 
  __pyx_t_6 = (__pyx_t_5 != 0);
  if (!__pyx_t_6) {
  } else {
    __pyx_t_4 = __pyx_t_6;
    goto __pyx_L3_bool_binop_done;
  }
  __pyx_t_6 = PyObject_IsInstance(__pyx_v_model, __pyx_t_3); 
  __pyx_t_5 = (__pyx_t_6 != 0);
  __pyx_t_4 = __pyx_t_5;
  __pyx_L3_bool_binop_done:;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2352, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "validator.pyx":2334
 *     return has_numerical and has_categorical
 * 
 * def is_keras_model(model: Any) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Determine whether the provided object is an instance of a Keras model.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("validator.is_keras_model", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_import_optional_dependency);
  __Pyx_XDECREF(__pyx_v_tf);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2354
 *     return isinstance(model, (tf.keras.models.Model, tf.keras.Sequential))
 * 
 * def has_required_attributes(model: Any, attributes: list[str]) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Check if the model has all required Keras-specific attributes.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_65has_required_attributes(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_64has_required_attributes[] = "\n    Check if the model has all required Keras-specific attributes.\n\n    This function is part of the deep validation process to ensure that the\n    model not only inherits from Keras model classes but also implements \n    essential methods.\n\n    Parameters\n    ----------\n    model : Any\n        The model object to inspect.\n    attributes : list of str\n        A list of strings representing the names of the attributes to check for\n        in the model.\n\n    Returns\n    -------\n    bool\n        True if the model contains all specified attributes, False otherwise.\n    ";
static PyMethodDef __pyx_mdef_9validator_65has_required_attributes = {"has_required_attributes", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_65has_required_attributes, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_64has_required_attributes};
static PyObject *__pyx_pw_9validator_65has_required_attributes(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_model = 0;
  PyObject *__pyx_v_attributes = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("has_required_attributes (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_model,&__pyx_n_s_attributes,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_model)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_attributes)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("has_required_attributes", 1, 2, 2, 1); __PYX_ERR(0, 2354, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "has_required_attributes") < 0)) __PYX_ERR(0, 2354, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_model = values[0];
    __pyx_v_attributes = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("has_required_attributes", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2354, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.has_required_attributes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_64has_required_attributes(__pyx_self, __pyx_v_model, __pyx_v_attributes);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9validator_23has_required_attributes_2generator9(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */

/* "validator.pyx":2375
 *         True if the model contains all specified attributes, False otherwise.
 *     """
 *     return all(hasattr(model, attr) for attr in attributes)             # <<<<<<<<<<<<<<
 * 
 * def validate_dates(
 */

static PyObject *__pyx_pf_9validator_23has_required_attributes_genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_9validator___pyx_scope_struct_18_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_18_genexpr *)__pyx_tp_new_9validator___pyx_scope_struct_18_genexpr(__pyx_ptype_9validator___pyx_scope_struct_18_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_18_genexpr *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 2375, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_17_has_required_attributes *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9validator_23has_required_attributes_2generator9, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_has_required_attributes_locals_g, __pyx_n_s_validator); if (unlikely(!gen)) __PYX_ERR(0, 2375, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("validator.has_required_attributes.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9validator_23has_required_attributes_2generator9(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9validator___pyx_scope_struct_18_genexpr *__pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_18_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *(*__pyx_t_3)(PyObject *);
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genexpr", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 2375, __pyx_L1_error)
  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_attributes)) { __Pyx_RaiseClosureNameError("attributes"); __PYX_ERR(0, 2375, __pyx_L1_error) }
  if (likely(PyList_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_attributes)) || PyTuple_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_attributes)) {
    __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_attributes; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
    __pyx_t_3 = NULL;
  } else {
    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_attributes); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2375, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2375, __pyx_L1_error)
  }
  for (;;) {
    if (likely(!__pyx_t_3)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 2375, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2375, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 2375, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2375, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_3(__pyx_t_1);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 2375, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_attr);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_attr, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_model)) { __Pyx_RaiseClosureNameError("model"); __PYX_ERR(0, 2375, __pyx_L1_error) }
    __pyx_t_4 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_model;
    __Pyx_INCREF(__pyx_t_4);
    __pyx_t_5 = __Pyx_HasAttr(__pyx_t_4, __pyx_cur_scope->__pyx_v_attr); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(0, 2375, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_6 = ((!(__pyx_t_5 != 0)) != 0);
    if (__pyx_t_6) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_False);
      __pyx_r = Py_False;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
  }
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_True);
    __pyx_r = Py_True;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    goto __pyx_L0;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  #if !CYTHON_USE_EXC_INFO_STACK
  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
  #endif
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2354
 *     return isinstance(model, (tf.keras.models.Model, tf.keras.Sequential))
 * 
 * def has_required_attributes(model: Any, attributes: list[str]) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Check if the model has all required Keras-specific attributes.
 */

static PyObject *__pyx_pf_9validator_64has_required_attributes(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_model, PyObject *__pyx_v_attributes) {
  struct __pyx_obj_9validator___pyx_scope_struct_17_has_required_attributes *__pyx_cur_scope;
  PyObject *__pyx_gb_9validator_23has_required_attributes_2generator9 = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("has_required_attributes", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_17_has_required_attributes *)__pyx_tp_new_9validator___pyx_scope_struct_17_has_required_attributes(__pyx_ptype_9validator___pyx_scope_struct_17_has_required_attributes, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_17_has_required_attributes *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 2354, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_v_model = __pyx_v_model;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_model);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_model);
  __pyx_cur_scope->__pyx_v_attributes = __pyx_v_attributes;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_attributes);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_attributes);

  /* "validator.pyx":2375
 *         True if the model contains all specified attributes, False otherwise.
 *     """
 *     return all(hasattr(model, attr) for attr in attributes)             # <<<<<<<<<<<<<<
 * 
 * def validate_dates(
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_pf_9validator_23has_required_attributes_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2375, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_Generator_Next(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2375, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "validator.pyx":2354
 *     return isinstance(model, (tf.keras.models.Model, tf.keras.Sequential))
 * 
 * def has_required_attributes(model: Any, attributes: list[str]) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Check if the model has all required Keras-specific attributes.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("validator.has_required_attributes", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_gb_9validator_23has_required_attributes_2generator9);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2377
 *     return all(hasattr(model, attr) for attr in attributes)
 * 
 * def validate_dates(             # <<<<<<<<<<<<<<
 *         start_date, end_date, return_as_date_str=False, date_format="%Y-%m-%d"):
 *     """
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_67validate_dates(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_66validate_dates[] = "\n    Validates and parses start and end years/dates, with options for output formatting.\n\n    This function ensures the validity of provided start and end years or dates, checks\n    if they fall within a reasonable range, and allows the option to return the validated\n    years or dates in a specified string format.\n\n    Parameters\n    ----------\n    start_date : int, float, or str\n        The starting year or date. Can be an integer, float (converted to integer),\n        or string in \"YYYY\" or \"YYYY-MM-DD\" format.\n    end_date : int, float, or str\n        The ending year or date, with the same format options as `start_date`.\n    return_as_date_str : bool, optional\n        If True, returns the start and end dates as strings in the specified format.\n        Default is False, returning years as integers.\n    date_format : str, optional\n        The format string for output dates if `return_as_date_str` is True.\n        Default format is \"%Y-%m-%d\".\n\n    Returns\n    -------\n    tuple\n        A tuple of two elements, either integers (years) or strings (formatted dates),\n        representing the validated start and end years or dates.\n\n    Raises\n    ------\n    ValueError\n        If the input years or dates are invalid, out of the acceptable range,\n        or if the start year/date does not precede the end year/date.\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import validate_dates\n    >>> validate_dates(1999, 2001)\n    (1999, 2001)\n\n    >>> validate_dates(\"1999/01/01\", \"2001/12/31\", return_as_date_str=True)\n    ('1999-01-01', '2001-12-31')\n\n    >>> validate_dates(\"1999\", \"1998\")\n    ValueError: The start date/time must precede the end date/time.\n\n    >>> validate_years(\"1899\", \"2001\")\n    ValueError: Years must be within the valid range: 1900 to [current year].\n\n    Notes\n    -----\n    The function supports flexible input formats for years and dates, including\n    handling both slash ""\"/\" and dash \"-\" separators in date strings. It enforces\n    logical and chronological order between start and end inputs and allows\n    customization of the output format for date strings.\n    ";
static PyMethodDef __pyx_mdef_9validator_67validate_dates = {"validate_dates", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_67validate_dates, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_66validate_dates};
static PyObject *__pyx_pw_9validator_67validate_dates(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_start_date = 0;
  PyObject *__pyx_v_end_date = 0;
  PyObject *__pyx_v_return_as_date_str = 0;
  PyObject *__pyx_v_date_format = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validate_dates (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_start_date,&__pyx_n_s_end_date,&__pyx_n_s_return_as_date_str,&__pyx_n_s_date_format,0};
    PyObject* values[4] = {0,0,0,0};

    /* "validator.pyx":2378
 * 
 * def validate_dates(
 *         start_date, end_date, return_as_date_str=False, date_format="%Y-%m-%d"):             # <<<<<<<<<<<<<<
 *     """
 *     Validates and parses start and end years/dates, with options for output formatting.
 */
    values[2] = ((PyObject *)Py_False);
    values[3] = ((PyObject *)__pyx_kp_u_Y_m_d);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_start_date)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_end_date)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("validate_dates", 0, 2, 4, 1); __PYX_ERR(0, 2377, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_return_as_date_str);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_date_format);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "validate_dates") < 0)) __PYX_ERR(0, 2377, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_start_date = values[0];
    __pyx_v_end_date = values[1];
    __pyx_v_return_as_date_str = values[2];
    __pyx_v_date_format = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("validate_dates", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2377, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.validate_dates", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_66validate_dates(__pyx_self, __pyx_v_start_date, __pyx_v_end_date, __pyx_v_return_as_date_str, __pyx_v_date_format);

  /* "validator.pyx":2377
 *     return all(hasattr(model, attr) for attr in attributes)
 * 
 * def validate_dates(             # <<<<<<<<<<<<<<
 *         start_date, end_date, return_as_date_str=False, date_format="%Y-%m-%d"):
 *     """
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2434
 *     customization of the output format for date strings.
 *     """
 *     def parse_year_input(year_input):             # <<<<<<<<<<<<<<
 *         if isinstance(year_input, (int, float)):
 *             return datetime(int(year_input), 1, 1)
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_14validate_dates_1parse_year_input(PyObject *__pyx_self, PyObject *__pyx_v_year_input); /*proto*/
static PyMethodDef __pyx_mdef_9validator_14validate_dates_1parse_year_input = {"parse_year_input", (PyCFunction)__pyx_pw_9validator_14validate_dates_1parse_year_input, METH_O, 0};
static PyObject *__pyx_pw_9validator_14validate_dates_1parse_year_input(PyObject *__pyx_self, PyObject *__pyx_v_year_input) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("parse_year_input (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_14validate_dates_parse_year_input(__pyx_self, ((PyObject *)__pyx_v_year_input));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_14validate_dates_parse_year_input(PyObject *__pyx_self, PyObject *__pyx_v_year_input) {
  struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates *__pyx_cur_scope;
  struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates *__pyx_outer_scope;
  PyObject *__pyx_v_type_err = NULL;
  PyObject *__pyx_v_value_err = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_t_8;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  PyObject *__pyx_t_15 = NULL;
  PyObject *__pyx_t_16 = NULL;
  PyObject *__pyx_t_17 = NULL;
  PyObject *__pyx_t_18 = NULL;
  Py_ssize_t __pyx_t_19;
  Py_UCS4 __pyx_t_20;
  int __pyx_t_21;
  char const *__pyx_t_22;
  PyObject *__pyx_t_23 = NULL;
  PyObject *__pyx_t_24 = NULL;
  PyObject *__pyx_t_25 = NULL;
  PyObject *__pyx_t_26 = NULL;
  PyObject *__pyx_t_27 = NULL;
  PyObject *__pyx_t_28 = NULL;
  char const *__pyx_t_29;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("parse_year_input", 0);
  __pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates *) __Pyx_CyFunction_GetClosure(__pyx_self);
  __pyx_cur_scope = __pyx_outer_scope;
  __Pyx_INCREF(__pyx_v_year_input);

  /* "validator.pyx":2435
 *     """
 *     def parse_year_input(year_input):
 *         if isinstance(year_input, (int, float)):             # <<<<<<<<<<<<<<
 *             return datetime(int(year_input), 1, 1)
 *         elif isinstance(year_input, str):
 */
  __pyx_t_2 = PyInt_Check(__pyx_v_year_input); 
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (!__pyx_t_3) {
  } else {
    __pyx_t_1 = __pyx_t_3;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_3 = PyFloat_Check(__pyx_v_year_input); 
  __pyx_t_2 = (__pyx_t_3 != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L4_bool_binop_done:;
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "validator.pyx":2436
 *     def parse_year_input(year_input):
 *         if isinstance(year_input, (int, float)):
 *             return datetime(int(year_input), 1, 1)             # <<<<<<<<<<<<<<
 *         elif isinstance(year_input, str):
 *             year_input = year_input.replace("/", "-")
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_datetime); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2436, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = __Pyx_PyNumber_Int(__pyx_v_year_input); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2436, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_7 = NULL;
    __pyx_t_8 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
        __pyx_t_8 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_5)) {
      PyObject *__pyx_temp[4] = {__pyx_t_7, __pyx_t_6, __pyx_int_1, __pyx_int_1};
      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 3+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2436, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
      PyObject *__pyx_temp[4] = {__pyx_t_7, __pyx_t_6, __pyx_int_1, __pyx_int_1};
      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 3+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2436, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    } else
    #endif
    {
      __pyx_t_9 = PyTuple_New(3+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 2436, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      if (__pyx_t_7) {
        __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_7); __pyx_t_7 = NULL;
      }
      __Pyx_GIVEREF(__pyx_t_6);
      PyTuple_SET_ITEM(__pyx_t_9, 0+__pyx_t_8, __pyx_t_6);
      __Pyx_INCREF(__pyx_int_1);
      __Pyx_GIVEREF(__pyx_int_1);
      PyTuple_SET_ITEM(__pyx_t_9, 1+__pyx_t_8, __pyx_int_1);
      __Pyx_INCREF(__pyx_int_1);
      __Pyx_GIVEREF(__pyx_int_1);
      PyTuple_SET_ITEM(__pyx_t_9, 2+__pyx_t_8, __pyx_int_1);
      __pyx_t_6 = 0;
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_9, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2436, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    }
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "validator.pyx":2435
 *     """
 *     def parse_year_input(year_input):
 *         if isinstance(year_input, (int, float)):             # <<<<<<<<<<<<<<
 *             return datetime(int(year_input), 1, 1)
 *         elif isinstance(year_input, str):
 */
  }

  /* "validator.pyx":2437
 *         if isinstance(year_input, (int, float)):
 *             return datetime(int(year_input), 1, 1)
 *         elif isinstance(year_input, str):             # <<<<<<<<<<<<<<
 *             year_input = year_input.replace("/", "-")
 *             try:
 */
  __pyx_t_2 = PyUnicode_Check(__pyx_v_year_input); 
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "validator.pyx":2438
 *             return datetime(int(year_input), 1, 1)
 *         elif isinstance(year_input, str):
 *             year_input = year_input.replace("/", "-")             # <<<<<<<<<<<<<<
 *             try:
 *                 return  datetime.strptime(year_input, date_format)
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_year_input, __pyx_n_s_replace); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2438, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__65, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2438, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF_SET(__pyx_v_year_input, __pyx_t_5);
    __pyx_t_5 = 0;

    /* "validator.pyx":2439
 *         elif isinstance(year_input, str):
 *             year_input = year_input.replace("/", "-")
 *             try:             # <<<<<<<<<<<<<<
 *                 return  datetime.strptime(year_input, date_format)
 *             except ValueError:
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12);
      __Pyx_XGOTREF(__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_11);
      __Pyx_XGOTREF(__pyx_t_12);
      /*try:*/ {

        /* "validator.pyx":2440
 *             year_input = year_input.replace("/", "-")
 *             try:
 *                 return  datetime.strptime(year_input, date_format)             # <<<<<<<<<<<<<<
 *             except ValueError:
 *                 try:
 */
        __Pyx_XDECREF(__pyx_r);
        __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_datetime); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2440, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_4);
        __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_strptime); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 2440, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_cur_scope->__pyx_v_date_format)) { __Pyx_RaiseClosureNameError("date_format"); __PYX_ERR(0, 2440, __pyx_L6_error) }
        __pyx_t_4 = NULL;
        __pyx_t_8 = 0;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_9))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_9);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_9, function);
            __pyx_t_8 = 1;
          }
        }
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_9)) {
          PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_year_input, __pyx_cur_scope->__pyx_v_date_format};
          __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_9, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2440, __pyx_L6_error)
          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
          __Pyx_GOTREF(__pyx_t_5);
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_9)) {
          PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_year_input, __pyx_cur_scope->__pyx_v_date_format};
          __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_9, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2440, __pyx_L6_error)
          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
          __Pyx_GOTREF(__pyx_t_5);
        } else
        #endif
        {
          __pyx_t_6 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2440, __pyx_L6_error)
          __Pyx_GOTREF(__pyx_t_6);
          if (__pyx_t_4) {
            __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
          }
          __Pyx_INCREF(__pyx_v_year_input);
          __Pyx_GIVEREF(__pyx_v_year_input);
          PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_8, __pyx_v_year_input);
          __Pyx_INCREF(__pyx_cur_scope->__pyx_v_date_format);
          __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_date_format);
          PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_8, __pyx_cur_scope->__pyx_v_date_format);
          __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_9, __pyx_t_6, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2440, __pyx_L6_error)
          __Pyx_GOTREF(__pyx_t_5);
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        }
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        __pyx_r = __pyx_t_5;
        __pyx_t_5 = 0;
        goto __pyx_L10_try_return;

        /* "validator.pyx":2439
 *         elif isinstance(year_input, str):
 *             year_input = year_input.replace("/", "-")
 *             try:             # <<<<<<<<<<<<<<
 *                 return  datetime.strptime(year_input, date_format)
 *             except ValueError:
 */
      }
      __pyx_L6_error:;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;

      /* "validator.pyx":2441
 *             try:
 *                 return  datetime.strptime(year_input, date_format)
 *             except ValueError:             # <<<<<<<<<<<<<<
 *                 try:
 *                     # Fallback to parsing as year only
 */
      __pyx_t_8 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_ValueError);
      if (__pyx_t_8) {
        __Pyx_AddTraceback("validator.validate_dates.parse_year_input", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_9, &__pyx_t_6) < 0) __PYX_ERR(0, 2441, __pyx_L8_except_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_GOTREF(__pyx_t_6);

        /* "validator.pyx":2442
 *                 return  datetime.strptime(year_input, date_format)
 *             except ValueError:
 *                 try:             # <<<<<<<<<<<<<<
 *                     # Fallback to parsing as year only
 *                     return datetime(int(year_input), 1, 1)
 */
        {
          __Pyx_PyThreadState_declare
          __Pyx_PyThreadState_assign
          __Pyx_ExceptionSave(&__pyx_t_13, &__pyx_t_14, &__pyx_t_15);
          __Pyx_XGOTREF(__pyx_t_13);
          __Pyx_XGOTREF(__pyx_t_14);
          __Pyx_XGOTREF(__pyx_t_15);
          /*try:*/ {

            /* "validator.pyx":2444
 *                 try:
 *                     # Fallback to parsing as year only
 *                     return datetime(int(year_input), 1, 1)             # <<<<<<<<<<<<<<
 *                 except TypeError as type_err:
 *                     raise TypeError (
 */
            __Pyx_XDECREF(__pyx_r);
            __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_datetime); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2444, __pyx_L14_error)
            __Pyx_GOTREF(__pyx_t_7);
            __pyx_t_16 = __Pyx_PyNumber_Int(__pyx_v_year_input); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 2444, __pyx_L14_error)
            __Pyx_GOTREF(__pyx_t_16);
            __pyx_t_17 = NULL;
            __pyx_t_8 = 0;
            if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
              __pyx_t_17 = PyMethod_GET_SELF(__pyx_t_7);
              if (likely(__pyx_t_17)) {
                PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
                __Pyx_INCREF(__pyx_t_17);
                __Pyx_INCREF(function);
                __Pyx_DECREF_SET(__pyx_t_7, function);
                __pyx_t_8 = 1;
              }
            }
            #if CYTHON_FAST_PYCALL
            if (PyFunction_Check(__pyx_t_7)) {
              PyObject *__pyx_temp[4] = {__pyx_t_17, __pyx_t_16, __pyx_int_1, __pyx_int_1};
              __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_8, 3+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2444, __pyx_L14_error)
              __Pyx_XDECREF(__pyx_t_17); __pyx_t_17 = 0;
              __Pyx_GOTREF(__pyx_t_4);
              __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
            } else
            #endif
            #if CYTHON_FAST_PYCCALL
            if (__Pyx_PyFastCFunction_Check(__pyx_t_7)) {
              PyObject *__pyx_temp[4] = {__pyx_t_17, __pyx_t_16, __pyx_int_1, __pyx_int_1};
              __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_8, 3+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2444, __pyx_L14_error)
              __Pyx_XDECREF(__pyx_t_17); __pyx_t_17 = 0;
              __Pyx_GOTREF(__pyx_t_4);
              __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
            } else
            #endif
            {
              __pyx_t_18 = PyTuple_New(3+__pyx_t_8); if (unlikely(!__pyx_t_18)) __PYX_ERR(0, 2444, __pyx_L14_error)
              __Pyx_GOTREF(__pyx_t_18);
              if (__pyx_t_17) {
                __Pyx_GIVEREF(__pyx_t_17); PyTuple_SET_ITEM(__pyx_t_18, 0, __pyx_t_17); __pyx_t_17 = NULL;
              }
              __Pyx_GIVEREF(__pyx_t_16);
              PyTuple_SET_ITEM(__pyx_t_18, 0+__pyx_t_8, __pyx_t_16);
              __Pyx_INCREF(__pyx_int_1);
              __Pyx_GIVEREF(__pyx_int_1);
              PyTuple_SET_ITEM(__pyx_t_18, 1+__pyx_t_8, __pyx_int_1);
              __Pyx_INCREF(__pyx_int_1);
              __Pyx_GIVEREF(__pyx_int_1);
              PyTuple_SET_ITEM(__pyx_t_18, 2+__pyx_t_8, __pyx_int_1);
              __pyx_t_16 = 0;
              __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_18, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2444, __pyx_L14_error)
              __Pyx_GOTREF(__pyx_t_4);
              __Pyx_DECREF(__pyx_t_18); __pyx_t_18 = 0;
            }
            __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
            __pyx_r = __pyx_t_4;
            __pyx_t_4 = 0;
            __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
            __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
            __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
            goto __pyx_L18_try_return;

            /* "validator.pyx":2442
 *                 return  datetime.strptime(year_input, date_format)
 *             except ValueError:
 *                 try:             # <<<<<<<<<<<<<<
 *                     # Fallback to parsing as year only
 *                     return datetime(int(year_input), 1, 1)
 */
          }
          __pyx_L14_error:;
          __Pyx_XDECREF(__pyx_t_16); __pyx_t_16 = 0;
          __Pyx_XDECREF(__pyx_t_17); __pyx_t_17 = 0;
          __Pyx_XDECREF(__pyx_t_18); __pyx_t_18 = 0;
          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
          __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;

          /* "validator.pyx":2445
 *                     # Fallback to parsing as year only
 *                     return datetime(int(year_input), 1, 1)
 *                 except TypeError as type_err:             # <<<<<<<<<<<<<<
 *                     raise TypeError (
 *                         "Expected int, float, or str for"
 */
          __pyx_t_8 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_TypeError);
          if (__pyx_t_8) {
            __Pyx_AddTraceback("validator.validate_dates.parse_year_input", __pyx_clineno, __pyx_lineno, __pyx_filename);
            if (__Pyx_GetException(&__pyx_t_4, &__pyx_t_7, &__pyx_t_18) < 0) __PYX_ERR(0, 2445, __pyx_L16_except_error)
            __Pyx_GOTREF(__pyx_t_4);
            __Pyx_GOTREF(__pyx_t_7);
            __Pyx_GOTREF(__pyx_t_18);
            __Pyx_INCREF(__pyx_t_7);
            __pyx_v_type_err = __pyx_t_7;
            /*try:*/ {

              /* "validator.pyx":2447
 *                 except TypeError as type_err:
 *                     raise TypeError (
 *                         "Expected int, float, or str for"             # <<<<<<<<<<<<<<
 *                         f" year, got {type(year_input)}."
 *                         ) from type_err
 */
              __pyx_t_16 = PyTuple_New(3); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 2447, __pyx_L27_error)
              __Pyx_GOTREF(__pyx_t_16);
              __pyx_t_19 = 0;
              __pyx_t_20 = 127;
              __Pyx_INCREF(__pyx_kp_u_Expected_int_float_or_str_for_ye);
              __pyx_t_19 += 42;
              __Pyx_GIVEREF(__pyx_kp_u_Expected_int_float_or_str_for_ye);
              PyTuple_SET_ITEM(__pyx_t_16, 0, __pyx_kp_u_Expected_int_float_or_str_for_ye);

              /* "validator.pyx":2448
 *                     raise TypeError (
 *                         "Expected int, float, or str for"
 *                         f" year, got {type(year_input)}."             # <<<<<<<<<<<<<<
 *                         ) from type_err
 *                 except ValueError as value_err :
 */
              __pyx_t_17 = __Pyx_PyObject_FormatSimple(((PyObject *)Py_TYPE(__pyx_v_year_input)), __pyx_empty_unicode); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 2448, __pyx_L27_error)
              __Pyx_GOTREF(__pyx_t_17);
              __pyx_t_20 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_17) > __pyx_t_20) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_17) : __pyx_t_20;
              __pyx_t_19 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_17);
              __Pyx_GIVEREF(__pyx_t_17);
              PyTuple_SET_ITEM(__pyx_t_16, 1, __pyx_t_17);
              __pyx_t_17 = 0;
              __Pyx_INCREF(__pyx_kp_u__16);
              __pyx_t_19 += 1;
              __Pyx_GIVEREF(__pyx_kp_u__16);
              PyTuple_SET_ITEM(__pyx_t_16, 2, __pyx_kp_u__16);

              /* "validator.pyx":2447
 *                 except TypeError as type_err:
 *                     raise TypeError (
 *                         "Expected int, float, or str for"             # <<<<<<<<<<<<<<
 *                         f" year, got {type(year_input)}."
 *                         ) from type_err
 */
              __pyx_t_17 = __Pyx_PyUnicode_Join(__pyx_t_16, 3, __pyx_t_19, __pyx_t_20); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 2447, __pyx_L27_error)
              __Pyx_GOTREF(__pyx_t_17);
              __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;

              /* "validator.pyx":2446
 *                     return datetime(int(year_input), 1, 1)
 *                 except TypeError as type_err:
 *                     raise TypeError (             # <<<<<<<<<<<<<<
 *                         "Expected int, float, or str for"
 *                         f" year, got {type(year_input)}."
 */
              __pyx_t_16 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_17); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 2446, __pyx_L27_error)
              __Pyx_GOTREF(__pyx_t_16);
              __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;

              /* "validator.pyx":2449
 *                         "Expected int, float, or str for"
 *                         f" year, got {type(year_input)}."
 *                         ) from type_err             # <<<<<<<<<<<<<<
 *                 except ValueError as value_err :
 *                     raise ValueError (
 */
              __Pyx_Raise(__pyx_t_16, 0, 0, __pyx_v_type_err);
              __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
              __PYX_ERR(0, 2446, __pyx_L27_error)
            }

            /* "validator.pyx":2445
 *                     # Fallback to parsing as year only
 *                     return datetime(int(year_input), 1, 1)
 *                 except TypeError as type_err:             # <<<<<<<<<<<<<<
 *                     raise TypeError (
 *                         "Expected int, float, or str for"
 */
            /*finally:*/ {
              __pyx_L27_error:;
              /*exception exit:*/{
                __Pyx_PyThreadState_declare
                __Pyx_PyThreadState_assign
                __pyx_t_23 = 0; __pyx_t_24 = 0; __pyx_t_25 = 0; __pyx_t_26 = 0; __pyx_t_27 = 0; __pyx_t_28 = 0;
                __Pyx_XDECREF(__pyx_t_16); __pyx_t_16 = 0;
                __Pyx_XDECREF(__pyx_t_17); __pyx_t_17 = 0;
                if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_26, &__pyx_t_27, &__pyx_t_28);
                if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_23, &__pyx_t_24, &__pyx_t_25) < 0)) __Pyx_ErrFetch(&__pyx_t_23, &__pyx_t_24, &__pyx_t_25);
                __Pyx_XGOTREF(__pyx_t_23);
                __Pyx_XGOTREF(__pyx_t_24);
                __Pyx_XGOTREF(__pyx_t_25);
                __Pyx_XGOTREF(__pyx_t_26);
                __Pyx_XGOTREF(__pyx_t_27);
                __Pyx_XGOTREF(__pyx_t_28);
                __pyx_t_8 = __pyx_lineno; __pyx_t_21 = __pyx_clineno; __pyx_t_22 = __pyx_filename;
                {
                  __Pyx_DECREF(__pyx_v_type_err);
                  __pyx_v_type_err = NULL;
                }
                if (PY_MAJOR_VERSION >= 3) {
                  __Pyx_XGIVEREF(__pyx_t_26);
                  __Pyx_XGIVEREF(__pyx_t_27);
                  __Pyx_XGIVEREF(__pyx_t_28);
                  __Pyx_ExceptionReset(__pyx_t_26, __pyx_t_27, __pyx_t_28);
                }
                __Pyx_XGIVEREF(__pyx_t_23);
                __Pyx_XGIVEREF(__pyx_t_24);
                __Pyx_XGIVEREF(__pyx_t_25);
                __Pyx_ErrRestore(__pyx_t_23, __pyx_t_24, __pyx_t_25);
                __pyx_t_23 = 0; __pyx_t_24 = 0; __pyx_t_25 = 0; __pyx_t_26 = 0; __pyx_t_27 = 0; __pyx_t_28 = 0;
                __pyx_lineno = __pyx_t_8; __pyx_clineno = __pyx_t_21; __pyx_filename = __pyx_t_22;
                goto __pyx_L16_except_error;
              }
            }
          }

          /* "validator.pyx":2450
 *                         f" year, got {type(year_input)}."
 *                         ) from type_err
 *                 except ValueError as value_err :             # <<<<<<<<<<<<<<
 *                     raise ValueError (
 *                         "Check your date data. For datetime value, set `date_format`"
 */
          __pyx_t_21 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_ValueError);
          if (__pyx_t_21) {
            __Pyx_AddTraceback("validator.validate_dates.parse_year_input", __pyx_clineno, __pyx_lineno, __pyx_filename);
            if (__Pyx_GetException(&__pyx_t_18, &__pyx_t_7, &__pyx_t_4) < 0) __PYX_ERR(0, 2450, __pyx_L16_except_error)
            __Pyx_GOTREF(__pyx_t_18);
            __Pyx_GOTREF(__pyx_t_7);
            __Pyx_GOTREF(__pyx_t_4);
            __Pyx_INCREF(__pyx_t_7);
            __pyx_v_value_err = __pyx_t_7;
            /*try:*/ {

              /* "validator.pyx":2451
 *                         ) from type_err
 *                 except ValueError as value_err :
 *                     raise ValueError (             # <<<<<<<<<<<<<<
 *                         "Check your date data. For datetime value, set `date_format`"
 *                         " to '%Y-%m-%d %H:%M:%S'") from value_err
 */
              __pyx_t_16 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__66, NULL); if (unlikely(!__pyx_t_16)) __PYX_ERR(0, 2451, __pyx_L38_error)
              __Pyx_GOTREF(__pyx_t_16);

              /* "validator.pyx":2453
 *                     raise ValueError (
 *                         "Check your date data. For datetime value, set `date_format`"
 *                         " to '%Y-%m-%d %H:%M:%S'") from value_err             # <<<<<<<<<<<<<<
 *         raise TypeError(f"Invalid input '{year_input}'."
 *                         " Expected format: YYYY or YYYY-MM-DD.")
 */
              __Pyx_Raise(__pyx_t_16, 0, 0, __pyx_v_value_err);
              __Pyx_DECREF(__pyx_t_16); __pyx_t_16 = 0;
              __PYX_ERR(0, 2451, __pyx_L38_error)
            }

            /* "validator.pyx":2450
 *                         f" year, got {type(year_input)}."
 *                         ) from type_err
 *                 except ValueError as value_err :             # <<<<<<<<<<<<<<
 *                     raise ValueError (
 *                         "Check your date data. For datetime value, set `date_format`"
 */
            /*finally:*/ {
              __pyx_L38_error:;
              /*exception exit:*/{
                __Pyx_PyThreadState_declare
                __Pyx_PyThreadState_assign
                __pyx_t_28 = 0; __pyx_t_27 = 0; __pyx_t_26 = 0; __pyx_t_25 = 0; __pyx_t_24 = 0; __pyx_t_23 = 0;
                __Pyx_XDECREF(__pyx_t_16); __pyx_t_16 = 0;
                __Pyx_XDECREF(__pyx_t_17); __pyx_t_17 = 0;
                if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_25, &__pyx_t_24, &__pyx_t_23);
                if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_28, &__pyx_t_27, &__pyx_t_26) < 0)) __Pyx_ErrFetch(&__pyx_t_28, &__pyx_t_27, &__pyx_t_26);
                __Pyx_XGOTREF(__pyx_t_28);
                __Pyx_XGOTREF(__pyx_t_27);
                __Pyx_XGOTREF(__pyx_t_26);
                __Pyx_XGOTREF(__pyx_t_25);
                __Pyx_XGOTREF(__pyx_t_24);
                __Pyx_XGOTREF(__pyx_t_23);
                __pyx_t_21 = __pyx_lineno; __pyx_t_8 = __pyx_clineno; __pyx_t_29 = __pyx_filename;
                {
                  __Pyx_DECREF(__pyx_v_value_err);
                  __pyx_v_value_err = NULL;
                }
                if (PY_MAJOR_VERSION >= 3) {
                  __Pyx_XGIVEREF(__pyx_t_25);
                  __Pyx_XGIVEREF(__pyx_t_24);
                  __Pyx_XGIVEREF(__pyx_t_23);
                  __Pyx_ExceptionReset(__pyx_t_25, __pyx_t_24, __pyx_t_23);
                }
                __Pyx_XGIVEREF(__pyx_t_28);
                __Pyx_XGIVEREF(__pyx_t_27);
                __Pyx_XGIVEREF(__pyx_t_26);
                __Pyx_ErrRestore(__pyx_t_28, __pyx_t_27, __pyx_t_26);
                __pyx_t_28 = 0; __pyx_t_27 = 0; __pyx_t_26 = 0; __pyx_t_25 = 0; __pyx_t_24 = 0; __pyx_t_23 = 0;
                __pyx_lineno = __pyx_t_21; __pyx_clineno = __pyx_t_8; __pyx_filename = __pyx_t_29;
                goto __pyx_L16_except_error;
              }
            }
          }
          goto __pyx_L16_except_error;
          __pyx_L16_except_error:;

          /* "validator.pyx":2442
 *                 return  datetime.strptime(year_input, date_format)
 *             except ValueError:
 *                 try:             # <<<<<<<<<<<<<<
 *                     # Fallback to parsing as year only
 *                     return datetime(int(year_input), 1, 1)
 */
          __Pyx_XGIVEREF(__pyx_t_13);
          __Pyx_XGIVEREF(__pyx_t_14);
          __Pyx_XGIVEREF(__pyx_t_15);
          __Pyx_ExceptionReset(__pyx_t_13, __pyx_t_14, __pyx_t_15);
          goto __pyx_L8_except_error;
          __pyx_L18_try_return:;
          __Pyx_XGIVEREF(__pyx_t_13);
          __Pyx_XGIVEREF(__pyx_t_14);
          __Pyx_XGIVEREF(__pyx_t_15);
          __Pyx_ExceptionReset(__pyx_t_13, __pyx_t_14, __pyx_t_15);
          goto __pyx_L9_except_return;
        }
      }
      goto __pyx_L8_except_error;
      __pyx_L8_except_error:;

      /* "validator.pyx":2439
 *         elif isinstance(year_input, str):
 *             year_input = year_input.replace("/", "-")
 *             try:             # <<<<<<<<<<<<<<
 *                 return  datetime.strptime(year_input, date_format)
 *             except ValueError:
 */
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_11);
      __Pyx_XGIVEREF(__pyx_t_12);
      __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_11, __pyx_t_12);
      goto __pyx_L1_error;
      __pyx_L10_try_return:;
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_11);
      __Pyx_XGIVEREF(__pyx_t_12);
      __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_11, __pyx_t_12);
      goto __pyx_L0;
      __pyx_L9_except_return:;
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_11);
      __Pyx_XGIVEREF(__pyx_t_12);
      __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_11, __pyx_t_12);
      goto __pyx_L0;
    }

    /* "validator.pyx":2437
 *         if isinstance(year_input, (int, float)):
 *             return datetime(int(year_input), 1, 1)
 *         elif isinstance(year_input, str):             # <<<<<<<<<<<<<<
 *             year_input = year_input.replace("/", "-")
 *             try:
 */
  }

  /* "validator.pyx":2454
 *                         "Check your date data. For datetime value, set `date_format`"
 *                         " to '%Y-%m-%d %H:%M:%S'") from value_err
 *         raise TypeError(f"Invalid input '{year_input}'."             # <<<<<<<<<<<<<<
 *                         " Expected format: YYYY or YYYY-MM-DD.")
 * 
 */
  __pyx_t_6 = PyTuple_New(3); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2454, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_19 = 0;
  __pyx_t_20 = 127;
  __Pyx_INCREF(__pyx_kp_u_Invalid_input);
  __pyx_t_19 += 15;
  __Pyx_GIVEREF(__pyx_kp_u_Invalid_input);
  PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_kp_u_Invalid_input);
  __pyx_t_9 = __Pyx_PyObject_FormatSimple(__pyx_v_year_input, __pyx_empty_unicode); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 2454, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_9);
  __pyx_t_20 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_9) > __pyx_t_20) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_9) : __pyx_t_20;
  __pyx_t_19 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_9);
  __Pyx_GIVEREF(__pyx_t_9);
  PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_9);
  __pyx_t_9 = 0;
  __Pyx_INCREF(__pyx_kp_u_Expected_format_YYYY_or_YYYY_MM);
  __pyx_t_19 += 39;
  __Pyx_GIVEREF(__pyx_kp_u_Expected_format_YYYY_or_YYYY_MM);
  PyTuple_SET_ITEM(__pyx_t_6, 2, __pyx_kp_u_Expected_format_YYYY_or_YYYY_MM);
  __pyx_t_9 = __Pyx_PyUnicode_Join(__pyx_t_6, 3, __pyx_t_19, __pyx_t_20); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 2454, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_9);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_9); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2454, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
  __Pyx_Raise(__pyx_t_6, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __PYX_ERR(0, 2454, __pyx_L1_error)

  /* "validator.pyx":2434
 *     customization of the output format for date strings.
 *     """
 *     def parse_year_input(year_input):             # <<<<<<<<<<<<<<
 *         if isinstance(year_input, (int, float)):
 *             return datetime(int(year_input), 1, 1)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_XDECREF(__pyx_t_16);
  __Pyx_XDECREF(__pyx_t_17);
  __Pyx_XDECREF(__pyx_t_18);
  __Pyx_AddTraceback("validator.validate_dates.parse_year_input", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_type_err);
  __Pyx_XDECREF(__pyx_v_value_err);
  __Pyx_XDECREF(__pyx_v_year_input);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2377
 *     return all(hasattr(model, attr) for attr in attributes)
 * 
 * def validate_dates(             # <<<<<<<<<<<<<<
 *         start_date, end_date, return_as_date_str=False, date_format="%Y-%m-%d"):
 *     """
 */

static PyObject *__pyx_pf_9validator_66validate_dates(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_start_date, PyObject *__pyx_v_end_date, PyObject *__pyx_v_return_as_date_str, PyObject *__pyx_v_date_format) {
  struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates *__pyx_cur_scope;
  PyObject *__pyx_v_parse_year_input = 0;
  PyObject *__pyx_v_current_year = NULL;
  PyObject *__pyx_v_year = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *(*__pyx_t_5)(PyObject *);
  int __pyx_t_6;
  Py_ssize_t __pyx_t_7;
  int __pyx_t_8;
  Py_ssize_t __pyx_t_9;
  Py_UCS4 __pyx_t_10;
  int __pyx_t_11;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validate_dates", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates *)__pyx_tp_new_9validator___pyx_scope_struct_19_validate_dates(__pyx_ptype_9validator___pyx_scope_struct_19_validate_dates, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 2377, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_v_date_format = __pyx_v_date_format;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_date_format);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_date_format);
  __Pyx_INCREF(__pyx_v_start_date);
  __Pyx_INCREF(__pyx_v_end_date);

  /* "validator.pyx":2434
 *     customization of the output format for date strings.
 *     """
 *     def parse_year_input(year_input):             # <<<<<<<<<<<<<<
 *         if isinstance(year_input, (int, float)):
 *             return datetime(int(year_input), 1, 1)
 */
  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_9validator_14validate_dates_1parse_year_input, 0, __pyx_n_s_validate_dates_locals_parse_year, ((PyObject*)__pyx_cur_scope), __pyx_n_s_validator, __pyx_d, ((PyObject *)__pyx_codeobj__68)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2434, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_parse_year_input = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":2457
 *                         " Expected format: YYYY or YYYY-MM-DD.")
 * 
 *     start_date, end_date = map(parse_year_input, [start_date, end_date])             # <<<<<<<<<<<<<<
 * 
 *     if start_date >= end_date:
 */
  __pyx_t_1 = PyList_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2457, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_v_start_date);
  __Pyx_GIVEREF(__pyx_v_start_date);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_v_start_date);
  __Pyx_INCREF(__pyx_v_end_date);
  __Pyx_GIVEREF(__pyx_v_end_date);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_v_end_date);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2457, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_parse_year_input);
  __Pyx_GIVEREF(__pyx_v_parse_year_input);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_parse_year_input);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_map, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2457, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
    PyObject* sequence = __pyx_t_1;
    Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
    if (unlikely(size != 2)) {
      if (size > 2) __Pyx_RaiseTooManyValuesError(2);
      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
      __PYX_ERR(0, 2457, __pyx_L1_error)
    }
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    if (likely(PyTuple_CheckExact(sequence))) {
      __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 1); 
    } else {
      __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
      __pyx_t_3 = PyList_GET_ITEM(sequence, 1); 
    }
    __Pyx_INCREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_t_3);
    #else
    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2457, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2457, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    #endif
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  } else {
    Py_ssize_t index = -1;
    __pyx_t_4 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2457, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_5 = Py_TYPE(__pyx_t_4)->tp_iternext;
    index = 0; __pyx_t_2 = __pyx_t_5(__pyx_t_4); if (unlikely(!__pyx_t_2)) goto __pyx_L3_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_2);
    index = 1; __pyx_t_3 = __pyx_t_5(__pyx_t_4); if (unlikely(!__pyx_t_3)) goto __pyx_L3_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_3);
    if (__Pyx_IternextUnpackEndCheck(__pyx_t_5(__pyx_t_4), 2) < 0) __PYX_ERR(0, 2457, __pyx_L1_error)
    __pyx_t_5 = NULL;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    goto __pyx_L4_unpacking_done;
    __pyx_L3_unpacking_failed:;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_5 = NULL;
    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
    __PYX_ERR(0, 2457, __pyx_L1_error)
    __pyx_L4_unpacking_done:;
  }
  __Pyx_DECREF_SET(__pyx_v_start_date, __pyx_t_2);
  __pyx_t_2 = 0;
  __Pyx_DECREF_SET(__pyx_v_end_date, __pyx_t_3);
  __pyx_t_3 = 0;

  /* "validator.pyx":2459
 *     start_date, end_date = map(parse_year_input, [start_date, end_date])
 * 
 *     if start_date >= end_date:             # <<<<<<<<<<<<<<
 *         raise ValueError("Start date/time must be earlier than end date/time.")
 * 
 */
  __pyx_t_1 = PyObject_RichCompare(__pyx_v_start_date, __pyx_v_end_date, Py_GE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2459, __pyx_L1_error)
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 2459, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (unlikely(__pyx_t_6)) {

    /* "validator.pyx":2460
 * 
 *     if start_date >= end_date:
 *         raise ValueError("Start date/time must be earlier than end date/time.")             # <<<<<<<<<<<<<<
 * 
 *     if return_as_date_str:
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__69, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2460, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 2460, __pyx_L1_error)

    /* "validator.pyx":2459
 *     start_date, end_date = map(parse_year_input, [start_date, end_date])
 * 
 *     if start_date >= end_date:             # <<<<<<<<<<<<<<
 *         raise ValueError("Start date/time must be earlier than end date/time.")
 * 
 */
  }

  /* "validator.pyx":2462
 *         raise ValueError("Start date/time must be earlier than end date/time.")
 * 
 *     if return_as_date_str:             # <<<<<<<<<<<<<<
 *         return start_date.strftime(date_format), end_date.strftime(date_format)
 * 
 */
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_return_as_date_str); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 2462, __pyx_L1_error)
  if (__pyx_t_6) {

    /* "validator.pyx":2463
 * 
 *     if return_as_date_str:
 *         return start_date.strftime(date_format), end_date.strftime(date_format)             # <<<<<<<<<<<<<<
 * 
 *     current_year = datetime.now().year
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_start_date, __pyx_n_s_strftime); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2463, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_2 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_2)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_2);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_cur_scope->__pyx_v_date_format) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_cur_scope->__pyx_v_date_format);
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2463, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_end_date, __pyx_n_s_strftime); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2463, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_cur_scope->__pyx_v_date_format) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_cur_scope->__pyx_v_date_format);
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2463, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2463, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_GIVEREF(__pyx_t_1);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_3);
    __pyx_t_1 = 0;
    __pyx_t_3 = 0;
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;

    /* "validator.pyx":2462
 *         raise ValueError("Start date/time must be earlier than end date/time.")
 * 
 *     if return_as_date_str:             # <<<<<<<<<<<<<<
 *         return start_date.strftime(date_format), end_date.strftime(date_format)
 * 
 */
  }

  /* "validator.pyx":2465
 *         return start_date.strftime(date_format), end_date.strftime(date_format)
 * 
 *     current_year = datetime.now().year             # <<<<<<<<<<<<<<
 *     for year in (start_date.year, end_date.year):
 *         if not 1900 <= year <= current_year:
 */
  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_datetime); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2465, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_now); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2465, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2465, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_year); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2465, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_current_year = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":2466
 * 
 *     current_year = datetime.now().year
 *     for year in (start_date.year, end_date.year):             # <<<<<<<<<<<<<<
 *         if not 1900 <= year <= current_year:
 *             raise ValueError(f"Year {year} is out of the valid"
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_start_date, __pyx_n_s_year); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2466, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_end_date, __pyx_n_s_year); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2466, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2466, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
  __pyx_t_1 = 0;
  __pyx_t_2 = 0;
  __pyx_t_2 = __pyx_t_3; __Pyx_INCREF(__pyx_t_2); __pyx_t_7 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  for (;;) {
    if (__pyx_t_7 >= 2) break;
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_7); __Pyx_INCREF(__pyx_t_3); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 2466, __pyx_L1_error)
    #else
    __pyx_t_3 = PySequence_ITEM(__pyx_t_2, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2466, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    #endif
    __Pyx_XDECREF_SET(__pyx_v_year, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "validator.pyx":2467
 *     current_year = datetime.now().year
 *     for year in (start_date.year, end_date.year):
 *         if not 1900 <= year <= current_year:             # <<<<<<<<<<<<<<
 *             raise ValueError(f"Year {year} is out of the valid"
 *                              f" range: 1900 to {current_year}.")
 */
    __pyx_t_3 = PyObject_RichCompare(__pyx_int_1900, __pyx_v_year, Py_LE); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2467, __pyx_L1_error)
    if (__Pyx_PyObject_IsTrue(__pyx_t_3)) {
      __Pyx_DECREF(__pyx_t_3);
      __pyx_t_3 = PyObject_RichCompare(__pyx_v_year, __pyx_v_current_year, Py_LE); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2467, __pyx_L1_error)
    }
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 2467, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_8 = ((!__pyx_t_6) != 0);
    if (unlikely(__pyx_t_8)) {

      /* "validator.pyx":2468
 *     for year in (start_date.year, end_date.year):
 *         if not 1900 <= year <= current_year:
 *             raise ValueError(f"Year {year} is out of the valid"             # <<<<<<<<<<<<<<
 *                              f" range: 1900 to {current_year}.")
 * 
 */
      __pyx_t_3 = PyTuple_New(5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2468, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_9 = 0;
      __pyx_t_10 = 127;
      __Pyx_INCREF(__pyx_kp_u_Year);
      __pyx_t_9 += 5;
      __Pyx_GIVEREF(__pyx_kp_u_Year);
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_kp_u_Year);
      __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_year, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2468, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_10 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) > __pyx_t_10) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) : __pyx_t_10;
      __pyx_t_9 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_1);
      __Pyx_GIVEREF(__pyx_t_1);
      PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
      __pyx_t_1 = 0;
      __Pyx_INCREF(__pyx_kp_u_is_out_of_the_valid_range_1900);
      __pyx_t_9 += 36;
      __Pyx_GIVEREF(__pyx_kp_u_is_out_of_the_valid_range_1900);
      PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_kp_u_is_out_of_the_valid_range_1900);

      /* "validator.pyx":2469
 *         if not 1900 <= year <= current_year:
 *             raise ValueError(f"Year {year} is out of the valid"
 *                              f" range: 1900 to {current_year}.")             # <<<<<<<<<<<<<<
 * 
 *     # Additional validation for non-string return format
 */
      __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_current_year, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2469, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_10 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) > __pyx_t_10) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) : __pyx_t_10;
      __pyx_t_9 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_1);
      __Pyx_GIVEREF(__pyx_t_1);
      PyTuple_SET_ITEM(__pyx_t_3, 3, __pyx_t_1);
      __pyx_t_1 = 0;
      __Pyx_INCREF(__pyx_kp_u__16);
      __pyx_t_9 += 1;
      __Pyx_GIVEREF(__pyx_kp_u__16);
      PyTuple_SET_ITEM(__pyx_t_3, 4, __pyx_kp_u__16);

      /* "validator.pyx":2468
 *     for year in (start_date.year, end_date.year):
 *         if not 1900 <= year <= current_year:
 *             raise ValueError(f"Year {year} is out of the valid"             # <<<<<<<<<<<<<<
 *                              f" range: 1900 to {current_year}.")
 * 
 */
      __pyx_t_1 = __Pyx_PyUnicode_Join(__pyx_t_3, 5, __pyx_t_9, __pyx_t_10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2468, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2468, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __PYX_ERR(0, 2468, __pyx_L1_error)

      /* "validator.pyx":2467
 *     current_year = datetime.now().year
 *     for year in (start_date.year, end_date.year):
 *         if not 1900 <= year <= current_year:             # <<<<<<<<<<<<<<
 *             raise ValueError(f"Year {year} is out of the valid"
 *                              f" range: 1900 to {current_year}.")
 */
    }

    /* "validator.pyx":2466
 * 
 *     current_year = datetime.now().year
 *     for year in (start_date.year, end_date.year):             # <<<<<<<<<<<<<<
 *         if not 1900 <= year <= current_year:
 *             raise ValueError(f"Year {year} is out of the valid"
 */
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":2473
 *     # Additional validation for non-string return format
 *     if (
 *         start_date.year == end_date.year             # <<<<<<<<<<<<<<
 *         and start_date != end_date
 *         and not return_as_date_str
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_start_date, __pyx_n_s_year); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2473, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_end_date, __pyx_n_s_year); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2473, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_1 = PyObject_RichCompare(__pyx_t_2, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2473, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 2473, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_6) {
  } else {
    __pyx_t_8 = __pyx_t_6;
    goto __pyx_L11_bool_binop_done;
  }

  /* "validator.pyx":2474
 *     if (
 *         start_date.year == end_date.year
 *         and start_date != end_date             # <<<<<<<<<<<<<<
 *         and not return_as_date_str
 *         ):
 */
  __pyx_t_1 = PyObject_RichCompare(__pyx_v_start_date, __pyx_v_end_date, Py_NE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2474, __pyx_L1_error)
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 2474, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_6) {
  } else {
    __pyx_t_8 = __pyx_t_6;
    goto __pyx_L11_bool_binop_done;
  }

  /* "validator.pyx":2475
 *         start_date.year == end_date.year
 *         and start_date != end_date
 *         and not return_as_date_str             # <<<<<<<<<<<<<<
 *         ):
 *         raise ValueError(
 */
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_return_as_date_str); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 2475, __pyx_L1_error)
  __pyx_t_11 = ((!__pyx_t_6) != 0);
  __pyx_t_8 = __pyx_t_11;
  __pyx_L11_bool_binop_done:;

  /* "validator.pyx":2472
 * 
 *     # Additional validation for non-string return format
 *     if (             # <<<<<<<<<<<<<<
 *         start_date.year == end_date.year
 *         and start_date != end_date
 */
  if (unlikely(__pyx_t_8)) {

    /* "validator.pyx":2477
 *         and not return_as_date_str
 *         ):
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             "Start and end dates are within the same year but not the same date. "
 *             "Consider using return_as_date_str=True or providing specific dates.")
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__70, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2477, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 2477, __pyx_L1_error)

    /* "validator.pyx":2472
 * 
 *     # Additional validation for non-string return format
 *     if (             # <<<<<<<<<<<<<<
 *         start_date.year == end_date.year
 *         and start_date != end_date
 */
  }

  /* "validator.pyx":2481
 *             "Consider using return_as_date_str=True or providing specific dates.")
 * 
 *     return start_date.year, end_date.year             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_start_date, __pyx_n_s_year); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2481, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_end_date, __pyx_n_s_year); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2481, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2481, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_3);
  __pyx_t_1 = 0;
  __pyx_t_3 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "validator.pyx":2377
 *     return all(hasattr(model, attr) for attr in attributes)
 * 
 * def validate_dates(             # <<<<<<<<<<<<<<
 *         start_date, end_date, return_as_date_str=False, date_format="%Y-%m-%d"):
 *     """
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("validator.validate_dates", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_parse_year_input);
  __Pyx_XDECREF(__pyx_v_current_year);
  __Pyx_XDECREF(__pyx_v_year);
  __Pyx_XDECREF(__pyx_v_start_date);
  __Pyx_XDECREF(__pyx_v_end_date);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2486
 * 
 * 
 * def validate_positive_integer(value, variable_name, include_zero=False, round_float=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates whether the given value is a positive integer or zero based
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_69validate_positive_integer(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_68validate_positive_integer[] = "\n    Validates whether the given value is a positive integer or zero based \n    on the parameter and rounds float values according to the specified method.\n\n    Parameters:\n    ----------\n    value : int or float\n        The value to validate.\n    variable_name : str\n        The name of the variable for error message purposes.\n    include_zero : bool, optional\n        If True, zero is considered a valid value. Default is False.\n    round_float : str, optional\n        If \"ceil\", rounds up float values; if \"floor\", rounds down float values;\n        if None, truncates float values to the nearest whole number towards zero.\n\n    Returns:\n    -------\n    int\n        The validated value converted to an integer.\n\n    Raises:\n    ------\n    ValueError\n        If the value is not a positive integer or zero (based on `include_zero`),\n        or if the `round_float` parameter is improperly specified.\n    ";
static PyMethodDef __pyx_mdef_9validator_69validate_positive_integer = {"validate_positive_integer", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_69validate_positive_integer, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_68validate_positive_integer};
static PyObject *__pyx_pw_9validator_69validate_positive_integer(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_value = 0;
  PyObject *__pyx_v_variable_name = 0;
  PyObject *__pyx_v_include_zero = 0;
  PyObject *__pyx_v_round_float = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validate_positive_integer (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_value,&__pyx_n_s_variable_name,&__pyx_n_s_include_zero,&__pyx_n_s_round_float,0};
    PyObject* values[4] = {0,0,0,0};
    values[2] = ((PyObject *)Py_False);
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_variable_name)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("validate_positive_integer", 0, 2, 4, 1); __PYX_ERR(0, 2486, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_include_zero);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_round_float);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "validate_positive_integer") < 0)) __PYX_ERR(0, 2486, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_value = values[0];
    __pyx_v_variable_name = values[1];
    __pyx_v_include_zero = values[2];
    __pyx_v_round_float = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("validate_positive_integer", 0, 2, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2486, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.validate_positive_integer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_68validate_positive_integer(__pyx_self, __pyx_v_value, __pyx_v_variable_name, __pyx_v_include_zero, __pyx_v_round_float);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_68validate_positive_integer(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value, PyObject *__pyx_v_variable_name, PyObject *__pyx_v_include_zero, PyObject *__pyx_v_round_float) {
  PyObject *__pyx_v_math = NULL;
  long __pyx_v_min_value;
  PyObject *__pyx_v_condition = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  long __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_t_7;
  Py_ssize_t __pyx_t_8;
  Py_UCS4 __pyx_t_9;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validate_positive_integer", 0);
  __Pyx_INCREF(__pyx_v_value);

  /* "validator.pyx":2514
 *         or if the `round_float` parameter is improperly specified.
 *     """
 *     import math             # <<<<<<<<<<<<<<
 * 
 *     # Determine the minimum acceptable value
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_math, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2514, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_math = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":2517
 * 
 *     # Determine the minimum acceptable value
 *     min_value = 0 if include_zero else 1             # <<<<<<<<<<<<<<
 * 
 *     # Check for proper type and round if necessary
 */
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_include_zero); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 2517, __pyx_L1_error)
  if (__pyx_t_3) {
    __pyx_t_2 = 0;
  } else {
    __pyx_t_2 = 1;
  }
  __pyx_v_min_value = __pyx_t_2;

  /* "validator.pyx":2520
 * 
 *     # Check for proper type and round if necessary
 *     if not isinstance(value, (int, float, np.integer, np.floating)):             # <<<<<<<<<<<<<<
 *         raise ValueError(f"{variable_name} must be an integer or float.")
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2520, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_integer); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2520, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2520, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_floating); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2520, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_6 = PyInt_Check(__pyx_v_value); 
  __pyx_t_7 = (__pyx_t_6 != 0);
  if (!__pyx_t_7) {
  } else {
    __pyx_t_3 = __pyx_t_7;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_7 = PyFloat_Check(__pyx_v_value); 
  __pyx_t_6 = (__pyx_t_7 != 0);
  if (!__pyx_t_6) {
  } else {
    __pyx_t_3 = __pyx_t_6;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_6 = PyObject_IsInstance(__pyx_v_value, __pyx_t_4); 
  __pyx_t_7 = (__pyx_t_6 != 0);
  if (!__pyx_t_7) {
  } else {
    __pyx_t_3 = __pyx_t_7;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_7 = PyObject_IsInstance(__pyx_v_value, __pyx_t_5); 
  __pyx_t_6 = (__pyx_t_7 != 0);
  __pyx_t_3 = __pyx_t_6;
  __pyx_L4_bool_binop_done:;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_6 = ((!(__pyx_t_3 != 0)) != 0);
  if (unlikely(__pyx_t_6)) {

    /* "validator.pyx":2521
 *     # Check for proper type and round if necessary
 *     if not isinstance(value, (int, float, np.integer, np.floating)):
 *         raise ValueError(f"{variable_name} must be an integer or float.")             # <<<<<<<<<<<<<<
 * 
 *     if isinstance(value, float):
 */
    __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_v_variable_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2521, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __Pyx_PyUnicode_Concat(__pyx_t_4, __pyx_kp_u_must_be_an_integer_or_float); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2521, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2521, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 2521, __pyx_L1_error)

    /* "validator.pyx":2520
 * 
 *     # Check for proper type and round if necessary
 *     if not isinstance(value, (int, float, np.integer, np.floating)):             # <<<<<<<<<<<<<<
 *         raise ValueError(f"{variable_name} must be an integer or float.")
 * 
 */
  }

  /* "validator.pyx":2523
 *         raise ValueError(f"{variable_name} must be an integer or float.")
 * 
 *     if isinstance(value, float):             # <<<<<<<<<<<<<<
 *         if round_float == "ceil":
 *             value = math.ceil(value)
 */
  __pyx_t_6 = PyFloat_Check(__pyx_v_value); 
  __pyx_t_3 = (__pyx_t_6 != 0);
  if (__pyx_t_3) {

    /* "validator.pyx":2524
 * 
 *     if isinstance(value, float):
 *         if round_float == "ceil":             # <<<<<<<<<<<<<<
 *             value = math.ceil(value)
 *         elif round_float == "floor":
 */
    __pyx_t_3 = (__Pyx_PyUnicode_Equals(__pyx_v_round_float, __pyx_n_u_ceil, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 2524, __pyx_L1_error)
    if (__pyx_t_3) {

      /* "validator.pyx":2525
 *     if isinstance(value, float):
 *         if round_float == "ceil":
 *             value = math.ceil(value)             # <<<<<<<<<<<<<<
 *         elif round_float == "floor":
 *             value = math.floor(value)
 */
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_math, __pyx_n_s_ceil); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2525, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_1 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
        __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_5);
        if (likely(__pyx_t_1)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
          __Pyx_INCREF(__pyx_t_1);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_5, function);
        }
      }
      __pyx_t_4 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_1, __pyx_v_value) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_value);
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2525, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_DECREF_SET(__pyx_v_value, __pyx_t_4);
      __pyx_t_4 = 0;

      /* "validator.pyx":2524
 * 
 *     if isinstance(value, float):
 *         if round_float == "ceil":             # <<<<<<<<<<<<<<
 *             value = math.ceil(value)
 *         elif round_float == "floor":
 */
      goto __pyx_L9;
    }

    /* "validator.pyx":2526
 *         if round_float == "ceil":
 *             value = math.ceil(value)
 *         elif round_float == "floor":             # <<<<<<<<<<<<<<
 *             value = math.floor(value)
 *         elif round_float is None:
 */
    __pyx_t_3 = (__Pyx_PyUnicode_Equals(__pyx_v_round_float, __pyx_n_u_floor, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 2526, __pyx_L1_error)
    if (__pyx_t_3) {

      /* "validator.pyx":2527
 *             value = math.ceil(value)
 *         elif round_float == "floor":
 *             value = math.floor(value)             # <<<<<<<<<<<<<<
 *         elif round_float is None:
 *             value = int(value)
 */
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_math, __pyx_n_s_floor); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2527, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_1 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
        __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_5);
        if (likely(__pyx_t_1)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
          __Pyx_INCREF(__pyx_t_1);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_5, function);
        }
      }
      __pyx_t_4 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_1, __pyx_v_value) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_value);
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2527, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_DECREF_SET(__pyx_v_value, __pyx_t_4);
      __pyx_t_4 = 0;

      /* "validator.pyx":2526
 *         if round_float == "ceil":
 *             value = math.ceil(value)
 *         elif round_float == "floor":             # <<<<<<<<<<<<<<
 *             value = math.floor(value)
 *         elif round_float is None:
 */
      goto __pyx_L9;
    }

    /* "validator.pyx":2528
 *         elif round_float == "floor":
 *             value = math.floor(value)
 *         elif round_float is None:             # <<<<<<<<<<<<<<
 *             value = int(value)
 *         else:
 */
    __pyx_t_3 = (__pyx_v_round_float == Py_None);
    __pyx_t_6 = (__pyx_t_3 != 0);
    if (likely(__pyx_t_6)) {

      /* "validator.pyx":2529
 *             value = math.floor(value)
 *         elif round_float is None:
 *             value = int(value)             # <<<<<<<<<<<<<<
 *         else:
 *             raise ValueError(f"Invalid rounding method '{round_float}'."
 */
      __pyx_t_4 = __Pyx_PyNumber_Int(__pyx_v_value); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2529, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF_SET(__pyx_v_value, __pyx_t_4);
      __pyx_t_4 = 0;

      /* "validator.pyx":2528
 *         elif round_float == "floor":
 *             value = math.floor(value)
 *         elif round_float is None:             # <<<<<<<<<<<<<<
 *             value = int(value)
 *         else:
 */
      goto __pyx_L9;
    }

    /* "validator.pyx":2531
 *             value = int(value)
 *         else:
 *             raise ValueError(f"Invalid rounding method '{round_float}'."             # <<<<<<<<<<<<<<
 *                              " Choose 'ceil', 'floor', or None.")
 *     # if isinstance(value, float) and not value.is_integer():
 */
    /*else*/ {
      __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2531, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_8 = 0;
      __pyx_t_9 = 127;
      __Pyx_INCREF(__pyx_kp_u_Invalid_rounding_method);
      __pyx_t_8 += 25;
      __Pyx_GIVEREF(__pyx_kp_u_Invalid_rounding_method);
      PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_kp_u_Invalid_rounding_method);
      __pyx_t_5 = __Pyx_PyObject_FormatSimple(__pyx_v_round_float, __pyx_empty_unicode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2531, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_9 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) > __pyx_t_9) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) : __pyx_t_9;
      __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_5);
      __Pyx_GIVEREF(__pyx_t_5);
      PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_5);
      __pyx_t_5 = 0;
      __Pyx_INCREF(__pyx_kp_u_Choose_ceil_floor_or_None);
      __pyx_t_8 += 35;
      __Pyx_GIVEREF(__pyx_kp_u_Choose_ceil_floor_or_None);
      PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_kp_u_Choose_ceil_floor_or_None);
      __pyx_t_5 = __Pyx_PyUnicode_Join(__pyx_t_4, 3, __pyx_t_8, __pyx_t_9); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2531, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2531, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __PYX_ERR(0, 2531, __pyx_L1_error)
    }
    __pyx_L9:;

    /* "validator.pyx":2523
 *         raise ValueError(f"{variable_name} must be an integer or float.")
 * 
 *     if isinstance(value, float):             # <<<<<<<<<<<<<<
 *         if round_float == "ceil":
 *             value = math.ceil(value)
 */
  }

  /* "validator.pyx":2535
 *     # if isinstance(value, float) and not value.is_integer():
 *     #     raise ValueError(f"{variable_name} must be a whole number, got {value}.")
 *     if value < min_value:             # <<<<<<<<<<<<<<
 *         condition = "a non-negative integer" if include_zero else "a positive integer"
 *         raise ValueError(f"{variable_name} must be {condition}, got {value}.")
 */
  __pyx_t_4 = __Pyx_PyInt_From_long(__pyx_v_min_value); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2535, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = PyObject_RichCompare(__pyx_v_value, __pyx_t_4, Py_LT); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2535, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 2535, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  if (unlikely(__pyx_t_6)) {

    /* "validator.pyx":2536
 *     #     raise ValueError(f"{variable_name} must be a whole number, got {value}.")
 *     if value < min_value:
 *         condition = "a non-negative integer" if include_zero else "a positive integer"             # <<<<<<<<<<<<<<
 *         raise ValueError(f"{variable_name} must be {condition}, got {value}.")
 * 
 */
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_include_zero); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 2536, __pyx_L1_error)
    if (__pyx_t_6) {
      __Pyx_INCREF(__pyx_kp_u_a_non_negative_integer);
      __pyx_t_5 = __pyx_kp_u_a_non_negative_integer;
    } else {
      __Pyx_INCREF(__pyx_kp_u_a_positive_integer);
      __pyx_t_5 = __pyx_kp_u_a_positive_integer;
    }
    __pyx_v_condition = ((PyObject*)__pyx_t_5);
    __pyx_t_5 = 0;

    /* "validator.pyx":2537
 *     if value < min_value:
 *         condition = "a non-negative integer" if include_zero else "a positive integer"
 *         raise ValueError(f"{variable_name} must be {condition}, got {value}.")             # <<<<<<<<<<<<<<
 * 
 *     return int(value)
 */
    __pyx_t_5 = PyTuple_New(6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2537, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_8 = 0;
    __pyx_t_9 = 127;
    __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_v_variable_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2537, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_9 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) > __pyx_t_9) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) : __pyx_t_9;
    __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
    __pyx_t_4 = 0;
    __Pyx_INCREF(__pyx_kp_u_must_be);
    __pyx_t_8 += 9;
    __Pyx_GIVEREF(__pyx_kp_u_must_be);
    PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_kp_u_must_be);
    __pyx_t_4 = __Pyx_PyUnicode_Unicode(__pyx_v_condition); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2537, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_9 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) > __pyx_t_9) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) : __pyx_t_9;
    __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_t_4);
    __pyx_t_4 = 0;
    __Pyx_INCREF(__pyx_kp_u_got);
    __pyx_t_8 += 6;
    __Pyx_GIVEREF(__pyx_kp_u_got);
    PyTuple_SET_ITEM(__pyx_t_5, 3, __pyx_kp_u_got);
    __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_v_value, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2537, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_9 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) > __pyx_t_9) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) : __pyx_t_9;
    __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_5, 4, __pyx_t_4);
    __pyx_t_4 = 0;
    __Pyx_INCREF(__pyx_kp_u__16);
    __pyx_t_8 += 1;
    __Pyx_GIVEREF(__pyx_kp_u__16);
    PyTuple_SET_ITEM(__pyx_t_5, 5, __pyx_kp_u__16);
    __pyx_t_4 = __Pyx_PyUnicode_Join(__pyx_t_5, 6, __pyx_t_8, __pyx_t_9); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2537, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2537, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __PYX_ERR(0, 2537, __pyx_L1_error)

    /* "validator.pyx":2535
 *     # if isinstance(value, float) and not value.is_integer():
 *     #     raise ValueError(f"{variable_name} must be a whole number, got {value}.")
 *     if value < min_value:             # <<<<<<<<<<<<<<
 *         condition = "a non-negative integer" if include_zero else "a positive integer"
 *         raise ValueError(f"{variable_name} must be {condition}, got {value}.")
 */
  }

  /* "validator.pyx":2539
 *         raise ValueError(f"{variable_name} must be {condition}, got {value}.")
 * 
 *     return int(value)             # <<<<<<<<<<<<<<
 * 
 * def validate_and_adjust_ranges(**kwargs):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_5 = __Pyx_PyNumber_Int(__pyx_v_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2539, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_r = __pyx_t_5;
  __pyx_t_5 = 0;
  goto __pyx_L0;

  /* "validator.pyx":2486
 * 
 * 
 * def validate_positive_integer(value, variable_name, include_zero=False, round_float=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates whether the given value is a positive integer or zero based
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("validator.validate_positive_integer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_math);
  __Pyx_XDECREF(__pyx_v_condition);
  __Pyx_XDECREF(__pyx_v_value);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2541
 *     return int(value)
 * 
 * def validate_and_adjust_ranges(**kwargs):             # <<<<<<<<<<<<<<
 *     """
 *     Validates and adjusts the provided range tuples to ensure each is
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_71validate_and_adjust_ranges(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_70validate_and_adjust_ranges[] = "\n    Validates and adjusts the provided range tuples to ensure each is\n    composed of two numerical values and is sorted in ascending order.\n\n    This function takes multiple range specifications as keyword arguments,\n    each expected to be a tuple of two numerical values (min, max). It validates\n    the format and contents of each range, adjusting them if necessary to ensure\n    that each tuple is ordered as (min, max).\n\n    Parameters\n    ----------\n    **kwargs : dict\n        Keyword arguments where each key is the name of a range (e.g., 'lat_range')\n        and its corresponding value is a tuple of two numerical values representing\n        the minimum and maximum of that range.\n\n    Returns\n    -------\n    dict\n        A dictionary with the same keys as the input, but with each tuple value\n        adjusted to ensure it is in the format (min, max).\n\n    Raises\n    ------\n    ValueError\n        If any provided range tuple does not contain exactly two values, contains\n        non-numerical values, or if the min value is not less than the max value.\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import validate_and_adjust_ranges\n    >>> validate_and_adjust_ranges(lat_range=(34.00, 36.00), lon_range=(-118.50, -117.00))\n    {'lat_range': (34.00, 36.00), 'lon_range': (-118.50, -117.00)}\n\n    >>> validate_and_adjust_ranges(time_range=(10.0, 0.01))\n    {'time_range': (0.01, 10.0)}\n\n    >>> validate_and_adjust_ranges(invalid_range=(1, 'a'))\n    ValueError: invalid_range must contain numerical values.\n\n    Notes\n    -----\n    This function is particularly useful for preprocessing input ranges for\n    various analyses, ensuring consistency and correctness of range specifications.\n    It automates the adjustment of provided ranges, simplifying the setup process\n    for further data processing or modeling tasks.\n    ";
static PyMethodDef __pyx_mdef_9validator_71validate_and_adjust_ranges = {"validate_and_adjust_ranges", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_71validate_and_adjust_ranges, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_70validate_and_adjust_ranges};
static PyObject *__pyx_pw_9validator_71validate_and_adjust_ranges(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_kwargs = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validate_and_adjust_ranges (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("validate_and_adjust_ranges", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return NULL;}
  if (__pyx_kwds && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "validate_and_adjust_ranges", 1))) return NULL;
  __pyx_v_kwargs = (__pyx_kwds) ? PyDict_Copy(__pyx_kwds) : PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return NULL;
  __Pyx_GOTREF(__pyx_v_kwargs);
  __pyx_r = __pyx_pf_9validator_70validate_and_adjust_ranges(__pyx_self, __pyx_v_kwargs);

  /* function exit code */
  __Pyx_XDECREF(__pyx_v_kwargs);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9validator_26validate_and_adjust_ranges_2generator10(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */

/* "validator.pyx":2595
 *             raise ValueError(f"{range_name} must be a tuple of two values.")
 * 
 *         if not all(isinstance(value, (int, float)) for value in range_tuple):             # <<<<<<<<<<<<<<
 *             raise ValueError(f"{range_name} must contain numerical values.")
 * 
 */

static PyObject *__pyx_pf_9validator_26validate_and_adjust_ranges_genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_9validator___pyx_scope_struct_21_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_21_genexpr *)__pyx_tp_new_9validator___pyx_scope_struct_21_genexpr(__pyx_ptype_9validator___pyx_scope_struct_21_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_21_genexpr *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 2595, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_20_validate_and_adjust_ranges *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9validator_26validate_and_adjust_ranges_2generator10, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_validate_and_adjust_ranges_local, __pyx_n_s_validator); if (unlikely(!gen)) __PYX_ERR(0, 2595, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("validator.validate_and_adjust_ranges.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9validator_26validate_and_adjust_ranges_2generator10(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9validator___pyx_scope_struct_21_genexpr *__pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_21_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *(*__pyx_t_3)(PyObject *);
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_t_7;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genexpr", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 2595, __pyx_L1_error)
  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_range_tuple)) { __Pyx_RaiseClosureNameError("range_tuple"); __PYX_ERR(0, 2595, __pyx_L1_error) }
  if (likely(PyList_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_range_tuple)) || PyTuple_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_range_tuple)) {
    __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_range_tuple; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
    __pyx_t_3 = NULL;
  } else {
    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_range_tuple); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2595, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2595, __pyx_L1_error)
  }
  for (;;) {
    if (likely(!__pyx_t_3)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 2595, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2595, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 2595, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2595, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_3(__pyx_t_1);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 2595, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_value);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_value, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_t_6 = PyInt_Check(__pyx_cur_scope->__pyx_v_value); 
    __pyx_t_7 = (__pyx_t_6 != 0);
    if (!__pyx_t_7) {
    } else {
      __pyx_t_5 = __pyx_t_7;
      goto __pyx_L7_bool_binop_done;
    }
    __pyx_t_7 = PyFloat_Check(__pyx_cur_scope->__pyx_v_value); 
    __pyx_t_6 = (__pyx_t_7 != 0);
    __pyx_t_5 = __pyx_t_6;
    __pyx_L7_bool_binop_done:;
    __pyx_t_6 = ((!(__pyx_t_5 != 0)) != 0);
    if (__pyx_t_6) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_False);
      __pyx_r = Py_False;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
  }
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_True);
    __pyx_r = Py_True;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    goto __pyx_L0;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  #if !CYTHON_USE_EXC_INFO_STACK
  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
  #endif
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2541
 *     return int(value)
 * 
 * def validate_and_adjust_ranges(**kwargs):             # <<<<<<<<<<<<<<
 *     """
 *     Validates and adjusts the provided range tuples to ensure each is
 */

static PyObject *__pyx_pf_9validator_70validate_and_adjust_ranges(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_kwargs) {
  struct __pyx_obj_9validator___pyx_scope_struct_20_validate_and_adjust_ranges *__pyx_cur_scope;
  PyObject *__pyx_v_adjusted_ranges = NULL;
  PyObject *__pyx_v_range_name = NULL;
  PyObject *__pyx_v_min_value = NULL;
  PyObject *__pyx_v_max_value = NULL;
  PyObject *__pyx_gb_9validator_26validate_and_adjust_ranges_2generator10 = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  Py_ssize_t __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  int __pyx_t_8;
  int __pyx_t_9;
  int __pyx_t_10;
  Py_ssize_t __pyx_t_11;
  PyObject *__pyx_t_12 = NULL;
  int __pyx_t_13;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validate_and_adjust_ranges", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_20_validate_and_adjust_ranges *)__pyx_tp_new_9validator___pyx_scope_struct_20_validate_and_adjust_ranges(__pyx_ptype_9validator___pyx_scope_struct_20_validate_and_adjust_ranges, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_20_validate_and_adjust_ranges *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 2541, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }

  /* "validator.pyx":2589
 *     for further data processing or modeling tasks.
 *     """
 *     adjusted_ranges = {}             # <<<<<<<<<<<<<<
 * 
 *     for range_name, range_tuple in kwargs.items():
 */
  __pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2589, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_adjusted_ranges = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":2591
 *     adjusted_ranges = {}
 * 
 *     for range_name, range_tuple in kwargs.items():             # <<<<<<<<<<<<<<
 *         if not isinstance(range_tuple, tuple) or len(range_tuple) != 2:
 *             raise ValueError(f"{range_name} must be a tuple of two values.")
 */
  __pyx_t_2 = 0;
  __pyx_t_5 = __Pyx_dict_iterator(__pyx_v_kwargs, 1, __pyx_n_s_items, (&__pyx_t_3), (&__pyx_t_4)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2591, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_1);
  __pyx_t_1 = __pyx_t_5;
  __pyx_t_5 = 0;
  while (1) {
    __pyx_t_7 = __Pyx_dict_iter_next(__pyx_t_1, __pyx_t_3, &__pyx_t_2, &__pyx_t_5, &__pyx_t_6, NULL, __pyx_t_4);
    if (unlikely(__pyx_t_7 == 0)) break;
    if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 2591, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_XDECREF_SET(__pyx_v_range_name, __pyx_t_5);
    __pyx_t_5 = 0;
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_range_tuple);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_range_tuple, __pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_6);
    __pyx_t_6 = 0;

    /* "validator.pyx":2592
 * 
 *     for range_name, range_tuple in kwargs.items():
 *         if not isinstance(range_tuple, tuple) or len(range_tuple) != 2:             # <<<<<<<<<<<<<<
 *             raise ValueError(f"{range_name} must be a tuple of two values.")
 * 
 */
    __pyx_t_6 = __pyx_cur_scope->__pyx_v_range_tuple;
    __Pyx_INCREF(__pyx_t_6);
    __pyx_t_9 = PyTuple_Check(__pyx_t_6); 
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_10 = ((!(__pyx_t_9 != 0)) != 0);
    if (!__pyx_t_10) {
    } else {
      __pyx_t_8 = __pyx_t_10;
      goto __pyx_L6_bool_binop_done;
    }
    __pyx_t_6 = __pyx_cur_scope->__pyx_v_range_tuple;
    __Pyx_INCREF(__pyx_t_6);
    __pyx_t_11 = PyObject_Length(__pyx_t_6); if (unlikely(__pyx_t_11 == ((Py_ssize_t)-1))) __PYX_ERR(0, 2592, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_10 = ((__pyx_t_11 != 2) != 0);
    __pyx_t_8 = __pyx_t_10;
    __pyx_L6_bool_binop_done:;
    if (unlikely(__pyx_t_8)) {

      /* "validator.pyx":2593
 *     for range_name, range_tuple in kwargs.items():
 *         if not isinstance(range_tuple, tuple) or len(range_tuple) != 2:
 *             raise ValueError(f"{range_name} must be a tuple of two values.")             # <<<<<<<<<<<<<<
 * 
 *         if not all(isinstance(value, (int, float)) for value in range_tuple):
 */
      __pyx_t_6 = __Pyx_PyObject_FormatSimple(__pyx_v_range_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2593, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_5 = __Pyx_PyUnicode_Concat(__pyx_t_6, __pyx_kp_u_must_be_a_tuple_of_two_values); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2593, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2593, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_Raise(__pyx_t_6, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __PYX_ERR(0, 2593, __pyx_L1_error)

      /* "validator.pyx":2592
 * 
 *     for range_name, range_tuple in kwargs.items():
 *         if not isinstance(range_tuple, tuple) or len(range_tuple) != 2:             # <<<<<<<<<<<<<<
 *             raise ValueError(f"{range_name} must be a tuple of two values.")
 * 
 */
    }

    /* "validator.pyx":2595
 *             raise ValueError(f"{range_name} must be a tuple of two values.")
 * 
 *         if not all(isinstance(value, (int, float)) for value in range_tuple):             # <<<<<<<<<<<<<<
 *             raise ValueError(f"{range_name} must contain numerical values.")
 * 
 */
    __pyx_t_6 = __pyx_pf_9validator_26validate_and_adjust_ranges_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2595, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_5 = __Pyx_Generator_Next(__pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2595, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 2595, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_10 = ((!__pyx_t_8) != 0);
    if (unlikely(__pyx_t_10)) {

      /* "validator.pyx":2596
 * 
 *         if not all(isinstance(value, (int, float)) for value in range_tuple):
 *             raise ValueError(f"{range_name} must contain numerical values.")             # <<<<<<<<<<<<<<
 * 
 *         # Ensure the range is in (min, max) format
 */
      __pyx_t_5 = __Pyx_PyObject_FormatSimple(__pyx_v_range_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2596, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_6 = __Pyx_PyUnicode_Concat(__pyx_t_5, __pyx_kp_u_must_contain_numerical_values); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2596, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2596, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __PYX_ERR(0, 2596, __pyx_L1_error)

      /* "validator.pyx":2595
 *             raise ValueError(f"{range_name} must be a tuple of two values.")
 * 
 *         if not all(isinstance(value, (int, float)) for value in range_tuple):             # <<<<<<<<<<<<<<
 *             raise ValueError(f"{range_name} must contain numerical values.")
 * 
 */
    }

    /* "validator.pyx":2599
 * 
 *         # Ensure the range is in (min, max) format
 *         min_value, max_value = sorted(range_tuple)             # <<<<<<<<<<<<<<
 *         adjusted_ranges[range_name] = (min_value, max_value)
 * 
 */
    __pyx_t_6 = __pyx_cur_scope->__pyx_v_range_tuple;
    __Pyx_INCREF(__pyx_t_6);
    __pyx_t_12 = PySequence_List(__pyx_t_6); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 2599, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_12);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_5 = ((PyObject*)__pyx_t_12);
    __pyx_t_12 = 0;
    __pyx_t_13 = PyList_Sort(__pyx_t_5); if (unlikely(__pyx_t_13 == ((int)-1))) __PYX_ERR(0, 2599, __pyx_L1_error)
    if (likely(__pyx_t_5 != Py_None)) {
      PyObject* sequence = __pyx_t_5;
      Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
      if (unlikely(size != 2)) {
        if (size > 2) __Pyx_RaiseTooManyValuesError(2);
        else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
        __PYX_ERR(0, 2599, __pyx_L1_error)
      }
      #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
      __pyx_t_12 = PyList_GET_ITEM(sequence, 0); 
      __pyx_t_6 = PyList_GET_ITEM(sequence, 1); 
      __Pyx_INCREF(__pyx_t_12);
      __Pyx_INCREF(__pyx_t_6);
      #else
      __pyx_t_12 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 2599, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_12);
      __pyx_t_6 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2599, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      #endif
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    } else {
      __Pyx_RaiseNoneNotIterableError(); __PYX_ERR(0, 2599, __pyx_L1_error)
    }
    __Pyx_XDECREF_SET(__pyx_v_min_value, __pyx_t_12);
    __pyx_t_12 = 0;
    __Pyx_XDECREF_SET(__pyx_v_max_value, __pyx_t_6);
    __pyx_t_6 = 0;

    /* "validator.pyx":2600
 *         # Ensure the range is in (min, max) format
 *         min_value, max_value = sorted(range_tuple)
 *         adjusted_ranges[range_name] = (min_value, max_value)             # <<<<<<<<<<<<<<
 * 
 *     return adjusted_ranges
 */
    __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2600, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_INCREF(__pyx_v_min_value);
    __Pyx_GIVEREF(__pyx_v_min_value);
    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_min_value);
    __Pyx_INCREF(__pyx_v_max_value);
    __Pyx_GIVEREF(__pyx_v_max_value);
    PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_v_max_value);
    if (unlikely(PyDict_SetItem(__pyx_v_adjusted_ranges, __pyx_v_range_name, __pyx_t_5) < 0)) __PYX_ERR(0, 2600, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":2602
 *         adjusted_ranges[range_name] = (min_value, max_value)
 * 
 *     return adjusted_ranges             # <<<<<<<<<<<<<<
 * 
 * def recheck_data_types(
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_adjusted_ranges);
  __pyx_r = __pyx_v_adjusted_ranges;
  goto __pyx_L0;

  /* "validator.pyx":2541
 *     return int(value)
 * 
 * def validate_and_adjust_ranges(**kwargs):             # <<<<<<<<<<<<<<
 *     """
 *     Validates and adjusts the provided range tuples to ensure each is
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_12);
  __Pyx_AddTraceback("validator.validate_and_adjust_ranges", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_adjusted_ranges);
  __Pyx_XDECREF(__pyx_v_range_name);
  __Pyx_XDECREF(__pyx_v_min_value);
  __Pyx_XDECREF(__pyx_v_max_value);
  __Pyx_XDECREF(__pyx_gb_9validator_26validate_and_adjust_ranges_2generator10);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2604
 *     return adjusted_ranges
 * 
 * def recheck_data_types(             # <<<<<<<<<<<<<<
 *     data: Union[pd.DataFrame, pd.Series, list, dict],
 *     coerce_numeric: bool = True,
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_73recheck_data_types(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_72recheck_data_types[] = "\n    Rechecks and coerces column data types in a DataFrame to the most appropriate\n    numeric or datetime types if initially identified as objects. It can also handle\n    non-DataFrame inputs by attempting to construct a DataFrame before processing.\n\n    Parameters\n    ----------\n    data : pd.DataFrame, pd.Series, list, or dict\n        The data to process. If not a DataFrame, an attempt will be made to convert it.\n    coerce_numeric : bool, default=True\n        If True, tries to convert object columns to numeric data types.\n    coerce_datetime : bool, default=True\n        If True, tries to convert object columns to datetime data types.\n    column_prefix : str, default=\"col\"\n        Prefix for column names when constructing a DataFrame from non-DataFrame input.\n    return_as_numpy : bool or str, default=\"auto\"\n        If True or \"auto\", converts the DataFrame to a NumPy array upon returning.\n        If \"auto\", the output type matches the input type.\n\n    Returns\n    -------\n    Union[pd.DataFrame, np.ndarray]\n        The processed data, either as a DataFrame or a NumPy array.\n\n    Examples\n    --------\n    >>> data = {'a': ['1', '2', '3'], 'b': ['2021-01-01', '2021-02-01', 'not a date'], \n                'c': ['1.1', '2.2', '3.3']}\n    >>> df = pd.DataFrame(data)\n    >>> df = recheck_data_types(df)\n    >>> print(df.dtypes)\n    a             int64\n    b            object  # remains object due to mixed valid and invalid dates\n    c           float64\n    ";
static PyMethodDef __pyx_mdef_9validator_73recheck_data_types = {"recheck_data_types", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_73recheck_data_types, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_72recheck_data_types};
static PyObject *__pyx_pw_9validator_73recheck_data_types(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_data = 0;
  PyObject *__pyx_v_coerce_numeric = 0;
  PyObject *__pyx_v_coerce_datetime = 0;
  PyObject *__pyx_v_column_prefix = 0;
  PyObject *__pyx_v_return_as_numpy = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("recheck_data_types (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_data,&__pyx_n_s_coerce_numeric,&__pyx_n_s_coerce_datetime,&__pyx_n_s_column_prefix,&__pyx_n_s_return_as_numpy,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "validator.pyx":2606
 * def recheck_data_types(
 *     data: Union[pd.DataFrame, pd.Series, list, dict],
 *     coerce_numeric: bool = True,             # <<<<<<<<<<<<<<
 *     coerce_datetime: bool = True,
 *     column_prefix: str = "col",
 */
    values[1] = ((PyObject *)Py_True);

    /* "validator.pyx":2607
 *     data: Union[pd.DataFrame, pd.Series, list, dict],
 *     coerce_numeric: bool = True,
 *     coerce_datetime: bool = True,             # <<<<<<<<<<<<<<
 *     column_prefix: str = "col",
 *     return_as_numpy: Union[bool, str] = "auto"
 */
    values[2] = ((PyObject *)Py_True);
    values[3] = ((PyObject*)__pyx_n_u_col);
    values[4] = ((PyObject *)__pyx_n_u_auto);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_coerce_numeric);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_coerce_datetime);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_column_prefix);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_return_as_numpy);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "recheck_data_types") < 0)) __PYX_ERR(0, 2604, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_data = values[0];
    __pyx_v_coerce_numeric = values[1];
    __pyx_v_coerce_datetime = values[2];
    __pyx_v_column_prefix = ((PyObject*)values[3]);
    __pyx_v_return_as_numpy = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("recheck_data_types", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2604, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.recheck_data_types", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_column_prefix), (&PyUnicode_Type), 1, "column_prefix", 1))) __PYX_ERR(0, 2608, __pyx_L1_error)
  __pyx_r = __pyx_pf_9validator_72recheck_data_types(__pyx_self, __pyx_v_data, __pyx_v_coerce_numeric, __pyx_v_coerce_datetime, __pyx_v_column_prefix, __pyx_v_return_as_numpy);

  /* "validator.pyx":2604
 *     return adjusted_ranges
 * 
 * def recheck_data_types(             # <<<<<<<<<<<<<<
 *     data: Union[pd.DataFrame, pd.Series, list, dict],
 *     coerce_numeric: bool = True,
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_72recheck_data_types(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_coerce_numeric, PyObject *__pyx_v_coerce_datetime, PyObject *__pyx_v_column_prefix, PyObject *__pyx_v_return_as_numpy) {
  int __pyx_v_is_frame;
  PyObject *__pyx_v_e = NULL;
  PyObject *__pyx_v_column = NULL;
  Py_ssize_t __pyx_9genexpr14__pyx_v_i;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  Py_ssize_t __pyx_t_10;
  Py_ssize_t __pyx_t_11;
  Py_ssize_t __pyx_t_12;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  int __pyx_t_15;
  int __pyx_t_16;
  char const *__pyx_t_17;
  PyObject *__pyx_t_18 = NULL;
  PyObject *__pyx_t_19 = NULL;
  PyObject *__pyx_t_20 = NULL;
  PyObject *__pyx_t_21 = NULL;
  PyObject *__pyx_t_22 = NULL;
  PyObject *__pyx_t_23 = NULL;
  PyObject *(*__pyx_t_24)(PyObject *);
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("recheck_data_types", 0);
  __Pyx_INCREF(__pyx_v_data);
  __Pyx_INCREF(__pyx_v_return_as_numpy);

  /* "validator.pyx":2646
 *     c           float64
 *     """
 *     return_as_numpy= parameter_validator(             # <<<<<<<<<<<<<<
 *         "return_as_numpy", target_strs={"auto", True, False})(return_as_numpy)
 *     is_frame = True
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_parameter_validator); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2646, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);

  /* "validator.pyx":2647
 *     """
 *     return_as_numpy= parameter_validator(
 *         "return_as_numpy", target_strs={"auto", True, False})(return_as_numpy)             # <<<<<<<<<<<<<<
 *     is_frame = True
 *     if not isinstance(data, pd.DataFrame):
 */
  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2647, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = PySet_New(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2647, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PySet_Add(__pyx_t_4, __pyx_n_u_auto) < 0) __PYX_ERR(0, 2647, __pyx_L1_error)
  if (PySet_Add(__pyx_t_4, Py_True) < 0) __PYX_ERR(0, 2647, __pyx_L1_error)
  if (PySet_Add(__pyx_t_4, Py_False) < 0) __PYX_ERR(0, 2647, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_target_strs, __pyx_t_4) < 0) __PYX_ERR(0, 2647, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "validator.pyx":2646
 *     c           float64
 *     """
 *     return_as_numpy= parameter_validator(             # <<<<<<<<<<<<<<
 *         "return_as_numpy", target_strs={"auto", True, False})(return_as_numpy)
 *     is_frame = True
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__71, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2646, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "validator.pyx":2647
 *     """
 *     return_as_numpy= parameter_validator(
 *         "return_as_numpy", target_strs={"auto", True, False})(return_as_numpy)             # <<<<<<<<<<<<<<
 *     is_frame = True
 *     if not isinstance(data, pd.DataFrame):
 */
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_3, __pyx_v_return_as_numpy) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_return_as_numpy);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2647, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF_SET(__pyx_v_return_as_numpy, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":2648
 *     return_as_numpy= parameter_validator(
 *         "return_as_numpy", target_strs={"auto", True, False})(return_as_numpy)
 *     is_frame = True             # <<<<<<<<<<<<<<
 *     if not isinstance(data, pd.DataFrame):
 *         is_frame = False
 */
  __pyx_v_is_frame = 1;

  /* "validator.pyx":2649
 *         "return_as_numpy", target_strs={"auto", True, False})(return_as_numpy)
 *     is_frame = True
 *     if not isinstance(data, pd.DataFrame):             # <<<<<<<<<<<<<<
 *         is_frame = False
 *         try:
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pd); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2649, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_DataFrame); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2649, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = PyObject_IsInstance(__pyx_v_data, __pyx_t_4); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(0, 2649, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_6 = ((!(__pyx_t_5 != 0)) != 0);
  if (__pyx_t_6) {

    /* "validator.pyx":2650
 *     is_frame = True
 *     if not isinstance(data, pd.DataFrame):
 *         is_frame = False             # <<<<<<<<<<<<<<
 *         try:
 *             data = pd.DataFrame(data, columns=[
 */
    __pyx_v_is_frame = 0;

    /* "validator.pyx":2651
 *     if not isinstance(data, pd.DataFrame):
 *         is_frame = False
 *         try:             # <<<<<<<<<<<<<<
 *             data = pd.DataFrame(data, columns=[
 *                 column_prefix + str(i) for i in range(len(data))])
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_7, &__pyx_t_8, &__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_7);
      __Pyx_XGOTREF(__pyx_t_8);
      __Pyx_XGOTREF(__pyx_t_9);
      /*try:*/ {

        /* "validator.pyx":2652
 *         is_frame = False
 *         try:
 *             data = pd.DataFrame(data, columns=[             # <<<<<<<<<<<<<<
 *                 column_prefix + str(i) for i in range(len(data))])
 *         except Exception as e:
 */
        __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_pd); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2652, __pyx_L4_error)
        __Pyx_GOTREF(__pyx_t_4);
        __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_DataFrame); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2652, __pyx_L4_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2652, __pyx_L4_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_INCREF(__pyx_v_data);
        __Pyx_GIVEREF(__pyx_v_data);
        PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_data);
        __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2652, __pyx_L4_error)
        __Pyx_GOTREF(__pyx_t_3);
        { /* enter inner scope */
          __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2652, __pyx_L4_error)
          __Pyx_GOTREF(__pyx_t_2);

          /* "validator.pyx":2653
 *         try:
 *             data = pd.DataFrame(data, columns=[
 *                 column_prefix + str(i) for i in range(len(data))])             # <<<<<<<<<<<<<<
 *         except Exception as e:
 *             raise ValueError(
 */
          __pyx_t_10 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_10 == ((Py_ssize_t)-1))) __PYX_ERR(0, 2653, __pyx_L4_error)
          __pyx_t_11 = __pyx_t_10;
          for (__pyx_t_12 = 0; __pyx_t_12 < __pyx_t_11; __pyx_t_12+=1) {
            __pyx_9genexpr14__pyx_v_i = __pyx_t_12;
            __pyx_t_13 = PyInt_FromSsize_t(__pyx_9genexpr14__pyx_v_i); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 2653, __pyx_L4_error)
            __Pyx_GOTREF(__pyx_t_13);
            __pyx_t_14 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyUnicode_Type)), __pyx_t_13); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 2653, __pyx_L4_error)
            __Pyx_GOTREF(__pyx_t_14);
            __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
            __pyx_t_13 = __Pyx_PyUnicode_ConcatSafe(__pyx_v_column_prefix, __pyx_t_14); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 2653, __pyx_L4_error)
            __Pyx_GOTREF(__pyx_t_13);
            __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
            if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_t_13))) __PYX_ERR(0, 2652, __pyx_L4_error)
            __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
          }
        } /* exit inner scope */
        if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_columns, __pyx_t_2) < 0) __PYX_ERR(0, 2652, __pyx_L4_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

        /* "validator.pyx":2652
 *         is_frame = False
 *         try:
 *             data = pd.DataFrame(data, columns=[             # <<<<<<<<<<<<<<
 *                 column_prefix + str(i) for i in range(len(data))])
 *         except Exception as e:
 */
        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_4, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2652, __pyx_L4_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_2);
        __pyx_t_2 = 0;

        /* "validator.pyx":2651
 *     if not isinstance(data, pd.DataFrame):
 *         is_frame = False
 *         try:             # <<<<<<<<<<<<<<
 *             data = pd.DataFrame(data, columns=[
 *                 column_prefix + str(i) for i in range(len(data))])
 */
      }
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      goto __pyx_L9_try_end;
      __pyx_L4_error:;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
      __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;

      /* "validator.pyx":2654
 *             data = pd.DataFrame(data, columns=[
 *                 column_prefix + str(i) for i in range(len(data))])
 *         except Exception as e:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 "Failed to construct a DataFrame from the provided data. "
 */
      __pyx_t_15 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
      if (__pyx_t_15) {
        __Pyx_AddTraceback("validator.recheck_data_types", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_2, &__pyx_t_3, &__pyx_t_4) < 0) __PYX_ERR(0, 2654, __pyx_L6_except_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_3);
        __pyx_v_e = __pyx_t_3;
        /*try:*/ {

          /* "validator.pyx":2655
 *                 column_prefix + str(i) for i in range(len(data))])
 *         except Exception as e:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "Failed to construct a DataFrame from the provided data. "
 *                 "Ensure that your input data is structured correctly, such as "
 */
          __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__72, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2655, __pyx_L17_error)
          __Pyx_GOTREF(__pyx_t_1);

          /* "validator.pyx":2659
 *                 "Ensure that your input data is structured correctly, such as "
 *                 "a list of lists or a dictionary with equal-length lists. "
 *                 "Alternatively, provide a DataFrame directly.") from e             # <<<<<<<<<<<<<<
 * 
 *     for column in data.columns:
 */
          __Pyx_Raise(__pyx_t_1, 0, 0, __pyx_v_e);
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
          __PYX_ERR(0, 2655, __pyx_L17_error)
        }

        /* "validator.pyx":2654
 *             data = pd.DataFrame(data, columns=[
 *                 column_prefix + str(i) for i in range(len(data))])
 *         except Exception as e:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 "Failed to construct a DataFrame from the provided data. "
 */
        /*finally:*/ {
          __pyx_L17_error:;
          /*exception exit:*/{
            __Pyx_PyThreadState_declare
            __Pyx_PyThreadState_assign
            __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0; __pyx_t_22 = 0; __pyx_t_23 = 0;
            __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
            __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
            __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
            if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_21, &__pyx_t_22, &__pyx_t_23);
            if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_18, &__pyx_t_19, &__pyx_t_20) < 0)) __Pyx_ErrFetch(&__pyx_t_18, &__pyx_t_19, &__pyx_t_20);
            __Pyx_XGOTREF(__pyx_t_18);
            __Pyx_XGOTREF(__pyx_t_19);
            __Pyx_XGOTREF(__pyx_t_20);
            __Pyx_XGOTREF(__pyx_t_21);
            __Pyx_XGOTREF(__pyx_t_22);
            __Pyx_XGOTREF(__pyx_t_23);
            __pyx_t_15 = __pyx_lineno; __pyx_t_16 = __pyx_clineno; __pyx_t_17 = __pyx_filename;
            {
              __Pyx_DECREF(__pyx_v_e);
              __pyx_v_e = NULL;
            }
            if (PY_MAJOR_VERSION >= 3) {
              __Pyx_XGIVEREF(__pyx_t_21);
              __Pyx_XGIVEREF(__pyx_t_22);
              __Pyx_XGIVEREF(__pyx_t_23);
              __Pyx_ExceptionReset(__pyx_t_21, __pyx_t_22, __pyx_t_23);
            }
            __Pyx_XGIVEREF(__pyx_t_18);
            __Pyx_XGIVEREF(__pyx_t_19);
            __Pyx_XGIVEREF(__pyx_t_20);
            __Pyx_ErrRestore(__pyx_t_18, __pyx_t_19, __pyx_t_20);
            __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0; __pyx_t_22 = 0; __pyx_t_23 = 0;
            __pyx_lineno = __pyx_t_15; __pyx_clineno = __pyx_t_16; __pyx_filename = __pyx_t_17;
            goto __pyx_L6_except_error;
          }
        }
      }
      goto __pyx_L6_except_error;
      __pyx_L6_except_error:;

      /* "validator.pyx":2651
 *     if not isinstance(data, pd.DataFrame):
 *         is_frame = False
 *         try:             # <<<<<<<<<<<<<<
 *             data = pd.DataFrame(data, columns=[
 *                 column_prefix + str(i) for i in range(len(data))])
 */
      __Pyx_XGIVEREF(__pyx_t_7);
      __Pyx_XGIVEREF(__pyx_t_8);
      __Pyx_XGIVEREF(__pyx_t_9);
      __Pyx_ExceptionReset(__pyx_t_7, __pyx_t_8, __pyx_t_9);
      goto __pyx_L1_error;
      __pyx_L9_try_end:;
    }

    /* "validator.pyx":2649
 *         "return_as_numpy", target_strs={"auto", True, False})(return_as_numpy)
 *     is_frame = True
 *     if not isinstance(data, pd.DataFrame):             # <<<<<<<<<<<<<<
 *         is_frame = False
 *         try:
 */
  }

  /* "validator.pyx":2661
 *                 "Alternatively, provide a DataFrame directly.") from e
 * 
 *     for column in data.columns:             # <<<<<<<<<<<<<<
 *         if data[column].dtype == 'object':
 *             if coerce_datetime:
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_columns); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2661, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (likely(PyList_CheckExact(__pyx_t_4)) || PyTuple_CheckExact(__pyx_t_4)) {
    __pyx_t_3 = __pyx_t_4; __Pyx_INCREF(__pyx_t_3); __pyx_t_10 = 0;
    __pyx_t_24 = NULL;
  } else {
    __pyx_t_10 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2661, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_24 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_24)) __PYX_ERR(0, 2661, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  for (;;) {
    if (likely(!__pyx_t_24)) {
      if (likely(PyList_CheckExact(__pyx_t_3))) {
        if (__pyx_t_10 >= PyList_GET_SIZE(__pyx_t_3)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_10); __Pyx_INCREF(__pyx_t_4); __pyx_t_10++; if (unlikely(0 < 0)) __PYX_ERR(0, 2661, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_3, __pyx_t_10); __pyx_t_10++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2661, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_10 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_10); __Pyx_INCREF(__pyx_t_4); __pyx_t_10++; if (unlikely(0 < 0)) __PYX_ERR(0, 2661, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_3, __pyx_t_10); __pyx_t_10++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2661, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_24(__pyx_t_3);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 2661, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XDECREF_SET(__pyx_v_column, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "validator.pyx":2662
 * 
 *     for column in data.columns:
 *         if data[column].dtype == 'object':             # <<<<<<<<<<<<<<
 *             if coerce_datetime:
 *                 try:
 */
    __pyx_t_4 = __Pyx_PyObject_GetItem(__pyx_v_data, __pyx_v_column); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2662, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_dtype); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2662, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_6 = (__Pyx_PyUnicode_Equals(__pyx_t_2, __pyx_n_u_object, Py_EQ)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 2662, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (__pyx_t_6) {

      /* "validator.pyx":2663
 *     for column in data.columns:
 *         if data[column].dtype == 'object':
 *             if coerce_datetime:             # <<<<<<<<<<<<<<
 *                 try:
 *                     data[column] = pd.to_datetime(data[column])
 */
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_coerce_datetime); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 2663, __pyx_L1_error)
      if (__pyx_t_6) {

        /* "validator.pyx":2664
 *         if data[column].dtype == 'object':
 *             if coerce_datetime:
 *                 try:             # <<<<<<<<<<<<<<
 *                     data[column] = pd.to_datetime(data[column])
 *                     continue  # Skip further processing if datetime conversion is successful
 */
        {
          __Pyx_PyThreadState_declare
          __Pyx_PyThreadState_assign
          __Pyx_ExceptionSave(&__pyx_t_9, &__pyx_t_8, &__pyx_t_7);
          __Pyx_XGOTREF(__pyx_t_9);
          __Pyx_XGOTREF(__pyx_t_8);
          __Pyx_XGOTREF(__pyx_t_7);
          /*try:*/ {

            /* "validator.pyx":2665
 *             if coerce_datetime:
 *                 try:
 *                     data[column] = pd.to_datetime(data[column])             # <<<<<<<<<<<<<<
 *                     continue  # Skip further processing if datetime conversion is successful
 *                 except (TypeError, ValueError):
 */
            __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_pd); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2665, __pyx_L27_error)
            __Pyx_GOTREF(__pyx_t_4);
            __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_to_datetime); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2665, __pyx_L27_error)
            __Pyx_GOTREF(__pyx_t_1);
            __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
            __pyx_t_4 = __Pyx_PyObject_GetItem(__pyx_v_data, __pyx_v_column); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2665, __pyx_L27_error)
            __Pyx_GOTREF(__pyx_t_4);
            __pyx_t_13 = NULL;
            if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
              __pyx_t_13 = PyMethod_GET_SELF(__pyx_t_1);
              if (likely(__pyx_t_13)) {
                PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
                __Pyx_INCREF(__pyx_t_13);
                __Pyx_INCREF(function);
                __Pyx_DECREF_SET(__pyx_t_1, function);
              }
            }
            __pyx_t_2 = (__pyx_t_13) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_13, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_4);
            __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
            __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
            if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2665, __pyx_L27_error)
            __Pyx_GOTREF(__pyx_t_2);
            __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
            if (unlikely(PyObject_SetItem(__pyx_v_data, __pyx_v_column, __pyx_t_2) < 0)) __PYX_ERR(0, 2665, __pyx_L27_error)
            __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

            /* "validator.pyx":2666
 *                 try:
 *                     data[column] = pd.to_datetime(data[column])
 *                     continue  # Skip further processing if datetime conversion is successful             # <<<<<<<<<<<<<<
 *                 except (TypeError, ValueError):
 *                     pass  # Continue if datetime conversion fails
 */
            goto __pyx_L33_try_continue;

            /* "validator.pyx":2664
 *         if data[column].dtype == 'object':
 *             if coerce_datetime:
 *                 try:             # <<<<<<<<<<<<<<
 *                     data[column] = pd.to_datetime(data[column])
 *                     continue  # Skip further processing if datetime conversion is successful
 */
          }
          __pyx_L27_error:;
          __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
          __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
          __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
          __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;

          /* "validator.pyx":2667
 *                     data[column] = pd.to_datetime(data[column])
 *                     continue  # Skip further processing if datetime conversion is successful
 *                 except (TypeError, ValueError):             # <<<<<<<<<<<<<<
 *                     pass  # Continue if datetime conversion fails
 * 
 */
          __pyx_t_16 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_TypeError) || __Pyx_PyErr_ExceptionMatches(__pyx_builtin_ValueError);
          if (__pyx_t_16) {
            __Pyx_ErrRestore(0,0,0);
            goto __pyx_L28_exception_handled;
          }
          goto __pyx_L29_except_error;
          __pyx_L29_except_error:;

          /* "validator.pyx":2664
 *         if data[column].dtype == 'object':
 *             if coerce_datetime:
 *                 try:             # <<<<<<<<<<<<<<
 *                     data[column] = pd.to_datetime(data[column])
 *                     continue  # Skip further processing if datetime conversion is successful
 */
          __Pyx_XGIVEREF(__pyx_t_9);
          __Pyx_XGIVEREF(__pyx_t_8);
          __Pyx_XGIVEREF(__pyx_t_7);
          __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_8, __pyx_t_7);
          goto __pyx_L1_error;
          __pyx_L33_try_continue:;
          __Pyx_XGIVEREF(__pyx_t_9);
          __Pyx_XGIVEREF(__pyx_t_8);
          __Pyx_XGIVEREF(__pyx_t_7);
          __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_8, __pyx_t_7);
          goto __pyx_L23_continue;
          __pyx_L28_exception_handled:;
          __Pyx_XGIVEREF(__pyx_t_9);
          __Pyx_XGIVEREF(__pyx_t_8);
          __Pyx_XGIVEREF(__pyx_t_7);
          __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_8, __pyx_t_7);
        }

        /* "validator.pyx":2663
 *     for column in data.columns:
 *         if data[column].dtype == 'object':
 *             if coerce_datetime:             # <<<<<<<<<<<<<<
 *                 try:
 *                     data[column] = pd.to_datetime(data[column])
 */
      }

      /* "validator.pyx":2670
 *                     pass  # Continue if datetime conversion fails
 * 
 *             if coerce_numeric:             # <<<<<<<<<<<<<<
 *                 try:
 *                     data[column] = pd.to_numeric(data[column])
 */
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_coerce_numeric); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 2670, __pyx_L1_error)
      if (__pyx_t_6) {

        /* "validator.pyx":2671
 * 
 *             if coerce_numeric:
 *                 try:             # <<<<<<<<<<<<<<
 *                     data[column] = pd.to_numeric(data[column])
 *                 except ValueError:
 */
        {
          __Pyx_PyThreadState_declare
          __Pyx_PyThreadState_assign
          __Pyx_ExceptionSave(&__pyx_t_7, &__pyx_t_8, &__pyx_t_9);
          __Pyx_XGOTREF(__pyx_t_7);
          __Pyx_XGOTREF(__pyx_t_8);
          __Pyx_XGOTREF(__pyx_t_9);
          /*try:*/ {

            /* "validator.pyx":2672
 *             if coerce_numeric:
 *                 try:
 *                     data[column] = pd.to_numeric(data[column])             # <<<<<<<<<<<<<<
 *                 except ValueError:
 *                     pass  # Keep as object if conversion fails
 */
            __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pd); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2672, __pyx_L36_error)
            __Pyx_GOTREF(__pyx_t_1);
            __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_to_numeric); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2672, __pyx_L36_error)
            __Pyx_GOTREF(__pyx_t_4);
            __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
            __pyx_t_1 = __Pyx_PyObject_GetItem(__pyx_v_data, __pyx_v_column); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2672, __pyx_L36_error)
            __Pyx_GOTREF(__pyx_t_1);
            __pyx_t_13 = NULL;
            if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
              __pyx_t_13 = PyMethod_GET_SELF(__pyx_t_4);
              if (likely(__pyx_t_13)) {
                PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
                __Pyx_INCREF(__pyx_t_13);
                __Pyx_INCREF(function);
                __Pyx_DECREF_SET(__pyx_t_4, function);
              }
            }
            __pyx_t_2 = (__pyx_t_13) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_13, __pyx_t_1) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_1);
            __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
            __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
            if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2672, __pyx_L36_error)
            __Pyx_GOTREF(__pyx_t_2);
            __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
            if (unlikely(PyObject_SetItem(__pyx_v_data, __pyx_v_column, __pyx_t_2) < 0)) __PYX_ERR(0, 2672, __pyx_L36_error)
            __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

            /* "validator.pyx":2671
 * 
 *             if coerce_numeric:
 *                 try:             # <<<<<<<<<<<<<<
 *                     data[column] = pd.to_numeric(data[column])
 *                 except ValueError:
 */
          }
          __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
          __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
          __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
          goto __pyx_L43_try_end;
          __pyx_L36_error:;
          __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
          __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
          __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
          __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;

          /* "validator.pyx":2673
 *                 try:
 *                     data[column] = pd.to_numeric(data[column])
 *                 except ValueError:             # <<<<<<<<<<<<<<
 *                     pass  # Keep as object if conversion fails
 * 
 */
          __pyx_t_16 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_ValueError);
          if (__pyx_t_16) {
            __Pyx_ErrRestore(0,0,0);
            goto __pyx_L37_exception_handled;
          }
          goto __pyx_L38_except_error;
          __pyx_L38_except_error:;

          /* "validator.pyx":2671
 * 
 *             if coerce_numeric:
 *                 try:             # <<<<<<<<<<<<<<
 *                     data[column] = pd.to_numeric(data[column])
 *                 except ValueError:
 */
          __Pyx_XGIVEREF(__pyx_t_7);
          __Pyx_XGIVEREF(__pyx_t_8);
          __Pyx_XGIVEREF(__pyx_t_9);
          __Pyx_ExceptionReset(__pyx_t_7, __pyx_t_8, __pyx_t_9);
          goto __pyx_L1_error;
          __pyx_L37_exception_handled:;
          __Pyx_XGIVEREF(__pyx_t_7);
          __Pyx_XGIVEREF(__pyx_t_8);
          __Pyx_XGIVEREF(__pyx_t_9);
          __Pyx_ExceptionReset(__pyx_t_7, __pyx_t_8, __pyx_t_9);
          __pyx_L43_try_end:;
        }

        /* "validator.pyx":2670
 *                     pass  # Continue if datetime conversion fails
 * 
 *             if coerce_numeric:             # <<<<<<<<<<<<<<
 *                 try:
 *                     data[column] = pd.to_numeric(data[column])
 */
      }

      /* "validator.pyx":2662
 * 
 *     for column in data.columns:
 *         if data[column].dtype == 'object':             # <<<<<<<<<<<<<<
 *             if coerce_datetime:
 *                 try:
 */
    }

    /* "validator.pyx":2661
 *                 "Alternatively, provide a DataFrame directly.") from e
 * 
 *     for column in data.columns:             # <<<<<<<<<<<<<<
 *         if data[column].dtype == 'object':
 *             if coerce_datetime:
 */
    __pyx_L23_continue:;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "validator.pyx":2676
 *                     pass  # Keep as object if conversion fails
 * 
 *     if return_as_numpy == "auto" and not is_frame:             # <<<<<<<<<<<<<<
 *         return_as_numpy = True  # Automatically determine if output should be a NumPy array
 * 
 */
  __pyx_t_5 = (__Pyx_PyUnicode_Equals(__pyx_v_return_as_numpy, __pyx_n_u_auto, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 2676, __pyx_L1_error)
  if (__pyx_t_5) {
  } else {
    __pyx_t_6 = __pyx_t_5;
    goto __pyx_L45_bool_binop_done;
  }
  __pyx_t_5 = ((!(__pyx_v_is_frame != 0)) != 0);
  __pyx_t_6 = __pyx_t_5;
  __pyx_L45_bool_binop_done:;
  if (__pyx_t_6) {

    /* "validator.pyx":2677
 * 
 *     if return_as_numpy == "auto" and not is_frame:
 *         return_as_numpy = True  # Automatically determine if output should be a NumPy array             # <<<<<<<<<<<<<<
 * 
 *     if return_as_numpy is True: # Explicitly set to True since "auto" is True
 */
    __Pyx_INCREF(Py_True);
    __Pyx_DECREF_SET(__pyx_v_return_as_numpy, Py_True);

    /* "validator.pyx":2676
 *                     pass  # Keep as object if conversion fails
 * 
 *     if return_as_numpy == "auto" and not is_frame:             # <<<<<<<<<<<<<<
 *         return_as_numpy = True  # Automatically determine if output should be a NumPy array
 * 
 */
  }

  /* "validator.pyx":2679
 *         return_as_numpy = True  # Automatically determine if output should be a NumPy array
 * 
 *     if return_as_numpy is True: # Explicitly set to True since "auto" is True             # <<<<<<<<<<<<<<
 *         return data.to_numpy()
 * 
 */
  __pyx_t_6 = (__pyx_v_return_as_numpy == Py_True);
  __pyx_t_5 = (__pyx_t_6 != 0);
  if (__pyx_t_5) {

    /* "validator.pyx":2680
 * 
 *     if return_as_numpy is True: # Explicitly set to True since "auto" is True
 *         return data.to_numpy()             # <<<<<<<<<<<<<<
 * 
 *     return data
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_to_numpy); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2680, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2680, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;

    /* "validator.pyx":2679
 *         return_as_numpy = True  # Automatically determine if output should be a NumPy array
 * 
 *     if return_as_numpy is True: # Explicitly set to True since "auto" is True             # <<<<<<<<<<<<<<
 *         return data.to_numpy()
 * 
 */
  }

  /* "validator.pyx":2682
 *         return data.to_numpy()
 * 
 *     return data             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_data);
  __pyx_r = __pyx_v_data;
  goto __pyx_L0;

  /* "validator.pyx":2604
 *     return adjusted_ranges
 * 
 * def recheck_data_types(             # <<<<<<<<<<<<<<
 *     data: Union[pd.DataFrame, pd.Series, list, dict],
 *     coerce_numeric: bool = True,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_13);
  __Pyx_XDECREF(__pyx_t_14);
  __Pyx_AddTraceback("validator.recheck_data_types", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_e);
  __Pyx_XDECREF(__pyx_v_column);
  __Pyx_XDECREF(__pyx_v_data);
  __Pyx_XDECREF(__pyx_v_return_as_numpy);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2685
 * 
 * 
 * def validate_keras_model(             # <<<<<<<<<<<<<<
 *         model: Any, custom_check: Optional[Callable[[Any], bool]] = None,
 *         deep_check: bool = False, raise_exception =False ) -> bool:
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_75validate_keras_model(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_74validate_keras_model[] = "\n    Validates whether a given object is a Keras model and optionally performs \n    additional checks.\n\n    This function provides a mechanism to ensure that an object not only is an \n    instance of a Keras model but also conforms to additional, user-defined \n    criteria if specified. It offers an optional deep check that inspects the \n    model for key Keras methods, enhancing the validation\n    process.\n\n    Parameters\n    ----------\n    model : Any\n        The object to validate as a Keras model.\n    custom_check : Callable[[Any], bool], optional\n        An optional callback function that takes the model as input and returns\n        a boolean indicating whether the model passes custom validation criteria. \n        If `None`, no custom validation is performed.\n    deep_check : bool, optional\n        If True, performs a deep inspection of the model's attributes to ensure\n        it supports essential Keras functionality (default is False).\n        \n    raise_exception : bool, optional\n        If True, raises a TypeError when the model fails the validation\n        checks, instead of returning False.\n    Returns\n    -------\n    bool\n        True if the object is validated as a Keras model and satisfies any \n        specified custom validation criteria. False otherwise.\n\n    Raises\n    ------\n    ValueError\n        If the custom check is provided and raises an exception, indicating \n        failure of the custom validation logic.\n\n    Examples\n    --------\n    >>> from tensorflow.keras.layers import Dense\n    >>> from tensorflow.keras.models import Sequential\n    >>> from gofast.tools.validator import  validate_keras_model\n    >>> model = Sequential([Dense(2)])\n\n    Validate a simple Keras model without additional checks:\n    >>> validate_keras_model(model)\n    True\n\n    Validate with a custom check (e.g., model must have more than 1 layer):\n    >>> custom_layer_check = lambda m: len(m.layers) > 1\n    >>> validate_ke""ras_model(model, custom_check=custom_layer_check)\n    False\n\n    Validate with deep inspection:\n    >>> validate_keras_model(model, deep_check=True)\n    True\n    ";
static PyMethodDef __pyx_mdef_9validator_75validate_keras_model = {"validate_keras_model", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_75validate_keras_model, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_74validate_keras_model};
static PyObject *__pyx_pw_9validator_75validate_keras_model(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_model = 0;
  PyObject *__pyx_v_custom_check = 0;
  PyObject *__pyx_v_deep_check = 0;
  PyObject *__pyx_v_raise_exception = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validate_keras_model (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_model,&__pyx_n_s_custom_check,&__pyx_n_s_deep_check,&__pyx_n_s_raise_exception,0};
    PyObject* values[4] = {0,0,0,0};

    /* "validator.pyx":2686
 * 
 * def validate_keras_model(
 *         model: Any, custom_check: Optional[Callable[[Any], bool]] = None,             # <<<<<<<<<<<<<<
 *         deep_check: bool = False, raise_exception =False ) -> bool:
 *     """
 */
    values[1] = ((PyObject *)Py_None);

    /* "validator.pyx":2687
 * def validate_keras_model(
 *         model: Any, custom_check: Optional[Callable[[Any], bool]] = None,
 *         deep_check: bool = False, raise_exception =False ) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Validates whether a given object is a Keras model and optionally performs
 */
    values[2] = ((PyObject *)Py_False);
    values[3] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_model)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_custom_check);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_deep_check);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_raise_exception);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "validate_keras_model") < 0)) __PYX_ERR(0, 2685, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_model = values[0];
    __pyx_v_custom_check = values[1];
    __pyx_v_deep_check = values[2];
    __pyx_v_raise_exception = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("validate_keras_model", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2685, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.validate_keras_model", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_74validate_keras_model(__pyx_self, __pyx_v_model, __pyx_v_custom_check, __pyx_v_deep_check, __pyx_v_raise_exception);

  /* "validator.pyx":2685
 * 
 * 
 * def validate_keras_model(             # <<<<<<<<<<<<<<
 *         model: Any, custom_check: Optional[Callable[[Any], bool]] = None,
 *         deep_check: bool = False, raise_exception =False ) -> bool:
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_74validate_keras_model(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_model, PyObject *__pyx_v_custom_check, PyObject *__pyx_v_deep_check, PyObject *__pyx_v_raise_exception) {
  PyObject *__pyx_v_e = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_t_9;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  int __pyx_t_13;
  char const *__pyx_t_14;
  PyObject *__pyx_t_15 = NULL;
  PyObject *__pyx_t_16 = NULL;
  PyObject *__pyx_t_17 = NULL;
  PyObject *__pyx_t_18 = NULL;
  PyObject *__pyx_t_19 = NULL;
  PyObject *__pyx_t_20 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validate_keras_model", 0);

  /* "validator.pyx":2745
 *     True
 *     """
 *     if not is_keras_model(model):             # <<<<<<<<<<<<<<
 *         if raise_exception:
 *             raise TypeError("Provided object is not a Keras model.")
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_is_keras_model); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2745, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_model) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_model);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2745, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 2745, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (__pyx_t_5) {

    /* "validator.pyx":2746
 *     """
 *     if not is_keras_model(model):
 *         if raise_exception:             # <<<<<<<<<<<<<<
 *             raise TypeError("Provided object is not a Keras model.")
 *         return False
 */
    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_v_raise_exception); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 2746, __pyx_L1_error)
    if (unlikely(__pyx_t_5)) {

      /* "validator.pyx":2747
 *     if not is_keras_model(model):
 *         if raise_exception:
 *             raise TypeError("Provided object is not a Keras model.")             # <<<<<<<<<<<<<<
 *         return False
 * 
 */
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__73, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2747, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 2747, __pyx_L1_error)

      /* "validator.pyx":2746
 *     """
 *     if not is_keras_model(model):
 *         if raise_exception:             # <<<<<<<<<<<<<<
 *             raise TypeError("Provided object is not a Keras model.")
 *         return False
 */
    }

    /* "validator.pyx":2748
 *         if raise_exception:
 *             raise TypeError("Provided object is not a Keras model.")
 *         return False             # <<<<<<<<<<<<<<
 * 
 *     if deep_check and not has_required_attributes(
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    goto __pyx_L0;

    /* "validator.pyx":2745
 *     True
 *     """
 *     if not is_keras_model(model):             # <<<<<<<<<<<<<<
 *         if raise_exception:
 *             raise TypeError("Provided object is not a Keras model.")
 */
  }

  /* "validator.pyx":2750
 *         return False
 * 
 *     if deep_check and not has_required_attributes(             # <<<<<<<<<<<<<<
 *             model, ['fit', 'predict', 'compile', 'summary']):
 *         if raise_exception:
 */
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_deep_check); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 2750, __pyx_L1_error)
  if (__pyx_t_4) {
  } else {
    __pyx_t_5 = __pyx_t_4;
    goto __pyx_L6_bool_binop_done;
  }
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_has_required_attributes); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2750, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);

  /* "validator.pyx":2751
 * 
 *     if deep_check and not has_required_attributes(
 *             model, ['fit', 'predict', 'compile', 'summary']):             # <<<<<<<<<<<<<<
 *         if raise_exception:
 *             raise TypeError("Model does not support essential Keras functionalities.")
 */
  __pyx_t_3 = PyList_New(4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2751, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_n_u_fit);
  __Pyx_GIVEREF(__pyx_n_u_fit);
  PyList_SET_ITEM(__pyx_t_3, 0, __pyx_n_u_fit);
  __Pyx_INCREF(__pyx_n_u_predict);
  __Pyx_GIVEREF(__pyx_n_u_predict);
  PyList_SET_ITEM(__pyx_t_3, 1, __pyx_n_u_predict);
  __Pyx_INCREF(__pyx_n_u_compile);
  __Pyx_GIVEREF(__pyx_n_u_compile);
  PyList_SET_ITEM(__pyx_t_3, 2, __pyx_n_u_compile);
  __Pyx_INCREF(__pyx_n_u_summary);
  __Pyx_GIVEREF(__pyx_n_u_summary);
  PyList_SET_ITEM(__pyx_t_3, 3, __pyx_n_u_summary);
  __pyx_t_6 = NULL;
  __pyx_t_7 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_7 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_model, __pyx_t_3};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2750, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[3] = {__pyx_t_6, __pyx_v_model, __pyx_t_3};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2750, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else
  #endif
  {
    __pyx_t_8 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 2750, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    if (__pyx_t_6) {
      __Pyx_GIVEREF(__pyx_t_6); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __pyx_t_6 = NULL;
    }
    __Pyx_INCREF(__pyx_v_model);
    __Pyx_GIVEREF(__pyx_v_model);
    PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_v_model);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2750, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":2750
 *         return False
 * 
 *     if deep_check and not has_required_attributes(             # <<<<<<<<<<<<<<
 *             model, ['fit', 'predict', 'compile', 'summary']):
 *         if raise_exception:
 */
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 2750, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_9 = ((!__pyx_t_4) != 0);
  __pyx_t_5 = __pyx_t_9;
  __pyx_L6_bool_binop_done:;
  if (__pyx_t_5) {

    /* "validator.pyx":2752
 *     if deep_check and not has_required_attributes(
 *             model, ['fit', 'predict', 'compile', 'summary']):
 *         if raise_exception:             # <<<<<<<<<<<<<<
 *             raise TypeError("Model does not support essential Keras functionalities.")
 *         return False
 */
    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_v_raise_exception); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 2752, __pyx_L1_error)
    if (unlikely(__pyx_t_5)) {

      /* "validator.pyx":2753
 *             model, ['fit', 'predict', 'compile', 'summary']):
 *         if raise_exception:
 *             raise TypeError("Model does not support essential Keras functionalities.")             # <<<<<<<<<<<<<<
 *         return False
 * 
 */
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__74, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2753, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 2753, __pyx_L1_error)

      /* "validator.pyx":2752
 *     if deep_check and not has_required_attributes(
 *             model, ['fit', 'predict', 'compile', 'summary']):
 *         if raise_exception:             # <<<<<<<<<<<<<<
 *             raise TypeError("Model does not support essential Keras functionalities.")
 *         return False
 */
    }

    /* "validator.pyx":2754
 *         if raise_exception:
 *             raise TypeError("Model does not support essential Keras functionalities.")
 *         return False             # <<<<<<<<<<<<<<
 * 
 *     if custom_check:
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    goto __pyx_L0;

    /* "validator.pyx":2750
 *         return False
 * 
 *     if deep_check and not has_required_attributes(             # <<<<<<<<<<<<<<
 *             model, ['fit', 'predict', 'compile', 'summary']):
 *         if raise_exception:
 */
  }

  /* "validator.pyx":2756
 *         return False
 * 
 *     if custom_check:             # <<<<<<<<<<<<<<
 *         try:
 *             return custom_check(model)
 */
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_v_custom_check); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 2756, __pyx_L1_error)
  if (__pyx_t_5) {

    /* "validator.pyx":2757
 * 
 *     if custom_check:
 *         try:             # <<<<<<<<<<<<<<
 *             return custom_check(model)
 *         except Exception as e:
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12);
      __Pyx_XGOTREF(__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_11);
      __Pyx_XGOTREF(__pyx_t_12);
      /*try:*/ {

        /* "validator.pyx":2758
 *     if custom_check:
 *         try:
 *             return custom_check(model)             # <<<<<<<<<<<<<<
 *         except Exception as e:
 *             raise ValueError(f"Custom check failed: {e}")
 */
        __Pyx_XDECREF(__pyx_r);
        __Pyx_INCREF(__pyx_v_custom_check);
        __pyx_t_2 = __pyx_v_custom_check; __pyx_t_8 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
          __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_2);
          if (likely(__pyx_t_8)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
            __Pyx_INCREF(__pyx_t_8);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_2, function);
          }
        }
        __pyx_t_1 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_8, __pyx_v_model) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_model);
        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
        if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2758, __pyx_L10_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_r = __pyx_t_1;
        __pyx_t_1 = 0;
        goto __pyx_L14_try_return;

        /* "validator.pyx":2757
 * 
 *     if custom_check:
 *         try:             # <<<<<<<<<<<<<<
 *             return custom_check(model)
 *         except Exception as e:
 */
      }
      __pyx_L10_error:;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;

      /* "validator.pyx":2759
 *         try:
 *             return custom_check(model)
 *         except Exception as e:             # <<<<<<<<<<<<<<
 *             raise ValueError(f"Custom check failed: {e}")
 * 
 */
      __pyx_t_7 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
      if (__pyx_t_7) {
        __Pyx_AddTraceback("validator.validate_keras_model", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_1, &__pyx_t_2, &__pyx_t_8) < 0) __PYX_ERR(0, 2759, __pyx_L12_except_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_INCREF(__pyx_t_2);
        __pyx_v_e = __pyx_t_2;
        /*try:*/ {

          /* "validator.pyx":2760
 *             return custom_check(model)
 *         except Exception as e:
 *             raise ValueError(f"Custom check failed: {e}")             # <<<<<<<<<<<<<<
 * 
 *     return True
 */
          __pyx_t_3 = __Pyx_PyObject_FormatSimple(__pyx_v_e, __pyx_empty_unicode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2760, __pyx_L21_error)
          __Pyx_GOTREF(__pyx_t_3);
          __pyx_t_6 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Custom_check_failed, __pyx_t_3); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2760, __pyx_L21_error)
          __Pyx_GOTREF(__pyx_t_6);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2760, __pyx_L21_error)
          __Pyx_GOTREF(__pyx_t_3);
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
          __Pyx_Raise(__pyx_t_3, 0, 0, 0);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          __PYX_ERR(0, 2760, __pyx_L21_error)
        }

        /* "validator.pyx":2759
 *         try:
 *             return custom_check(model)
 *         except Exception as e:             # <<<<<<<<<<<<<<
 *             raise ValueError(f"Custom check failed: {e}")
 * 
 */
        /*finally:*/ {
          __pyx_L21_error:;
          /*exception exit:*/{
            __Pyx_PyThreadState_declare
            __Pyx_PyThreadState_assign
            __pyx_t_15 = 0; __pyx_t_16 = 0; __pyx_t_17 = 0; __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0;
            __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
            __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
            if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_18, &__pyx_t_19, &__pyx_t_20);
            if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_15, &__pyx_t_16, &__pyx_t_17) < 0)) __Pyx_ErrFetch(&__pyx_t_15, &__pyx_t_16, &__pyx_t_17);
            __Pyx_XGOTREF(__pyx_t_15);
            __Pyx_XGOTREF(__pyx_t_16);
            __Pyx_XGOTREF(__pyx_t_17);
            __Pyx_XGOTREF(__pyx_t_18);
            __Pyx_XGOTREF(__pyx_t_19);
            __Pyx_XGOTREF(__pyx_t_20);
            __pyx_t_7 = __pyx_lineno; __pyx_t_13 = __pyx_clineno; __pyx_t_14 = __pyx_filename;
            {
              __Pyx_DECREF(__pyx_v_e);
              __pyx_v_e = NULL;
            }
            if (PY_MAJOR_VERSION >= 3) {
              __Pyx_XGIVEREF(__pyx_t_18);
              __Pyx_XGIVEREF(__pyx_t_19);
              __Pyx_XGIVEREF(__pyx_t_20);
              __Pyx_ExceptionReset(__pyx_t_18, __pyx_t_19, __pyx_t_20);
            }
            __Pyx_XGIVEREF(__pyx_t_15);
            __Pyx_XGIVEREF(__pyx_t_16);
            __Pyx_XGIVEREF(__pyx_t_17);
            __Pyx_ErrRestore(__pyx_t_15, __pyx_t_16, __pyx_t_17);
            __pyx_t_15 = 0; __pyx_t_16 = 0; __pyx_t_17 = 0; __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0;
            __pyx_lineno = __pyx_t_7; __pyx_clineno = __pyx_t_13; __pyx_filename = __pyx_t_14;
            goto __pyx_L12_except_error;
          }
        }
      }
      goto __pyx_L12_except_error;
      __pyx_L12_except_error:;

      /* "validator.pyx":2757
 * 
 *     if custom_check:
 *         try:             # <<<<<<<<<<<<<<
 *             return custom_check(model)
 *         except Exception as e:
 */
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_11);
      __Pyx_XGIVEREF(__pyx_t_12);
      __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_11, __pyx_t_12);
      goto __pyx_L1_error;
      __pyx_L14_try_return:;
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_11);
      __Pyx_XGIVEREF(__pyx_t_12);
      __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_11, __pyx_t_12);
      goto __pyx_L0;
    }

    /* "validator.pyx":2756
 *         return False
 * 
 *     if custom_check:             # <<<<<<<<<<<<<<
 *         try:
 *             return custom_check(model)
 */
  }

  /* "validator.pyx":2762
 *             raise ValueError(f"Custom check failed: {e}")
 * 
 *     return True             # <<<<<<<<<<<<<<
 * 
 * def is_installed(module: str ) -> bool:
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_True);
  __pyx_r = Py_True;
  goto __pyx_L0;

  /* "validator.pyx":2685
 * 
 * 
 * def validate_keras_model(             # <<<<<<<<<<<<<<
 *         model: Any, custom_check: Optional[Callable[[Any], bool]] = None,
 *         deep_check: bool = False, raise_exception =False ) -> bool:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("validator.validate_keras_model", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_e);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2764
 *     return True
 * 
 * def is_installed(module: str ) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Checks if TensorFlow is installed.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_77is_installed(PyObject *__pyx_self, PyObject *__pyx_v_module); /*proto*/
static char __pyx_doc_9validator_76is_installed[] = "\n    Checks if TensorFlow is installed.\n\n    This function attempts to find the TensorFlow package specification without\n    importing the package. It's a lightweight method to verify the presence of\n    TensorFlow in the environment.\n\n    Returns\n    -------\n    bool\n        True if TensorFlow is installed, False otherwise.\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import is_installed \n    >>> print(is_installed(\"tensorflow\"))\n    True  # Output will be True if TensorFlow is installed, False otherwise.\n    ";
static PyMethodDef __pyx_mdef_9validator_77is_installed = {"is_installed", (PyCFunction)__pyx_pw_9validator_77is_installed, METH_O, __pyx_doc_9validator_76is_installed};
static PyObject *__pyx_pw_9validator_77is_installed(PyObject *__pyx_self, PyObject *__pyx_v_module) {
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("is_installed (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_module), (&PyUnicode_Type), 1, "module", 1))) __PYX_ERR(0, 2764, __pyx_L1_error)
  __pyx_r = __pyx_pf_9validator_76is_installed(__pyx_self, ((PyObject*)__pyx_v_module));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_76is_installed(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_module) {
  PyObject *__pyx_v_importlib = NULL;
  PyObject *__pyx_v_module_spec = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("is_installed", 0);

  /* "validator.pyx":2783
 *     True  # Output will be True if TensorFlow is installed, False otherwise.
 *     """
 *     import importlib.util             # <<<<<<<<<<<<<<
 *     module_spec = importlib.util.find_spec(module)
 *     return module_spec is not None
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_importlib_util, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2783, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_importlib = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":2784
 *     """
 *     import importlib.util
 *     module_spec = importlib.util.find_spec(module)             # <<<<<<<<<<<<<<
 *     return module_spec is not None
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_importlib, __pyx_n_s_util); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2784, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_find_spec); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2784, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_v_module) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_module);
  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2784, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_module_spec = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":2785
 *     import importlib.util
 *     module_spec = importlib.util.find_spec(module)
 *     return module_spec is not None             # <<<<<<<<<<<<<<
 * 
 * def is_time_series(data, time_col, check_time_interval=False ):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_4 = (__pyx_v_module_spec != Py_None);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2785, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "validator.pyx":2764
 *     return True
 * 
 * def is_installed(module: str ) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Checks if TensorFlow is installed.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("validator.is_installed", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_importlib);
  __Pyx_XDECREF(__pyx_v_module_spec);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2787
 *     return module_spec is not None
 * 
 * def is_time_series(data, time_col, check_time_interval=False ):             # <<<<<<<<<<<<<<
 *     """
 *     Check if the provided DataFrame is time series data.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_79is_time_series(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_78is_time_series[] = "\n    Check if the provided DataFrame is time series data.\n\n    Parameters\n    ----------\n    data : pandas.DataFrame\n        The DataFrame to be checked.\n    time_col : str\n        The name of the column in `df` expected to represent time.\n\n    Returns\n    -------\n    bool\n        True if `df` is a time series, False otherwise.\n        \n    Example\n    -------\n    >>> import pandas as pd \n    >>> df = pd.DataFrame({\n        'Date': ['2021-01-01', '2021-01-02', '2021-01-03', '2021-01-04', '2021-01-05'],\n        'Value': [1, 2, 3, 4, 5]\n    })\n    >>> # Should return True if Date column \n    >>> # can be converted to datetime\n    >>> print(is_time_series(df, 'Date'))   \n \n    ";
static PyMethodDef __pyx_mdef_9validator_79is_time_series = {"is_time_series", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_79is_time_series, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_78is_time_series};
static PyObject *__pyx_pw_9validator_79is_time_series(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_data = 0;
  PyObject *__pyx_v_time_col = 0;
  PyObject *__pyx_v_check_time_interval = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("is_time_series (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_data,&__pyx_n_s_time_col,&__pyx_n_s_check_time_interval,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_time_col)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("is_time_series", 0, 2, 3, 1); __PYX_ERR(0, 2787, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_check_time_interval);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "is_time_series") < 0)) __PYX_ERR(0, 2787, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_data = values[0];
    __pyx_v_time_col = values[1];
    __pyx_v_check_time_interval = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("is_time_series", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2787, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.is_time_series", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_78is_time_series(__pyx_self, __pyx_v_data, __pyx_v_time_col, __pyx_v_check_time_interval);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_78is_time_series(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_time_col, PyObject *__pyx_v_check_time_interval) {
  PyObject *__pyx_v_intervals = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  Py_ssize_t __pyx_t_4;
  Py_UCS4 __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  int __pyx_t_12;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("is_time_series", 0);

  /* "validator.pyx":2815
 * 
 *     """
 *     if time_col not in data.columns:             # <<<<<<<<<<<<<<
 *         print(f"Time column '{time_col}' not found in DataFrame.")
 *         return False
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_columns); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2815, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_v_time_col, __pyx_t_1, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 2815, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (__pyx_t_3) {

    /* "validator.pyx":2816
 *     """
 *     if time_col not in data.columns:
 *         print(f"Time column '{time_col}' not found in DataFrame.")             # <<<<<<<<<<<<<<
 *         return False
 * 
 */
    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2816, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = 0;
    __pyx_t_5 = 127;
    __Pyx_INCREF(__pyx_kp_u_Time_column);
    __pyx_t_4 += 13;
    __Pyx_GIVEREF(__pyx_kp_u_Time_column);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_Time_column);
    __pyx_t_6 = __Pyx_PyObject_FormatSimple(__pyx_v_time_col, __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2816, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_5 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) > __pyx_t_5) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) : __pyx_t_5;
    __pyx_t_4 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_6);
    __pyx_t_6 = 0;
    __Pyx_INCREF(__pyx_kp_u_not_found_in_DataFrame);
    __pyx_t_4 += 25;
    __Pyx_GIVEREF(__pyx_kp_u_not_found_in_DataFrame);
    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_not_found_in_DataFrame);
    __pyx_t_6 = __Pyx_PyUnicode_Join(__pyx_t_1, 3, __pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2816, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_print, __pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2816, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "validator.pyx":2817
 *     if time_col not in data.columns:
 *         print(f"Time column '{time_col}' not found in DataFrame.")
 *         return False             # <<<<<<<<<<<<<<
 * 
 *     # Check if the column is datetime type or can be converted to datetime
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    goto __pyx_L0;

    /* "validator.pyx":2815
 * 
 *     """
 *     if time_col not in data.columns:             # <<<<<<<<<<<<<<
 *         print(f"Time column '{time_col}' not found in DataFrame.")
 *         return False
 */
  }

  /* "validator.pyx":2820
 * 
 *     # Check if the column is datetime type or can be converted to datetime
 *     if not pd.api.types.is_datetime64_any_dtype(data[time_col]):             # <<<<<<<<<<<<<<
 *         try:
 *             pd.to_datetime(data[time_col])
 */
  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_pd); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2820, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_api); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2820, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_types); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2820, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_is_datetime64_any_dtype); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2820, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_6 = __Pyx_PyObject_GetItem(__pyx_v_data, __pyx_v_time_col); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2820, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_8 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_7))) {
    __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
    if (likely(__pyx_t_8)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
      __Pyx_INCREF(__pyx_t_8);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_7, function);
    }
  }
  __pyx_t_1 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_8, __pyx_t_6) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_6);
  __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2820, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 2820, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_2 = ((!__pyx_t_3) != 0);
  if (__pyx_t_2) {

    /* "validator.pyx":2821
 *     # Check if the column is datetime type or can be converted to datetime
 *     if not pd.api.types.is_datetime64_any_dtype(data[time_col]):
 *         try:             # <<<<<<<<<<<<<<
 *             pd.to_datetime(data[time_col])
 *         except ValueError:
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_11);
      /*try:*/ {

        /* "validator.pyx":2822
 *     if not pd.api.types.is_datetime64_any_dtype(data[time_col]):
 *         try:
 *             pd.to_datetime(data[time_col])             # <<<<<<<<<<<<<<
 *         except ValueError:
 *             print(f"Column '{time_col}' does not contain datetime objects.")
 */
        __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_pd); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2822, __pyx_L5_error)
        __Pyx_GOTREF(__pyx_t_7);
        __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_to_datetime); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2822, __pyx_L5_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        __pyx_t_7 = __Pyx_PyObject_GetItem(__pyx_v_data, __pyx_v_time_col); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2822, __pyx_L5_error)
        __Pyx_GOTREF(__pyx_t_7);
        __pyx_t_8 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
          __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_6);
          if (likely(__pyx_t_8)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
            __Pyx_INCREF(__pyx_t_8);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_6, function);
          }
        }
        __pyx_t_1 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_8, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_7);
        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2822, __pyx_L5_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "validator.pyx":2821
 *     # Check if the column is datetime type or can be converted to datetime
 *     if not pd.api.types.is_datetime64_any_dtype(data[time_col]):
 *         try:             # <<<<<<<<<<<<<<
 *             pd.to_datetime(data[time_col])
 *         except ValueError:
 */
      }
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
      goto __pyx_L10_try_end;
      __pyx_L5_error:;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;

      /* "validator.pyx":2823
 *         try:
 *             pd.to_datetime(data[time_col])
 *         except ValueError:             # <<<<<<<<<<<<<<
 *             print(f"Column '{time_col}' does not contain datetime objects.")
 *             return False
 */
      __pyx_t_12 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_ValueError);
      if (__pyx_t_12) {
        __Pyx_AddTraceback("validator.is_time_series", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_1, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(0, 2823, __pyx_L7_except_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_GOTREF(__pyx_t_7);

        /* "validator.pyx":2824
 *             pd.to_datetime(data[time_col])
 *         except ValueError:
 *             print(f"Column '{time_col}' does not contain datetime objects.")             # <<<<<<<<<<<<<<
 *             return False
 * 
 */
        __pyx_t_8 = PyTuple_New(3); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 2824, __pyx_L7_except_error)
        __Pyx_GOTREF(__pyx_t_8);
        __pyx_t_4 = 0;
        __pyx_t_5 = 127;
        __Pyx_INCREF(__pyx_kp_u_Column);
        __pyx_t_4 += 8;
        __Pyx_GIVEREF(__pyx_kp_u_Column);
        PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_kp_u_Column);
        __pyx_t_13 = __Pyx_PyObject_FormatSimple(__pyx_v_time_col, __pyx_empty_unicode); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 2824, __pyx_L7_except_error)
        __Pyx_GOTREF(__pyx_t_13);
        __pyx_t_5 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_13) > __pyx_t_5) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_13) : __pyx_t_5;
        __pyx_t_4 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_13);
        __Pyx_GIVEREF(__pyx_t_13);
        PyTuple_SET_ITEM(__pyx_t_8, 1, __pyx_t_13);
        __pyx_t_13 = 0;
        __Pyx_INCREF(__pyx_kp_u_does_not_contain_datetime_objec);
        __pyx_t_4 += 36;
        __Pyx_GIVEREF(__pyx_kp_u_does_not_contain_datetime_objec);
        PyTuple_SET_ITEM(__pyx_t_8, 2, __pyx_kp_u_does_not_contain_datetime_objec);
        __pyx_t_13 = __Pyx_PyUnicode_Join(__pyx_t_8, 3, __pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 2824, __pyx_L7_except_error)
        __Pyx_GOTREF(__pyx_t_13);
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
        __pyx_t_8 = __Pyx_PyObject_CallOneArg(__pyx_builtin_print, __pyx_t_13); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 2824, __pyx_L7_except_error)
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;

        /* "validator.pyx":2825
 *         except ValueError:
 *             print(f"Column '{time_col}' does not contain datetime objects.")
 *             return False             # <<<<<<<<<<<<<<
 * 
 *     if check_time_interval:
 */
        __Pyx_XDECREF(__pyx_r);
        __Pyx_INCREF(Py_False);
        __pyx_r = Py_False;
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        goto __pyx_L8_except_return;
      }
      goto __pyx_L7_except_error;
      __pyx_L7_except_error:;

      /* "validator.pyx":2821
 *     # Check if the column is datetime type or can be converted to datetime
 *     if not pd.api.types.is_datetime64_any_dtype(data[time_col]):
 *         try:             # <<<<<<<<<<<<<<
 *             pd.to_datetime(data[time_col])
 *         except ValueError:
 */
      __Pyx_XGIVEREF(__pyx_t_9);
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_11);
      __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_10, __pyx_t_11);
      goto __pyx_L1_error;
      __pyx_L8_except_return:;
      __Pyx_XGIVEREF(__pyx_t_9);
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_11);
      __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_10, __pyx_t_11);
      goto __pyx_L0;
      __pyx_L10_try_end:;
    }

    /* "validator.pyx":2820
 * 
 *     # Check if the column is datetime type or can be converted to datetime
 *     if not pd.api.types.is_datetime64_any_dtype(data[time_col]):             # <<<<<<<<<<<<<<
 *         try:
 *             pd.to_datetime(data[time_col])
 */
  }

  /* "validator.pyx":2827
 *             return False
 * 
 *     if check_time_interval:             # <<<<<<<<<<<<<<
 *         # Optional: Check for regular intervals (commented out by default)
 *         intervals = pd.to_datetime(data[time_col]).diff().dropna()
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_check_time_interval); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 2827, __pyx_L1_error)
  if (__pyx_t_2) {

    /* "validator.pyx":2829
 *     if check_time_interval:
 *         # Optional: Check for regular intervals (commented out by default)
 *         intervals = pd.to_datetime(data[time_col]).diff().dropna()             # <<<<<<<<<<<<<<
 *         if not intervals.nunique() == 1:
 *             print("Time intervals are not regular.")
 */
    __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_pd); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 2829, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_to_datetime); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 2829, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_13);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_8 = __Pyx_PyObject_GetItem(__pyx_v_data, __pyx_v_time_col); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 2829, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_14 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_13))) {
      __pyx_t_14 = PyMethod_GET_SELF(__pyx_t_13);
      if (likely(__pyx_t_14)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_13);
        __Pyx_INCREF(__pyx_t_14);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_13, function);
      }
    }
    __pyx_t_1 = (__pyx_t_14) ? __Pyx_PyObject_Call2Args(__pyx_t_13, __pyx_t_14, __pyx_t_8) : __Pyx_PyObject_CallOneArg(__pyx_t_13, __pyx_t_8);
    __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2829, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
    __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_diff); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 2829, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_13);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_13))) {
      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_13);
      if (likely(__pyx_t_1)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_13);
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_13, function);
      }
    }
    __pyx_t_6 = (__pyx_t_1) ? __Pyx_PyObject_CallOneArg(__pyx_t_13, __pyx_t_1) : __Pyx_PyObject_CallNoArg(__pyx_t_13);
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2829, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
    __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_dropna); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 2829, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_13);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_13))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_13);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_13);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_13, function);
      }
    }
    __pyx_t_7 = (__pyx_t_6) ? __Pyx_PyObject_CallOneArg(__pyx_t_13, __pyx_t_6) : __Pyx_PyObject_CallNoArg(__pyx_t_13);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2829, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
    __pyx_v_intervals = __pyx_t_7;
    __pyx_t_7 = 0;

    /* "validator.pyx":2830
 *         # Optional: Check for regular intervals (commented out by default)
 *         intervals = pd.to_datetime(data[time_col]).diff().dropna()
 *         if not intervals.nunique() == 1:             # <<<<<<<<<<<<<<
 *             print("Time intervals are not regular.")
 *             return False
 */
    __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_v_intervals, __pyx_n_s_nunique); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 2830, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_13);
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_13))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_13);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_13);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_13, function);
      }
    }
    __pyx_t_7 = (__pyx_t_6) ? __Pyx_PyObject_CallOneArg(__pyx_t_13, __pyx_t_6) : __Pyx_PyObject_CallNoArg(__pyx_t_13);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2830, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
    __pyx_t_13 = __Pyx_PyInt_EqObjC(__pyx_t_7, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 2830, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_13);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_13); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 2830, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
    __pyx_t_3 = ((!__pyx_t_2) != 0);
    if (__pyx_t_3) {

      /* "validator.pyx":2831
 *         intervals = pd.to_datetime(data[time_col]).diff().dropna()
 *         if not intervals.nunique() == 1:
 *             print("Time intervals are not regular.")             # <<<<<<<<<<<<<<
 *             return False
 * 
 */
      __pyx_t_13 = __Pyx_PyObject_Call(__pyx_builtin_print, __pyx_tuple__75, NULL); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 2831, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_13);
      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;

      /* "validator.pyx":2832
 *         if not intervals.nunique() == 1:
 *             print("Time intervals are not regular.")
 *             return False             # <<<<<<<<<<<<<<
 * 
 *     return True
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_False);
      __pyx_r = Py_False;
      goto __pyx_L0;

      /* "validator.pyx":2830
 *         # Optional: Check for regular intervals (commented out by default)
 *         intervals = pd.to_datetime(data[time_col]).diff().dropna()
 *         if not intervals.nunique() == 1:             # <<<<<<<<<<<<<<
 *             print("Time intervals are not regular.")
 *             return False
 */
    }

    /* "validator.pyx":2827
 *             return False
 * 
 *     if check_time_interval:             # <<<<<<<<<<<<<<
 *         # Optional: Check for regular intervals (commented out by default)
 *         intervals = pd.to_datetime(data[time_col]).diff().dropna()
 */
  }

  /* "validator.pyx":2834
 *             return False
 * 
 *     return True             # <<<<<<<<<<<<<<
 * 
 * def check_is_fitted2(estimator, attributes, *, msg=None):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_True);
  __pyx_r = Py_True;
  goto __pyx_L0;

  /* "validator.pyx":2787
 *     return module_spec is not None
 * 
 * def is_time_series(data, time_col, check_time_interval=False ):             # <<<<<<<<<<<<<<
 *     """
 *     Check if the provided DataFrame is time series data.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_13);
  __Pyx_XDECREF(__pyx_t_14);
  __Pyx_AddTraceback("validator.is_time_series", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_intervals);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2836
 *     return True
 * 
 * def check_is_fitted2(estimator, attributes, *, msg=None):             # <<<<<<<<<<<<<<
 *     """
 *     Perform is_fitted validation for estimator.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_81check_is_fitted2(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_80check_is_fitted2[] = "\n    Perform is_fitted validation for estimator.\n\n    Checks if the estimator is fitted by looking for attributes set during fitting.\n    Typically, these attributes end with an underscore ('_').\n\n    Parameters\n    ----------\n    estimator : BaseEstimator\n        An instance of a scikit-learn estimator.\n\n    attributes : str or list of str\n        The attributes to check for. These are typically set in the 'fit' method.\n\n    msg : str, optional\n        The message to raise in the NotFittedError. If not provided, a default\n        message is used.\n\n    Raises\n    ------\n    NotFittedError\n        If the given attributes are not found in the estimator.\n\n    Examples\n    --------\n    >>> from sklearn.ensemble import RandomForestClassifier\n    >>> clf = RandomForestClassifier()\n    >>> check_is_fitted(clf, ['feature_importances_'])\n    NotFittedError: This RandomForestClassifier instance is not fitted yet.\n    ";
static PyMethodDef __pyx_mdef_9validator_81check_is_fitted2 = {"check_is_fitted2", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_81check_is_fitted2, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_80check_is_fitted2};
static PyObject *__pyx_pw_9validator_81check_is_fitted2(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_estimator = 0;
  PyObject *__pyx_v_attributes = 0;
  PyObject *__pyx_v_msg = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("check_is_fitted2 (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_estimator,&__pyx_n_s_attributes,&__pyx_n_s_msg,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_estimator)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_attributes)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("check_is_fitted2", 1, 2, 2, 1); __PYX_ERR(0, 2836, __pyx_L3_error)
        }
      }
      if (kw_args == 1) {
        const Py_ssize_t index = 2;
        PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
        if (value) { values[index] = value; kw_args--; }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "check_is_fitted2") < 0)) __PYX_ERR(0, 2836, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_estimator = values[0];
    __pyx_v_attributes = values[1];
    __pyx_v_msg = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("check_is_fitted2", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2836, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.check_is_fitted2", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_80check_is_fitted2(__pyx_self, __pyx_v_estimator, __pyx_v_attributes, __pyx_v_msg);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_80check_is_fitted2(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_estimator, PyObject *__pyx_v_attributes, PyObject *__pyx_v_msg) {
  PyObject *__pyx_v_NotFittedError = NULL;
  PyObject *__pyx_v_fitted = NULL;
  PyObject *__pyx_v_cls_name = NULL;
  PyObject *__pyx_9genexpr15__pyx_v_attr = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  Py_ssize_t __pyx_t_6;
  PyObject *(*__pyx_t_7)(PyObject *);
  PyObject *__pyx_t_8 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("check_is_fitted2", 0);
  __Pyx_INCREF(__pyx_v_attributes);
  __Pyx_INCREF(__pyx_v_msg);

  /* "validator.pyx":2867
 *     NotFittedError: This RandomForestClassifier instance is not fitted yet.
 *     """
 *     from ..exceptions import NotFittedError             # <<<<<<<<<<<<<<
 *     if not hasattr(estimator, "fit"):
 *         raise TypeError("%s is not an estimator instance." % (estimator))
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2867, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_NotFittedError);
  __Pyx_GIVEREF(__pyx_n_s_NotFittedError);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_NotFittedError);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_exceptions, __pyx_t_1, 2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2867, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_NotFittedError); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2867, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_t_1);
  __pyx_v_NotFittedError = __pyx_t_1;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":2868
 *     """
 *     from ..exceptions import NotFittedError
 *     if not hasattr(estimator, "fit"):             # <<<<<<<<<<<<<<
 *         raise TypeError("%s is not an estimator instance." % (estimator))
 * 
 */
  __pyx_t_3 = __Pyx_HasAttr(__pyx_v_estimator, __pyx_n_u_fit); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 2868, __pyx_L1_error)
  __pyx_t_4 = ((!(__pyx_t_3 != 0)) != 0);
  if (unlikely(__pyx_t_4)) {

    /* "validator.pyx":2869
 *     from ..exceptions import NotFittedError
 *     if not hasattr(estimator, "fit"):
 *         raise TypeError("%s is not an estimator instance." % (estimator))             # <<<<<<<<<<<<<<
 * 
 *     if not isinstance(attributes, (list, tuple)):
 */
    __pyx_t_2 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_s_is_not_an_estimator_instance, __pyx_v_estimator); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2869, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2869, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 2869, __pyx_L1_error)

    /* "validator.pyx":2868
 *     """
 *     from ..exceptions import NotFittedError
 *     if not hasattr(estimator, "fit"):             # <<<<<<<<<<<<<<
 *         raise TypeError("%s is not an estimator instance." % (estimator))
 * 
 */
  }

  /* "validator.pyx":2871
 *         raise TypeError("%s is not an estimator instance." % (estimator))
 * 
 *     if not isinstance(attributes, (list, tuple)):             # <<<<<<<<<<<<<<
 *         attributes = [attributes]
 * 
 */
  __pyx_t_3 = PyList_Check(__pyx_v_attributes); 
  __pyx_t_5 = (__pyx_t_3 != 0);
  if (!__pyx_t_5) {
  } else {
    __pyx_t_4 = __pyx_t_5;
    goto __pyx_L5_bool_binop_done;
  }
  __pyx_t_5 = PyTuple_Check(__pyx_v_attributes); 
  __pyx_t_3 = (__pyx_t_5 != 0);
  __pyx_t_4 = __pyx_t_3;
  __pyx_L5_bool_binop_done:;
  __pyx_t_3 = ((!(__pyx_t_4 != 0)) != 0);
  if (__pyx_t_3) {

    /* "validator.pyx":2872
 * 
 *     if not isinstance(attributes, (list, tuple)):
 *         attributes = [attributes]             # <<<<<<<<<<<<<<
 * 
 *     fitted = all([hasattr(estimator, attr) for attr in attributes])
 */
    __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2872, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_INCREF(__pyx_v_attributes);
    __Pyx_GIVEREF(__pyx_v_attributes);
    PyList_SET_ITEM(__pyx_t_1, 0, __pyx_v_attributes);
    __Pyx_DECREF_SET(__pyx_v_attributes, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "validator.pyx":2871
 *         raise TypeError("%s is not an estimator instance." % (estimator))
 * 
 *     if not isinstance(attributes, (list, tuple)):             # <<<<<<<<<<<<<<
 *         attributes = [attributes]
 * 
 */
  }

  /* "validator.pyx":2874
 *         attributes = [attributes]
 * 
 *     fitted = all([hasattr(estimator, attr) for attr in attributes])             # <<<<<<<<<<<<<<
 * 
 *     if not fitted:
 */
  { /* enter inner scope */
    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2874, __pyx_L9_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (likely(PyList_CheckExact(__pyx_v_attributes)) || PyTuple_CheckExact(__pyx_v_attributes)) {
      __pyx_t_2 = __pyx_v_attributes; __Pyx_INCREF(__pyx_t_2); __pyx_t_6 = 0;
      __pyx_t_7 = NULL;
    } else {
      __pyx_t_6 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_v_attributes); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2874, __pyx_L9_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_7 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2874, __pyx_L9_error)
    }
    for (;;) {
      if (likely(!__pyx_t_7)) {
        if (likely(PyList_CheckExact(__pyx_t_2))) {
          if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_2)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_8 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_6); __Pyx_INCREF(__pyx_t_8); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 2874, __pyx_L9_error)
          #else
          __pyx_t_8 = PySequence_ITEM(__pyx_t_2, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 2874, __pyx_L9_error)
          __Pyx_GOTREF(__pyx_t_8);
          #endif
        } else {
          if (__pyx_t_6 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_8 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_6); __Pyx_INCREF(__pyx_t_8); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 2874, __pyx_L9_error)
          #else
          __pyx_t_8 = PySequence_ITEM(__pyx_t_2, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 2874, __pyx_L9_error)
          __Pyx_GOTREF(__pyx_t_8);
          #endif
        }
      } else {
        __pyx_t_8 = __pyx_t_7(__pyx_t_2);
        if (unlikely(!__pyx_t_8)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else __PYX_ERR(0, 2874, __pyx_L9_error)
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_8);
      }
      __Pyx_XDECREF_SET(__pyx_9genexpr15__pyx_v_attr, __pyx_t_8);
      __pyx_t_8 = 0;
      __pyx_t_3 = __Pyx_HasAttr(__pyx_v_estimator, __pyx_9genexpr15__pyx_v_attr); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 2874, __pyx_L9_error)
      __pyx_t_8 = __Pyx_PyBool_FromLong(__pyx_t_3); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 2874, __pyx_L9_error)
      __Pyx_GOTREF(__pyx_t_8);
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_8))) __PYX_ERR(0, 2874, __pyx_L9_error)
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_9genexpr15__pyx_v_attr); __pyx_9genexpr15__pyx_v_attr = 0;
    goto __pyx_L12_exit_scope;
    __pyx_L9_error:;
    __Pyx_XDECREF(__pyx_9genexpr15__pyx_v_attr); __pyx_9genexpr15__pyx_v_attr = 0;
    goto __pyx_L1_error;
    __pyx_L12_exit_scope:;
  } /* exit inner scope */
  __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_all, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2874, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_fitted = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "validator.pyx":2876
 *     fitted = all([hasattr(estimator, attr) for attr in attributes])
 * 
 *     if not fitted:             # <<<<<<<<<<<<<<
 *         if msg is None:
 *             cls_name = estimator.__class__.__name__
 */
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_fitted); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 2876, __pyx_L1_error)
  __pyx_t_4 = ((!__pyx_t_3) != 0);
  if (__pyx_t_4) {

    /* "validator.pyx":2877
 * 
 *     if not fitted:
 *         if msg is None:             # <<<<<<<<<<<<<<
 *             cls_name = estimator.__class__.__name__
 *             msg = ("This %s instance is not fitted yet. Call 'fit' with appropriate "
 */
    __pyx_t_4 = (__pyx_v_msg == Py_None);
    __pyx_t_3 = (__pyx_t_4 != 0);
    if (__pyx_t_3) {

      /* "validator.pyx":2878
 *     if not fitted:
 *         if msg is None:
 *             cls_name = estimator.__class__.__name__             # <<<<<<<<<<<<<<
 *             msg = ("This %s instance is not fitted yet. Call 'fit' with appropriate "
 *                    "arguments before using this estimator." % cls_name)
 */
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_estimator, __pyx_n_s_class); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2878, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2878, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_v_cls_name = __pyx_t_1;
      __pyx_t_1 = 0;

      /* "validator.pyx":2880
 *             cls_name = estimator.__class__.__name__
 *             msg = ("This %s instance is not fitted yet. Call 'fit' with appropriate "
 *                    "arguments before using this estimator." % cls_name)             # <<<<<<<<<<<<<<
 * 
 *         raise NotFittedError(msg)
 */
      __pyx_t_1 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_This_s_instance_is_not_fitted_ye, __pyx_v_cls_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2880, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF_SET(__pyx_v_msg, __pyx_t_1);
      __pyx_t_1 = 0;

      /* "validator.pyx":2877
 * 
 *     if not fitted:
 *         if msg is None:             # <<<<<<<<<<<<<<
 *             cls_name = estimator.__class__.__name__
 *             msg = ("This %s instance is not fitted yet. Call 'fit' with appropriate "
 */
    }

    /* "validator.pyx":2882
 *                    "arguments before using this estimator." % cls_name)
 * 
 *         raise NotFittedError(msg)             # <<<<<<<<<<<<<<
 * 
 * def assert_xy_in (
 */
    __Pyx_INCREF(__pyx_v_NotFittedError);
    __pyx_t_2 = __pyx_v_NotFittedError; __pyx_t_8 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_8)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_8);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    __pyx_t_1 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_8, __pyx_v_msg) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_msg);
    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2882, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 2882, __pyx_L1_error)

    /* "validator.pyx":2876
 *     fitted = all([hasattr(estimator, attr) for attr in attributes])
 * 
 *     if not fitted:             # <<<<<<<<<<<<<<
 *         if msg is None:
 *             cls_name = estimator.__class__.__name__
 */
  }

  /* "validator.pyx":2836
 *     return True
 * 
 * def check_is_fitted2(estimator, attributes, *, msg=None):             # <<<<<<<<<<<<<<
 *     """
 *     Perform is_fitted validation for estimator.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("validator.check_is_fitted2", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_NotFittedError);
  __Pyx_XDECREF(__pyx_v_fitted);
  __Pyx_XDECREF(__pyx_v_cls_name);
  __Pyx_XDECREF(__pyx_9genexpr15__pyx_v_attr);
  __Pyx_XDECREF(__pyx_v_attributes);
  __Pyx_XDECREF(__pyx_v_msg);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":2884
 *         raise NotFittedError(msg)
 * 
 * def assert_xy_in (             # <<<<<<<<<<<<<<
 *     x,
 *     y, *,
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_83assert_xy_in(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_82assert_xy_in[] = "\n    Assert the name of x and y in the given data. \n    \n    Check whether string arguments passed to x and y are valid in the data, \n    then retrieve the x and y array values. \n    \n    Parameters \n    -----------\n    x, y : Arraylike 1d or str, str  \n       One dimensional arrays. In principle if data is supplied, they must \n       constitute series.  If `x` and `y` are given as string values, the \n       `data` must be supplied. x and y names must be included in the  \n       dataframe otherwise an error raises. \n       \n    data: pd.DataFrame, \n       Data containing x and y names. Need to be supplied when x and y \n       are given as string names. \n    asarray: bool, default =True \n       Returns x and y as array rather than series. \n    to_frame: bool, default=False, \n       Convert data to a dataframe using either the columns names or \n       the input_names when the keyword parameter ``force=True``.\n    columns: list of str, Optional \n       Name of columns to transform the array ( ``data``) to a dataframe. \n    xy_numeric:bool, default=False\n       Convert x and y to numeric values. \n    ignore: str, optional \n       It should be 'x' or 'y'. If set the array is ignored and not asserted. \n       \n    kws: dict, \n       Keyword arguments passed to :func:`~.array_to_frame`.\n       \n       \n    Returns \n    --------\n    x, y : Arraylike \n       One dimensional array or pd.Series \n      \n    Examples \n    ---------\n    >>> import numpy as np \n    >>> import pandas as pd \n    >>> from gofast.tools.validator import assert_xy_in \n    >>> x, y = np.random.rand(7 ), np.arange (7 ) \n    >>> data = pd.DataFrame ({'x': x, 'y':y} ) \n    >>> assert_xy_in (x='x', y='y', data = data ) \n    (array([0.37454012, 0.95071431, 0.73199394, 0.59865848, 0.15601864,\n            0.15599452, 0.05808361]),\n     array([0, 1, 2, 3, 4, 5, 6]))\n    >>> assert_xy_in (x=x, y=y) \n    (array([0.37454012, 0.95071431, 0.73199394, 0.59865848, 0.156""01864,\n            0.15599452, 0.05808361]),\n     array([0, 1, 2, 3, 4, 5, 6]))\n    >>> assert_xy_in (x=x, y=data.y) # y is a series \n    (array([0.37454012, 0.95071431, 0.73199394, 0.59865848, 0.15601864,\n            0.15599452, 0.05808361]),\n     array([0, 1, 2, 3, 4, 5, 6]))\n    >>> assert_xy_in (x=x, y=data.y, asarray =False ) # return y like it was\n    (array([0.37454012, 0.95071431, 0.73199394, 0.59865848, 0.15601864,\n            0.15599452, 0.05808361]),\n    0    0\n    1    1\n    2    2\n    3    3\n    4    4\n    5    5\n    6    6\n    Name: y, dtype: int32)\n    ";
static PyMethodDef __pyx_mdef_9validator_83assert_xy_in = {"assert_xy_in", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_83assert_xy_in, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_82assert_xy_in};
static PyObject *__pyx_pw_9validator_83assert_xy_in(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_x = 0;
  PyObject *__pyx_v_y = 0;
  PyObject *__pyx_v_data = 0;
  PyObject *__pyx_v_asarray = 0;
  PyObject *__pyx_v_to_frame = 0;
  PyObject *__pyx_v_columns = 0;
  PyObject *__pyx_v_xy_numeric = 0;
  PyObject *__pyx_v_ignore = 0;
  PyObject *__pyx_v_kws = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("assert_xy_in (wrapper)", 0);
  __pyx_v_kws = PyDict_New(); if (unlikely(!__pyx_v_kws)) return NULL;
  __Pyx_GOTREF(__pyx_v_kws);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_x,&__pyx_n_s_y,&__pyx_n_s_data,&__pyx_n_s_asarray,&__pyx_n_s_to_frame,&__pyx_n_s_columns,&__pyx_n_s_xy_numeric,&__pyx_n_s_ignore,0};
    PyObject* values[8] = {0,0,0,0,0,0,0,0};

    /* "validator.pyx":2887
 *     x,
 *     y, *,
 *     data=None,             # <<<<<<<<<<<<<<
 *     asarray=True,
 *     to_frame=False,
 */
    values[2] = ((PyObject *)Py_None);

    /* "validator.pyx":2888
 *     y, *,
 *     data=None,
 *     asarray=True,             # <<<<<<<<<<<<<<
 *     to_frame=False,
 *     columns= None,
 */
    values[3] = ((PyObject *)Py_True);

    /* "validator.pyx":2889
 *     data=None,
 *     asarray=True,
 *     to_frame=False,             # <<<<<<<<<<<<<<
 *     columns= None,
 *     xy_numeric=False,
 */
    values[4] = ((PyObject *)Py_False);

    /* "validator.pyx":2890
 *     asarray=True,
 *     to_frame=False,
 *     columns= None,             # <<<<<<<<<<<<<<
 *     xy_numeric=False,
 *     ignore=None,
 */
    values[5] = ((PyObject *)Py_None);

    /* "validator.pyx":2891
 *     to_frame=False,
 *     columns= None,
 *     xy_numeric=False,             # <<<<<<<<<<<<<<
 *     ignore=None,
 *     **kws
 */
    values[6] = ((PyObject *)Py_False);

    /* "validator.pyx":2892
 *     columns= None,
 *     xy_numeric=False,
 *     ignore=None,             # <<<<<<<<<<<<<<
 *     **kws
 *     ):
 */
    values[7] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("assert_xy_in", 1, 2, 2, 1); __PYX_ERR(0, 2884, __pyx_L3_error)
        }
      }
      if (kw_args > 0 && (kw_args <= 6)) {
        Py_ssize_t index;
        for (index = 2; index < 8 && kw_args > 0; index++) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
          if (value) { values[index] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kws, values, pos_args, "assert_xy_in") < 0)) __PYX_ERR(0, 2884, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_x = values[0];
    __pyx_v_y = values[1];
    __pyx_v_data = values[2];
    __pyx_v_asarray = values[3];
    __pyx_v_to_frame = values[4];
    __pyx_v_columns = values[5];
    __pyx_v_xy_numeric = values[6];
    __pyx_v_ignore = values[7];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("assert_xy_in", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2884, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_DECREF(__pyx_v_kws); __pyx_v_kws = 0;
  __Pyx_AddTraceback("validator.assert_xy_in", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_82assert_xy_in(__pyx_self, __pyx_v_x, __pyx_v_y, __pyx_v_data, __pyx_v_asarray, __pyx_v_to_frame, __pyx_v_columns, __pyx_v_xy_numeric, __pyx_v_ignore, __pyx_v_kws);

  /* "validator.pyx":2884
 *         raise NotFittedError(msg)
 * 
 * def assert_xy_in (             # <<<<<<<<<<<<<<
 *     x,
 *     y, *,
 */

  /* function exit code */
  __Pyx_XDECREF(__pyx_v_kws);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_82assert_xy_in(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_x, PyObject *__pyx_v_y, PyObject *__pyx_v_data, PyObject *__pyx_v_asarray, PyObject *__pyx_v_to_frame, PyObject *__pyx_v_columns, PyObject *__pyx_v_xy_numeric, PyObject *__pyx_v_ignore, PyObject *__pyx_v_kws) {
  PyObject *__pyx_v_exist_features = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_t_7;
  int __pyx_t_8;
  PyObject *__pyx_t_9 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("assert_xy_in", 0);
  __Pyx_INCREF(__pyx_v_x);
  __Pyx_INCREF(__pyx_v_y);
  __Pyx_INCREF(__pyx_v_data);

  /* "validator.pyx":2964
 *     Name: y, dtype: int32)
 *     """
 *     from .coreutils import exist_features             # <<<<<<<<<<<<<<
 *     if to_frame :
 *         data = array_to_frame(data , to_frame = True ,  input_name ='Data',
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2964, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_exist_features);
  __Pyx_GIVEREF(__pyx_n_s_exist_features);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_exist_features);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_coreutils, __pyx_t_1, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2964, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_exist_features); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2964, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_t_1);
  __pyx_v_exist_features = __pyx_t_1;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":2965
 *     """
 *     from .coreutils import exist_features
 *     if to_frame :             # <<<<<<<<<<<<<<
 *         data = array_to_frame(data , to_frame = True ,  input_name ='Data',
 *                               columns =columns , **kws)
 */
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_to_frame); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 2965, __pyx_L1_error)
  if (__pyx_t_3) {

    /* "validator.pyx":2966
 *     from .coreutils import exist_features
 *     if to_frame :
 *         data = array_to_frame(data , to_frame = True ,  input_name ='Data',             # <<<<<<<<<<<<<<
 *                               columns =columns , **kws)
 *     if data is not None:
 */
    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_array_to_frame); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2966, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2966, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_INCREF(__pyx_v_data);
    __Pyx_GIVEREF(__pyx_v_data);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_data);
    __pyx_t_5 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2966, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_to_frame, Py_True) < 0) __PYX_ERR(0, 2966, __pyx_L1_error)
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_input_name, __pyx_n_u_Data) < 0) __PYX_ERR(0, 2966, __pyx_L1_error)

    /* "validator.pyx":2967
 *     if to_frame :
 *         data = array_to_frame(data , to_frame = True ,  input_name ='Data',
 *                               columns =columns , **kws)             # <<<<<<<<<<<<<<
 *     if data is not None:
 *         if not hasattr (data, '__array__') and not hasattr(data, 'columns'):
 */
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_columns, __pyx_v_columns) < 0) __PYX_ERR(0, 2966, __pyx_L1_error)
    __pyx_t_4 = __pyx_t_5;
    __pyx_t_5 = 0;
    if (__Pyx_MergeKeywords(__pyx_t_4, __pyx_v_kws) < 0) __PYX_ERR(0, 2967, __pyx_L1_error)

    /* "validator.pyx":2966
 *     from .coreutils import exist_features
 *     if to_frame :
 *         data = array_to_frame(data , to_frame = True ,  input_name ='Data',             # <<<<<<<<<<<<<<
 *                               columns =columns , **kws)
 *     if data is not None:
 */
    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_1, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2966, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_5);
    __pyx_t_5 = 0;

    /* "validator.pyx":2965
 *     """
 *     from .coreutils import exist_features
 *     if to_frame :             # <<<<<<<<<<<<<<
 *         data = array_to_frame(data , to_frame = True ,  input_name ='Data',
 *                               columns =columns , **kws)
 */
  }

  /* "validator.pyx":2968
 *         data = array_to_frame(data , to_frame = True ,  input_name ='Data',
 *                               columns =columns , **kws)
 *     if data is not None:             # <<<<<<<<<<<<<<
 *         if not hasattr (data, '__array__') and not hasattr(data, 'columns'):
 *             raise TypeError(f"Expect a dataframe. Got {type (data).__name__!r}")
 */
  __pyx_t_3 = (__pyx_v_data != Py_None);
  __pyx_t_6 = (__pyx_t_3 != 0);
  if (__pyx_t_6) {

    /* "validator.pyx":2969
 *                               columns =columns , **kws)
 *     if data is not None:
 *         if not hasattr (data, '__array__') and not hasattr(data, 'columns'):             # <<<<<<<<<<<<<<
 *             raise TypeError(f"Expect a dataframe. Got {type (data).__name__!r}")
 * 
 */
    __pyx_t_3 = __Pyx_HasAttr(__pyx_v_data, __pyx_n_u_array_2); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 2969, __pyx_L1_error)
    __pyx_t_7 = ((!(__pyx_t_3 != 0)) != 0);
    if (__pyx_t_7) {
    } else {
      __pyx_t_6 = __pyx_t_7;
      goto __pyx_L6_bool_binop_done;
    }
    __pyx_t_7 = __Pyx_HasAttr(__pyx_v_data, __pyx_n_u_columns); if (unlikely(__pyx_t_7 == ((int)-1))) __PYX_ERR(0, 2969, __pyx_L1_error)
    __pyx_t_3 = ((!(__pyx_t_7 != 0)) != 0);
    __pyx_t_6 = __pyx_t_3;
    __pyx_L6_bool_binop_done:;
    if (unlikely(__pyx_t_6)) {

      /* "validator.pyx":2970
 *     if data is not None:
 *         if not hasattr (data, '__array__') and not hasattr(data, 'columns'):
 *             raise TypeError(f"Expect a dataframe. Got {type (data).__name__!r}")             # <<<<<<<<<<<<<<
 * 
 *     if  (
 */
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_data)), __pyx_n_s_name); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2970, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_4 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_t_5), __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2970, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_5 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Expect_a_dataframe_Got, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2970, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2970, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __PYX_ERR(0, 2970, __pyx_L1_error)

      /* "validator.pyx":2969
 *                               columns =columns , **kws)
 *     if data is not None:
 *         if not hasattr (data, '__array__') and not hasattr(data, 'columns'):             # <<<<<<<<<<<<<<
 *             raise TypeError(f"Expect a dataframe. Got {type (data).__name__!r}")
 * 
 */
    }

    /* "validator.pyx":2968
 *         data = array_to_frame(data , to_frame = True ,  input_name ='Data',
 *                               columns =columns , **kws)
 *     if data is not None:             # <<<<<<<<<<<<<<
 *         if not hasattr (data, '__array__') and not hasattr(data, 'columns'):
 *             raise TypeError(f"Expect a dataframe. Got {type (data).__name__!r}")
 */
  }

  /* "validator.pyx":2973
 * 
 *     if  (
 *             ( isinstance (x, str) or isinstance (y, str))             # <<<<<<<<<<<<<<
 *             and data is None) :
 *         raise TypeError("Data cannot be None when x and y have string"
 */
  __pyx_t_3 = PyUnicode_Check(__pyx_v_x); 
  __pyx_t_7 = (__pyx_t_3 != 0);
  if (!__pyx_t_7) {
  } else {
    goto __pyx_L10_next_and;
  }
  __pyx_t_7 = PyUnicode_Check(__pyx_v_y); 
  __pyx_t_3 = (__pyx_t_7 != 0);
  if (__pyx_t_3) {
  } else {
    __pyx_t_6 = __pyx_t_3;
    goto __pyx_L9_bool_binop_done;
  }
  __pyx_L10_next_and:;

  /* "validator.pyx":2974
 *     if  (
 *             ( isinstance (x, str) or isinstance (y, str))
 *             and data is None) :             # <<<<<<<<<<<<<<
 *         raise TypeError("Data cannot be None when x and y have string"
 *                         " arguments.")
 */
  __pyx_t_3 = (__pyx_v_data == Py_None);
  __pyx_t_7 = (__pyx_t_3 != 0);
  __pyx_t_6 = __pyx_t_7;
  __pyx_L9_bool_binop_done:;

  /* "validator.pyx":2972
 *             raise TypeError(f"Expect a dataframe. Got {type (data).__name__!r}")
 * 
 *     if  (             # <<<<<<<<<<<<<<
 *             ( isinstance (x, str) or isinstance (y, str))
 *             and data is None) :
 */
  if (unlikely(__pyx_t_6)) {

    /* "validator.pyx":2975
 *             ( isinstance (x, str) or isinstance (y, str))
 *             and data is None) :
 *         raise TypeError("Data cannot be None when x and y have string"             # <<<<<<<<<<<<<<
 *                         " arguments.")
 *     if  (
 */
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__76, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2975, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 2975, __pyx_L1_error)

    /* "validator.pyx":2972
 *             raise TypeError(f"Expect a dataframe. Got {type (data).__name__!r}")
 * 
 *     if  (             # <<<<<<<<<<<<<<
 *             ( isinstance (x, str) or isinstance (y, str))
 *             and data is None) :
 */
  }

  /* "validator.pyx":2978
 *                         " arguments.")
 *     if  (
 *             (x is None or y is None)             # <<<<<<<<<<<<<<
 *             and data is None):
 *         raise TypeError ( "Missing x and y. NoneType not supported.")
 */
  __pyx_t_7 = (__pyx_v_x == Py_None);
  __pyx_t_3 = (__pyx_t_7 != 0);
  if (!__pyx_t_3) {
  } else {
    goto __pyx_L14_next_and;
  }
  __pyx_t_3 = (__pyx_v_y == Py_None);
  __pyx_t_7 = (__pyx_t_3 != 0);
  if (__pyx_t_7) {
  } else {
    __pyx_t_6 = __pyx_t_7;
    goto __pyx_L13_bool_binop_done;
  }
  __pyx_L14_next_and:;

  /* "validator.pyx":2979
 *     if  (
 *             (x is None or y is None)
 *             and data is None):             # <<<<<<<<<<<<<<
 *         raise TypeError ( "Missing x and y. NoneType not supported.")
 * 
 */
  __pyx_t_7 = (__pyx_v_data == Py_None);
  __pyx_t_3 = (__pyx_t_7 != 0);
  __pyx_t_6 = __pyx_t_3;
  __pyx_L13_bool_binop_done:;

  /* "validator.pyx":2977
 *         raise TypeError("Data cannot be None when x and y have string"
 *                         " arguments.")
 *     if  (             # <<<<<<<<<<<<<<
 *             (x is None or y is None)
 *             and data is None):
 */
  if (unlikely(__pyx_t_6)) {

    /* "validator.pyx":2980
 *             (x is None or y is None)
 *             and data is None):
 *         raise TypeError ( "Missing x and y. NoneType not supported.")             # <<<<<<<<<<<<<<
 * 
 *     if isinstance (x, str):
 */
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__77, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2980, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 2980, __pyx_L1_error)

    /* "validator.pyx":2977
 *         raise TypeError("Data cannot be None when x and y have string"
 *                         " arguments.")
 *     if  (             # <<<<<<<<<<<<<<
 *             (x is None or y is None)
 *             and data is None):
 */
  }

  /* "validator.pyx":2982
 *         raise TypeError ( "Missing x and y. NoneType not supported.")
 * 
 *     if isinstance (x, str):             # <<<<<<<<<<<<<<
 *         exist_features(data , x ) ; x = data [x ]
 *     if isinstance (y, str):
 */
  __pyx_t_6 = PyUnicode_Check(__pyx_v_x); 
  __pyx_t_3 = (__pyx_t_6 != 0);
  if (__pyx_t_3) {

    /* "validator.pyx":2983
 * 
 *     if isinstance (x, str):
 *         exist_features(data , x ) ; x = data [x ]             # <<<<<<<<<<<<<<
 *     if isinstance (y, str):
 *         exist_features(data, y) ; y = data [y]
 */
    __Pyx_INCREF(__pyx_v_exist_features);
    __pyx_t_5 = __pyx_v_exist_features; __pyx_t_1 = NULL;
    __pyx_t_8 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_1)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
        __pyx_t_8 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_5)) {
      PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_v_data, __pyx_v_x};
      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2983, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_GOTREF(__pyx_t_4);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
      PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_v_data, __pyx_v_x};
      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2983, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_GOTREF(__pyx_t_4);
    } else
    #endif
    {
      __pyx_t_2 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2983, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      if (__pyx_t_1) {
        __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1); __pyx_t_1 = NULL;
      }
      __Pyx_INCREF(__pyx_v_data);
      __Pyx_GIVEREF(__pyx_v_data);
      PyTuple_SET_ITEM(__pyx_t_2, 0+__pyx_t_8, __pyx_v_data);
      __Pyx_INCREF(__pyx_v_x);
      __Pyx_GIVEREF(__pyx_v_x);
      PyTuple_SET_ITEM(__pyx_t_2, 1+__pyx_t_8, __pyx_v_x);
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_2, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2983, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    }
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_GetItem(__pyx_v_data, __pyx_v_x); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2983, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF_SET(__pyx_v_x, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "validator.pyx":2982
 *         raise TypeError ( "Missing x and y. NoneType not supported.")
 * 
 *     if isinstance (x, str):             # <<<<<<<<<<<<<<
 *         exist_features(data , x ) ; x = data [x ]
 *     if isinstance (y, str):
 */
  }

  /* "validator.pyx":2984
 *     if isinstance (x, str):
 *         exist_features(data , x ) ; x = data [x ]
 *     if isinstance (y, str):             # <<<<<<<<<<<<<<
 *         exist_features(data, y) ; y = data [y]
 * 
 */
  __pyx_t_3 = PyUnicode_Check(__pyx_v_y); 
  __pyx_t_6 = (__pyx_t_3 != 0);
  if (__pyx_t_6) {

    /* "validator.pyx":2985
 *         exist_features(data , x ) ; x = data [x ]
 *     if isinstance (y, str):
 *         exist_features(data, y) ; y = data [y]             # <<<<<<<<<<<<<<
 * 
 *     if hasattr (x, '__len__') and not hasattr(x, '__array__'):
 */
    __Pyx_INCREF(__pyx_v_exist_features);
    __pyx_t_5 = __pyx_v_exist_features; __pyx_t_2 = NULL;
    __pyx_t_8 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_2)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_2);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
        __pyx_t_8 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_5)) {
      PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_data, __pyx_v_y};
      __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2985, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_4);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
      PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_data, __pyx_v_y};
      __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2985, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_GOTREF(__pyx_t_4);
    } else
    #endif
    {
      __pyx_t_1 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2985, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (__pyx_t_2) {
        __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2); __pyx_t_2 = NULL;
      }
      __Pyx_INCREF(__pyx_v_data);
      __Pyx_GIVEREF(__pyx_v_data);
      PyTuple_SET_ITEM(__pyx_t_1, 0+__pyx_t_8, __pyx_v_data);
      __Pyx_INCREF(__pyx_v_y);
      __Pyx_GIVEREF(__pyx_v_y);
      PyTuple_SET_ITEM(__pyx_t_1, 1+__pyx_t_8, __pyx_v_y);
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_1, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2985, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    }
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_GetItem(__pyx_v_data, __pyx_v_y); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2985, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF_SET(__pyx_v_y, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "validator.pyx":2984
 *     if isinstance (x, str):
 *         exist_features(data , x ) ; x = data [x ]
 *     if isinstance (y, str):             # <<<<<<<<<<<<<<
 *         exist_features(data, y) ; y = data [y]
 * 
 */
  }

  /* "validator.pyx":2987
 *         exist_features(data, y) ; y = data [y]
 * 
 *     if hasattr (x, '__len__') and not hasattr(x, '__array__'):             # <<<<<<<<<<<<<<
 *         x = np.array(x )
 *     if hasattr (y, '__len__') and not hasattr(y, '__array__'):
 */
  __pyx_t_3 = __Pyx_HasAttr(__pyx_v_x, __pyx_n_u_len); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 2987, __pyx_L1_error)
  __pyx_t_7 = (__pyx_t_3 != 0);
  if (__pyx_t_7) {
  } else {
    __pyx_t_6 = __pyx_t_7;
    goto __pyx_L19_bool_binop_done;
  }
  __pyx_t_7 = __Pyx_HasAttr(__pyx_v_x, __pyx_n_u_array_2); if (unlikely(__pyx_t_7 == ((int)-1))) __PYX_ERR(0, 2987, __pyx_L1_error)
  __pyx_t_3 = ((!(__pyx_t_7 != 0)) != 0);
  __pyx_t_6 = __pyx_t_3;
  __pyx_L19_bool_binop_done:;
  if (__pyx_t_6) {

    /* "validator.pyx":2988
 * 
 *     if hasattr (x, '__len__') and not hasattr(x, '__array__'):
 *         x = np.array(x )             # <<<<<<<<<<<<<<
 *     if hasattr (y, '__len__') and not hasattr(y, '__array__'):
 *         y = np.array(y )
 */
    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2988, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_array); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2988, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    __pyx_t_4 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_5, __pyx_v_x) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_x);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2988, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF_SET(__pyx_v_x, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "validator.pyx":2987
 *         exist_features(data, y) ; y = data [y]
 * 
 *     if hasattr (x, '__len__') and not hasattr(x, '__array__'):             # <<<<<<<<<<<<<<
 *         x = np.array(x )
 *     if hasattr (y, '__len__') and not hasattr(y, '__array__'):
 */
  }

  /* "validator.pyx":2989
 *     if hasattr (x, '__len__') and not hasattr(x, '__array__'):
 *         x = np.array(x )
 *     if hasattr (y, '__len__') and not hasattr(y, '__array__'):             # <<<<<<<<<<<<<<
 *         y = np.array(y )
 * 
 */
  __pyx_t_3 = __Pyx_HasAttr(__pyx_v_y, __pyx_n_u_len); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 2989, __pyx_L1_error)
  __pyx_t_7 = (__pyx_t_3 != 0);
  if (__pyx_t_7) {
  } else {
    __pyx_t_6 = __pyx_t_7;
    goto __pyx_L22_bool_binop_done;
  }
  __pyx_t_7 = __Pyx_HasAttr(__pyx_v_y, __pyx_n_u_array_2); if (unlikely(__pyx_t_7 == ((int)-1))) __PYX_ERR(0, 2989, __pyx_L1_error)
  __pyx_t_3 = ((!(__pyx_t_7 != 0)) != 0);
  __pyx_t_6 = __pyx_t_3;
  __pyx_L22_bool_binop_done:;
  if (__pyx_t_6) {

    /* "validator.pyx":2990
 *         x = np.array(x )
 *     if hasattr (y, '__len__') and not hasattr(y, '__array__'):
 *         y = np.array(y )             # <<<<<<<<<<<<<<
 * 
 *     _validate_input(ignore, x, y, _is_arraylike_1d)
 */
    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2990, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_array); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2990, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_1)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    __pyx_t_4 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_1, __pyx_v_y) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_y);
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2990, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF_SET(__pyx_v_y, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "validator.pyx":2989
 *     if hasattr (x, '__len__') and not hasattr(x, '__array__'):
 *         x = np.array(x )
 *     if hasattr (y, '__len__') and not hasattr(y, '__array__'):             # <<<<<<<<<<<<<<
 *         y = np.array(y )
 * 
 */
  }

  /* "validator.pyx":2992
 *         y = np.array(y )
 * 
 *     _validate_input(ignore, x, y, _is_arraylike_1d)             # <<<<<<<<<<<<<<
 * 
 *     check_consistent_length(x, y )
 */
  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_validate_input); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2992, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_is_arraylike_1d); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2992, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = NULL;
  __pyx_t_8 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
      __pyx_t_8 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_5)) {
    PyObject *__pyx_temp[5] = {__pyx_t_2, __pyx_v_ignore, __pyx_v_x, __pyx_v_y, __pyx_t_1};
    __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 4+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2992, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
    PyObject *__pyx_temp[5] = {__pyx_t_2, __pyx_v_ignore, __pyx_v_x, __pyx_v_y, __pyx_t_1};
    __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 4+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2992, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  } else
  #endif
  {
    __pyx_t_9 = PyTuple_New(4+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 2992, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    if (__pyx_t_2) {
      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_2); __pyx_t_2 = NULL;
    }
    __Pyx_INCREF(__pyx_v_ignore);
    __Pyx_GIVEREF(__pyx_v_ignore);
    PyTuple_SET_ITEM(__pyx_t_9, 0+__pyx_t_8, __pyx_v_ignore);
    __Pyx_INCREF(__pyx_v_x);
    __Pyx_GIVEREF(__pyx_v_x);
    PyTuple_SET_ITEM(__pyx_t_9, 1+__pyx_t_8, __pyx_v_x);
    __Pyx_INCREF(__pyx_v_y);
    __Pyx_GIVEREF(__pyx_v_y);
    PyTuple_SET_ITEM(__pyx_t_9, 2+__pyx_t_8, __pyx_v_y);
    __Pyx_GIVEREF(__pyx_t_1);
    PyTuple_SET_ITEM(__pyx_t_9, 3+__pyx_t_8, __pyx_t_1);
    __pyx_t_1 = 0;
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_9, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2992, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
  }
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "validator.pyx":2994
 *     _validate_input(ignore, x, y, _is_arraylike_1d)
 * 
 *     check_consistent_length(x, y )             # <<<<<<<<<<<<<<
 * 
 *     if xy_numeric:
 */
  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_check_consistent_length); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2994, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_9 = NULL;
  __pyx_t_8 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_9)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_9);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
      __pyx_t_8 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_5)) {
    PyObject *__pyx_temp[3] = {__pyx_t_9, __pyx_v_x, __pyx_v_y};
    __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2994, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
    __Pyx_GOTREF(__pyx_t_4);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
    PyObject *__pyx_temp[3] = {__pyx_t_9, __pyx_v_x, __pyx_v_y};
    __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2994, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
    __Pyx_GOTREF(__pyx_t_4);
  } else
  #endif
  {
    __pyx_t_1 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2994, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (__pyx_t_9) {
      __Pyx_GIVEREF(__pyx_t_9); PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_9); __pyx_t_9 = NULL;
    }
    __Pyx_INCREF(__pyx_v_x);
    __Pyx_GIVEREF(__pyx_v_x);
    PyTuple_SET_ITEM(__pyx_t_1, 0+__pyx_t_8, __pyx_v_x);
    __Pyx_INCREF(__pyx_v_y);
    __Pyx_GIVEREF(__pyx_v_y);
    PyTuple_SET_ITEM(__pyx_t_1, 1+__pyx_t_8, __pyx_v_y);
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_1, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2994, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "validator.pyx":2996
 *     check_consistent_length(x, y )
 * 
 *     if xy_numeric:             # <<<<<<<<<<<<<<
 *         if (
 *                 not _is_numeric_dtype(x, to_array =True )
 */
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_xy_numeric); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 2996, __pyx_L1_error)
  if (__pyx_t_6) {

    /* "validator.pyx":2998
 *     if xy_numeric:
 *         if (
 *                 not _is_numeric_dtype(x, to_array =True )             # <<<<<<<<<<<<<<
 *                 or not _is_numeric_dtype(y, to_array=True )
 *                 ):
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_is_numeric_dtype); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2998, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2998, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_INCREF(__pyx_v_x);
    __Pyx_GIVEREF(__pyx_v_x);
    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_x);
    __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2998, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_to_array, Py_True) < 0) __PYX_ERR(0, 2998, __pyx_L1_error)
    __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_5, __pyx_t_1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 2998, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 2998, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_t_7 = ((!__pyx_t_3) != 0);
    if (!__pyx_t_7) {
    } else {
      __pyx_t_6 = __pyx_t_7;
      goto __pyx_L26_bool_binop_done;
    }

    /* "validator.pyx":2999
 *         if (
 *                 not _is_numeric_dtype(x, to_array =True )
 *                 or not _is_numeric_dtype(y, to_array=True )             # <<<<<<<<<<<<<<
 *                 ):
 *             raise ValueError ("x and y must be a numeric array.")
 */
    __Pyx_GetModuleGlobalName(__pyx_t_9, __pyx_n_s_is_numeric_dtype); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 2999, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2999, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_INCREF(__pyx_v_y);
    __Pyx_GIVEREF(__pyx_v_y);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_y);
    __pyx_t_5 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2999, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_to_array, Py_True) < 0) __PYX_ERR(0, 2999, __pyx_L1_error)
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_9, __pyx_t_1, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2999, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 2999, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_3 = ((!__pyx_t_7) != 0);
    __pyx_t_6 = __pyx_t_3;
    __pyx_L26_bool_binop_done:;

    /* "validator.pyx":2997
 * 
 *     if xy_numeric:
 *         if (             # <<<<<<<<<<<<<<
 *                 not _is_numeric_dtype(x, to_array =True )
 *                 or not _is_numeric_dtype(y, to_array=True )
 */
    if (unlikely(__pyx_t_6)) {

      /* "validator.pyx":3001
 *                 or not _is_numeric_dtype(y, to_array=True )
 *                 ):
 *             raise ValueError ("x and y must be a numeric array.")             # <<<<<<<<<<<<<<
 * 
 *         x = x.astype (np.float64)
 */
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__78, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3001, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __PYX_ERR(0, 3001, __pyx_L1_error)

      /* "validator.pyx":2997
 * 
 *     if xy_numeric:
 *         if (             # <<<<<<<<<<<<<<
 *                 not _is_numeric_dtype(x, to_array =True )
 *                 or not _is_numeric_dtype(y, to_array=True )
 */
    }

    /* "validator.pyx":3003
 *             raise ValueError ("x and y must be a numeric array.")
 * 
 *         x = x.astype (np.float64)             # <<<<<<<<<<<<<<
 *         y = y.astype (np.float64)
 * 
 */
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_x, __pyx_n_s_astype); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3003, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3003, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_float64); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 3003, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_1)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    __pyx_t_4 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_1, __pyx_t_9) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_9);
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3003, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF_SET(__pyx_v_x, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "validator.pyx":3004
 * 
 *         x = x.astype (np.float64)
 *         y = y.astype (np.float64)             # <<<<<<<<<<<<<<
 * 
 *     return ( np.array(x), np.array (y) ) if asarray else (x, y )
 */
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_y, __pyx_n_s_astype); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3004, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_GetModuleGlobalName(__pyx_t_9, __pyx_n_s_np); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 3004, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_9, __pyx_n_s_float64); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3004, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_t_9 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_9)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_9);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    __pyx_t_4 = (__pyx_t_9) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_9, __pyx_t_1) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_1);
    __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3004, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF_SET(__pyx_v_y, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "validator.pyx":2996
 *     check_consistent_length(x, y )
 * 
 *     if xy_numeric:             # <<<<<<<<<<<<<<
 *         if (
 *                 not _is_numeric_dtype(x, to_array =True )
 */
  }

  /* "validator.pyx":3006
 *         y = y.astype (np.float64)
 * 
 *     return ( np.array(x), np.array (y) ) if asarray else (x, y )             # <<<<<<<<<<<<<<
 * 
 * def validate_numeric(
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_asarray); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 3006, __pyx_L1_error)
  if (__pyx_t_6) {
    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3006, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_array); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 3006, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_9))) {
      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_9);
      if (likely(__pyx_t_1)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_9, function);
      }
    }
    __pyx_t_5 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_9, __pyx_t_1, __pyx_v_x) : __Pyx_PyObject_CallOneArg(__pyx_t_9, __pyx_v_x);
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3006, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3006, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_array); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3006, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_1)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    __pyx_t_9 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_1, __pyx_v_y) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_y);
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 3006, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3006, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_GIVEREF(__pyx_t_5);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_9);
    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_9);
    __pyx_t_5 = 0;
    __pyx_t_9 = 0;
    __pyx_t_4 = __pyx_t_2;
    __pyx_t_2 = 0;
  } else {
    __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3006, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_v_x);
    __Pyx_GIVEREF(__pyx_v_x);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_x);
    __Pyx_INCREF(__pyx_v_y);
    __Pyx_GIVEREF(__pyx_v_y);
    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_y);
    __pyx_t_4 = __pyx_t_2;
    __pyx_t_2 = 0;
  }
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "validator.pyx":2884
 *         raise NotFittedError(msg)
 * 
 * def assert_xy_in (             # <<<<<<<<<<<<<<
 *     x,
 *     y, *,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("validator.assert_xy_in", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_exist_features);
  __Pyx_XDECREF(__pyx_v_x);
  __Pyx_XDECREF(__pyx_v_y);
  __Pyx_XDECREF(__pyx_v_data);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3008
 *     return ( np.array(x), np.array (y) ) if asarray else (x, y )
 * 
 * def validate_numeric(             # <<<<<<<<<<<<<<
 *     value,
 *     convert_to='float',
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_85validate_numeric(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_84validate_numeric[] = "\n    Validates if a given value is numeric. It can accept numeric strings \n    and numpy arrays of single values. Optionally converts the value to \n    either float or integer.\n\n    Parameters\n    ----------\n    value : Any\n        The value to be validated as numeric. This can be of any type \n        but is expected to be convertible to a numeric type. Accepted \n        types include numeric strings (e.g., `\"42\"`), single-element \n        numpy arrays (e.g., `np.array([3.14])`), integers, and floats.\n    convert_to : str, optional\n        The type to convert the validated numeric value to. Options are \n        ``'float'`` or ``'int'``. Defaults to ``'float'``. \n        - If ``'float'``, the value will be converted to a floating-point number.\n        - If ``'int'``, the value will be converted to an integer.\n    allow_negative : bool, optional\n        Whether to allow negative values. Defaults to ``True``. \n        - If ``True``, negative values are allowed.\n        - If ``False``, negative values will raise a `ValueError`.\n    min_value : float or int, optional\n        The minimum value allowed. If `None`, no minimum value check \n        is applied. Defaults to ``None``.\n    max_value : float or int, optional\n        The maximum value allowed. If `None`, no maximum value check \n        is applied. Defaults to ``None``.\n    check_mode : str, optional\n        The mode of checking the value. Options are ``'soft'`` or ``'strict'``. \n        Defaults to ``'soft'``. \n        - If ``'soft'``, iterables containing a single value are accepted \n          and the single value is validated.\n        - If ``'strict'``, only non-iterable numeric values are accepted.\n\n    Returns\n    -------\n    float or int\n        The validated and optionally converted numeric value. The type \n        of the return value is determined by the `convert_to` parameter.\n\n    Raises\n    ------\n    ValueError\n        If the value is not numeric or does not m""eet the specified criteria.\n\n    Notes\n    -----\n    The function performs several checks and transformations:\n    1. If the value is a numpy array with a single element, it extracts \n       the element.\n    2. If the value is a numeric string, it attempts to convert it to \n       a float.\n    3. If `check_mode` is ``'soft'`` and the value is an iterable with \n       a single element, it extracts and validates the element.\n    4. It validates whether the value is numeric.\n    5. It converts the value to the specified type (`float` or `int`).\n    6. It checks if negative values are allowed.\n    7. It checks if the value is within the specified `min_value` and \n       `max_value` range.\n\n    The mathematical formulation for the validation can be expressed as:\n\n    .. math::\n        y = \n        \010egin{cases} \n        x & \text{if } x \\in \\mathbb{R} \\\n        \text{convert_to}(x) & \text{if } x \\in \text{numeric\\_string} \\\n        \text{single\\_element}(x) & \text{if } x \\in \text{numpy\\_array} \\\n        \\end{cases}\n\n    Where:\n    - :math:`x` is the input value\n    - :math:`y` is the output value after validation and conversion\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import validate_numeric\n    >>> validate_numeric(\"42\", convert_to='int')\n    42\n    >>> validate_numeric(np.array([3.14]), convert_to='float')\n    3.14\n    >>> validate_numeric([123], check_mode='soft')\n    123.0\n    >>> validate_numeric([123], check_mode='strict')\n    Traceback (most recent call last):\n        ...\n    ValueError: Value '[123]' is not a numeric type.\n    >>> validate_numeric(\"-123.45\", allow_negative=False)\n    Traceback (most recent call last):\n        ...\n    ValueError: Negative values are not allowed: -123.45\n\n    See Also\n    --------\n    numpy.array : Numpy arrays, which can be validated by this function.\n\n    References\n    ----------\n    .. [1] \"NumPy Documentation\", https://numpy.org/""doc/stable/\n    ";
static PyMethodDef __pyx_mdef_9validator_85validate_numeric = {"validate_numeric", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_85validate_numeric, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_84validate_numeric};
static PyObject *__pyx_pw_9validator_85validate_numeric(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_value = 0;
  PyObject *__pyx_v_convert_to = 0;
  PyObject *__pyx_v_allow_negative = 0;
  PyObject *__pyx_v_min_value = 0;
  PyObject *__pyx_v_max_value = 0;
  PyObject *__pyx_v_check_mode = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validate_numeric (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_value,&__pyx_n_s_convert_to,&__pyx_n_s_allow_negative,&__pyx_n_s_min_value,&__pyx_n_s_max_value,&__pyx_n_s_check_mode,0};
    PyObject* values[6] = {0,0,0,0,0,0};
    values[1] = ((PyObject *)__pyx_n_u_float);

    /* "validator.pyx":3011
 *     value,
 *     convert_to='float',
 *     allow_negative=True,             # <<<<<<<<<<<<<<
 *     min_value=None,
 *     max_value=None,
 */
    values[2] = ((PyObject *)Py_True);

    /* "validator.pyx":3012
 *     convert_to='float',
 *     allow_negative=True,
 *     min_value=None,             # <<<<<<<<<<<<<<
 *     max_value=None,
 *     check_mode='soft'
 */
    values[3] = ((PyObject *)Py_None);

    /* "validator.pyx":3013
 *     allow_negative=True,
 *     min_value=None,
 *     max_value=None,             # <<<<<<<<<<<<<<
 *     check_mode='soft'
 *     ):
 */
    values[4] = ((PyObject *)Py_None);
    values[5] = ((PyObject *)__pyx_n_u_soft);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_value)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_convert_to);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_allow_negative);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_min_value);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_max_value);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_check_mode);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "validate_numeric") < 0)) __PYX_ERR(0, 3008, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_value = values[0];
    __pyx_v_convert_to = values[1];
    __pyx_v_allow_negative = values[2];
    __pyx_v_min_value = values[3];
    __pyx_v_max_value = values[4];
    __pyx_v_check_mode = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("validate_numeric", 0, 1, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3008, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.validate_numeric", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_84validate_numeric(__pyx_self, __pyx_v_value, __pyx_v_convert_to, __pyx_v_allow_negative, __pyx_v_min_value, __pyx_v_max_value, __pyx_v_check_mode);

  /* "validator.pyx":3008
 *     return ( np.array(x), np.array (y) ) if asarray else (x, y )
 * 
 * def validate_numeric(             # <<<<<<<<<<<<<<
 *     value,
 *     convert_to='float',
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_84validate_numeric(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_value, PyObject *__pyx_v_convert_to, PyObject *__pyx_v_allow_negative, PyObject *__pyx_v_min_value, PyObject *__pyx_v_max_value, PyObject *__pyx_v_check_mode) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_t_7;
  Py_ssize_t __pyx_t_8;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  int __pyx_t_12;
  PyObject *__pyx_t_13 = NULL;
  Py_UCS4 __pyx_t_14;
  PyObject *__pyx_t_15 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validate_numeric", 0);
  __Pyx_INCREF(__pyx_v_value);

  /* "validator.pyx":3117
 *     """
 *     # Check if the value is a numpy array with a single element
 *     if isinstance(value, np.ndarray):             # <<<<<<<<<<<<<<
 *         if value.size != 1:
 *             raise ValueError("Numpy array must contain exactly one element.")
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3117, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_ndarray); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3117, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = PyObject_IsInstance(__pyx_v_value, __pyx_t_2); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 3117, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = (__pyx_t_3 != 0);
  if (__pyx_t_4) {

    /* "validator.pyx":3118
 *     # Check if the value is a numpy array with a single element
 *     if isinstance(value, np.ndarray):
 *         if value.size != 1:             # <<<<<<<<<<<<<<
 *             raise ValueError("Numpy array must contain exactly one element.")
 *         value = value.item()
 */
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_value, __pyx_n_s_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3118, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = __Pyx_PyInt_NeObjC(__pyx_t_2, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3118, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 3118, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(__pyx_t_4)) {

      /* "validator.pyx":3119
 *     if isinstance(value, np.ndarray):
 *         if value.size != 1:
 *             raise ValueError("Numpy array must contain exactly one element.")             # <<<<<<<<<<<<<<
 *         value = value.item()
 * 
 */
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__79, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3119, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 3119, __pyx_L1_error)

      /* "validator.pyx":3118
 *     # Check if the value is a numpy array with a single element
 *     if isinstance(value, np.ndarray):
 *         if value.size != 1:             # <<<<<<<<<<<<<<
 *             raise ValueError("Numpy array must contain exactly one element.")
 *         value = value.item()
 */
    }

    /* "validator.pyx":3120
 *         if value.size != 1:
 *             raise ValueError("Numpy array must contain exactly one element.")
 *         value = value.item()             # <<<<<<<<<<<<<<
 * 
 *     # If check_mode is 'soft', handle single-element iterables
 */
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_value, __pyx_n_s_item); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3120, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3120, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF_SET(__pyx_v_value, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "validator.pyx":3117
 *     """
 *     # Check if the value is a numpy array with a single element
 *     if isinstance(value, np.ndarray):             # <<<<<<<<<<<<<<
 *         if value.size != 1:
 *             raise ValueError("Numpy array must contain exactly one element.")
 */
  }

  /* "validator.pyx":3123
 * 
 *     # If check_mode is 'soft', handle single-element iterables
 *     if check_mode == 'soft' and isinstance(             # <<<<<<<<<<<<<<
 *             value, (list, tuple, set)) and len(value) == 1:
 *         value = next(iter(value))
 */
  __pyx_t_3 = (__Pyx_PyUnicode_Equals(__pyx_v_check_mode, __pyx_n_u_soft, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 3123, __pyx_L1_error)
  if (__pyx_t_3) {
  } else {
    __pyx_t_4 = __pyx_t_3;
    goto __pyx_L6_bool_binop_done;
  }

  /* "validator.pyx":3124
 *     # If check_mode is 'soft', handle single-element iterables
 *     if check_mode == 'soft' and isinstance(
 *             value, (list, tuple, set)) and len(value) == 1:             # <<<<<<<<<<<<<<
 *         value = next(iter(value))
 * 
 */
  __pyx_t_6 = PyList_Check(__pyx_v_value); 
  __pyx_t_7 = (__pyx_t_6 != 0);
  if (!__pyx_t_7) {
  } else {
    __pyx_t_3 = __pyx_t_7;
    goto __pyx_L9_bool_binop_done;
  }
  __pyx_t_7 = PyTuple_Check(__pyx_v_value); 
  __pyx_t_6 = (__pyx_t_7 != 0);
  if (!__pyx_t_6) {
  } else {
    __pyx_t_3 = __pyx_t_6;
    goto __pyx_L9_bool_binop_done;
  }
  __pyx_t_6 = PySet_Check(__pyx_v_value); 
  __pyx_t_7 = (__pyx_t_6 != 0);
  __pyx_t_3 = __pyx_t_7;
  __pyx_L9_bool_binop_done:;

  /* "validator.pyx":3123
 * 
 *     # If check_mode is 'soft', handle single-element iterables
 *     if check_mode == 'soft' and isinstance(             # <<<<<<<<<<<<<<
 *             value, (list, tuple, set)) and len(value) == 1:
 *         value = next(iter(value))
 */
  __pyx_t_7 = (__pyx_t_3 != 0);
  if (__pyx_t_7) {
  } else {
    __pyx_t_4 = __pyx_t_7;
    goto __pyx_L6_bool_binop_done;
  }

  /* "validator.pyx":3124
 *     # If check_mode is 'soft', handle single-element iterables
 *     if check_mode == 'soft' and isinstance(
 *             value, (list, tuple, set)) and len(value) == 1:             # <<<<<<<<<<<<<<
 *         value = next(iter(value))
 * 
 */
  __pyx_t_8 = PyObject_Length(__pyx_v_value); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3124, __pyx_L1_error)
  __pyx_t_7 = ((__pyx_t_8 == 1) != 0);
  __pyx_t_4 = __pyx_t_7;
  __pyx_L6_bool_binop_done:;

  /* "validator.pyx":3123
 * 
 *     # If check_mode is 'soft', handle single-element iterables
 *     if check_mode == 'soft' and isinstance(             # <<<<<<<<<<<<<<
 *             value, (list, tuple, set)) and len(value) == 1:
 *         value = next(iter(value))
 */
  if (__pyx_t_4) {

    /* "validator.pyx":3125
 *     if check_mode == 'soft' and isinstance(
 *             value, (list, tuple, set)) and len(value) == 1:
 *         value = next(iter(value))             # <<<<<<<<<<<<<<
 * 
 *     # Check if the value is a numeric string
 */
    __pyx_t_1 = PyObject_GetIter(__pyx_v_value); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3125, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __Pyx_PyIter_Next(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3125, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF_SET(__pyx_v_value, __pyx_t_2);
    __pyx_t_2 = 0;

    /* "validator.pyx":3123
 * 
 *     # If check_mode is 'soft', handle single-element iterables
 *     if check_mode == 'soft' and isinstance(             # <<<<<<<<<<<<<<
 *             value, (list, tuple, set)) and len(value) == 1:
 *         value = next(iter(value))
 */
  }

  /* "validator.pyx":3128
 * 
 *     # Check if the value is a numeric string
 *     if isinstance(value, str):             # <<<<<<<<<<<<<<
 *         try:
 *             value = float(value)
 */
  __pyx_t_4 = PyUnicode_Check(__pyx_v_value); 
  __pyx_t_7 = (__pyx_t_4 != 0);
  if (__pyx_t_7) {

    /* "validator.pyx":3129
 *     # Check if the value is a numeric string
 *     if isinstance(value, str):
 *         try:             # <<<<<<<<<<<<<<
 *             value = float(value)
 *         except ValueError:
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11);
      __Pyx_XGOTREF(__pyx_t_9);
      __Pyx_XGOTREF(__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_11);
      /*try:*/ {

        /* "validator.pyx":3130
 *     if isinstance(value, str):
 *         try:
 *             value = float(value)             # <<<<<<<<<<<<<<
 *         except ValueError:
 *             raise ValueError(f"Value '{value}' is not a valid numeric string.")
 */
        __pyx_t_2 = __Pyx_PyNumber_Float(__pyx_v_value); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3130, __pyx_L13_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF_SET(__pyx_v_value, __pyx_t_2);
        __pyx_t_2 = 0;

        /* "validator.pyx":3129
 *     # Check if the value is a numeric string
 *     if isinstance(value, str):
 *         try:             # <<<<<<<<<<<<<<
 *             value = float(value)
 *         except ValueError:
 */
      }
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
      goto __pyx_L18_try_end;
      __pyx_L13_error:;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;

      /* "validator.pyx":3131
 *         try:
 *             value = float(value)
 *         except ValueError:             # <<<<<<<<<<<<<<
 *             raise ValueError(f"Value '{value}' is not a valid numeric string.")
 * 
 */
      __pyx_t_12 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_ValueError);
      if (__pyx_t_12) {
        __Pyx_AddTraceback("validator.validate_numeric", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_2, &__pyx_t_1, &__pyx_t_5) < 0) __PYX_ERR(0, 3131, __pyx_L15_except_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_GOTREF(__pyx_t_5);

        /* "validator.pyx":3132
 *             value = float(value)
 *         except ValueError:
 *             raise ValueError(f"Value '{value}' is not a valid numeric string.")             # <<<<<<<<<<<<<<
 * 
 *     # Check if the value is numeric
 */
        __pyx_t_13 = PyTuple_New(3); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 3132, __pyx_L15_except_error)
        __Pyx_GOTREF(__pyx_t_13);
        __pyx_t_8 = 0;
        __pyx_t_14 = 127;
        __Pyx_INCREF(__pyx_kp_u_Value);
        __pyx_t_8 += 7;
        __Pyx_GIVEREF(__pyx_kp_u_Value);
        PyTuple_SET_ITEM(__pyx_t_13, 0, __pyx_kp_u_Value);
        __pyx_t_15 = __Pyx_PyObject_FormatSimple(__pyx_v_value, __pyx_empty_unicode); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 3132, __pyx_L15_except_error)
        __Pyx_GOTREF(__pyx_t_15);
        __pyx_t_14 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_15) > __pyx_t_14) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_15) : __pyx_t_14;
        __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_15);
        __Pyx_GIVEREF(__pyx_t_15);
        PyTuple_SET_ITEM(__pyx_t_13, 1, __pyx_t_15);
        __pyx_t_15 = 0;
        __Pyx_INCREF(__pyx_kp_u_is_not_a_valid_numeric_string);
        __pyx_t_8 += 32;
        __Pyx_GIVEREF(__pyx_kp_u_is_not_a_valid_numeric_string);
        PyTuple_SET_ITEM(__pyx_t_13, 2, __pyx_kp_u_is_not_a_valid_numeric_string);
        __pyx_t_15 = __Pyx_PyUnicode_Join(__pyx_t_13, 3, __pyx_t_8, __pyx_t_14); if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 3132, __pyx_L15_except_error)
        __Pyx_GOTREF(__pyx_t_15);
        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
        __pyx_t_13 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_15); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 3132, __pyx_L15_except_error)
        __Pyx_GOTREF(__pyx_t_13);
        __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
        __Pyx_Raise(__pyx_t_13, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
        __PYX_ERR(0, 3132, __pyx_L15_except_error)
      }
      goto __pyx_L15_except_error;
      __pyx_L15_except_error:;

      /* "validator.pyx":3129
 *     # Check if the value is a numeric string
 *     if isinstance(value, str):
 *         try:             # <<<<<<<<<<<<<<
 *             value = float(value)
 *         except ValueError:
 */
      __Pyx_XGIVEREF(__pyx_t_9);
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_11);
      __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_10, __pyx_t_11);
      goto __pyx_L1_error;
      __pyx_L18_try_end:;
    }

    /* "validator.pyx":3128
 * 
 *     # Check if the value is a numeric string
 *     if isinstance(value, str):             # <<<<<<<<<<<<<<
 *         try:
 *             value = float(value)
 */
  }

  /* "validator.pyx":3135
 * 
 *     # Check if the value is numeric
 *     if not isinstance(value, (int, float)):             # <<<<<<<<<<<<<<
 *         raise ValueError(f"Value '{value}' is not a numeric type.")
 * 
 */
  __pyx_t_4 = PyInt_Check(__pyx_v_value); 
  __pyx_t_3 = (__pyx_t_4 != 0);
  if (!__pyx_t_3) {
  } else {
    __pyx_t_7 = __pyx_t_3;
    goto __pyx_L22_bool_binop_done;
  }
  __pyx_t_3 = PyFloat_Check(__pyx_v_value); 
  __pyx_t_4 = (__pyx_t_3 != 0);
  __pyx_t_7 = __pyx_t_4;
  __pyx_L22_bool_binop_done:;
  __pyx_t_4 = ((!(__pyx_t_7 != 0)) != 0);
  if (unlikely(__pyx_t_4)) {

    /* "validator.pyx":3136
 *     # Check if the value is numeric
 *     if not isinstance(value, (int, float)):
 *         raise ValueError(f"Value '{value}' is not a numeric type.")             # <<<<<<<<<<<<<<
 * 
 *     # Convert the value to the desired type
 */
    __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3136, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_8 = 0;
    __pyx_t_14 = 127;
    __Pyx_INCREF(__pyx_kp_u_Value);
    __pyx_t_8 += 7;
    __Pyx_GIVEREF(__pyx_kp_u_Value);
    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_kp_u_Value);
    __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_value, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3136, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_14 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) > __pyx_t_14) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) : __pyx_t_14;
    __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_1);
    __Pyx_GIVEREF(__pyx_t_1);
    PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_1);
    __pyx_t_1 = 0;
    __Pyx_INCREF(__pyx_kp_u_is_not_a_numeric_type);
    __pyx_t_8 += 24;
    __Pyx_GIVEREF(__pyx_kp_u_is_not_a_numeric_type);
    PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_kp_u_is_not_a_numeric_type);
    __pyx_t_1 = __Pyx_PyUnicode_Join(__pyx_t_5, 3, __pyx_t_8, __pyx_t_14); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3136, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3136, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __PYX_ERR(0, 3136, __pyx_L1_error)

    /* "validator.pyx":3135
 * 
 *     # Check if the value is numeric
 *     if not isinstance(value, (int, float)):             # <<<<<<<<<<<<<<
 *         raise ValueError(f"Value '{value}' is not a numeric type.")
 * 
 */
  }

  /* "validator.pyx":3139
 * 
 *     # Convert the value to the desired type
 *     if convert_to == 'int':             # <<<<<<<<<<<<<<
 *         value = int(value)
 *     else:
 */
  __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_v_convert_to, __pyx_n_u_int, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 3139, __pyx_L1_error)
  if (__pyx_t_4) {

    /* "validator.pyx":3140
 *     # Convert the value to the desired type
 *     if convert_to == 'int':
 *         value = int(value)             # <<<<<<<<<<<<<<
 *     else:
 *         value = float(value)
 */
    __pyx_t_5 = __Pyx_PyNumber_Int(__pyx_v_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3140, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF_SET(__pyx_v_value, __pyx_t_5);
    __pyx_t_5 = 0;

    /* "validator.pyx":3139
 * 
 *     # Convert the value to the desired type
 *     if convert_to == 'int':             # <<<<<<<<<<<<<<
 *         value = int(value)
 *     else:
 */
    goto __pyx_L24;
  }

  /* "validator.pyx":3142
 *         value = int(value)
 *     else:
 *         value = float(value)             # <<<<<<<<<<<<<<
 * 
 *     # Check if negative values are allowed
 */
  /*else*/ {
    __pyx_t_5 = __Pyx_PyNumber_Float(__pyx_v_value); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3142, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF_SET(__pyx_v_value, __pyx_t_5);
    __pyx_t_5 = 0;
  }
  __pyx_L24:;

  /* "validator.pyx":3145
 * 
 *     # Check if negative values are allowed
 *     if not allow_negative and value < 0:             # <<<<<<<<<<<<<<
 *         raise ValueError(f"Negative values are not allowed: {value}")
 * 
 */
  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_allow_negative); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 3145, __pyx_L1_error)
  __pyx_t_3 = ((!__pyx_t_7) != 0);
  if (__pyx_t_3) {
  } else {
    __pyx_t_4 = __pyx_t_3;
    goto __pyx_L26_bool_binop_done;
  }
  __pyx_t_5 = PyObject_RichCompare(__pyx_v_value, __pyx_int_0, Py_LT); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3145, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 3145, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_4 = __pyx_t_3;
  __pyx_L26_bool_binop_done:;
  if (unlikely(__pyx_t_4)) {

    /* "validator.pyx":3146
 *     # Check if negative values are allowed
 *     if not allow_negative and value < 0:
 *         raise ValueError(f"Negative values are not allowed: {value}")             # <<<<<<<<<<<<<<
 * 
 *     # Check if the value is within the specified range
 */
    __pyx_t_5 = __Pyx_PyObject_FormatSimple(__pyx_v_value, __pyx_empty_unicode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3146, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_1 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Negative_values_are_not_allowed, __pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3146, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3146, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __PYX_ERR(0, 3146, __pyx_L1_error)

    /* "validator.pyx":3145
 * 
 *     # Check if negative values are allowed
 *     if not allow_negative and value < 0:             # <<<<<<<<<<<<<<
 *         raise ValueError(f"Negative values are not allowed: {value}")
 * 
 */
  }

  /* "validator.pyx":3149
 * 
 *     # Check if the value is within the specified range
 *     if min_value is not None and value < min_value:             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             f"Value {value} is less than the minimum allowed value {min_value}.")
 */
  __pyx_t_3 = (__pyx_v_min_value != Py_None);
  __pyx_t_7 = (__pyx_t_3 != 0);
  if (__pyx_t_7) {
  } else {
    __pyx_t_4 = __pyx_t_7;
    goto __pyx_L29_bool_binop_done;
  }
  __pyx_t_5 = PyObject_RichCompare(__pyx_v_value, __pyx_v_min_value, Py_LT); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3149, __pyx_L1_error)
  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 3149, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_4 = __pyx_t_7;
  __pyx_L29_bool_binop_done:;
  if (unlikely(__pyx_t_4)) {

    /* "validator.pyx":3151
 *     if min_value is not None and value < min_value:
 *         raise ValueError(
 *             f"Value {value} is less than the minimum allowed value {min_value}.")             # <<<<<<<<<<<<<<
 *     if max_value is not None and value > max_value:
 *         raise ValueError(
 */
    __pyx_t_5 = PyTuple_New(5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3151, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_8 = 0;
    __pyx_t_14 = 127;
    __Pyx_INCREF(__pyx_kp_u_Value_2);
    __pyx_t_8 += 6;
    __Pyx_GIVEREF(__pyx_kp_u_Value_2);
    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_kp_u_Value_2);
    __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_value, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3151, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_14 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) > __pyx_t_14) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) : __pyx_t_14;
    __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_1);
    __Pyx_GIVEREF(__pyx_t_1);
    PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_1);
    __pyx_t_1 = 0;
    __Pyx_INCREF(__pyx_kp_u_is_less_than_the_minimum_allowe);
    __pyx_t_8 += 40;
    __Pyx_GIVEREF(__pyx_kp_u_is_less_than_the_minimum_allowe);
    PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_kp_u_is_less_than_the_minimum_allowe);
    __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_min_value, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3151, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_14 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) > __pyx_t_14) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) : __pyx_t_14;
    __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_1);
    __Pyx_GIVEREF(__pyx_t_1);
    PyTuple_SET_ITEM(__pyx_t_5, 3, __pyx_t_1);
    __pyx_t_1 = 0;
    __Pyx_INCREF(__pyx_kp_u__16);
    __pyx_t_8 += 1;
    __Pyx_GIVEREF(__pyx_kp_u__16);
    PyTuple_SET_ITEM(__pyx_t_5, 4, __pyx_kp_u__16);
    __pyx_t_1 = __Pyx_PyUnicode_Join(__pyx_t_5, 5, __pyx_t_8, __pyx_t_14); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3151, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

    /* "validator.pyx":3150
 *     # Check if the value is within the specified range
 *     if min_value is not None and value < min_value:
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             f"Value {value} is less than the minimum allowed value {min_value}.")
 *     if max_value is not None and value > max_value:
 */
    __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3150, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __PYX_ERR(0, 3150, __pyx_L1_error)

    /* "validator.pyx":3149
 * 
 *     # Check if the value is within the specified range
 *     if min_value is not None and value < min_value:             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             f"Value {value} is less than the minimum allowed value {min_value}.")
 */
  }

  /* "validator.pyx":3152
 *         raise ValueError(
 *             f"Value {value} is less than the minimum allowed value {min_value}.")
 *     if max_value is not None and value > max_value:             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             f"Value {value} is greater than the maximum allowed value {max_value}.")
 */
  __pyx_t_7 = (__pyx_v_max_value != Py_None);
  __pyx_t_3 = (__pyx_t_7 != 0);
  if (__pyx_t_3) {
  } else {
    __pyx_t_4 = __pyx_t_3;
    goto __pyx_L32_bool_binop_done;
  }
  __pyx_t_5 = PyObject_RichCompare(__pyx_v_value, __pyx_v_max_value, Py_GT); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3152, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 3152, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_4 = __pyx_t_3;
  __pyx_L32_bool_binop_done:;
  if (unlikely(__pyx_t_4)) {

    /* "validator.pyx":3154
 *     if max_value is not None and value > max_value:
 *         raise ValueError(
 *             f"Value {value} is greater than the maximum allowed value {max_value}.")             # <<<<<<<<<<<<<<
 * 
 *     return value
 */
    __pyx_t_5 = PyTuple_New(5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3154, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_8 = 0;
    __pyx_t_14 = 127;
    __Pyx_INCREF(__pyx_kp_u_Value_2);
    __pyx_t_8 += 6;
    __Pyx_GIVEREF(__pyx_kp_u_Value_2);
    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_kp_u_Value_2);
    __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_value, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3154, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_14 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) > __pyx_t_14) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) : __pyx_t_14;
    __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_1);
    __Pyx_GIVEREF(__pyx_t_1);
    PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_1);
    __pyx_t_1 = 0;
    __Pyx_INCREF(__pyx_kp_u_is_greater_than_the_maximum_all);
    __pyx_t_8 += 43;
    __Pyx_GIVEREF(__pyx_kp_u_is_greater_than_the_maximum_all);
    PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_kp_u_is_greater_than_the_maximum_all);
    __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_max_value, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3154, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_14 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) > __pyx_t_14) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) : __pyx_t_14;
    __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_1);
    __Pyx_GIVEREF(__pyx_t_1);
    PyTuple_SET_ITEM(__pyx_t_5, 3, __pyx_t_1);
    __pyx_t_1 = 0;
    __Pyx_INCREF(__pyx_kp_u__16);
    __pyx_t_8 += 1;
    __Pyx_GIVEREF(__pyx_kp_u__16);
    PyTuple_SET_ITEM(__pyx_t_5, 4, __pyx_kp_u__16);
    __pyx_t_1 = __Pyx_PyUnicode_Join(__pyx_t_5, 5, __pyx_t_8, __pyx_t_14); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3154, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

    /* "validator.pyx":3153
 *             f"Value {value} is less than the minimum allowed value {min_value}.")
 *     if max_value is not None and value > max_value:
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             f"Value {value} is greater than the maximum allowed value {max_value}.")
 * 
 */
    __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3153, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __PYX_ERR(0, 3153, __pyx_L1_error)

    /* "validator.pyx":3152
 *         raise ValueError(
 *             f"Value {value} is less than the minimum allowed value {min_value}.")
 *     if max_value is not None and value > max_value:             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             f"Value {value} is greater than the maximum allowed value {max_value}.")
 */
  }

  /* "validator.pyx":3156
 *             f"Value {value} is greater than the maximum allowed value {max_value}.")
 * 
 *     return value             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_value);
  __pyx_r = __pyx_v_value;
  goto __pyx_L0;

  /* "validator.pyx":3008
 *     return ( np.array(x), np.array (y) ) if asarray else (x, y )
 * 
 * def validate_numeric(             # <<<<<<<<<<<<<<
 *     value,
 *     convert_to='float',
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_13);
  __Pyx_XDECREF(__pyx_t_15);
  __Pyx_AddTraceback("validator.validate_numeric", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_value);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3159
 * 
 * 
 * def _validate_input(ignore: str, x, y, _is_arraylike_1d):             # <<<<<<<<<<<<<<
 *     """
 *     Validates that x and y are one-dimensional array-like structures based
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_87_validate_input(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_86_validate_input[] = "\n    Validates that x and y are one-dimensional array-like structures based\n    on the ignore parameter.\n\n    Parameters\n    ----------\n    ignore : str\n        Specifies which variable ('x' or 'y') to ignore during validation.\n    x, y : array-like\n        The variables to be validated.\n    _is_arraylike_1d : function\n        Function to check if the input is array-like and one-dimensional.\n\n    Raises\n    ------\n    ValueError\n        If the non-ignored variable(s) are not one-dimensional array-like structures.\n    ";
static PyMethodDef __pyx_mdef_9validator_87_validate_input = {"_validate_input", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_87_validate_input, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_86_validate_input};
static PyObject *__pyx_pw_9validator_87_validate_input(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_ignore = 0;
  PyObject *__pyx_v_x = 0;
  PyObject *__pyx_v_y = 0;
  PyObject *__pyx_v__is_arraylike_1d = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_validate_input (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ignore,&__pyx_n_s_x,&__pyx_n_s_y,&__pyx_n_s_is_arraylike_1d,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ignore)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_x)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_validate_input", 1, 4, 4, 1); __PYX_ERR(0, 3159, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_validate_input", 1, 4, 4, 2); __PYX_ERR(0, 3159, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_is_arraylike_1d)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_validate_input", 1, 4, 4, 3); __PYX_ERR(0, 3159, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_validate_input") < 0)) __PYX_ERR(0, 3159, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 4) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
    }
    __pyx_v_ignore = ((PyObject*)values[0]);
    __pyx_v_x = values[1];
    __pyx_v_y = values[2];
    __pyx_v__is_arraylike_1d = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_validate_input", 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3159, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator._validate_input", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_ignore), (&PyUnicode_Type), 1, "ignore", 1))) __PYX_ERR(0, 3159, __pyx_L1_error)
  __pyx_r = __pyx_pf_9validator_86_validate_input(__pyx_self, __pyx_v_ignore, __pyx_v_x, __pyx_v_y, __pyx_v__is_arraylike_1d);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3179
 *     """
 *     validation_checks = {
 *         'x': lambda: _is_arraylike_1d(y),             # <<<<<<<<<<<<<<
 *         'y': lambda: _is_arraylike_1d(x),
 *         'both': lambda: _is_arraylike_1d(x) and _is_arraylike_1d(y)
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_15_validate_input_lambda14(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyMethodDef __pyx_mdef_9validator_15_validate_input_lambda14 = {"lambda14", (PyCFunction)__pyx_pw_9validator_15_validate_input_lambda14, METH_NOARGS, 0};
static PyObject *__pyx_pw_9validator_15_validate_input_lambda14(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("lambda14 (wrapper)", 0);
  __pyx_r = __pyx_lambda_funcdef_lambda14(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_lambda_funcdef_lambda14(PyObject *__pyx_self) {
  struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *__pyx_cur_scope;
  struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *__pyx_outer_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("lambda14", 0);
  __pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *) __Pyx_CyFunction_GetClosure(__pyx_self);
  __pyx_cur_scope = __pyx_outer_scope;
  __Pyx_XDECREF(__pyx_r);
  if (unlikely(!__pyx_cur_scope->__pyx_v__is_arraylike_1d)) { __Pyx_RaiseClosureNameError("_is_arraylike_1d"); __PYX_ERR(0, 3179, __pyx_L1_error) }
  if (unlikely(!__pyx_cur_scope->__pyx_v_y)) { __Pyx_RaiseClosureNameError("y"); __PYX_ERR(0, 3179, __pyx_L1_error) }
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v__is_arraylike_1d);
  __pyx_t_2 = __pyx_cur_scope->__pyx_v__is_arraylike_1d; __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_cur_scope->__pyx_v_y) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_cur_scope->__pyx_v_y);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3179, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("validator._validate_input.lambda14", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3180
 *     validation_checks = {
 *         'x': lambda: _is_arraylike_1d(y),
 *         'y': lambda: _is_arraylike_1d(x),             # <<<<<<<<<<<<<<
 *         'both': lambda: _is_arraylike_1d(x) and _is_arraylike_1d(y)
 *     }
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_15_validate_input_1lambda15(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyMethodDef __pyx_mdef_9validator_15_validate_input_1lambda15 = {"lambda15", (PyCFunction)__pyx_pw_9validator_15_validate_input_1lambda15, METH_NOARGS, 0};
static PyObject *__pyx_pw_9validator_15_validate_input_1lambda15(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("lambda15 (wrapper)", 0);
  __pyx_r = __pyx_lambda_funcdef_lambda15(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_lambda_funcdef_lambda15(PyObject *__pyx_self) {
  struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *__pyx_cur_scope;
  struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *__pyx_outer_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("lambda15", 0);
  __pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *) __Pyx_CyFunction_GetClosure(__pyx_self);
  __pyx_cur_scope = __pyx_outer_scope;
  __Pyx_XDECREF(__pyx_r);
  if (unlikely(!__pyx_cur_scope->__pyx_v__is_arraylike_1d)) { __Pyx_RaiseClosureNameError("_is_arraylike_1d"); __PYX_ERR(0, 3180, __pyx_L1_error) }
  if (unlikely(!__pyx_cur_scope->__pyx_v_x)) { __Pyx_RaiseClosureNameError("x"); __PYX_ERR(0, 3180, __pyx_L1_error) }
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v__is_arraylike_1d);
  __pyx_t_2 = __pyx_cur_scope->__pyx_v__is_arraylike_1d; __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_cur_scope->__pyx_v_x) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_cur_scope->__pyx_v_x);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3180, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("validator._validate_input.lambda15", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3181
 *         'x': lambda: _is_arraylike_1d(y),
 *         'y': lambda: _is_arraylike_1d(x),
 *         'both': lambda: _is_arraylike_1d(x) and _is_arraylike_1d(y)             # <<<<<<<<<<<<<<
 *     }
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_15_validate_input_2lambda16(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyMethodDef __pyx_mdef_9validator_15_validate_input_2lambda16 = {"lambda16", (PyCFunction)__pyx_pw_9validator_15_validate_input_2lambda16, METH_NOARGS, 0};
static PyObject *__pyx_pw_9validator_15_validate_input_2lambda16(PyObject *__pyx_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("lambda16 (wrapper)", 0);
  __pyx_r = __pyx_lambda_funcdef_lambda16(__pyx_self);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_lambda_funcdef_lambda16(PyObject *__pyx_self) {
  struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *__pyx_cur_scope;
  struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *__pyx_outer_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("lambda16", 0);
  __pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *) __Pyx_CyFunction_GetClosure(__pyx_self);
  __pyx_cur_scope = __pyx_outer_scope;
  __Pyx_XDECREF(__pyx_r);
  if (unlikely(!__pyx_cur_scope->__pyx_v__is_arraylike_1d)) { __Pyx_RaiseClosureNameError("_is_arraylike_1d"); __PYX_ERR(0, 3181, __pyx_L1_error) }
  if (unlikely(!__pyx_cur_scope->__pyx_v_x)) { __Pyx_RaiseClosureNameError("x"); __PYX_ERR(0, 3181, __pyx_L1_error) }
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v__is_arraylike_1d);
  __pyx_t_3 = __pyx_cur_scope->__pyx_v__is_arraylike_1d; __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_cur_scope->__pyx_v_x) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_cur_scope->__pyx_v_x);
  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3181, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 3181, __pyx_L1_error)
  if (__pyx_t_5) {
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  } else {
    __Pyx_INCREF(__pyx_t_2);
    __pyx_t_1 = __pyx_t_2;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    goto __pyx_L3_bool_binop_done;
  }
  if (unlikely(!__pyx_cur_scope->__pyx_v__is_arraylike_1d)) { __Pyx_RaiseClosureNameError("_is_arraylike_1d"); __PYX_ERR(0, 3181, __pyx_L1_error) }
  if (unlikely(!__pyx_cur_scope->__pyx_v_y)) { __Pyx_RaiseClosureNameError("y"); __PYX_ERR(0, 3181, __pyx_L1_error) }
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v__is_arraylike_1d);
  __pyx_t_3 = __pyx_cur_scope->__pyx_v__is_arraylike_1d; __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_cur_scope->__pyx_v_y) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_cur_scope->__pyx_v_y);
  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3181, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_INCREF(__pyx_t_2);
  __pyx_t_1 = __pyx_t_2;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_L3_bool_binop_done:;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("validator._validate_input.lambda16", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3159
 * 
 * 
 * def _validate_input(ignore: str, x, y, _is_arraylike_1d):             # <<<<<<<<<<<<<<
 *     """
 *     Validates that x and y are one-dimensional array-like structures based
 */

static PyObject *__pyx_pf_9validator_86_validate_input(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_ignore, PyObject *__pyx_v_x, PyObject *__pyx_v_y, PyObject *__pyx_v__is_arraylike_1d) {
  struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *__pyx_cur_scope;
  PyObject *__pyx_v_validation_checks = NULL;
  PyObject *__pyx_v_check = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  Py_ssize_t __pyx_t_8;
  Py_UCS4 __pyx_t_9;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_validate_input", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *)__pyx_tp_new_9validator___pyx_scope_struct_22__validate_input(__pyx_ptype_9validator___pyx_scope_struct_22__validate_input, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 3159, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_v_x = __pyx_v_x;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_x);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_x);
  __pyx_cur_scope->__pyx_v_y = __pyx_v_y;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_y);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_y);
  __pyx_cur_scope->__pyx_v__is_arraylike_1d = __pyx_v__is_arraylike_1d;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v__is_arraylike_1d);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v__is_arraylike_1d);

  /* "validator.pyx":3179
 *     """
 *     validation_checks = {
 *         'x': lambda: _is_arraylike_1d(y),             # <<<<<<<<<<<<<<
 *         'y': lambda: _is_arraylike_1d(x),
 *         'both': lambda: _is_arraylike_1d(x) and _is_arraylike_1d(y)
 */
  __pyx_t_1 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3179, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_9validator_15_validate_input_lambda14, 0, __pyx_n_s_validate_input_locals_lambda, ((PyObject*)__pyx_cur_scope), __pyx_n_s_validator, __pyx_d, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3179, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_u_x, __pyx_t_2) < 0) __PYX_ERR(0, 3179, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":3180
 *     validation_checks = {
 *         'x': lambda: _is_arraylike_1d(y),
 *         'y': lambda: _is_arraylike_1d(x),             # <<<<<<<<<<<<<<
 *         'both': lambda: _is_arraylike_1d(x) and _is_arraylike_1d(y)
 *     }
 */
  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_9validator_15_validate_input_1lambda15, 0, __pyx_n_s_validate_input_locals_lambda, ((PyObject*)__pyx_cur_scope), __pyx_n_s_validator, __pyx_d, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3180, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_u_y, __pyx_t_2) < 0) __PYX_ERR(0, 3179, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":3181
 *         'x': lambda: _is_arraylike_1d(y),
 *         'y': lambda: _is_arraylike_1d(x),
 *         'both': lambda: _is_arraylike_1d(x) and _is_arraylike_1d(y)             # <<<<<<<<<<<<<<
 *     }
 * 
 */
  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_9validator_15_validate_input_2lambda16, 0, __pyx_n_s_validate_input_locals_lambda, ((PyObject*)__pyx_cur_scope), __pyx_n_s_validator, __pyx_d, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3181, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_u_both, __pyx_t_2) < 0) __PYX_ERR(0, 3179, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_validation_checks = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":3184
 *     }
 * 
 *     check = validation_checks.get(ignore, validation_checks['both'])             # <<<<<<<<<<<<<<
 *     if not check():
 *         if ignore in ['x', 'y']:
 */
  __pyx_t_1 = __Pyx_PyDict_GetItem(__pyx_v_validation_checks, __pyx_n_u_both); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3184, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyDict_GetItemDefault(__pyx_v_validation_checks, __pyx_v_ignore, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3184, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_check = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "validator.pyx":3185
 * 
 *     check = validation_checks.get(ignore, validation_checks['both'])
 *     if not check():             # <<<<<<<<<<<<<<
 *         if ignore in ['x', 'y']:
 *             raise ValueError(f"Expected '{'y' if ignore == 'x' else 'x'}' to be"
 */
  __Pyx_INCREF(__pyx_v_check);
  __pyx_t_1 = __pyx_v_check; __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3185, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 3185, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (__pyx_t_5) {

    /* "validator.pyx":3186
 *     check = validation_checks.get(ignore, validation_checks['both'])
 *     if not check():
 *         if ignore in ['x', 'y']:             # <<<<<<<<<<<<<<
 *             raise ValueError(f"Expected '{'y' if ignore == 'x' else 'x'}' to be"
 *                              " a one-dimensional array-like structure.")
 */
    __Pyx_INCREF(__pyx_v_ignore);
    __pyx_t_6 = __pyx_v_ignore;
    __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_t_6, __pyx_n_u_x, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 3186, __pyx_L1_error)
    __pyx_t_7 = (__pyx_t_4 != 0);
    if (!__pyx_t_7) {
    } else {
      __pyx_t_5 = __pyx_t_7;
      goto __pyx_L5_bool_binop_done;
    }
    __pyx_t_7 = (__Pyx_PyUnicode_Equals(__pyx_t_6, __pyx_n_u_y, Py_EQ)); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 3186, __pyx_L1_error)
    __pyx_t_4 = (__pyx_t_7 != 0);
    __pyx_t_5 = __pyx_t_4;
    __pyx_L5_bool_binop_done:;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_4 = (__pyx_t_5 != 0);
    if (unlikely(__pyx_t_4)) {

      /* "validator.pyx":3187
 *     if not check():
 *         if ignore in ['x', 'y']:
 *             raise ValueError(f"Expected '{'y' if ignore == 'x' else 'x'}' to be"             # <<<<<<<<<<<<<<
 *                              " a one-dimensional array-like structure.")
 *         else:
 */
      __pyx_t_2 = PyTuple_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3187, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_8 = 0;
      __pyx_t_9 = 127;
      __Pyx_INCREF(__pyx_kp_u_Expected);
      __pyx_t_8 += 10;
      __Pyx_GIVEREF(__pyx_kp_u_Expected);
      PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_kp_u_Expected);
      __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_v_ignore, __pyx_n_u_x, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 3187, __pyx_L1_error)
      if ((__pyx_t_4 != 0)) {
        __Pyx_INCREF(__pyx_n_u_y);
        __pyx_t_1 = __pyx_n_u_y;
      } else {
        __Pyx_INCREF(__pyx_n_u_x);
        __pyx_t_1 = __pyx_n_u_x;
      }
      __pyx_t_3 = __Pyx_PyUnicode_Unicode(__pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3187, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_9 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) > __pyx_t_9) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) : __pyx_t_9;
      __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_3);
      __Pyx_GIVEREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_3);
      __pyx_t_3 = 0;
      __Pyx_INCREF(__pyx_kp_u_to_be_a_one_dimensional_array_l);
      __pyx_t_8 += 47;
      __Pyx_GIVEREF(__pyx_kp_u_to_be_a_one_dimensional_array_l);
      PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_kp_u_to_be_a_one_dimensional_array_l);
      __pyx_t_3 = __Pyx_PyUnicode_Join(__pyx_t_2, 3, __pyx_t_8, __pyx_t_9); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3187, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3187, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_Raise(__pyx_t_2, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __PYX_ERR(0, 3187, __pyx_L1_error)

      /* "validator.pyx":3186
 *     check = validation_checks.get(ignore, validation_checks['both'])
 *     if not check():
 *         if ignore in ['x', 'y']:             # <<<<<<<<<<<<<<
 *             raise ValueError(f"Expected '{'y' if ignore == 'x' else 'x'}' to be"
 *                              " a one-dimensional array-like structure.")
 */
    }

    /* "validator.pyx":3190
 *                              " a one-dimensional array-like structure.")
 *         else:
 *             raise ValueError("Expected both 'x' and 'y' to be one-dimensional "             # <<<<<<<<<<<<<<
 *                              "array-like structures.")
 * 
 */
    /*else*/ {
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__80, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3190, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_Raise(__pyx_t_2, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __PYX_ERR(0, 3190, __pyx_L1_error)
    }

    /* "validator.pyx":3185
 * 
 *     check = validation_checks.get(ignore, validation_checks['both'])
 *     if not check():             # <<<<<<<<<<<<<<
 *         if ignore in ['x', 'y']:
 *             raise ValueError(f"Expected '{'y' if ignore == 'x' else 'x'}' to be"
 */
  }

  /* "validator.pyx":3159
 * 
 * 
 * def _validate_input(ignore: str, x, y, _is_arraylike_1d):             # <<<<<<<<<<<<<<
 *     """
 *     Validates that x and y are one-dimensional array-like structures based
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("validator._validate_input", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_validation_checks);
  __Pyx_XDECREF(__pyx_v_check);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3193
 *                              "array-like structures.")
 * 
 * def _is_numeric_dtype (o, to_array =False ):             # <<<<<<<<<<<<<<
 *     """ Determine whether the argument has a numeric datatype, when
 *     converted to a NumPy array.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_89_is_numeric_dtype(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_88_is_numeric_dtype[] = " Determine whether the argument has a numeric datatype, when\n    converted to a NumPy array.\n\n    Booleans, unsigned integers, signed integers, floats and complex\n    numbers are the kinds of numeric datatype. \n    \n    :param o: object, arraylike \n        Object presumed to be an array \n    :param to_array: bool, default=False \n        If `o` is passed as non-array like list or tuple or other iterable \n        object. Setting `to_array` to ``True`` will convert `o` to array. \n    :return: bool, \n        ``True`` if `o` has a numeric dtype and ``False`` otherwise. \n    ";
static PyMethodDef __pyx_mdef_9validator_89_is_numeric_dtype = {"_is_numeric_dtype", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_89_is_numeric_dtype, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_88_is_numeric_dtype};
static PyObject *__pyx_pw_9validator_89_is_numeric_dtype(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_o = 0;
  PyObject *__pyx_v_to_array = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_is_numeric_dtype (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_o,&__pyx_n_s_to_array,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_o)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_to_array);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_is_numeric_dtype") < 0)) __PYX_ERR(0, 3193, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_o = values[0];
    __pyx_v_to_array = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_is_numeric_dtype", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3193, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator._is_numeric_dtype", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_88_is_numeric_dtype(__pyx_self, __pyx_v_o, __pyx_v_to_array);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_88_is_numeric_dtype(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_o, PyObject *__pyx_v_to_array) {
  PyObject *__pyx_v__NUMERIC_KINDS = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_is_numeric_dtype", 0);
  __Pyx_INCREF(__pyx_v_o);

  /* "validator.pyx":3208
 *         ``True`` if `o` has a numeric dtype and ``False`` otherwise.
 *     """
 *     _NUMERIC_KINDS = set('buifc')             # <<<<<<<<<<<<<<
 *     if not hasattr (o, '__iter__'):
 *         raise TypeError ("'o' is expected to be an iterable object."
 */
  __pyx_t_1 = PySet_New(__pyx_n_u_buifc); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3208, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v__NUMERIC_KINDS = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":3209
 *     """
 *     _NUMERIC_KINDS = set('buifc')
 *     if not hasattr (o, '__iter__'):             # <<<<<<<<<<<<<<
 *         raise TypeError ("'o' is expected to be an iterable object."
 *                          f" got: {type(o).__name__!r}")
 */
  __pyx_t_2 = __Pyx_HasAttr(__pyx_v_o, __pyx_n_u_iter); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 3209, __pyx_L1_error)
  __pyx_t_3 = ((!(__pyx_t_2 != 0)) != 0);
  if (unlikely(__pyx_t_3)) {

    /* "validator.pyx":3211
 *     if not hasattr (o, '__iter__'):
 *         raise TypeError ("'o' is expected to be an iterable object."
 *                          f" got: {type(o).__name__!r}")             # <<<<<<<<<<<<<<
 *     if to_array :
 *         o = np.array (o )
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_o)), __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3211, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_t_1), __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3211, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "validator.pyx":3210
 *     _NUMERIC_KINDS = set('buifc')
 *     if not hasattr (o, '__iter__'):
 *         raise TypeError ("'o' is expected to be an iterable object."             # <<<<<<<<<<<<<<
 *                          f" got: {type(o).__name__!r}")
 *     if to_array :
 */
    __pyx_t_1 = __Pyx_PyUnicode_Concat(__pyx_kp_u_o_is_expected_to_be_an_iterable, __pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3210, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3210, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 3210, __pyx_L1_error)

    /* "validator.pyx":3209
 *     """
 *     _NUMERIC_KINDS = set('buifc')
 *     if not hasattr (o, '__iter__'):             # <<<<<<<<<<<<<<
 *         raise TypeError ("'o' is expected to be an iterable object."
 *                          f" got: {type(o).__name__!r}")
 */
  }

  /* "validator.pyx":3212
 *         raise TypeError ("'o' is expected to be an iterable object."
 *                          f" got: {type(o).__name__!r}")
 *     if to_array :             # <<<<<<<<<<<<<<
 *         o = np.array (o )
 *     if not hasattr(o, '__array__'):
 */
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_to_array); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 3212, __pyx_L1_error)
  if (__pyx_t_3) {

    /* "validator.pyx":3213
 *                          f" got: {type(o).__name__!r}")
 *     if to_array :
 *         o = np.array (o )             # <<<<<<<<<<<<<<
 *     if not hasattr(o, '__array__'):
 *         raise ValueError (f"Expect type array, got: {type (o).__name__!r}")
 */
    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3213, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_array); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3213, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_1)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    __pyx_t_4 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_1, __pyx_v_o) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_o);
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3213, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF_SET(__pyx_v_o, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "validator.pyx":3212
 *         raise TypeError ("'o' is expected to be an iterable object."
 *                          f" got: {type(o).__name__!r}")
 *     if to_array :             # <<<<<<<<<<<<<<
 *         o = np.array (o )
 *     if not hasattr(o, '__array__'):
 */
  }

  /* "validator.pyx":3214
 *     if to_array :
 *         o = np.array (o )
 *     if not hasattr(o, '__array__'):             # <<<<<<<<<<<<<<
 *         raise ValueError (f"Expect type array, got: {type (o).__name__!r}")
 *     # use NUMERICKIND rather than # pd.api.types.is_numeric_dtype(arr)
 */
  __pyx_t_3 = __Pyx_HasAttr(__pyx_v_o, __pyx_n_u_array_2); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 3214, __pyx_L1_error)
  __pyx_t_2 = ((!(__pyx_t_3 != 0)) != 0);
  if (unlikely(__pyx_t_2)) {

    /* "validator.pyx":3215
 *         o = np.array (o )
 *     if not hasattr(o, '__array__'):
 *         raise ValueError (f"Expect type array, got: {type (o).__name__!r}")             # <<<<<<<<<<<<<<
 *     # use NUMERICKIND rather than # pd.api.types.is_numeric_dtype(arr)
 *     # for series and dataframes
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_o)), __pyx_n_s_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3215, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_t_4), __pyx_empty_unicode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3215, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Expect_type_array_got, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3215, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3215, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __PYX_ERR(0, 3215, __pyx_L1_error)

    /* "validator.pyx":3214
 *     if to_array :
 *         o = np.array (o )
 *     if not hasattr(o, '__array__'):             # <<<<<<<<<<<<<<
 *         raise ValueError (f"Expect type array, got: {type (o).__name__!r}")
 *     # use NUMERICKIND rather than # pd.api.types.is_numeric_dtype(arr)
 */
  }

  /* "validator.pyx":3218
 *     # use NUMERICKIND rather than # pd.api.types.is_numeric_dtype(arr)
 *     # for series and dataframes
 *     return ( o.values.dtype.kind             # <<<<<<<<<<<<<<
 *             if ( hasattr(o, 'columns') or hasattr (o, 'name'))
 *             else o.dtype.kind ) in _NUMERIC_KINDS
 */
  __Pyx_XDECREF(__pyx_r);

  /* "validator.pyx":3219
 *     # for series and dataframes
 *     return ( o.values.dtype.kind
 *             if ( hasattr(o, 'columns') or hasattr (o, 'name'))             # <<<<<<<<<<<<<<
 *             else o.dtype.kind ) in _NUMERIC_KINDS
 * 
 */
  __pyx_t_3 = __Pyx_HasAttr(__pyx_v_o, __pyx_n_u_columns); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 3219, __pyx_L1_error)
  __pyx_t_6 = (__pyx_t_3 != 0);
  if (!__pyx_t_6) {
  } else {
    __pyx_t_2 = __pyx_t_6;
    goto __pyx_L6_bool_binop_done;
  }
  __pyx_t_6 = __Pyx_HasAttr(__pyx_v_o, __pyx_n_u_name_2); if (unlikely(__pyx_t_6 == ((int)-1))) __PYX_ERR(0, 3219, __pyx_L1_error)
  __pyx_t_3 = (__pyx_t_6 != 0);
  __pyx_t_2 = __pyx_t_3;
  __pyx_L6_bool_binop_done:;
  if (__pyx_t_2) {

    /* "validator.pyx":3218
 *     # use NUMERICKIND rather than # pd.api.types.is_numeric_dtype(arr)
 *     # for series and dataframes
 *     return ( o.values.dtype.kind             # <<<<<<<<<<<<<<
 *             if ( hasattr(o, 'columns') or hasattr (o, 'name'))
 *             else o.dtype.kind ) in _NUMERIC_KINDS
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_o, __pyx_n_s_values); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3218, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_dtype); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3218, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_kind); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3218, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_5 = __pyx_t_4;
    __pyx_t_4 = 0;
  } else {

    /* "validator.pyx":3220
 *     return ( o.values.dtype.kind
 *             if ( hasattr(o, 'columns') or hasattr (o, 'name'))
 *             else o.dtype.kind ) in _NUMERIC_KINDS             # <<<<<<<<<<<<<<
 * 
 * def _check_consistency_size (ar1, ar2 ,  error ='raise') :
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_o, __pyx_n_s_dtype); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3220, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_kind); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3220, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_5 = __pyx_t_1;
    __pyx_t_1 = 0;
  }
  __pyx_t_2 = (__Pyx_PySet_ContainsTF(__pyx_t_5, __pyx_v__NUMERIC_KINDS, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 3220, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_PyBool_FromLong(__pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3220, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_r = __pyx_t_5;
  __pyx_t_5 = 0;
  goto __pyx_L0;

  /* "validator.pyx":3193
 *                              "array-like structures.")
 * 
 * def _is_numeric_dtype (o, to_array =False ):             # <<<<<<<<<<<<<<
 *     """ Determine whether the argument has a numeric datatype, when
 *     converted to a NumPy array.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("validator._is_numeric_dtype", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v__NUMERIC_KINDS);
  __Pyx_XDECREF(__pyx_v_o);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3222
 *             else o.dtype.kind ) in _NUMERIC_KINDS
 * 
 * def _check_consistency_size (ar1, ar2 ,  error ='raise') :             # <<<<<<<<<<<<<<
 *     """ Check consistency of two arrays and raises error if both sizes
 *     are differents.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_91_check_consistency_size(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_90_check_consistency_size[] = " Check consistency of two arrays and raises error if both sizes \n    are differents. \n    Returns 'False' if sizes are not consistent and error is set to 'ignore'.\n    ";
static PyMethodDef __pyx_mdef_9validator_91_check_consistency_size = {"_check_consistency_size", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_91_check_consistency_size, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_90_check_consistency_size};
static PyObject *__pyx_pw_9validator_91_check_consistency_size(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_ar1 = 0;
  PyObject *__pyx_v_ar2 = 0;
  PyObject *__pyx_v_error = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_check_consistency_size (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_ar1,&__pyx_n_s_ar2,&__pyx_n_s_error,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)__pyx_n_u_raise);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ar1)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_ar2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_check_consistency_size", 0, 2, 3, 1); __PYX_ERR(0, 3222, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_error);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_check_consistency_size") < 0)) __PYX_ERR(0, 3222, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_ar1 = values[0];
    __pyx_v_ar2 = values[1];
    __pyx_v_error = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_check_consistency_size", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3222, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator._check_consistency_size", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_90_check_consistency_size(__pyx_self, __pyx_v_ar1, __pyx_v_ar2, __pyx_v_error);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_90_check_consistency_size(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_ar1, PyObject *__pyx_v_ar2, PyObject *__pyx_v_error) {
  PyObject *__pyx_v_msg = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  Py_ssize_t __pyx_t_2;
  Py_ssize_t __pyx_t_3;
  Py_ssize_t __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_check_consistency_size", 0);

  /* "validator.pyx":3227
 *     Returns 'False' if sizes are not consistent and error is set to 'ignore'.
 *     """
 *     if error =='raise':             # <<<<<<<<<<<<<<
 *         msg =("Array sizes must be consistent: '{}' and '{}' were given.")
 *         assert len(ar1)==len(ar2), msg.format(len(ar1), len(ar2))
 */
  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_v_error, __pyx_n_u_raise, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 3227, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "validator.pyx":3228
 *     """
 *     if error =='raise':
 *         msg =("Array sizes must be consistent: '{}' and '{}' were given.")             # <<<<<<<<<<<<<<
 *         assert len(ar1)==len(ar2), msg.format(len(ar1), len(ar2))
 * 
 */
    __Pyx_INCREF(__pyx_kp_u_Array_sizes_must_be_consistent_a);
    __pyx_v_msg = __pyx_kp_u_Array_sizes_must_be_consistent_a;

    /* "validator.pyx":3229
 *     if error =='raise':
 *         msg =("Array sizes must be consistent: '{}' and '{}' were given.")
 *         assert len(ar1)==len(ar2), msg.format(len(ar1), len(ar2))             # <<<<<<<<<<<<<<
 * 
 *     return len(ar1)==len(ar2)
 */
    #ifndef CYTHON_WITHOUT_ASSERTIONS
    if (unlikely(!Py_OptimizeFlag)) {
      __pyx_t_2 = PyObject_Length(__pyx_v_ar1); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3229, __pyx_L1_error)
      __pyx_t_3 = PyObject_Length(__pyx_v_ar2); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3229, __pyx_L1_error)
      if (unlikely(!((__pyx_t_2 == __pyx_t_3) != 0))) {
        __pyx_t_4 = PyObject_Length(__pyx_v_ar1); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3229, __pyx_L1_error)
        __pyx_t_5 = PyInt_FromSsize_t(__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3229, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __pyx_t_4 = PyObject_Length(__pyx_v_ar2); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3229, __pyx_L1_error)
        __pyx_t_6 = PyInt_FromSsize_t(__pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3229, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __pyx_t_7 = __Pyx_CallUnboundCMethod2(&__pyx_umethod_PyUnicode_Type_format, __pyx_v_msg, __pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3229, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        __pyx_t_6 = PyTuple_Pack(1, __pyx_t_7); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3229, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        PyErr_SetObject(PyExc_AssertionError, __pyx_t_6);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        __PYX_ERR(0, 3229, __pyx_L1_error)
      }
    }
    #endif

    /* "validator.pyx":3227
 *     Returns 'False' if sizes are not consistent and error is set to 'ignore'.
 *     """
 *     if error =='raise':             # <<<<<<<<<<<<<<
 *         msg =("Array sizes must be consistent: '{}' and '{}' were given.")
 *         assert len(ar1)==len(ar2), msg.format(len(ar1), len(ar2))
 */
  }

  /* "validator.pyx":3231
 *         assert len(ar1)==len(ar2), msg.format(len(ar1), len(ar2))
 * 
 *     return len(ar1)==len(ar2)             # <<<<<<<<<<<<<<
 * 
 * def check_consistency_size ( *arrays ):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = PyObject_Length(__pyx_v_ar1); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3231, __pyx_L1_error)
  __pyx_t_2 = PyObject_Length(__pyx_v_ar2); if (unlikely(__pyx_t_2 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3231, __pyx_L1_error)
  __pyx_t_6 = __Pyx_PyBool_FromLong((__pyx_t_3 == __pyx_t_2)); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3231, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_r = __pyx_t_6;
  __pyx_t_6 = 0;
  goto __pyx_L0;

  /* "validator.pyx":3222
 *             else o.dtype.kind ) in _NUMERIC_KINDS
 * 
 * def _check_consistency_size (ar1, ar2 ,  error ='raise') :             # <<<<<<<<<<<<<<
 *     """ Check consistency of two arrays and raises error if both sizes
 *     are differents.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("validator._check_consistency_size", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_msg);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3233
 *     return len(ar1)==len(ar2)
 * 
 * def check_consistency_size ( *arrays ):             # <<<<<<<<<<<<<<
 *     """ Check consistency of array and raises error otherwise."""
 *     lengths = [len(X) for X in arrays if X is not None]
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_93check_consistency_size(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_92check_consistency_size[] = " Check consistency of array and raises error otherwise.";
static PyMethodDef __pyx_mdef_9validator_93check_consistency_size = {"check_consistency_size", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_93check_consistency_size, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_92check_consistency_size};
static PyObject *__pyx_pw_9validator_93check_consistency_size(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_arrays = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("check_consistency_size (wrapper)", 0);
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "check_consistency_size", 0))) return NULL;
  __Pyx_INCREF(__pyx_args);
  __pyx_v_arrays = __pyx_args;
  __pyx_r = __pyx_pf_9validator_92check_consistency_size(__pyx_self, __pyx_v_arrays);

  /* function exit code */
  __Pyx_XDECREF(__pyx_v_arrays);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_92check_consistency_size(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_arrays) {
  PyObject *__pyx_v_lengths = NULL;
  PyObject *__pyx_v_uniques = NULL;
  PyObject *__pyx_9genexpr16__pyx_v_X = NULL;
  PyObject *__pyx_9genexpr17__pyx_v_l = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  Py_ssize_t __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  Py_ssize_t __pyx_t_7;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("check_consistency_size", 0);

  /* "validator.pyx":3235
 * def check_consistency_size ( *arrays ):
 *     """ Check consistency of array and raises error otherwise."""
 *     lengths = [len(X) for X in arrays if X is not None]             # <<<<<<<<<<<<<<
 *     uniques = np.unique(lengths)
 *     if len(uniques) > 1:
 */
  { /* enter inner scope */
    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3235, __pyx_L5_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __pyx_v_arrays; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
    for (;;) {
      if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
      #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
      __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_4); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 3235, __pyx_L5_error)
      #else
      __pyx_t_4 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3235, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_4);
      #endif
      __Pyx_XDECREF_SET(__pyx_9genexpr16__pyx_v_X, __pyx_t_4);
      __pyx_t_4 = 0;
      __pyx_t_5 = (__pyx_9genexpr16__pyx_v_X != Py_None);
      __pyx_t_6 = (__pyx_t_5 != 0);
      if (__pyx_t_6) {
        __pyx_t_7 = PyObject_Length(__pyx_9genexpr16__pyx_v_X); if (unlikely(__pyx_t_7 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3235, __pyx_L5_error)
        __pyx_t_4 = PyInt_FromSsize_t(__pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3235, __pyx_L5_error)
        __Pyx_GOTREF(__pyx_t_4);
        if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_4))) __PYX_ERR(0, 3235, __pyx_L5_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_9genexpr16__pyx_v_X); __pyx_9genexpr16__pyx_v_X = 0;
    goto __pyx_L9_exit_scope;
    __pyx_L5_error:;
    __Pyx_XDECREF(__pyx_9genexpr16__pyx_v_X); __pyx_9genexpr16__pyx_v_X = 0;
    goto __pyx_L1_error;
    __pyx_L9_exit_scope:;
  } /* exit inner scope */
  __pyx_v_lengths = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":3236
 *     """ Check consistency of array and raises error otherwise."""
 *     lengths = [len(X) for X in arrays if X is not None]
 *     uniques = np.unique(lengths)             # <<<<<<<<<<<<<<
 *     if len(uniques) > 1:
 *         raise ValueError(
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3236, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_unique); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3236, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_2, __pyx_v_lengths) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_lengths);
  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3236, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_v_uniques = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":3237
 *     lengths = [len(X) for X in arrays if X is not None]
 *     uniques = np.unique(lengths)
 *     if len(uniques) > 1:             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             "Found input variables with inconsistent numbers of samples: %r"
 */
  __pyx_t_3 = PyObject_Length(__pyx_v_uniques); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3237, __pyx_L1_error)
  __pyx_t_6 = ((__pyx_t_3 > 1) != 0);
  if (unlikely(__pyx_t_6)) {

    /* "validator.pyx":3238
 *     uniques = np.unique(lengths)
 *     if len(uniques) > 1:
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             "Found input variables with inconsistent numbers of samples: %r"
 *             % [int(l) for l in lengths]
 */
    { /* enter inner scope */

      /* "validator.pyx":3240
 *         raise ValueError(
 *             "Found input variables with inconsistent numbers of samples: %r"
 *             % [int(l) for l in lengths]             # <<<<<<<<<<<<<<
 *         )
 * 
 */
      __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3240, __pyx_L13_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_4 = __pyx_v_lengths; __Pyx_INCREF(__pyx_t_4); __pyx_t_3 = 0;
      for (;;) {
        if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_4)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_2 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_3); __Pyx_INCREF(__pyx_t_2); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 3240, __pyx_L13_error)
        #else
        __pyx_t_2 = PySequence_ITEM(__pyx_t_4, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3240, __pyx_L13_error)
        __Pyx_GOTREF(__pyx_t_2);
        #endif
        __Pyx_XDECREF_SET(__pyx_9genexpr17__pyx_v_l, __pyx_t_2);
        __pyx_t_2 = 0;
        __pyx_t_2 = __Pyx_PyNumber_Int(__pyx_9genexpr17__pyx_v_l); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3240, __pyx_L13_error)
        __Pyx_GOTREF(__pyx_t_2);
        if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_2))) __PYX_ERR(0, 3240, __pyx_L13_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      }
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_9genexpr17__pyx_v_l); __pyx_9genexpr17__pyx_v_l = 0;
      goto __pyx_L16_exit_scope;
      __pyx_L13_error:;
      __Pyx_XDECREF(__pyx_9genexpr17__pyx_v_l); __pyx_9genexpr17__pyx_v_l = 0;
      goto __pyx_L1_error;
      __pyx_L16_exit_scope:;
    } /* exit inner scope */
    __pyx_t_4 = PyUnicode_Format(__pyx_kp_u_Found_input_variables_with_incon, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3240, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "validator.pyx":3238
 *     uniques = np.unique(lengths)
 *     if len(uniques) > 1:
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             "Found input variables with inconsistent numbers of samples: %r"
 *             % [int(l) for l in lengths]
 */
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3238, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 3238, __pyx_L1_error)

    /* "validator.pyx":3237
 *     lengths = [len(X) for X in arrays if X is not None]
 *     uniques = np.unique(lengths)
 *     if len(uniques) > 1:             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             "Found input variables with inconsistent numbers of samples: %r"
 */
  }

  /* "validator.pyx":3233
 *     return len(ar1)==len(ar2)
 * 
 * def check_consistency_size ( *arrays ):             # <<<<<<<<<<<<<<
 *     """ Check consistency of array and raises error otherwise."""
 *     lengths = [len(X) for X in arrays if X is not None]
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("validator.check_consistency_size", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_lengths);
  __Pyx_XDECREF(__pyx_v_uniques);
  __Pyx_XDECREF(__pyx_9genexpr16__pyx_v_X);
  __Pyx_XDECREF(__pyx_9genexpr17__pyx_v_l);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3243
 *         )
 * 
 * def _is_buildin (o,  mode ='soft'):             # <<<<<<<<<<<<<<
 *     """ Returns 'True' wether the module is a Python buidling function.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_95_is_buildin(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_94_is_buildin[] = " Returns 'True' wether the module is a Python buidling function. \n    \n    If  `mode` is ``strict`` only assert the specific predifined-functions \n    like 'str', 'len' etc, otherwise check in the whole predifined functions\n    including the object with type equals to 'module'\n    \n    :param o: object\n        Any object for verification \n    :param mode: str , default='soft' \n        mode for asserting object. Can also be 'strict' for the specific \n        predifined build-in functions. \n    :param module: \n    ";
static PyMethodDef __pyx_mdef_9validator_95_is_buildin = {"_is_buildin", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_95_is_buildin, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_94_is_buildin};
static PyObject *__pyx_pw_9validator_95_is_buildin(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_o = 0;
  PyObject *__pyx_v_mode = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_is_buildin (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_o,&__pyx_n_s_mode,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)__pyx_n_u_soft);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_o)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_mode);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_is_buildin") < 0)) __PYX_ERR(0, 3243, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_o = values[0];
    __pyx_v_mode = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_is_buildin", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3243, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator._is_buildin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_94_is_buildin(__pyx_self, __pyx_v_o, __pyx_v_mode);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_94_is_buildin(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_o, PyObject *__pyx_v_mode) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  Py_ssize_t __pyx_t_4;
  Py_UCS4 __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_is_buildin", 0);

  /* "validator.pyx":3257
 *     :param module:
 *     """
 *     assert mode in {'strict', 'soft'}, f"Unsupports mode {mode!r}, "\             # <<<<<<<<<<<<<<
 *         "expects 'strict'or 'soft'"
 * 
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!Py_OptimizeFlag)) {
    __Pyx_INCREF(__pyx_v_mode);
    __pyx_t_1 = __pyx_v_mode;
    __pyx_t_3 = (__Pyx_PyUnicode_Equals(__pyx_t_1, __pyx_n_u_strict, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 3257, __pyx_L1_error)
    if (!__pyx_t_3) {
    } else {
      __pyx_t_2 = __pyx_t_3;
      goto __pyx_L3_bool_binop_done;
    }
    __pyx_t_3 = (__Pyx_PyUnicode_Equals(__pyx_t_1, __pyx_n_u_soft, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 3257, __pyx_L1_error)
    __pyx_t_2 = __pyx_t_3;
    __pyx_L3_bool_binop_done:;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(!(__pyx_t_2 != 0))) {
      __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3257, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_4 = 0;
      __pyx_t_5 = 127;
      __Pyx_INCREF(__pyx_kp_u_Unsupports_mode);
      __pyx_t_4 += 16;
      __Pyx_GIVEREF(__pyx_kp_u_Unsupports_mode);
      PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_Unsupports_mode);
      __pyx_t_6 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_v_mode), __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3257, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_5 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) > __pyx_t_5) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) : __pyx_t_5;
      __pyx_t_4 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
      __Pyx_GIVEREF(__pyx_t_6);
      PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_6);
      __pyx_t_6 = 0;
      __Pyx_INCREF(__pyx_kp_u_expects_strict_or_soft);
      __pyx_t_4 += 27;
      __Pyx_GIVEREF(__pyx_kp_u_expects_strict_or_soft);
      PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_expects_strict_or_soft);
      __pyx_t_6 = __Pyx_PyUnicode_Join(__pyx_t_1, 3, __pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3257, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      PyErr_SetObject(PyExc_AssertionError, __pyx_t_6);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __PYX_ERR(0, 3257, __pyx_L1_error)
    }
  }
  #endif

  /* "validator.pyx":3260
 *         "expects 'strict'or 'soft'"
 * 
 *     return  (isinstance(o, types.BuiltinFunctionType) and inspect.isbuiltin (o)             # <<<<<<<<<<<<<<
 *              ) if mode=='strict' else type (o).__module__== 'builtins'
 * 
 */
  __Pyx_XDECREF(__pyx_r);

  /* "validator.pyx":3261
 * 
 *     return  (isinstance(o, types.BuiltinFunctionType) and inspect.isbuiltin (o)
 *              ) if mode=='strict' else type (o).__module__== 'builtins'             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_v_mode, __pyx_n_u_strict, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 3261, __pyx_L1_error)
  if (__pyx_t_2) {

    /* "validator.pyx":3260
 *         "expects 'strict'or 'soft'"
 * 
 *     return  (isinstance(o, types.BuiltinFunctionType) and inspect.isbuiltin (o)             # <<<<<<<<<<<<<<
 *              ) if mode=='strict' else type (o).__module__== 'builtins'
 * 
 */
    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_types); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3260, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_BuiltinFunctionType); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3260, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_3 = PyObject_IsInstance(__pyx_v_o, __pyx_t_8); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 3260, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    if (__pyx_t_3) {
    } else {
      __pyx_t_8 = __Pyx_PyBool_FromLong(__pyx_t_3); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3260, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_1 = __pyx_t_8;
      __pyx_t_8 = 0;
      goto __pyx_L5_bool_binop_done;
    }
    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_inspect); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3260, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_isbuiltin); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 3260, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_9))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_9);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_9, function);
      }
    }
    __pyx_t_8 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_9, __pyx_t_7, __pyx_v_o) : __Pyx_PyObject_CallOneArg(__pyx_t_9, __pyx_v_o);
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
    if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3260, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __Pyx_INCREF(__pyx_t_8);
    __pyx_t_1 = __pyx_t_8;
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_L5_bool_binop_done:;
    __pyx_t_6 = __pyx_t_1;
    __pyx_t_1 = 0;
  } else {

    /* "validator.pyx":3261
 * 
 *     return  (isinstance(o, types.BuiltinFunctionType) and inspect.isbuiltin (o)
 *              ) if mode=='strict' else type (o).__module__== 'builtins'             # <<<<<<<<<<<<<<
 * 
 * 
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_o)), __pyx_n_s_module); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3261, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_8 = PyObject_RichCompare(__pyx_t_1, __pyx_n_u_builtins, Py_EQ); __Pyx_XGOTREF(__pyx_t_8); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3261, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_6 = __pyx_t_8;
    __pyx_t_8 = 0;
  }
  __pyx_r = __pyx_t_6;
  __pyx_t_6 = 0;
  goto __pyx_L0;

  /* "validator.pyx":3243
 *         )
 * 
 * def _is_buildin (o,  mode ='soft'):             # <<<<<<<<<<<<<<
 *     """ Returns 'True' wether the module is a Python buidling function.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("validator._is_buildin", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3264
 * 
 * 
 * def get_estimator_name (estimator ):             # <<<<<<<<<<<<<<
 *     """ Get the estimator name whatever it is an instanciated object or not
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_97get_estimator_name(PyObject *__pyx_self, PyObject *__pyx_v_estimator); /*proto*/
static char __pyx_doc_9validator_96get_estimator_name[] = " Get the estimator name whatever it is an instanciated object or not  \n    \n    :param estimator: callable or instanciated object,\n        callable or instance object that has a fit method. \n    \n    :return: str, \n        name of the estimator. \n    ";
static PyMethodDef __pyx_mdef_9validator_97get_estimator_name = {"get_estimator_name", (PyCFunction)__pyx_pw_9validator_97get_estimator_name, METH_O, __pyx_doc_9validator_96get_estimator_name};
static PyObject *__pyx_pw_9validator_97get_estimator_name(PyObject *__pyx_self, PyObject *__pyx_v_estimator) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_estimator_name (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_96get_estimator_name(__pyx_self, ((PyObject *)__pyx_v_estimator));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_96get_estimator_name(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_estimator) {
  PyObject *__pyx_v_name = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("get_estimator_name", 0);

  /* "validator.pyx":3273
 *         name of the estimator.
 *     """
 *     name =' '             # <<<<<<<<<<<<<<
 *     if hasattr (estimator, '__qualname__') and hasattr(
 *             estimator, '__name__'):
 */
  __Pyx_INCREF(__pyx_kp_u__81);
  __pyx_v_name = __pyx_kp_u__81;

  /* "validator.pyx":3274
 *     """
 *     name =' '
 *     if hasattr (estimator, '__qualname__') and hasattr(             # <<<<<<<<<<<<<<
 *             estimator, '__name__'):
 *         name = estimator.__name__
 */
  __pyx_t_2 = __Pyx_HasAttr(__pyx_v_estimator, __pyx_n_u_qualname); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 3274, __pyx_L1_error)
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (__pyx_t_3) {
  } else {
    __pyx_t_1 = __pyx_t_3;
    goto __pyx_L4_bool_binop_done;
  }

  /* "validator.pyx":3275
 *     name =' '
 *     if hasattr (estimator, '__qualname__') and hasattr(
 *             estimator, '__name__'):             # <<<<<<<<<<<<<<
 *         name = estimator.__name__
 *     elif hasattr(estimator, '__class__') and not hasattr (
 */
  __pyx_t_3 = __Pyx_HasAttr(__pyx_v_estimator, __pyx_n_u_name); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 3274, __pyx_L1_error)

  /* "validator.pyx":3274
 *     """
 *     name =' '
 *     if hasattr (estimator, '__qualname__') and hasattr(             # <<<<<<<<<<<<<<
 *             estimator, '__name__'):
 *         name = estimator.__name__
 */
  __pyx_t_2 = (__pyx_t_3 != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L4_bool_binop_done:;
  if (__pyx_t_1) {

    /* "validator.pyx":3276
 *     if hasattr (estimator, '__qualname__') and hasattr(
 *             estimator, '__name__'):
 *         name = estimator.__name__             # <<<<<<<<<<<<<<
 *     elif hasattr(estimator, '__class__') and not hasattr (
 *             estimator, '__name__'):
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_estimator, __pyx_n_s_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3276, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF_SET(__pyx_v_name, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "validator.pyx":3274
 *     """
 *     name =' '
 *     if hasattr (estimator, '__qualname__') and hasattr(             # <<<<<<<<<<<<<<
 *             estimator, '__name__'):
 *         name = estimator.__name__
 */
    goto __pyx_L3;
  }

  /* "validator.pyx":3277
 *             estimator, '__name__'):
 *         name = estimator.__name__
 *     elif hasattr(estimator, '__class__') and not hasattr (             # <<<<<<<<<<<<<<
 *             estimator, '__name__'):
 *         name = estimator.__class__.__name__
 */
  __pyx_t_2 = __Pyx_HasAttr(__pyx_v_estimator, __pyx_n_u_class); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 3277, __pyx_L1_error)
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (__pyx_t_3) {
  } else {
    __pyx_t_1 = __pyx_t_3;
    goto __pyx_L6_bool_binop_done;
  }

  /* "validator.pyx":3278
 *         name = estimator.__name__
 *     elif hasattr(estimator, '__class__') and not hasattr (
 *             estimator, '__name__'):             # <<<<<<<<<<<<<<
 *         name = estimator.__class__.__name__
 *     return name
 */
  __pyx_t_3 = __Pyx_HasAttr(__pyx_v_estimator, __pyx_n_u_name); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 3277, __pyx_L1_error)

  /* "validator.pyx":3277
 *             estimator, '__name__'):
 *         name = estimator.__name__
 *     elif hasattr(estimator, '__class__') and not hasattr (             # <<<<<<<<<<<<<<
 *             estimator, '__name__'):
 *         name = estimator.__class__.__name__
 */
  __pyx_t_2 = ((!(__pyx_t_3 != 0)) != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L6_bool_binop_done:;
  if (__pyx_t_1) {

    /* "validator.pyx":3279
 *     elif hasattr(estimator, '__class__') and not hasattr (
 *             estimator, '__name__'):
 *         name = estimator.__class__.__name__             # <<<<<<<<<<<<<<
 *     return name
 * 
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_estimator, __pyx_n_s_class); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3279, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_name); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3279, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF_SET(__pyx_v_name, __pyx_t_5);
    __pyx_t_5 = 0;

    /* "validator.pyx":3277
 *             estimator, '__name__'):
 *         name = estimator.__name__
 *     elif hasattr(estimator, '__class__') and not hasattr (             # <<<<<<<<<<<<<<
 *             estimator, '__name__'):
 *         name = estimator.__class__.__name__
 */
  }
  __pyx_L3:;

  /* "validator.pyx":3280
 *             estimator, '__name__'):
 *         name = estimator.__class__.__name__
 *     return name             # <<<<<<<<<<<<<<
 * 
 * def _is_cross_validated (estimator ):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_name);
  __pyx_r = __pyx_v_name;
  goto __pyx_L0;

  /* "validator.pyx":3264
 * 
 * 
 * def get_estimator_name (estimator ):             # <<<<<<<<<<<<<<
 *     """ Get the estimator name whatever it is an instanciated object or not
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("validator.get_estimator_name", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_name);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3282
 *     return name
 * 
 * def _is_cross_validated (estimator ):             # <<<<<<<<<<<<<<
 *     """ Check whether the estimator has already passed the cross validation
 *      procedure.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_99_is_cross_validated(PyObject *__pyx_self, PyObject *__pyx_v_estimator); /*proto*/
static char __pyx_doc_9validator_98_is_cross_validated[] = " Check whether the estimator has already passed the cross validation\n     procedure. \n     \n    We assume it has the attributes 'best_params_' and 'best_estimator_' \n    already populated.\n    \n    :param estimator: callable or instanciated object, that has a fit method. \n    :return: bool, \n        estimator has already passed the cross-validation procedure. \n    \n    ";
static PyMethodDef __pyx_mdef_9validator_99_is_cross_validated = {"_is_cross_validated", (PyCFunction)__pyx_pw_9validator_99_is_cross_validated, METH_O, __pyx_doc_9validator_98_is_cross_validated};
static PyObject *__pyx_pw_9validator_99_is_cross_validated(PyObject *__pyx_self, PyObject *__pyx_v_estimator) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_is_cross_validated (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_98_is_cross_validated(__pyx_self, ((PyObject *)__pyx_v_estimator));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_98_is_cross_validated(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_estimator) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_is_cross_validated", 0);

  /* "validator.pyx":3294
 * 
 *     """
 *     return hasattr(estimator, 'best_estimator_') and hasattr (             # <<<<<<<<<<<<<<
 *         estimator , 'best_params_')
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_HasAttr(__pyx_v_estimator, __pyx_n_u_best_estimator); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 3294, __pyx_L1_error)
  if (__pyx_t_2) {
  } else {
    __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3294, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_1 = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L3_bool_binop_done;
  }

  /* "validator.pyx":3295
 *     """
 *     return hasattr(estimator, 'best_estimator_') and hasattr (
 *         estimator , 'best_params_')             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_2 = __Pyx_HasAttr(__pyx_v_estimator, __pyx_n_u_best_params); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 3294, __pyx_L1_error)

  /* "validator.pyx":3294
 * 
 *     """
 *     return hasattr(estimator, 'best_estimator_') and hasattr (             # <<<<<<<<<<<<<<
 *         estimator , 'best_params_')
 * 
 */
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3294, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_1 = __pyx_t_3;
  __pyx_t_3 = 0;
  __pyx_L3_bool_binop_done:;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "validator.pyx":3282
 *     return name
 * 
 * def _is_cross_validated (estimator ):             # <<<<<<<<<<<<<<
 *     """ Check whether the estimator has already passed the cross validation
 *      procedure.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("validator._is_cross_validated", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3298
 * 
 * 
 * def _check_array_in(obj,  arr_name):             # <<<<<<<<<<<<<<
 *     """Returns the array from the array name attribute. Note that the singleton
 *     array is not admitted.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_101_check_array_in(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_100_check_array_in[] = "Returns the array from the array name attribute. Note that the singleton \n    array is not admitted. \n    \n    This helper function tries to return array from object attribute  where \n    object attribute is the array name if exists. Otherwise raises an error. \n    \n    Parameters\n    ----------\n    obj : object \n       Object that is expected to contain the array attribute.\n    Returns\n    -------\n    X : array\n       Array fetched from its name in `obj`. \n    ";
static PyMethodDef __pyx_mdef_9validator_101_check_array_in = {"_check_array_in", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_101_check_array_in, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_100_check_array_in};
static PyObject *__pyx_pw_9validator_101_check_array_in(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_obj = 0;
  PyObject *__pyx_v_arr_name = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_check_array_in (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_obj,&__pyx_n_s_arr_name,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_obj)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arr_name)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_check_array_in", 1, 2, 2, 1); __PYX_ERR(0, 3298, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_check_array_in") < 0)) __PYX_ERR(0, 3298, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_obj = values[0];
    __pyx_v_arr_name = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_check_array_in", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3298, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator._check_array_in", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_100_check_array_in(__pyx_self, __pyx_v_obj, __pyx_v_arr_name);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_100_check_array_in(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_obj, PyObject *__pyx_v_arr_name) {
  PyTypeObject *__pyx_v_type_ = NULL;
  PyObject *__pyx_v_type_name = NULL;
  PyObject *__pyx_v_o_ = NULL;
  PyObject *__pyx_v_message = NULL;
  PyObject *__pyx_v_X = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  Py_ssize_t __pyx_t_5;
  Py_UCS4 __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_t_9;
  PyObject *__pyx_t_10 = NULL;
  int __pyx_t_11;
  int __pyx_t_12;
  int __pyx_t_13;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_check_array_in", 0);

  /* "validator.pyx":3315
 *     """
 * 
 *     type_ = type(obj)             # <<<<<<<<<<<<<<
 *     try :
 *         type_name = f"{obj.__module__}.{obj.__qualname__}"
 */
  __Pyx_INCREF(((PyObject *)Py_TYPE(__pyx_v_obj)));
  __pyx_v_type_ = ((PyTypeObject*)((PyObject *)Py_TYPE(__pyx_v_obj)));

  /* "validator.pyx":3316
 * 
 *     type_ = type(obj)
 *     try :             # <<<<<<<<<<<<<<
 *         type_name = f"{obj.__module__}.{obj.__qualname__}"
 *         o_= f" in {obj.__name__!r}"
 */
  {
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
    __Pyx_XGOTREF(__pyx_t_1);
    __Pyx_XGOTREF(__pyx_t_2);
    __Pyx_XGOTREF(__pyx_t_3);
    /*try:*/ {

      /* "validator.pyx":3317
 *     type_ = type(obj)
 *     try :
 *         type_name = f"{obj.__module__}.{obj.__qualname__}"             # <<<<<<<<<<<<<<
 *         o_= f" in {obj.__name__!r}"
 *     except AttributeError:
 */
      __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3317, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_5 = 0;
      __pyx_t_6 = 127;
      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_obj, __pyx_n_s_module); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3317, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_8 = __Pyx_PyObject_FormatSimple(__pyx_t_7, __pyx_empty_unicode); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3317, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_8) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_8) : __pyx_t_6;
      __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_8);
      __Pyx_GIVEREF(__pyx_t_8);
      PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_8);
      __pyx_t_8 = 0;
      __Pyx_INCREF(__pyx_kp_u__16);
      __pyx_t_5 += 1;
      __Pyx_GIVEREF(__pyx_kp_u__16);
      PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_kp_u__16);
      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_obj, __pyx_n_s_qualname); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3317, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_7 = __Pyx_PyObject_FormatSimple(__pyx_t_8, __pyx_empty_unicode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3317, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) : __pyx_t_6;
      __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_7);
      __Pyx_GIVEREF(__pyx_t_7);
      PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_7);
      __pyx_t_7 = 0;
      __pyx_t_7 = __Pyx_PyUnicode_Join(__pyx_t_4, 3, __pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3317, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_v_type_name = __pyx_t_7;
      __pyx_t_7 = 0;

      /* "validator.pyx":3318
 *     try :
 *         type_name = f"{obj.__module__}.{obj.__qualname__}"
 *         o_= f" in {obj.__name__!r}"             # <<<<<<<<<<<<<<
 *     except AttributeError:
 *         type_name = type_.__qualname__
 */
      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_obj, __pyx_n_s_name); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3318, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_4 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_t_7), __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3318, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __pyx_t_7 = __Pyx_PyUnicode_Concat(__pyx_kp_u_in, __pyx_t_4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3318, __pyx_L3_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_v_o_ = ((PyObject*)__pyx_t_7);
      __pyx_t_7 = 0;

      /* "validator.pyx":3316
 * 
 *     type_ = type(obj)
 *     try :             # <<<<<<<<<<<<<<
 *         type_name = f"{obj.__module__}.{obj.__qualname__}"
 *         o_= f" in {obj.__name__!r}"
 */
    }
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    goto __pyx_L8_try_end;
    __pyx_L3_error:;
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;

    /* "validator.pyx":3319
 *         type_name = f"{obj.__module__}.{obj.__qualname__}"
 *         o_= f" in {obj.__name__!r}"
 *     except AttributeError:             # <<<<<<<<<<<<<<
 *         type_name = type_.__qualname__
 *         o_=''
 */
    __pyx_t_9 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_AttributeError);
    if (__pyx_t_9) {
      __Pyx_AddTraceback("validator._check_array_in", __pyx_clineno, __pyx_lineno, __pyx_filename);
      if (__Pyx_GetException(&__pyx_t_7, &__pyx_t_4, &__pyx_t_8) < 0) __PYX_ERR(0, 3319, __pyx_L5_except_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_GOTREF(__pyx_t_8);

      /* "validator.pyx":3320
 *         o_= f" in {obj.__name__!r}"
 *     except AttributeError:
 *         type_name = type_.__qualname__             # <<<<<<<<<<<<<<
 *         o_=''
 * 
 */
      __pyx_t_10 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_type_), __pyx_n_s_qualname); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 3320, __pyx_L5_except_error)
      __Pyx_GOTREF(__pyx_t_10);
      __Pyx_XDECREF_SET(__pyx_v_type_name, __pyx_t_10);
      __pyx_t_10 = 0;

      /* "validator.pyx":3321
 *     except AttributeError:
 *         type_name = type_.__qualname__
 *         o_=''             # <<<<<<<<<<<<<<
 * 
 *     message = (f"Unable to find the name {arr_name!r}"
 */
      __Pyx_INCREF(__pyx_kp_u__7);
      __Pyx_XDECREF_SET(__pyx_v_o_, __pyx_kp_u__7);
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      goto __pyx_L4_exception_handled;
    }
    goto __pyx_L5_except_error;
    __pyx_L5_except_error:;

    /* "validator.pyx":3316
 * 
 *     type_ = type(obj)
 *     try :             # <<<<<<<<<<<<<<
 *         type_name = f"{obj.__module__}.{obj.__qualname__}"
 *         o_= f" in {obj.__name__!r}"
 */
    __Pyx_XGIVEREF(__pyx_t_1);
    __Pyx_XGIVEREF(__pyx_t_2);
    __Pyx_XGIVEREF(__pyx_t_3);
    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
    goto __pyx_L1_error;
    __pyx_L4_exception_handled:;
    __Pyx_XGIVEREF(__pyx_t_1);
    __Pyx_XGIVEREF(__pyx_t_2);
    __Pyx_XGIVEREF(__pyx_t_3);
    __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
    __pyx_L8_try_end:;
  }

  /* "validator.pyx":3323
 *         o_=''
 * 
 *     message = (f"Unable to find the name {arr_name!r}"             # <<<<<<<<<<<<<<
 *                f"{o_} from {type_name!r}")
 * 
 */
  __pyx_t_8 = PyTuple_New(5); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3323, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __pyx_t_5 = 0;
  __pyx_t_6 = 127;
  __Pyx_INCREF(__pyx_kp_u_Unable_to_find_the_name);
  __pyx_t_5 += 24;
  __Pyx_GIVEREF(__pyx_kp_u_Unable_to_find_the_name);
  PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_kp_u_Unable_to_find_the_name);
  __pyx_t_4 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_v_arr_name), __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3323, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) : __pyx_t_6;
  __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_8, 1, __pyx_t_4);
  __pyx_t_4 = 0;

  /* "validator.pyx":3324
 * 
 *     message = (f"Unable to find the name {arr_name!r}"
 *                f"{o_} from {type_name!r}")             # <<<<<<<<<<<<<<
 * 
 *     if not hasattr (obj , arr_name ):
 */
  __Pyx_INCREF(__pyx_v_o_);
  __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_v_o_) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_v_o_) : __pyx_t_6;
  __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_v_o_);
  __Pyx_GIVEREF(__pyx_v_o_);
  PyTuple_SET_ITEM(__pyx_t_8, 2, __pyx_v_o_);
  __Pyx_INCREF(__pyx_kp_u_from);
  __pyx_t_5 += 6;
  __Pyx_GIVEREF(__pyx_kp_u_from);
  PyTuple_SET_ITEM(__pyx_t_8, 3, __pyx_kp_u_from);
  __pyx_t_4 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_v_type_name), __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3324, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) : __pyx_t_6;
  __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_8, 4, __pyx_t_4);
  __pyx_t_4 = 0;

  /* "validator.pyx":3323
 *         o_=''
 * 
 *     message = (f"Unable to find the name {arr_name!r}"             # <<<<<<<<<<<<<<
 *                f"{o_} from {type_name!r}")
 * 
 */
  __pyx_t_4 = __Pyx_PyUnicode_Join(__pyx_t_8, 5, __pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3323, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __pyx_v_message = ((PyObject*)__pyx_t_4);
  __pyx_t_4 = 0;

  /* "validator.pyx":3326
 *                f"{o_} from {type_name!r}")
 * 
 *     if not hasattr (obj , arr_name ):             # <<<<<<<<<<<<<<
 *         raise TypeError (message )
 * 
 */
  __pyx_t_11 = __Pyx_HasAttr(__pyx_v_obj, __pyx_v_arr_name); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(0, 3326, __pyx_L1_error)
  __pyx_t_12 = ((!(__pyx_t_11 != 0)) != 0);
  if (unlikely(__pyx_t_12)) {

    /* "validator.pyx":3327
 * 
 *     if not hasattr (obj , arr_name ):
 *         raise TypeError (message )             # <<<<<<<<<<<<<<
 * 
 *     X = getattr ( obj , f"{arr_name}")
 */
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_v_message); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3327, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 3327, __pyx_L1_error)

    /* "validator.pyx":3326
 *                f"{o_} from {type_name!r}")
 * 
 *     if not hasattr (obj , arr_name ):             # <<<<<<<<<<<<<<
 *         raise TypeError (message )
 * 
 */
  }

  /* "validator.pyx":3329
 *         raise TypeError (message )
 * 
 *     X = getattr ( obj , f"{arr_name}")             # <<<<<<<<<<<<<<
 * 
 *     if not hasattr(X, "__len__") and not hasattr(X, "shape"):
 */
  __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_v_arr_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3329, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_8 = __Pyx_GetAttr(__pyx_v_obj, __pyx_t_4); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3329, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_v_X = __pyx_t_8;
  __pyx_t_8 = 0;

  /* "validator.pyx":3331
 *     X = getattr ( obj , f"{arr_name}")
 * 
 *     if not hasattr(X, "__len__") and not hasattr(X, "shape"):             # <<<<<<<<<<<<<<
 *         if not hasattr(X, "__array__"):
 *             raise TypeError(message)
 */
  __pyx_t_11 = __Pyx_HasAttr(__pyx_v_X, __pyx_n_u_len); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(0, 3331, __pyx_L1_error)
  __pyx_t_13 = ((!(__pyx_t_11 != 0)) != 0);
  if (__pyx_t_13) {
  } else {
    __pyx_t_12 = __pyx_t_13;
    goto __pyx_L13_bool_binop_done;
  }
  __pyx_t_13 = __Pyx_HasAttr(__pyx_v_X, __pyx_n_u_shape); if (unlikely(__pyx_t_13 == ((int)-1))) __PYX_ERR(0, 3331, __pyx_L1_error)
  __pyx_t_11 = ((!(__pyx_t_13 != 0)) != 0);
  __pyx_t_12 = __pyx_t_11;
  __pyx_L13_bool_binop_done:;
  if (__pyx_t_12) {

    /* "validator.pyx":3332
 * 
 *     if not hasattr(X, "__len__") and not hasattr(X, "shape"):
 *         if not hasattr(X, "__array__"):             # <<<<<<<<<<<<<<
 *             raise TypeError(message)
 *         # Only convert X to a numpy array if there is no cheaper, heuristic
 */
    __pyx_t_12 = __Pyx_HasAttr(__pyx_v_X, __pyx_n_u_array_2); if (unlikely(__pyx_t_12 == ((int)-1))) __PYX_ERR(0, 3332, __pyx_L1_error)
    __pyx_t_11 = ((!(__pyx_t_12 != 0)) != 0);
    if (unlikely(__pyx_t_11)) {

      /* "validator.pyx":3333
 *     if not hasattr(X, "__len__") and not hasattr(X, "shape"):
 *         if not hasattr(X, "__array__"):
 *             raise TypeError(message)             # <<<<<<<<<<<<<<
 *         # Only convert X to a numpy array if there is no cheaper, heuristic
 *         # option.
 */
      __pyx_t_8 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_v_message); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3333, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_Raise(__pyx_t_8, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __PYX_ERR(0, 3333, __pyx_L1_error)

      /* "validator.pyx":3332
 * 
 *     if not hasattr(X, "__len__") and not hasattr(X, "shape"):
 *         if not hasattr(X, "__array__"):             # <<<<<<<<<<<<<<
 *             raise TypeError(message)
 *         # Only convert X to a numpy array if there is no cheaper, heuristic
 */
    }

    /* "validator.pyx":3336
 *         # Only convert X to a numpy array if there is no cheaper, heuristic
 *         # option.
 *         X = np.asarray(X)             # <<<<<<<<<<<<<<
 * 
 *     if hasattr(X, "shape"):
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3336, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_asarray); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3336, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_7);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_7, function);
      }
    }
    __pyx_t_8 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_4, __pyx_v_X) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_v_X);
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3336, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_8);
    __pyx_t_8 = 0;

    /* "validator.pyx":3331
 *     X = getattr ( obj , f"{arr_name}")
 * 
 *     if not hasattr(X, "__len__") and not hasattr(X, "shape"):             # <<<<<<<<<<<<<<
 *         if not hasattr(X, "__array__"):
 *             raise TypeError(message)
 */
  }

  /* "validator.pyx":3338
 *         X = np.asarray(X)
 * 
 *     if hasattr(X, "shape"):             # <<<<<<<<<<<<<<
 *         if not hasattr(X.shape, "__len__") or len(X.shape) <= 1:
 *             warnings.warn (
 */
  __pyx_t_11 = __Pyx_HasAttr(__pyx_v_X, __pyx_n_u_shape); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(0, 3338, __pyx_L1_error)
  __pyx_t_12 = (__pyx_t_11 != 0);
  if (__pyx_t_12) {

    /* "validator.pyx":3339
 * 
 *     if hasattr(X, "shape"):
 *         if not hasattr(X.shape, "__len__") or len(X.shape) <= 1:             # <<<<<<<<<<<<<<
 *             warnings.warn (
 *                 "A singleton array %r cannot be considered a valid collection."% X)
 */
    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3339, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_11 = __Pyx_HasAttr(__pyx_t_8, __pyx_n_u_len); if (unlikely(__pyx_t_11 == ((int)-1))) __PYX_ERR(0, 3339, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_13 = ((!(__pyx_t_11 != 0)) != 0);
    if (!__pyx_t_13) {
    } else {
      __pyx_t_12 = __pyx_t_13;
      goto __pyx_L18_bool_binop_done;
    }
    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3339, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_5 = PyObject_Length(__pyx_t_8); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3339, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_13 = ((__pyx_t_5 <= 1) != 0);
    __pyx_t_12 = __pyx_t_13;
    __pyx_L18_bool_binop_done:;
    if (unlikely(__pyx_t_12)) {

      /* "validator.pyx":3340
 *     if hasattr(X, "shape"):
 *         if not hasattr(X.shape, "__len__") or len(X.shape) <= 1:
 *             warnings.warn (             # <<<<<<<<<<<<<<
 *                 "A singleton array %r cannot be considered a valid collection."% X)
 *             message += f" with shape {X.shape}"
 */
      __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_warnings); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3340, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_warn); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3340, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

      /* "validator.pyx":3341
 *         if not hasattr(X.shape, "__len__") or len(X.shape) <= 1:
 *             warnings.warn (
 *                 "A singleton array %r cannot be considered a valid collection."% X)             # <<<<<<<<<<<<<<
 *             message += f" with shape {X.shape}"
 *             raise TypeError(message)
 */
      __pyx_t_7 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_A_singleton_array_r_cannot_be_co, __pyx_v_X); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3341, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_10 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
        __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_4);
        if (likely(__pyx_t_10)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
          __Pyx_INCREF(__pyx_t_10);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_4, function);
        }
      }
      __pyx_t_8 = (__pyx_t_10) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_10, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_7);
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3340, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;

      /* "validator.pyx":3342
 *             warnings.warn (
 *                 "A singleton array %r cannot be considered a valid collection."% X)
 *             message += f" with shape {X.shape}"             # <<<<<<<<<<<<<<
 *             raise TypeError(message)
 * 
 */
      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3342, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_t_8, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3342, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __pyx_t_8 = __Pyx_PyUnicode_Concat(__pyx_kp_u_with_shape, __pyx_t_4); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3342, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyUnicode_Concat(__pyx_v_message, __pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3342, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_DECREF_SET(__pyx_v_message, ((PyObject*)__pyx_t_4));
      __pyx_t_4 = 0;

      /* "validator.pyx":3343
 *                 "A singleton array %r cannot be considered a valid collection."% X)
 *             message += f" with shape {X.shape}"
 *             raise TypeError(message)             # <<<<<<<<<<<<<<
 * 
 *     return X
 */
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_v_message); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3343, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __PYX_ERR(0, 3343, __pyx_L1_error)

      /* "validator.pyx":3339
 * 
 *     if hasattr(X, "shape"):
 *         if not hasattr(X.shape, "__len__") or len(X.shape) <= 1:             # <<<<<<<<<<<<<<
 *             warnings.warn (
 *                 "A singleton array %r cannot be considered a valid collection."% X)
 */
    }

    /* "validator.pyx":3338
 *         X = np.asarray(X)
 * 
 *     if hasattr(X, "shape"):             # <<<<<<<<<<<<<<
 *         if not hasattr(X.shape, "__len__") or len(X.shape) <= 1:
 *             warnings.warn (
 */
  }

  /* "validator.pyx":3345
 *             raise TypeError(message)
 * 
 *     return X             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_X);
  __pyx_r = __pyx_v_X;
  goto __pyx_L0;

  /* "validator.pyx":3298
 * 
 * 
 * def _check_array_in(obj,  arr_name):             # <<<<<<<<<<<<<<
 *     """Returns the array from the array name attribute. Note that the singleton
 *     array is not admitted.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_AddTraceback("validator._check_array_in", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_type_);
  __Pyx_XDECREF(__pyx_v_type_name);
  __Pyx_XDECREF(__pyx_v_o_);
  __Pyx_XDECREF(__pyx_v_message);
  __Pyx_XDECREF(__pyx_v_X);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3348
 * 
 * 
 * def _deprecate_positional_args(func=None, *, version="1.3"):             # <<<<<<<<<<<<<<
 *     """Decorator for methods that issues warnings for positional arguments.
 *     Using the keyword-only argument syntax in pep 3102, arguments after the
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_103_deprecate_positional_args(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_102_deprecate_positional_args[] = "Decorator for methods that issues warnings for positional arguments.\n    Using the keyword-only argument syntax in pep 3102, arguments after the\n    * will issue a warning when passed as a positional argument.\n    Parameters\n    ----------\n    func : callable, default=None\n        Function to check arguments on.\n    version : callable, default=\"1.3\"\n        The version when positional arguments will result in error.\n    ";
static PyMethodDef __pyx_mdef_9validator_103_deprecate_positional_args = {"_deprecate_positional_args", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_103_deprecate_positional_args, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_102_deprecate_positional_args};
static PyObject *__pyx_pw_9validator_103_deprecate_positional_args(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_func = 0;
  PyObject *__pyx_v_version = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_deprecate_positional_args (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_func,&__pyx_n_s_version,0};
    PyObject* values[2] = {0,0};
    values[0] = ((PyObject *)Py_None);
    values[1] = ((PyObject *)__pyx_kp_u_1_3);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_func);
          if (value) { values[0] = value; kw_args--; }
        }
      }
      if (kw_args == 1) {
        const Py_ssize_t index = 1;
        PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
        if (value) { values[index] = value; kw_args--; }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_deprecate_positional_args") < 0)) __PYX_ERR(0, 3348, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_func = values[0];
    __pyx_v_version = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_deprecate_positional_args", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3348, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator._deprecate_positional_args", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_102_deprecate_positional_args(__pyx_self, __pyx_v_func, __pyx_v_version);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3360
 *     """
 * 
 *     def _inner_deprecate_positional_args(f):             # <<<<<<<<<<<<<<
 *         sig = signature(f)
 *         kwonly_args = []
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_26_deprecate_positional_args_1_inner_deprecate_positional_args(PyObject *__pyx_self, PyObject *__pyx_v_f); /*proto*/
static PyMethodDef __pyx_mdef_9validator_26_deprecate_positional_args_1_inner_deprecate_positional_args = {"_inner_deprecate_positional_args", (PyCFunction)__pyx_pw_9validator_26_deprecate_positional_args_1_inner_deprecate_positional_args, METH_O, 0};
static PyObject *__pyx_pw_9validator_26_deprecate_positional_args_1_inner_deprecate_positional_args(PyObject *__pyx_self, PyObject *__pyx_v_f) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_inner_deprecate_positional_args (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_26_deprecate_positional_args__inner_deprecate_positional_args(__pyx_self, ((PyObject *)__pyx_v_f));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3372
 * 
 *         @wraps(f)
 *         def inner_f(*args, **kwargs):             # <<<<<<<<<<<<<<
 *             extra_args = len(args) - len(all_args)
 *             if extra_args <= 0:
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_26_deprecate_positional_args_32_inner_deprecate_positional_args_1inner_f(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyMethodDef __pyx_mdef_9validator_26_deprecate_positional_args_32_inner_deprecate_positional_args_1inner_f = {"inner_f", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_26_deprecate_positional_args_32_inner_deprecate_positional_args_1inner_f, METH_VARARGS|METH_KEYWORDS, 0};
static PyObject *__pyx_pw_9validator_26_deprecate_positional_args_32_inner_deprecate_positional_args_1inner_f(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_args = 0;
  PyObject *__pyx_v_kwargs = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("inner_f (wrapper)", 0);
  if (unlikely(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "inner_f", 1))) return NULL;
  __pyx_v_kwargs = (__pyx_kwds) ? PyDict_Copy(__pyx_kwds) : PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return NULL;
  __Pyx_GOTREF(__pyx_v_kwargs);
  __Pyx_INCREF(__pyx_args);
  __pyx_v_args = __pyx_args;
  __pyx_r = __pyx_pf_9validator_26_deprecate_positional_args_32_inner_deprecate_positional_args_inner_f(__pyx_self, __pyx_v_args, __pyx_v_kwargs);

  /* function exit code */
  __Pyx_XDECREF(__pyx_v_args);
  __Pyx_XDECREF(__pyx_v_kwargs);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_26_deprecate_positional_args_32_inner_deprecate_positional_args_inner_f(PyObject *__pyx_self, PyObject *__pyx_v_args, PyObject *__pyx_v_kwargs) {
  struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args *__pyx_cur_scope;
  struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args *__pyx_outer_scope;
  PyObject *__pyx_v_extra_args = NULL;
  PyObject *__pyx_v_args_msg = NULL;
  PyObject *__pyx_9genexpr18__pyx_v_name = NULL;
  PyObject *__pyx_9genexpr18__pyx_v_arg = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  Py_ssize_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  Py_ssize_t __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *(*__pyx_t_8)(PyObject *);
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *(*__pyx_t_11)(PyObject *);
  int __pyx_t_12;
  Py_UCS4 __pyx_t_13;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("inner_f", 0);
  __pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args *) __Pyx_CyFunction_GetClosure(__pyx_self);
  __pyx_cur_scope = __pyx_outer_scope;

  /* "validator.pyx":3373
 *         @wraps(f)
 *         def inner_f(*args, **kwargs):
 *             extra_args = len(args) - len(all_args)             # <<<<<<<<<<<<<<
 *             if extra_args <= 0:
 *                 return f(*args, **kwargs)
 */
  __pyx_t_1 = PyTuple_GET_SIZE(__pyx_v_args); if (unlikely(__pyx_t_1 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3373, __pyx_L1_error)
  if (unlikely(!__pyx_cur_scope->__pyx_v_all_args)) { __Pyx_RaiseClosureNameError("all_args"); __PYX_ERR(0, 3373, __pyx_L1_error) }
  __pyx_t_2 = __pyx_cur_scope->__pyx_v_all_args;
  __Pyx_INCREF(__pyx_t_2);
  if (unlikely(__pyx_t_2 == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 3373, __pyx_L1_error)
  }
  __pyx_t_3 = PyList_GET_SIZE(__pyx_t_2); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3373, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = PyInt_FromSsize_t((__pyx_t_1 - __pyx_t_3)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3373, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_v_extra_args = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "validator.pyx":3374
 *         def inner_f(*args, **kwargs):
 *             extra_args = len(args) - len(all_args)
 *             if extra_args <= 0:             # <<<<<<<<<<<<<<
 *                 return f(*args, **kwargs)
 * 
 */
  __pyx_t_2 = PyObject_RichCompare(__pyx_v_extra_args, __pyx_int_0, Py_LE); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3374, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 3374, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (__pyx_t_4) {

    /* "validator.pyx":3375
 *             extra_args = len(args) - len(all_args)
 *             if extra_args <= 0:
 *                 return f(*args, **kwargs)             # <<<<<<<<<<<<<<
 * 
 *             # extra_args > 0
 */
    __Pyx_XDECREF(__pyx_r);
    if (unlikely(!__pyx_cur_scope->__pyx_v_f)) { __Pyx_RaiseClosureNameError("f"); __PYX_ERR(0, 3375, __pyx_L1_error) }
    __pyx_t_2 = PyDict_Copy(__pyx_v_kwargs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3375, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_cur_scope->__pyx_v_f, __pyx_v_args, __pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3375, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_r = __pyx_t_5;
    __pyx_t_5 = 0;
    goto __pyx_L0;

    /* "validator.pyx":3374
 *         def inner_f(*args, **kwargs):
 *             extra_args = len(args) - len(all_args)
 *             if extra_args <= 0:             # <<<<<<<<<<<<<<
 *                 return f(*args, **kwargs)
 * 
 */
  }

  /* "validator.pyx":3378
 * 
 *             # extra_args > 0
 *             args_msg = [             # <<<<<<<<<<<<<<
 *                 "{}={}".format(name, arg)
 *                 for name, arg in zip(kwonly_args[:extra_args], args[-extra_args:])
 */
  { /* enter inner scope */
    __pyx_t_5 = PyList_New(0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3378, __pyx_L6_error)
    __Pyx_GOTREF(__pyx_t_5);

    /* "validator.pyx":3380
 *             args_msg = [
 *                 "{}={}".format(name, arg)
 *                 for name, arg in zip(kwonly_args[:extra_args], args[-extra_args:])             # <<<<<<<<<<<<<<
 *             ]
 *             args_msg = ", ".join(args_msg)
 */
    if (unlikely(!__pyx_cur_scope->__pyx_v_kwonly_args)) { __Pyx_RaiseClosureNameError("kwonly_args"); __PYX_ERR(0, 3380, __pyx_L6_error) }
    if (unlikely(__pyx_cur_scope->__pyx_v_kwonly_args == Py_None)) {
      PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
      __PYX_ERR(0, 3380, __pyx_L6_error)
    }
    __Pyx_INCREF(__pyx_v_extra_args);
    __pyx_t_2 = __pyx_v_extra_args;
    __pyx_t_4 = (__pyx_t_2 == Py_None);
    if (__pyx_t_4) {
      __pyx_t_3 = PY_SSIZE_T_MAX;
    } else {
      __pyx_t_1 = __Pyx_PyIndex_AsSsize_t(__pyx_t_2); if (unlikely((__pyx_t_1 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 3380, __pyx_L6_error)
      __pyx_t_3 = __pyx_t_1;
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyList_GetSlice(__pyx_cur_scope->__pyx_v_kwonly_args, 0, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3380, __pyx_L6_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_6 = PyNumber_Negative(__pyx_v_extra_args); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3380, __pyx_L6_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_4 = (__pyx_t_6 == Py_None);
    if (__pyx_t_4) {
      __pyx_t_3 = 0;
    } else {
      __pyx_t_1 = __Pyx_PyIndex_AsSsize_t(__pyx_t_6); if (unlikely((__pyx_t_1 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 3380, __pyx_L6_error)
      __pyx_t_3 = __pyx_t_1;
    }
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = __Pyx_PyTuple_GetSlice(__pyx_v_args, __pyx_t_3, PY_SSIZE_T_MAX); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3380, __pyx_L6_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_7 = PyTuple_New(2); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3380, __pyx_L6_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_GIVEREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_2);
    __Pyx_GIVEREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_t_6);
    __pyx_t_2 = 0;
    __pyx_t_6 = 0;
    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_zip, __pyx_t_7, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3380, __pyx_L6_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    if (likely(PyList_CheckExact(__pyx_t_6)) || PyTuple_CheckExact(__pyx_t_6)) {
      __pyx_t_7 = __pyx_t_6; __Pyx_INCREF(__pyx_t_7); __pyx_t_3 = 0;
      __pyx_t_8 = NULL;
    } else {
      __pyx_t_3 = -1; __pyx_t_7 = PyObject_GetIter(__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3380, __pyx_L6_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_8 = Py_TYPE(__pyx_t_7)->tp_iternext; if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3380, __pyx_L6_error)
    }
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    for (;;) {
      if (likely(!__pyx_t_8)) {
        if (likely(PyList_CheckExact(__pyx_t_7))) {
          if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_7)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_6 = PyList_GET_ITEM(__pyx_t_7, __pyx_t_3); __Pyx_INCREF(__pyx_t_6); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 3380, __pyx_L6_error)
          #else
          __pyx_t_6 = PySequence_ITEM(__pyx_t_7, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3380, __pyx_L6_error)
          __Pyx_GOTREF(__pyx_t_6);
          #endif
        } else {
          if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_7)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_6 = PyTuple_GET_ITEM(__pyx_t_7, __pyx_t_3); __Pyx_INCREF(__pyx_t_6); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 3380, __pyx_L6_error)
          #else
          __pyx_t_6 = PySequence_ITEM(__pyx_t_7, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3380, __pyx_L6_error)
          __Pyx_GOTREF(__pyx_t_6);
          #endif
        }
      } else {
        __pyx_t_6 = __pyx_t_8(__pyx_t_7);
        if (unlikely(!__pyx_t_6)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else __PYX_ERR(0, 3380, __pyx_L6_error)
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_6);
      }
      if ((likely(PyTuple_CheckExact(__pyx_t_6))) || (PyList_CheckExact(__pyx_t_6))) {
        PyObject* sequence = __pyx_t_6;
        Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
        if (unlikely(size != 2)) {
          if (size > 2) __Pyx_RaiseTooManyValuesError(2);
          else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
          __PYX_ERR(0, 3380, __pyx_L6_error)
        }
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        if (likely(PyTuple_CheckExact(sequence))) {
          __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
          __pyx_t_9 = PyTuple_GET_ITEM(sequence, 1); 
        } else {
          __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
          __pyx_t_9 = PyList_GET_ITEM(sequence, 1); 
        }
        __Pyx_INCREF(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_9);
        #else
        __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3380, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_2);
        __pyx_t_9 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 3380, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_9);
        #endif
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      } else {
        Py_ssize_t index = -1;
        __pyx_t_10 = PyObject_GetIter(__pyx_t_6); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 3380, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_10);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        __pyx_t_11 = Py_TYPE(__pyx_t_10)->tp_iternext;
        index = 0; __pyx_t_2 = __pyx_t_11(__pyx_t_10); if (unlikely(!__pyx_t_2)) goto __pyx_L9_unpacking_failed;
        __Pyx_GOTREF(__pyx_t_2);
        index = 1; __pyx_t_9 = __pyx_t_11(__pyx_t_10); if (unlikely(!__pyx_t_9)) goto __pyx_L9_unpacking_failed;
        __Pyx_GOTREF(__pyx_t_9);
        if (__Pyx_IternextUnpackEndCheck(__pyx_t_11(__pyx_t_10), 2) < 0) __PYX_ERR(0, 3380, __pyx_L6_error)
        __pyx_t_11 = NULL;
        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
        goto __pyx_L10_unpacking_done;
        __pyx_L9_unpacking_failed:;
        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
        __pyx_t_11 = NULL;
        if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
        __PYX_ERR(0, 3380, __pyx_L6_error)
        __pyx_L10_unpacking_done:;
      }
      __Pyx_XDECREF_SET(__pyx_9genexpr18__pyx_v_name, __pyx_t_2);
      __pyx_t_2 = 0;
      __Pyx_XDECREF_SET(__pyx_9genexpr18__pyx_v_arg, __pyx_t_9);
      __pyx_t_9 = 0;

      /* "validator.pyx":3379
 *             # extra_args > 0
 *             args_msg = [
 *                 "{}={}".format(name, arg)             # <<<<<<<<<<<<<<
 *                 for name, arg in zip(kwonly_args[:extra_args], args[-extra_args:])
 *             ]
 */
      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_kp_u__82, __pyx_n_s_format); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 3379, __pyx_L6_error)
      __Pyx_GOTREF(__pyx_t_9);
      __pyx_t_2 = NULL;
      __pyx_t_12 = 0;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_9))) {
        __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_9);
        if (likely(__pyx_t_2)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
          __Pyx_INCREF(__pyx_t_2);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_9, function);
          __pyx_t_12 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_9)) {
        PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_9genexpr18__pyx_v_name, __pyx_9genexpr18__pyx_v_arg};
        __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_9, __pyx_temp+1-__pyx_t_12, 2+__pyx_t_12); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3379, __pyx_L6_error)
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_GOTREF(__pyx_t_6);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_9)) {
        PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_9genexpr18__pyx_v_name, __pyx_9genexpr18__pyx_v_arg};
        __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_9, __pyx_temp+1-__pyx_t_12, 2+__pyx_t_12); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3379, __pyx_L6_error)
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_GOTREF(__pyx_t_6);
      } else
      #endif
      {
        __pyx_t_10 = PyTuple_New(2+__pyx_t_12); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 3379, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_10);
        if (__pyx_t_2) {
          __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_2); __pyx_t_2 = NULL;
        }
        __Pyx_INCREF(__pyx_9genexpr18__pyx_v_name);
        __Pyx_GIVEREF(__pyx_9genexpr18__pyx_v_name);
        PyTuple_SET_ITEM(__pyx_t_10, 0+__pyx_t_12, __pyx_9genexpr18__pyx_v_name);
        __Pyx_INCREF(__pyx_9genexpr18__pyx_v_arg);
        __Pyx_GIVEREF(__pyx_9genexpr18__pyx_v_arg);
        PyTuple_SET_ITEM(__pyx_t_10, 1+__pyx_t_12, __pyx_9genexpr18__pyx_v_arg);
        __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_9, __pyx_t_10, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3379, __pyx_L6_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
      }
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_5, (PyObject*)__pyx_t_6))) __PYX_ERR(0, 3378, __pyx_L6_error)
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

      /* "validator.pyx":3380
 *             args_msg = [
 *                 "{}={}".format(name, arg)
 *                 for name, arg in zip(kwonly_args[:extra_args], args[-extra_args:])             # <<<<<<<<<<<<<<
 *             ]
 *             args_msg = ", ".join(args_msg)
 */
    }
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_XDECREF(__pyx_9genexpr18__pyx_v_arg); __pyx_9genexpr18__pyx_v_arg = 0;
    __Pyx_XDECREF(__pyx_9genexpr18__pyx_v_name); __pyx_9genexpr18__pyx_v_name = 0;
    goto __pyx_L11_exit_scope;
    __pyx_L6_error:;
    __Pyx_XDECREF(__pyx_9genexpr18__pyx_v_arg); __pyx_9genexpr18__pyx_v_arg = 0;
    __Pyx_XDECREF(__pyx_9genexpr18__pyx_v_name); __pyx_9genexpr18__pyx_v_name = 0;
    goto __pyx_L1_error;
    __pyx_L11_exit_scope:;
  } /* exit inner scope */
  __pyx_v_args_msg = __pyx_t_5;
  __pyx_t_5 = 0;

  /* "validator.pyx":3382
 *                 for name, arg in zip(kwonly_args[:extra_args], args[-extra_args:])
 *             ]
 *             args_msg = ", ".join(args_msg)             # <<<<<<<<<<<<<<
 *             warnings.warn(
 *                 f"Pass {args_msg} as keyword args. From version "
 */
  __pyx_t_5 = PyUnicode_Join(__pyx_kp_u__83, __pyx_v_args_msg); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3382, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF_SET(__pyx_v_args_msg, __pyx_t_5);
  __pyx_t_5 = 0;

  /* "validator.pyx":3383
 *             ]
 *             args_msg = ", ".join(args_msg)
 *             warnings.warn(             # <<<<<<<<<<<<<<
 *                 f"Pass {args_msg} as keyword args. From version "
 *                 f"{version} passing these as positional arguments "
 */
  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_warnings); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3383, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_warn); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3383, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

  /* "validator.pyx":3384
 *             args_msg = ", ".join(args_msg)
 *             warnings.warn(
 *                 f"Pass {args_msg} as keyword args. From version "             # <<<<<<<<<<<<<<
 *                 f"{version} passing these as positional arguments "
 *                 "will result in an error",
 */
  __pyx_t_7 = PyTuple_New(5); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3384, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __pyx_t_3 = 0;
  __pyx_t_13 = 127;
  __Pyx_INCREF(__pyx_kp_u_Pass);
  __pyx_t_3 += 5;
  __Pyx_GIVEREF(__pyx_kp_u_Pass);
  PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_kp_u_Pass);
  __pyx_t_9 = __Pyx_PyObject_FormatSimple(__pyx_v_args_msg, __pyx_empty_unicode); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 3384, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_9);
  __pyx_t_13 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_9) > __pyx_t_13) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_9) : __pyx_t_13;
  __pyx_t_3 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_9);
  __Pyx_GIVEREF(__pyx_t_9);
  PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_t_9);
  __pyx_t_9 = 0;
  __Pyx_INCREF(__pyx_kp_u_as_keyword_args_From_version);
  __pyx_t_3 += 31;
  __Pyx_GIVEREF(__pyx_kp_u_as_keyword_args_From_version);
  PyTuple_SET_ITEM(__pyx_t_7, 2, __pyx_kp_u_as_keyword_args_From_version);

  /* "validator.pyx":3385
 *             warnings.warn(
 *                 f"Pass {args_msg} as keyword args. From version "
 *                 f"{version} passing these as positional arguments "             # <<<<<<<<<<<<<<
 *                 "will result in an error",
 *                 FutureWarning,
 */
  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_version)) { __Pyx_RaiseClosureNameError("version"); __PYX_ERR(0, 3385, __pyx_L1_error) }
  __pyx_t_9 = __Pyx_PyObject_FormatSimple(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_version, __pyx_empty_unicode); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 3385, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_9);
  __pyx_t_13 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_9) > __pyx_t_13) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_9) : __pyx_t_13;
  __pyx_t_3 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_9);
  __Pyx_GIVEREF(__pyx_t_9);
  PyTuple_SET_ITEM(__pyx_t_7, 3, __pyx_t_9);
  __pyx_t_9 = 0;
  __Pyx_INCREF(__pyx_kp_u_passing_these_as_positional_arg);
  __pyx_t_3 += 62;
  __Pyx_GIVEREF(__pyx_kp_u_passing_these_as_positional_arg);
  PyTuple_SET_ITEM(__pyx_t_7, 4, __pyx_kp_u_passing_these_as_positional_arg);

  /* "validator.pyx":3384
 *             args_msg = ", ".join(args_msg)
 *             warnings.warn(
 *                 f"Pass {args_msg} as keyword args. From version "             # <<<<<<<<<<<<<<
 *                 f"{version} passing these as positional arguments "
 *                 "will result in an error",
 */
  __pyx_t_9 = __Pyx_PyUnicode_Join(__pyx_t_7, 5, __pyx_t_3, __pyx_t_13); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 3384, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_9);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

  /* "validator.pyx":3387
 *                 f"{version} passing these as positional arguments "
 *                 "will result in an error",
 *                 FutureWarning,             # <<<<<<<<<<<<<<
 *             )
 *             kwargs.update(zip(sig.parameters, args))
 */
  __pyx_t_7 = NULL;
  __pyx_t_12 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
    __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6);
    if (likely(__pyx_t_7)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
      __Pyx_INCREF(__pyx_t_7);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_6, function);
      __pyx_t_12 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_6)) {
    PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_t_9, __pyx_builtin_FutureWarning};
    __pyx_t_5 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_12, 2+__pyx_t_12); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3383, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
    PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_t_9, __pyx_builtin_FutureWarning};
    __pyx_t_5 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_12, 2+__pyx_t_12); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3383, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
  } else
  #endif
  {
    __pyx_t_10 = PyTuple_New(2+__pyx_t_12); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 3383, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    if (__pyx_t_7) {
      __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_7); __pyx_t_7 = NULL;
    }
    __Pyx_GIVEREF(__pyx_t_9);
    PyTuple_SET_ITEM(__pyx_t_10, 0+__pyx_t_12, __pyx_t_9);
    __Pyx_INCREF(__pyx_builtin_FutureWarning);
    __Pyx_GIVEREF(__pyx_builtin_FutureWarning);
    PyTuple_SET_ITEM(__pyx_t_10, 1+__pyx_t_12, __pyx_builtin_FutureWarning);
    __pyx_t_9 = 0;
    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_10, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3383, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
  }
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

  /* "validator.pyx":3389
 *                 FutureWarning,
 *             )
 *             kwargs.update(zip(sig.parameters, args))             # <<<<<<<<<<<<<<
 *             return f(**kwargs)
 * 
 */
  if (unlikely(!__pyx_cur_scope->__pyx_v_sig)) { __Pyx_RaiseClosureNameError("sig"); __PYX_ERR(0, 3389, __pyx_L1_error) }
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_sig, __pyx_n_s_parameters); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3389, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3389, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_GIVEREF(__pyx_t_5);
  PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5);
  __Pyx_INCREF(__pyx_v_args);
  __Pyx_GIVEREF(__pyx_v_args);
  PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_v_args);
  __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_zip, __pyx_t_6, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3389, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_6 = __Pyx_CallUnboundCMethod1(&__pyx_umethod_PyDict_Type_update, __pyx_v_kwargs, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3389, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

  /* "validator.pyx":3390
 *             )
 *             kwargs.update(zip(sig.parameters, args))
 *             return f(**kwargs)             # <<<<<<<<<<<<<<
 * 
 *         return inner_f
 */
  __Pyx_XDECREF(__pyx_r);
  if (unlikely(!__pyx_cur_scope->__pyx_v_f)) { __Pyx_RaiseClosureNameError("f"); __PYX_ERR(0, 3390, __pyx_L1_error) }
  __pyx_t_6 = PyDict_Copy(__pyx_v_kwargs); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3390, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_cur_scope->__pyx_v_f, __pyx_empty_tuple, __pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3390, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_r = __pyx_t_5;
  __pyx_t_5 = 0;
  goto __pyx_L0;

  /* "validator.pyx":3372
 * 
 *         @wraps(f)
 *         def inner_f(*args, **kwargs):             # <<<<<<<<<<<<<<
 *             extra_args = len(args) - len(all_args)
 *             if extra_args <= 0:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_AddTraceback("validator._deprecate_positional_args._inner_deprecate_positional_args.inner_f", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_extra_args);
  __Pyx_XDECREF(__pyx_v_args_msg);
  __Pyx_XDECREF(__pyx_9genexpr18__pyx_v_name);
  __Pyx_XDECREF(__pyx_9genexpr18__pyx_v_arg);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3360
 *     """
 * 
 *     def _inner_deprecate_positional_args(f):             # <<<<<<<<<<<<<<
 *         sig = signature(f)
 *         kwonly_args = []
 */

static PyObject *__pyx_pf_9validator_26_deprecate_positional_args__inner_deprecate_positional_args(PyObject *__pyx_self, PyObject *__pyx_v_f) {
  struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args *__pyx_cur_scope;
  PyObject *__pyx_v_param = NULL;
  PyObject *__pyx_v_inner_f = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  Py_ssize_t __pyx_t_4;
  Py_ssize_t __pyx_t_5;
  int __pyx_t_6;
  int __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_t_9;
  int __pyx_t_10;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_inner_deprecate_positional_args", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args *)__pyx_tp_new_9validator___pyx_scope_struct_24__inner_deprecate_positional_args(__pyx_ptype_9validator___pyx_scope_struct_24__inner_deprecate_positional_args, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 3360, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args *) __Pyx_CyFunction_GetClosure(__pyx_self);
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  __pyx_cur_scope->__pyx_v_f = __pyx_v_f;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_f);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_f);

  /* "validator.pyx":3361
 * 
 *     def _inner_deprecate_positional_args(f):
 *         sig = signature(f)             # <<<<<<<<<<<<<<
 *         kwonly_args = []
 *         all_args = []
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_signature); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3361, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_cur_scope->__pyx_v_f) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_cur_scope->__pyx_v_f);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3361, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_cur_scope->__pyx_v_sig = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":3362
 *     def _inner_deprecate_positional_args(f):
 *         sig = signature(f)
 *         kwonly_args = []             # <<<<<<<<<<<<<<
 *         all_args = []
 * 
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3362, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_cur_scope->__pyx_v_kwonly_args = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":3363
 *         sig = signature(f)
 *         kwonly_args = []
 *         all_args = []             # <<<<<<<<<<<<<<
 * 
 *         for name, param in sig.parameters.items():
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3363, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_cur_scope->__pyx_v_all_args = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":3365
 *         all_args = []
 * 
 *         for name, param in sig.parameters.items():             # <<<<<<<<<<<<<<
 *             if param.kind == Parameter.POSITIONAL_OR_KEYWORD:
 *                 all_args.append(name)
 */
  __pyx_t_4 = 0;
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_sig, __pyx_n_s_parameters); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3365, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (unlikely(__pyx_t_2 == Py_None)) {
    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%.30s'", "items");
    __PYX_ERR(0, 3365, __pyx_L1_error)
  }
  __pyx_t_3 = __Pyx_dict_iterator(__pyx_t_2, 0, __pyx_n_s_items, (&__pyx_t_5), (&__pyx_t_6)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3365, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_XDECREF(__pyx_t_1);
  __pyx_t_1 = __pyx_t_3;
  __pyx_t_3 = 0;
  while (1) {
    __pyx_t_7 = __Pyx_dict_iter_next(__pyx_t_1, __pyx_t_5, &__pyx_t_4, &__pyx_t_3, &__pyx_t_2, NULL, __pyx_t_6);
    if (unlikely(__pyx_t_7 == 0)) break;
    if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 3365, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_name);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_name, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;
    __Pyx_XDECREF_SET(__pyx_v_param, __pyx_t_2);
    __pyx_t_2 = 0;

    /* "validator.pyx":3366
 * 
 *         for name, param in sig.parameters.items():
 *             if param.kind == Parameter.POSITIONAL_OR_KEYWORD:             # <<<<<<<<<<<<<<
 *                 all_args.append(name)
 *             elif param.kind == Parameter.KEYWORD_ONLY:
 */
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_param, __pyx_n_s_kind); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3366, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_Parameter); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3366, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_POSITIONAL_OR_KEYWORD); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3366, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = PyObject_RichCompare(__pyx_t_2, __pyx_t_8, Py_EQ); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3366, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 3366, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (__pyx_t_9) {

      /* "validator.pyx":3367
 *         for name, param in sig.parameters.items():
 *             if param.kind == Parameter.POSITIONAL_OR_KEYWORD:
 *                 all_args.append(name)             # <<<<<<<<<<<<<<
 *             elif param.kind == Parameter.KEYWORD_ONLY:
 *                 kwonly_args.append(name)
 */
      __pyx_t_3 = __pyx_cur_scope->__pyx_v_name;
      __Pyx_INCREF(__pyx_t_3);
      __pyx_t_10 = __Pyx_PyList_Append(__pyx_cur_scope->__pyx_v_all_args, __pyx_t_3); if (unlikely(__pyx_t_10 == ((int)-1))) __PYX_ERR(0, 3367, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

      /* "validator.pyx":3366
 * 
 *         for name, param in sig.parameters.items():
 *             if param.kind == Parameter.POSITIONAL_OR_KEYWORD:             # <<<<<<<<<<<<<<
 *                 all_args.append(name)
 *             elif param.kind == Parameter.KEYWORD_ONLY:
 */
      goto __pyx_L5;
    }

    /* "validator.pyx":3368
 *             if param.kind == Parameter.POSITIONAL_OR_KEYWORD:
 *                 all_args.append(name)
 *             elif param.kind == Parameter.KEYWORD_ONLY:             # <<<<<<<<<<<<<<
 *                 kwonly_args.append(name)
 * 
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_param, __pyx_n_s_kind); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3368, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_Parameter); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3368, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_KEYWORD_ONLY); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3368, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_8 = PyObject_RichCompare(__pyx_t_3, __pyx_t_2, Py_EQ); __Pyx_XGOTREF(__pyx_t_8); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3368, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_8); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 3368, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    if (__pyx_t_9) {

      /* "validator.pyx":3369
 *                 all_args.append(name)
 *             elif param.kind == Parameter.KEYWORD_ONLY:
 *                 kwonly_args.append(name)             # <<<<<<<<<<<<<<
 * 
 *         @wraps(f)
 */
      __pyx_t_8 = __pyx_cur_scope->__pyx_v_name;
      __Pyx_INCREF(__pyx_t_8);
      __pyx_t_10 = __Pyx_PyList_Append(__pyx_cur_scope->__pyx_v_kwonly_args, __pyx_t_8); if (unlikely(__pyx_t_10 == ((int)-1))) __PYX_ERR(0, 3369, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;

      /* "validator.pyx":3368
 *             if param.kind == Parameter.POSITIONAL_OR_KEYWORD:
 *                 all_args.append(name)
 *             elif param.kind == Parameter.KEYWORD_ONLY:             # <<<<<<<<<<<<<<
 *                 kwonly_args.append(name)
 * 
 */
    }
    __pyx_L5:;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3371
 *                 kwonly_args.append(name)
 * 
 *         @wraps(f)             # <<<<<<<<<<<<<<
 *         def inner_f(*args, **kwargs):
 *             extra_args = len(args) - len(all_args)
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_wraps); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3371, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_8 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_cur_scope->__pyx_v_f) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_cur_scope->__pyx_v_f);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3371, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":3372
 * 
 *         @wraps(f)
 *         def inner_f(*args, **kwargs):             # <<<<<<<<<<<<<<
 *             extra_args = len(args) - len(all_args)
 *             if extra_args <= 0:
 */
  __pyx_t_2 = __Pyx_CyFunction_New(&__pyx_mdef_9validator_26_deprecate_positional_args_32_inner_deprecate_positional_args_1inner_f, 0, __pyx_n_s_deprecate_positional_args_local, ((PyObject*)__pyx_cur_scope), __pyx_n_s_validator, __pyx_d, ((PyObject *)__pyx_codeobj__85)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3372, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_8))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_8);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_8, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_8, __pyx_t_3, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3371, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __pyx_v_inner_f = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":3392
 *             return f(**kwargs)
 * 
 *         return inner_f             # <<<<<<<<<<<<<<
 * 
 *     if func is not None:
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_inner_f);
  __pyx_r = __pyx_v_inner_f;
  goto __pyx_L0;

  /* "validator.pyx":3360
 *     """
 * 
 *     def _inner_deprecate_positional_args(f):             # <<<<<<<<<<<<<<
 *         sig = signature(f)
 *         kwonly_args = []
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("validator._deprecate_positional_args._inner_deprecate_positional_args", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_param);
  __Pyx_XDECREF(__pyx_v_inner_f);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3348
 * 
 * 
 * def _deprecate_positional_args(func=None, *, version="1.3"):             # <<<<<<<<<<<<<<
 *     """Decorator for methods that issues warnings for positional arguments.
 *     Using the keyword-only argument syntax in pep 3102, arguments after the
 */

static PyObject *__pyx_pf_9validator_102_deprecate_positional_args(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_func, PyObject *__pyx_v_version) {
  struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args *__pyx_cur_scope;
  PyObject *__pyx_v__inner_deprecate_positional_args = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_deprecate_positional_args", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args *)__pyx_tp_new_9validator___pyx_scope_struct_23__deprecate_positional_args(__pyx_ptype_9validator___pyx_scope_struct_23__deprecate_positional_args, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 3348, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_v_version = __pyx_v_version;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_version);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_version);

  /* "validator.pyx":3360
 *     """
 * 
 *     def _inner_deprecate_positional_args(f):             # <<<<<<<<<<<<<<
 *         sig = signature(f)
 *         kwonly_args = []
 */
  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_9validator_26_deprecate_positional_args_1_inner_deprecate_positional_args, 0, __pyx_n_s_deprecate_positional_args_local_2, ((PyObject*)__pyx_cur_scope), __pyx_n_s_validator, __pyx_d, ((PyObject *)__pyx_codeobj__87)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3360, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v__inner_deprecate_positional_args = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":3394
 *         return inner_f
 * 
 *     if func is not None:             # <<<<<<<<<<<<<<
 *         return _inner_deprecate_positional_args(func)
 * 
 */
  __pyx_t_2 = (__pyx_v_func != Py_None);
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (__pyx_t_3) {

    /* "validator.pyx":3395
 * 
 *     if func is not None:
 *         return _inner_deprecate_positional_args(func)             # <<<<<<<<<<<<<<
 * 
 *     return _inner_deprecate_positional_args
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __pyx_pf_9validator_26_deprecate_positional_args__inner_deprecate_positional_args(__pyx_v__inner_deprecate_positional_args, __pyx_v_func); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3395, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_r = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L0;

    /* "validator.pyx":3394
 *         return inner_f
 * 
 *     if func is not None:             # <<<<<<<<<<<<<<
 *         return _inner_deprecate_positional_args(func)
 * 
 */
  }

  /* "validator.pyx":3397
 *         return _inner_deprecate_positional_args(func)
 * 
 *     return _inner_deprecate_positional_args             # <<<<<<<<<<<<<<
 * 
 * def to_dtype_str (arr, return_values = False ):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v__inner_deprecate_positional_args);
  __pyx_r = __pyx_v__inner_deprecate_positional_args;
  goto __pyx_L0;

  /* "validator.pyx":3348
 * 
 * 
 * def _deprecate_positional_args(func=None, *, version="1.3"):             # <<<<<<<<<<<<<<
 *     """Decorator for methods that issues warnings for positional arguments.
 *     Using the keyword-only argument syntax in pep 3102, arguments after the
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("validator._deprecate_positional_args", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v__inner_deprecate_positional_args);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3399
 *     return _inner_deprecate_positional_args
 * 
 * def to_dtype_str (arr, return_values = False ):             # <<<<<<<<<<<<<<
 *     """ Convert numeric or object dtype to string dtype.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_105to_dtype_str(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_104to_dtype_str[] = " Convert numeric or object dtype to string dtype. \n    \n    This will avoid a particular TypeError when an array is filled by np.nan \n    and at the same time contains string values. \n    Converting the array to dtype str rather than keeping to 'object'\n    will pass this error. \n    \n    :param arr: array-like\n        array with all numpy datatype or pandas dtypes\n    :param return_values: bool, default=False \n        returns array values in string dtype. This might be usefull when a \n        series with dtype equals to object or numeric is passed. \n    :returns: array-like \n        array-like with dtype str \n        Note that if the dataframe or serie is passed, the object datatype \n        will change only if `return_values` is set to ``True``, otherwise \n        returns the same object. \n    \n    ";
static PyMethodDef __pyx_mdef_9validator_105to_dtype_str = {"to_dtype_str", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_105to_dtype_str, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_104to_dtype_str};
static PyObject *__pyx_pw_9validator_105to_dtype_str(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_arr = 0;
  PyObject *__pyx_v_return_values = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("to_dtype_str (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_arr,&__pyx_n_s_return_values,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arr)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_return_values);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "to_dtype_str") < 0)) __PYX_ERR(0, 3399, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_arr = values[0];
    __pyx_v_return_values = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("to_dtype_str", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3399, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.to_dtype_str", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_104to_dtype_str(__pyx_self, __pyx_v_arr, __pyx_v_return_values);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_104to_dtype_str(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_arr, PyObject *__pyx_v_return_values) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("to_dtype_str", 0);
  __Pyx_INCREF(__pyx_v_arr);

  /* "validator.pyx":3419
 * 
 *     """
 *     if not hasattr (arr, '__array__'):             # <<<<<<<<<<<<<<
 *         raise TypeError (f"Expects an array, got: {type(arr).__name__!r}")
 *     if return_values :
 */
  __pyx_t_1 = __Pyx_HasAttr(__pyx_v_arr, __pyx_n_u_array_2); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 3419, __pyx_L1_error)
  __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
  if (unlikely(__pyx_t_2)) {

    /* "validator.pyx":3420
 *     """
 *     if not hasattr (arr, '__array__'):
 *         raise TypeError (f"Expects an array, got: {type(arr).__name__!r}")             # <<<<<<<<<<<<<<
 *     if return_values :
 *         if (hasattr(arr, 'name') or hasattr (arr,'columns')):
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_arr)), __pyx_n_s_name); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3420, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_t_3), __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3420, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Expects_an_array_got, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3420, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3420, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 3420, __pyx_L1_error)

    /* "validator.pyx":3419
 * 
 *     """
 *     if not hasattr (arr, '__array__'):             # <<<<<<<<<<<<<<
 *         raise TypeError (f"Expects an array, got: {type(arr).__name__!r}")
 *     if return_values :
 */
  }

  /* "validator.pyx":3421
 *     if not hasattr (arr, '__array__'):
 *         raise TypeError (f"Expects an array, got: {type(arr).__name__!r}")
 *     if return_values :             # <<<<<<<<<<<<<<
 *         if (hasattr(arr, 'name') or hasattr (arr,'columns')):
 *             arr = arr.values
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_return_values); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 3421, __pyx_L1_error)
  if (__pyx_t_2) {

    /* "validator.pyx":3422
 *         raise TypeError (f"Expects an array, got: {type(arr).__name__!r}")
 *     if return_values :
 *         if (hasattr(arr, 'name') or hasattr (arr,'columns')):             # <<<<<<<<<<<<<<
 *             arr = arr.values
 *     return arr.astype (str )
 */
    __pyx_t_1 = __Pyx_HasAttr(__pyx_v_arr, __pyx_n_u_name_2); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 3422, __pyx_L1_error)
    __pyx_t_5 = (__pyx_t_1 != 0);
    if (!__pyx_t_5) {
    } else {
      __pyx_t_2 = __pyx_t_5;
      goto __pyx_L6_bool_binop_done;
    }
    __pyx_t_5 = __Pyx_HasAttr(__pyx_v_arr, __pyx_n_u_columns); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(0, 3422, __pyx_L1_error)
    __pyx_t_1 = (__pyx_t_5 != 0);
    __pyx_t_2 = __pyx_t_1;
    __pyx_L6_bool_binop_done:;
    if (__pyx_t_2) {

      /* "validator.pyx":3423
 *     if return_values :
 *         if (hasattr(arr, 'name') or hasattr (arr,'columns')):
 *             arr = arr.values             # <<<<<<<<<<<<<<
 *     return arr.astype (str )
 * 
 */
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_arr, __pyx_n_s_values); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3423, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF_SET(__pyx_v_arr, __pyx_t_4);
      __pyx_t_4 = 0;

      /* "validator.pyx":3422
 *         raise TypeError (f"Expects an array, got: {type(arr).__name__!r}")
 *     if return_values :
 *         if (hasattr(arr, 'name') or hasattr (arr,'columns')):             # <<<<<<<<<<<<<<
 *             arr = arr.values
 *     return arr.astype (str )
 */
    }

    /* "validator.pyx":3421
 *     if not hasattr (arr, '__array__'):
 *         raise TypeError (f"Expects an array, got: {type(arr).__name__!r}")
 *     if return_values :             # <<<<<<<<<<<<<<
 *         if (hasattr(arr, 'name') or hasattr (arr,'columns')):
 *             arr = arr.values
 */
  }

  /* "validator.pyx":3424
 *         if (hasattr(arr, 'name') or hasattr (arr,'columns')):
 *             arr = arr.values
 *     return arr.astype (str )             # <<<<<<<<<<<<<<
 * 
 * def _is_arraylike_1d (x) :
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_arr, __pyx_n_s_astype); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3424, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_6 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_4 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_6, ((PyObject *)(&PyUnicode_Type))) : __Pyx_PyObject_CallOneArg(__pyx_t_3, ((PyObject *)(&PyUnicode_Type)));
  __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3424, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "validator.pyx":3399
 *     return _inner_deprecate_positional_args
 * 
 * def to_dtype_str (arr, return_values = False ):             # <<<<<<<<<<<<<<
 *     """ Convert numeric or object dtype to string dtype.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("validator.to_dtype_str", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_arr);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3426
 *     return arr.astype (str )
 * 
 * def _is_arraylike_1d (x) :             # <<<<<<<<<<<<<<
 *     """ Returns whether the input is arraylike one dimensional and not a scalar"""
 *     if not hasattr (x, '__array__'):
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_107_is_arraylike_1d(PyObject *__pyx_self, PyObject *__pyx_v_x); /*proto*/
static char __pyx_doc_9validator_106_is_arraylike_1d[] = " Returns whether the input is arraylike one dimensional and not a scalar";
static PyMethodDef __pyx_mdef_9validator_107_is_arraylike_1d = {"_is_arraylike_1d", (PyCFunction)__pyx_pw_9validator_107_is_arraylike_1d, METH_O, __pyx_doc_9validator_106_is_arraylike_1d};
static PyObject *__pyx_pw_9validator_107_is_arraylike_1d(PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_is_arraylike_1d (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_106_is_arraylike_1d(__pyx_self, ((PyObject *)__pyx_v_x));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_106_is_arraylike_1d(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  Py_ssize_t __pyx_t_7;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_is_arraylike_1d", 0);

  /* "validator.pyx":3428
 * def _is_arraylike_1d (x) :
 *     """ Returns whether the input is arraylike one dimensional and not a scalar"""
 *     if not hasattr (x, '__array__'):             # <<<<<<<<<<<<<<
 *         raise TypeError ("Expects a one-dimensional array, "
 *                          f"got: {type(x).__name__!r}")
 */
  __pyx_t_1 = __Pyx_HasAttr(__pyx_v_x, __pyx_n_u_array_2); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 3428, __pyx_L1_error)
  __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
  if (unlikely(__pyx_t_2)) {

    /* "validator.pyx":3430
 *     if not hasattr (x, '__array__'):
 *         raise TypeError ("Expects a one-dimensional array, "
 *                          f"got: {type(x).__name__!r}")             # <<<<<<<<<<<<<<
 *     _is_arraylike_not_scalar(x)
 *     return _is_arraylike_not_scalar(x) and  (  len(x.shape )< 2 or (
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_x)), __pyx_n_s_name); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3430, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_t_3), __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3430, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "validator.pyx":3429
 *     """ Returns whether the input is arraylike one dimensional and not a scalar"""
 *     if not hasattr (x, '__array__'):
 *         raise TypeError ("Expects a one-dimensional array, "             # <<<<<<<<<<<<<<
 *                          f"got: {type(x).__name__!r}")
 *     _is_arraylike_not_scalar(x)
 */
    __pyx_t_3 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Expects_a_one_dimensional_array, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3429, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3429, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 3429, __pyx_L1_error)

    /* "validator.pyx":3428
 * def _is_arraylike_1d (x) :
 *     """ Returns whether the input is arraylike one dimensional and not a scalar"""
 *     if not hasattr (x, '__array__'):             # <<<<<<<<<<<<<<
 *         raise TypeError ("Expects a one-dimensional array, "
 *                          f"got: {type(x).__name__!r}")
 */
  }

  /* "validator.pyx":3431
 *         raise TypeError ("Expects a one-dimensional array, "
 *                          f"got: {type(x).__name__!r}")
 *     _is_arraylike_not_scalar(x)             # <<<<<<<<<<<<<<
 *     return _is_arraylike_not_scalar(x) and  (  len(x.shape )< 2 or (
 *         len(x.shape ) ==2 and x.shape [1]==1 ))
 */
  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_is_arraylike_not_scalar); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3431, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_5 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_4 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_5, __pyx_v_x) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_x);
  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3431, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "validator.pyx":3432
 *                          f"got: {type(x).__name__!r}")
 *     _is_arraylike_not_scalar(x)
 *     return _is_arraylike_not_scalar(x) and  (  len(x.shape )< 2 or (             # <<<<<<<<<<<<<<
 *         len(x.shape ) ==2 and x.shape [1]==1 ))
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_is_arraylike_not_scalar); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3432, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
    }
  }
  __pyx_t_3 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_v_x) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_x);
  __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3432, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 3432, __pyx_L1_error)
  if (__pyx_t_2) {
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __Pyx_INCREF(__pyx_t_3);
    __pyx_t_4 = __pyx_t_3;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_x, __pyx_n_s_shape); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3432, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_7 = PyObject_Length(__pyx_t_3); if (unlikely(__pyx_t_7 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3432, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_2 = (__pyx_t_7 < 2);
  if (!__pyx_t_2) {
  } else {
    __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3432, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L4_bool_binop_done;
  }

  /* "validator.pyx":3433
 *     _is_arraylike_not_scalar(x)
 *     return _is_arraylike_not_scalar(x) and  (  len(x.shape )< 2 or (
 *         len(x.shape ) ==2 and x.shape [1]==1 ))             # <<<<<<<<<<<<<<
 * 
 * def _is_arraylike(x):
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_x, __pyx_n_s_shape); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3433, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_7 = PyObject_Length(__pyx_t_3); if (unlikely(__pyx_t_7 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3433, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_2 = (__pyx_t_7 == 2);
  if (__pyx_t_2) {
  } else {
    __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3433, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_x, __pyx_n_s_shape); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3433, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_5 = __Pyx_GetItemInt(__pyx_t_3, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3433, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyInt_EqObjC(__pyx_t_5, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3433, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_INCREF(__pyx_t_3);
  __pyx_t_4 = __pyx_t_3;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_L4_bool_binop_done:;
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  /* "validator.pyx":3426
 *     return arr.astype (str )
 * 
 * def _is_arraylike_1d (x) :             # <<<<<<<<<<<<<<
 *     """ Returns whether the input is arraylike one dimensional and not a scalar"""
 *     if not hasattr (x, '__array__'):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("validator._is_arraylike_1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3435
 *         len(x.shape ) ==2 and x.shape [1]==1 ))
 * 
 * def _is_arraylike(x):             # <<<<<<<<<<<<<<
 *     """Returns whether the input is array-like."""
 *     return hasattr(x, "__len__") or hasattr(x, "shape") or hasattr(x, "__array__")
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_109_is_arraylike(PyObject *__pyx_self, PyObject *__pyx_v_x); /*proto*/
static char __pyx_doc_9validator_108_is_arraylike[] = "Returns whether the input is array-like.";
static PyMethodDef __pyx_mdef_9validator_109_is_arraylike = {"_is_arraylike", (PyCFunction)__pyx_pw_9validator_109_is_arraylike, METH_O, __pyx_doc_9validator_108_is_arraylike};
static PyObject *__pyx_pw_9validator_109_is_arraylike(PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_is_arraylike (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_108_is_arraylike(__pyx_self, ((PyObject *)__pyx_v_x));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_108_is_arraylike(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_is_arraylike", 0);

  /* "validator.pyx":3437
 * def _is_arraylike(x):
 *     """Returns whether the input is array-like."""
 *     return hasattr(x, "__len__") or hasattr(x, "shape") or hasattr(x, "__array__")             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_HasAttr(__pyx_v_x, __pyx_n_u_len); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 3437, __pyx_L1_error)
  if (!__pyx_t_2) {
  } else {
    __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3437, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_1 = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L3_bool_binop_done;
  }
  __pyx_t_2 = __Pyx_HasAttr(__pyx_v_x, __pyx_n_u_shape); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 3437, __pyx_L1_error)
  if (!__pyx_t_2) {
  } else {
    __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3437, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_1 = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L3_bool_binop_done;
  }
  __pyx_t_2 = __Pyx_HasAttr(__pyx_v_x, __pyx_n_u_array_2); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 3437, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyBool_FromLong(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3437, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_1 = __pyx_t_3;
  __pyx_t_3 = 0;
  __pyx_L3_bool_binop_done:;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "validator.pyx":3435
 *         len(x.shape ) ==2 and x.shape [1]==1 ))
 * 
 * def _is_arraylike(x):             # <<<<<<<<<<<<<<
 *     """Returns whether the input is array-like."""
 *     return hasattr(x, "__len__") or hasattr(x, "shape") or hasattr(x, "__array__")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("validator._is_arraylike", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3440
 * 
 * 
 * def _is_arraylike_not_scalar(array):             # <<<<<<<<<<<<<<
 *     """Return True if array is array-like and not a scalar"""
 *     return _is_arraylike(array) and not np.isscalar(array)
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_111_is_arraylike_not_scalar(PyObject *__pyx_self, PyObject *__pyx_v_array); /*proto*/
static char __pyx_doc_9validator_110_is_arraylike_not_scalar[] = "Return True if array is array-like and not a scalar";
static PyMethodDef __pyx_mdef_9validator_111_is_arraylike_not_scalar = {"_is_arraylike_not_scalar", (PyCFunction)__pyx_pw_9validator_111_is_arraylike_not_scalar, METH_O, __pyx_doc_9validator_110_is_arraylike_not_scalar};
static PyObject *__pyx_pw_9validator_111_is_arraylike_not_scalar(PyObject *__pyx_self, PyObject *__pyx_v_array) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_is_arraylike_not_scalar (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_110_is_arraylike_not_scalar(__pyx_self, ((PyObject *)__pyx_v_array));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_110_is_arraylike_not_scalar(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_array) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_is_arraylike_not_scalar", 0);

  /* "validator.pyx":3442
 * def _is_arraylike_not_scalar(array):
 *     """Return True if array is array-like and not a scalar"""
 *     return _is_arraylike(array) and not np.isscalar(array)             # <<<<<<<<<<<<<<
 * 
 * def _num_features(X):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_is_arraylike); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3442, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_v_array) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_array);
  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3442, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 3442, __pyx_L1_error)
  if (__pyx_t_5) {
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  } else {
    __Pyx_INCREF(__pyx_t_2);
    __pyx_t_1 = __pyx_t_2;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    goto __pyx_L3_bool_binop_done;
  }
  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3442, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_isscalar); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3442, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_3, __pyx_v_array) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_array);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3442, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 3442, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_6 = (!__pyx_t_5);
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3442, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __pyx_t_2;
  __pyx_t_2 = 0;
  __pyx_L3_bool_binop_done:;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "validator.pyx":3440
 * 
 * 
 * def _is_arraylike_not_scalar(array):             # <<<<<<<<<<<<<<
 *     """Return True if array is array-like and not a scalar"""
 *     return _is_arraylike(array) and not np.isscalar(array)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("validator._is_arraylike_not_scalar", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3444
 *     return _is_arraylike(array) and not np.isscalar(array)
 * 
 * def _num_features(X):             # <<<<<<<<<<<<<<
 *     """Return the number of features in an array-like X.
 *     This helper function tries hard to avoid to materialize an array version
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_113_num_features(PyObject *__pyx_self, PyObject *__pyx_v_X); /*proto*/
static char __pyx_doc_9validator_112_num_features[] = "Return the number of features in an array-like X.\n    This helper function tries hard to avoid to materialize an array version\n    of X unless necessary. For instance, if X is a list of lists,\n    this function will return the length of the first element, assuming\n    that subsequent elements are all lists of the same length without\n    checking.\n    Parameters\n    ----------\n    X : array-like\n        array-like to get the number of features.\n    Returns\n    -------\n    features : int\n        Number of features\n    ";
static PyMethodDef __pyx_mdef_9validator_113_num_features = {"_num_features", (PyCFunction)__pyx_pw_9validator_113_num_features, METH_O, __pyx_doc_9validator_112_num_features};
static PyObject *__pyx_pw_9validator_113_num_features(PyObject *__pyx_self, PyObject *__pyx_v_X) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_num_features (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_112_num_features(__pyx_self, ((PyObject *)__pyx_v_X));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_112_num_features(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X) {
  PyTypeObject *__pyx_v_type_ = NULL;
  PyObject *__pyx_v_type_name = NULL;
  PyObject *__pyx_v_message = NULL;
  PyObject *__pyx_v_first_sample = NULL;
  PyObject *__pyx_v_err = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  Py_ssize_t __pyx_t_3;
  Py_UCS4 __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  int __pyx_t_8;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  int __pyx_t_12;
  PyObject *__pyx_t_13 = NULL;
  int __pyx_t_14;
  char const *__pyx_t_15;
  PyObject *__pyx_t_16 = NULL;
  PyObject *__pyx_t_17 = NULL;
  PyObject *__pyx_t_18 = NULL;
  PyObject *__pyx_t_19 = NULL;
  PyObject *__pyx_t_20 = NULL;
  PyObject *__pyx_t_21 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_num_features", 0);
  __Pyx_INCREF(__pyx_v_X);

  /* "validator.pyx":3460
 *         Number of features
 *     """
 *     type_ = type(X)             # <<<<<<<<<<<<<<
 *     if type_.__module__ == "builtins":
 *         type_name = type_.__qualname__
 */
  __Pyx_INCREF(((PyObject *)Py_TYPE(__pyx_v_X)));
  __pyx_v_type_ = ((PyTypeObject*)((PyObject *)Py_TYPE(__pyx_v_X)));

  /* "validator.pyx":3461
 *     """
 *     type_ = type(X)
 *     if type_.__module__ == "builtins":             # <<<<<<<<<<<<<<
 *         type_name = type_.__qualname__
 *     else:
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_type_), __pyx_n_s_module); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3461, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_t_1, __pyx_n_u_builtins, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 3461, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_2) {

    /* "validator.pyx":3462
 *     type_ = type(X)
 *     if type_.__module__ == "builtins":
 *         type_name = type_.__qualname__             # <<<<<<<<<<<<<<
 *     else:
 *         type_name = f"{type_.__module__}.{type_.__qualname__}"
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_type_), __pyx_n_s_qualname); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3462, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_v_type_name = __pyx_t_1;
    __pyx_t_1 = 0;

    /* "validator.pyx":3461
 *     """
 *     type_ = type(X)
 *     if type_.__module__ == "builtins":             # <<<<<<<<<<<<<<
 *         type_name = type_.__qualname__
 *     else:
 */
    goto __pyx_L3;
  }

  /* "validator.pyx":3464
 *         type_name = type_.__qualname__
 *     else:
 *         type_name = f"{type_.__module__}.{type_.__qualname__}"             # <<<<<<<<<<<<<<
 *     message = f"Unable to find the number of features from X of type {type_name}"
 *     if not hasattr(X, "__len__") and not hasattr(X, "shape"):
 */
  /*else*/ {
    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3464, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = 0;
    __pyx_t_4 = 127;
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_type_), __pyx_n_s_module); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3464, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = __Pyx_PyObject_FormatSimple(__pyx_t_5, __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3464, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_4 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) > __pyx_t_4) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) : __pyx_t_4;
    __pyx_t_3 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_6);
    __pyx_t_6 = 0;
    __Pyx_INCREF(__pyx_kp_u__16);
    __pyx_t_3 += 1;
    __Pyx_GIVEREF(__pyx_kp_u__16);
    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_kp_u__16);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_type_), __pyx_n_s_qualname); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3464, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_5 = __Pyx_PyObject_FormatSimple(__pyx_t_6, __pyx_empty_unicode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3464, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_4 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) > __pyx_t_4) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) : __pyx_t_4;
    __pyx_t_3 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_5);
    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_t_5);
    __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_PyUnicode_Join(__pyx_t_1, 3, __pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3464, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_v_type_name = __pyx_t_5;
    __pyx_t_5 = 0;
  }
  __pyx_L3:;

  /* "validator.pyx":3465
 *     else:
 *         type_name = f"{type_.__module__}.{type_.__qualname__}"
 *     message = f"Unable to find the number of features from X of type {type_name}"             # <<<<<<<<<<<<<<
 *     if not hasattr(X, "__len__") and not hasattr(X, "shape"):
 *         if not hasattr(X, "__array__"):
 */
  __pyx_t_5 = __Pyx_PyObject_FormatSimple(__pyx_v_type_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3465, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_1 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Unable_to_find_the_number_of_fea, __pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3465, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_v_message = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":3466
 *         type_name = f"{type_.__module__}.{type_.__qualname__}"
 *     message = f"Unable to find the number of features from X of type {type_name}"
 *     if not hasattr(X, "__len__") and not hasattr(X, "shape"):             # <<<<<<<<<<<<<<
 *         if not hasattr(X, "__array__"):
 *             raise TypeError(message)
 */
  __pyx_t_7 = __Pyx_HasAttr(__pyx_v_X, __pyx_n_u_len); if (unlikely(__pyx_t_7 == ((int)-1))) __PYX_ERR(0, 3466, __pyx_L1_error)
  __pyx_t_8 = ((!(__pyx_t_7 != 0)) != 0);
  if (__pyx_t_8) {
  } else {
    __pyx_t_2 = __pyx_t_8;
    goto __pyx_L5_bool_binop_done;
  }
  __pyx_t_8 = __Pyx_HasAttr(__pyx_v_X, __pyx_n_u_shape); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(0, 3466, __pyx_L1_error)
  __pyx_t_7 = ((!(__pyx_t_8 != 0)) != 0);
  __pyx_t_2 = __pyx_t_7;
  __pyx_L5_bool_binop_done:;
  if (__pyx_t_2) {

    /* "validator.pyx":3467
 *     message = f"Unable to find the number of features from X of type {type_name}"
 *     if not hasattr(X, "__len__") and not hasattr(X, "shape"):
 *         if not hasattr(X, "__array__"):             # <<<<<<<<<<<<<<
 *             raise TypeError(message)
 *         # Only convert X to a numpy array if there is no cheaper, heuristic
 */
    __pyx_t_2 = __Pyx_HasAttr(__pyx_v_X, __pyx_n_u_array_2); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 3467, __pyx_L1_error)
    __pyx_t_7 = ((!(__pyx_t_2 != 0)) != 0);
    if (unlikely(__pyx_t_7)) {

      /* "validator.pyx":3468
 *     if not hasattr(X, "__len__") and not hasattr(X, "shape"):
 *         if not hasattr(X, "__array__"):
 *             raise TypeError(message)             # <<<<<<<<<<<<<<
 *         # Only convert X to a numpy array if there is no cheaper, heuristic
 *         # option.
 */
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_v_message); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3468, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 3468, __pyx_L1_error)

      /* "validator.pyx":3467
 *     message = f"Unable to find the number of features from X of type {type_name}"
 *     if not hasattr(X, "__len__") and not hasattr(X, "shape"):
 *         if not hasattr(X, "__array__"):             # <<<<<<<<<<<<<<
 *             raise TypeError(message)
 *         # Only convert X to a numpy array if there is no cheaper, heuristic
 */
    }

    /* "validator.pyx":3471
 *         # Only convert X to a numpy array if there is no cheaper, heuristic
 *         # option.
 *         X = np.asarray(X)             # <<<<<<<<<<<<<<
 * 
 *     if hasattr(X, "shape"):
 */
    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3471, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_asarray); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3471, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_6);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_6, function);
      }
    }
    __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_5, __pyx_v_X) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_X);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3471, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "validator.pyx":3466
 *         type_name = f"{type_.__module__}.{type_.__qualname__}"
 *     message = f"Unable to find the number of features from X of type {type_name}"
 *     if not hasattr(X, "__len__") and not hasattr(X, "shape"):             # <<<<<<<<<<<<<<
 *         if not hasattr(X, "__array__"):
 *             raise TypeError(message)
 */
  }

  /* "validator.pyx":3473
 *         X = np.asarray(X)
 * 
 *     if hasattr(X, "shape"):             # <<<<<<<<<<<<<<
 *         if not hasattr(X.shape, "__len__") or len(X.shape) <= 1:
 *             message += f" with shape {X.shape}"
 */
  __pyx_t_7 = __Pyx_HasAttr(__pyx_v_X, __pyx_n_u_shape); if (unlikely(__pyx_t_7 == ((int)-1))) __PYX_ERR(0, 3473, __pyx_L1_error)
  __pyx_t_2 = (__pyx_t_7 != 0);
  if (__pyx_t_2) {

    /* "validator.pyx":3474
 * 
 *     if hasattr(X, "shape"):
 *         if not hasattr(X.shape, "__len__") or len(X.shape) <= 1:             # <<<<<<<<<<<<<<
 *             message += f" with shape {X.shape}"
 *             raise TypeError(message)
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3474, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_7 = __Pyx_HasAttr(__pyx_t_1, __pyx_n_u_len); if (unlikely(__pyx_t_7 == ((int)-1))) __PYX_ERR(0, 3474, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_8 = ((!(__pyx_t_7 != 0)) != 0);
    if (!__pyx_t_8) {
    } else {
      __pyx_t_2 = __pyx_t_8;
      goto __pyx_L10_bool_binop_done;
    }
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3474, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = PyObject_Length(__pyx_t_1); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3474, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_8 = ((__pyx_t_3 <= 1) != 0);
    __pyx_t_2 = __pyx_t_8;
    __pyx_L10_bool_binop_done:;
    if (unlikely(__pyx_t_2)) {

      /* "validator.pyx":3475
 *     if hasattr(X, "shape"):
 *         if not hasattr(X.shape, "__len__") or len(X.shape) <= 1:
 *             message += f" with shape {X.shape}"             # <<<<<<<<<<<<<<
 *             raise TypeError(message)
 *         return X.shape[1]
 */
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3475, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_6 = __Pyx_PyObject_FormatSimple(__pyx_t_1, __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3475, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_1 = __Pyx_PyUnicode_Concat(__pyx_kp_u_with_shape, __pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3475, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_6 = __Pyx_PyUnicode_Concat(__pyx_v_message, __pyx_t_1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3475, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_DECREF_SET(__pyx_v_message, ((PyObject*)__pyx_t_6));
      __pyx_t_6 = 0;

      /* "validator.pyx":3476
 *         if not hasattr(X.shape, "__len__") or len(X.shape) <= 1:
 *             message += f" with shape {X.shape}"
 *             raise TypeError(message)             # <<<<<<<<<<<<<<
 *         return X.shape[1]
 * 
 */
      __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_v_message); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3476, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_Raise(__pyx_t_6, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __PYX_ERR(0, 3476, __pyx_L1_error)

      /* "validator.pyx":3474
 * 
 *     if hasattr(X, "shape"):
 *         if not hasattr(X.shape, "__len__") or len(X.shape) <= 1:             # <<<<<<<<<<<<<<
 *             message += f" with shape {X.shape}"
 *             raise TypeError(message)
 */
    }

    /* "validator.pyx":3477
 *             message += f" with shape {X.shape}"
 *             raise TypeError(message)
 *         return X.shape[1]             # <<<<<<<<<<<<<<
 * 
 *     first_sample = X[0]
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3477, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_1 = __Pyx_GetItemInt(__pyx_t_6, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3477, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_r = __pyx_t_1;
    __pyx_t_1 = 0;
    goto __pyx_L0;

    /* "validator.pyx":3473
 *         X = np.asarray(X)
 * 
 *     if hasattr(X, "shape"):             # <<<<<<<<<<<<<<
 *         if not hasattr(X.shape, "__len__") or len(X.shape) <= 1:
 *             message += f" with shape {X.shape}"
 */
  }

  /* "validator.pyx":3479
 *         return X.shape[1]
 * 
 *     first_sample = X[0]             # <<<<<<<<<<<<<<
 * 
 *     # Do not consider an array-like of strings or dicts to be a 2D array
 */
  __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_X, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3479, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_first_sample = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":3482
 * 
 *     # Do not consider an array-like of strings or dicts to be a 2D array
 *     if isinstance(first_sample, (str, bytes, dict)):             # <<<<<<<<<<<<<<
 *         message += f" where the samples are of type {type(first_sample).__qualname__}"
 *         raise TypeError(message)
 */
  __pyx_t_8 = PyUnicode_Check(__pyx_v_first_sample); 
  __pyx_t_7 = (__pyx_t_8 != 0);
  if (!__pyx_t_7) {
  } else {
    __pyx_t_2 = __pyx_t_7;
    goto __pyx_L13_bool_binop_done;
  }
  __pyx_t_7 = PyBytes_Check(__pyx_v_first_sample); 
  __pyx_t_8 = (__pyx_t_7 != 0);
  if (!__pyx_t_8) {
  } else {
    __pyx_t_2 = __pyx_t_8;
    goto __pyx_L13_bool_binop_done;
  }
  __pyx_t_8 = PyDict_Check(__pyx_v_first_sample); 
  __pyx_t_7 = (__pyx_t_8 != 0);
  __pyx_t_2 = __pyx_t_7;
  __pyx_L13_bool_binop_done:;
  __pyx_t_7 = (__pyx_t_2 != 0);
  if (unlikely(__pyx_t_7)) {

    /* "validator.pyx":3483
 *     # Do not consider an array-like of strings or dicts to be a 2D array
 *     if isinstance(first_sample, (str, bytes, dict)):
 *         message += f" where the samples are of type {type(first_sample).__qualname__}"             # <<<<<<<<<<<<<<
 *         raise TypeError(message)
 * 
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_first_sample)), __pyx_n_s_qualname); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3483, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_6 = __Pyx_PyObject_FormatSimple(__pyx_t_1, __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3483, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyUnicode_Concat(__pyx_kp_u_where_the_samples_are_of_type, __pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3483, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = __Pyx_PyUnicode_Concat(__pyx_v_message, __pyx_t_1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3483, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF_SET(__pyx_v_message, ((PyObject*)__pyx_t_6));
    __pyx_t_6 = 0;

    /* "validator.pyx":3484
 *     if isinstance(first_sample, (str, bytes, dict)):
 *         message += f" where the samples are of type {type(first_sample).__qualname__}"
 *         raise TypeError(message)             # <<<<<<<<<<<<<<
 * 
 *     try:
 */
    __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_v_message); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3484, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_Raise(__pyx_t_6, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __PYX_ERR(0, 3484, __pyx_L1_error)

    /* "validator.pyx":3482
 * 
 *     # Do not consider an array-like of strings or dicts to be a 2D array
 *     if isinstance(first_sample, (str, bytes, dict)):             # <<<<<<<<<<<<<<
 *         message += f" where the samples are of type {type(first_sample).__qualname__}"
 *         raise TypeError(message)
 */
  }

  /* "validator.pyx":3486
 *         raise TypeError(message)
 * 
 *     try:             # <<<<<<<<<<<<<<
 *         # If X is a list of lists, for instance, we assume that all nested
 *         # lists have the same length without checking or converting to
 */
  {
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ExceptionSave(&__pyx_t_9, &__pyx_t_10, &__pyx_t_11);
    __Pyx_XGOTREF(__pyx_t_9);
    __Pyx_XGOTREF(__pyx_t_10);
    __Pyx_XGOTREF(__pyx_t_11);
    /*try:*/ {

      /* "validator.pyx":3490
 *         # lists have the same length without checking or converting to
 *         # a numpy array to keep this function call as cheap as possible.
 *         return len(first_sample)             # <<<<<<<<<<<<<<
 *     except Exception as err:
 *         raise TypeError(message) from err
 */
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_3 = PyObject_Length(__pyx_v_first_sample); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3490, __pyx_L16_error)
      __pyx_t_6 = PyInt_FromSsize_t(__pyx_t_3); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3490, __pyx_L16_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_r = __pyx_t_6;
      __pyx_t_6 = 0;
      goto __pyx_L20_try_return;

      /* "validator.pyx":3486
 *         raise TypeError(message)
 * 
 *     try:             # <<<<<<<<<<<<<<
 *         # If X is a list of lists, for instance, we assume that all nested
 *         # lists have the same length without checking or converting to
 */
    }
    __pyx_L16_error:;
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;

    /* "validator.pyx":3491
 *         # a numpy array to keep this function call as cheap as possible.
 *         return len(first_sample)
 *     except Exception as err:             # <<<<<<<<<<<<<<
 *         raise TypeError(message) from err
 * 
 */
    __pyx_t_12 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
    if (__pyx_t_12) {
      __Pyx_AddTraceback("validator._num_features", __pyx_clineno, __pyx_lineno, __pyx_filename);
      if (__Pyx_GetException(&__pyx_t_6, &__pyx_t_1, &__pyx_t_5) < 0) __PYX_ERR(0, 3491, __pyx_L18_except_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_1);
      __pyx_v_err = __pyx_t_1;
      /*try:*/ {

        /* "validator.pyx":3492
 *         return len(first_sample)
 *     except Exception as err:
 *         raise TypeError(message) from err             # <<<<<<<<<<<<<<
 * 
 * 
 */
        __pyx_t_13 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_v_message); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 3492, __pyx_L27_error)
        __Pyx_GOTREF(__pyx_t_13);
        __Pyx_Raise(__pyx_t_13, 0, 0, __pyx_v_err);
        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
        __PYX_ERR(0, 3492, __pyx_L27_error)
      }

      /* "validator.pyx":3491
 *         # a numpy array to keep this function call as cheap as possible.
 *         return len(first_sample)
 *     except Exception as err:             # <<<<<<<<<<<<<<
 *         raise TypeError(message) from err
 * 
 */
      /*finally:*/ {
        __pyx_L27_error:;
        /*exception exit:*/{
          __Pyx_PyThreadState_declare
          __Pyx_PyThreadState_assign
          __pyx_t_16 = 0; __pyx_t_17 = 0; __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0;
          __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
          if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_19, &__pyx_t_20, &__pyx_t_21);
          if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_16, &__pyx_t_17, &__pyx_t_18) < 0)) __Pyx_ErrFetch(&__pyx_t_16, &__pyx_t_17, &__pyx_t_18);
          __Pyx_XGOTREF(__pyx_t_16);
          __Pyx_XGOTREF(__pyx_t_17);
          __Pyx_XGOTREF(__pyx_t_18);
          __Pyx_XGOTREF(__pyx_t_19);
          __Pyx_XGOTREF(__pyx_t_20);
          __Pyx_XGOTREF(__pyx_t_21);
          __pyx_t_12 = __pyx_lineno; __pyx_t_14 = __pyx_clineno; __pyx_t_15 = __pyx_filename;
          {
            __Pyx_DECREF(__pyx_v_err);
            __pyx_v_err = NULL;
          }
          if (PY_MAJOR_VERSION >= 3) {
            __Pyx_XGIVEREF(__pyx_t_19);
            __Pyx_XGIVEREF(__pyx_t_20);
            __Pyx_XGIVEREF(__pyx_t_21);
            __Pyx_ExceptionReset(__pyx_t_19, __pyx_t_20, __pyx_t_21);
          }
          __Pyx_XGIVEREF(__pyx_t_16);
          __Pyx_XGIVEREF(__pyx_t_17);
          __Pyx_XGIVEREF(__pyx_t_18);
          __Pyx_ErrRestore(__pyx_t_16, __pyx_t_17, __pyx_t_18);
          __pyx_t_16 = 0; __pyx_t_17 = 0; __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0; __pyx_t_21 = 0;
          __pyx_lineno = __pyx_t_12; __pyx_clineno = __pyx_t_14; __pyx_filename = __pyx_t_15;
          goto __pyx_L18_except_error;
        }
      }
    }
    goto __pyx_L18_except_error;
    __pyx_L18_except_error:;

    /* "validator.pyx":3486
 *         raise TypeError(message)
 * 
 *     try:             # <<<<<<<<<<<<<<
 *         # If X is a list of lists, for instance, we assume that all nested
 *         # lists have the same length without checking or converting to
 */
    __Pyx_XGIVEREF(__pyx_t_9);
    __Pyx_XGIVEREF(__pyx_t_10);
    __Pyx_XGIVEREF(__pyx_t_11);
    __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_10, __pyx_t_11);
    goto __pyx_L1_error;
    __pyx_L20_try_return:;
    __Pyx_XGIVEREF(__pyx_t_9);
    __Pyx_XGIVEREF(__pyx_t_10);
    __Pyx_XGIVEREF(__pyx_t_11);
    __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_10, __pyx_t_11);
    goto __pyx_L0;
  }

  /* "validator.pyx":3444
 *     return _is_arraylike(array) and not np.isscalar(array)
 * 
 * def _num_features(X):             # <<<<<<<<<<<<<<
 *     """Return the number of features in an array-like X.
 *     This helper function tries hard to avoid to materialize an array version
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_13);
  __Pyx_AddTraceback("validator._num_features", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_type_);
  __Pyx_XDECREF(__pyx_v_type_name);
  __Pyx_XDECREF(__pyx_v_message);
  __Pyx_XDECREF(__pyx_v_first_sample);
  __Pyx_XDECREF(__pyx_v_err);
  __Pyx_XDECREF(__pyx_v_X);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3495
 * 
 * 
 * def _num_samples(x):             # <<<<<<<<<<<<<<
 *     """Return number of samples in array-like x."""
 *     message = "Expected sequence or array-like, got %s" % type(x)
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_115_num_samples(PyObject *__pyx_self, PyObject *__pyx_v_x); /*proto*/
static char __pyx_doc_9validator_114_num_samples[] = "Return number of samples in array-like x.";
static PyMethodDef __pyx_mdef_9validator_115_num_samples = {"_num_samples", (PyCFunction)__pyx_pw_9validator_115_num_samples, METH_O, __pyx_doc_9validator_114_num_samples};
static PyObject *__pyx_pw_9validator_115_num_samples(PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_num_samples (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_114_num_samples(__pyx_self, ((PyObject *)__pyx_v_x));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_114_num_samples(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_x) {
  PyObject *__pyx_v_message = NULL;
  PyObject *__pyx_v_type_error = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  Py_ssize_t __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  int __pyx_t_11;
  PyObject *__pyx_t_12 = NULL;
  int __pyx_t_13;
  char const *__pyx_t_14;
  PyObject *__pyx_t_15 = NULL;
  PyObject *__pyx_t_16 = NULL;
  PyObject *__pyx_t_17 = NULL;
  PyObject *__pyx_t_18 = NULL;
  PyObject *__pyx_t_19 = NULL;
  PyObject *__pyx_t_20 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_num_samples", 0);
  __Pyx_INCREF(__pyx_v_x);

  /* "validator.pyx":3497
 * def _num_samples(x):
 *     """Return number of samples in array-like x."""
 *     message = "Expected sequence or array-like, got %s" % type(x)             # <<<<<<<<<<<<<<
 *     if hasattr(x, "fit") and callable(x.fit):
 *         # Don't get num_samples from an ensembles length!
 */
  __pyx_t_1 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_Expected_sequence_or_array_like, ((PyObject *)Py_TYPE(__pyx_v_x))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3497, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_message = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":3498
 *     """Return number of samples in array-like x."""
 *     message = "Expected sequence or array-like, got %s" % type(x)
 *     if hasattr(x, "fit") and callable(x.fit):             # <<<<<<<<<<<<<<
 *         # Don't get num_samples from an ensembles length!
 *         raise TypeError(message)
 */
  __pyx_t_3 = __Pyx_HasAttr(__pyx_v_x, __pyx_n_u_fit); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 3498, __pyx_L1_error)
  __pyx_t_4 = (__pyx_t_3 != 0);
  if (__pyx_t_4) {
  } else {
    __pyx_t_2 = __pyx_t_4;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_x, __pyx_n_s_fit); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3498, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = __Pyx_PyCallable_Check(__pyx_t_1); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 3498, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = (__pyx_t_4 != 0);
  __pyx_t_2 = __pyx_t_3;
  __pyx_L4_bool_binop_done:;
  if (unlikely(__pyx_t_2)) {

    /* "validator.pyx":3500
 *     if hasattr(x, "fit") and callable(x.fit):
 *         # Don't get num_samples from an ensembles length!
 *         raise TypeError(message)             # <<<<<<<<<<<<<<
 * 
 *     if not hasattr(x, "__len__") and not hasattr(x, "shape"):
 */
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_v_message); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3500, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 3500, __pyx_L1_error)

    /* "validator.pyx":3498
 *     """Return number of samples in array-like x."""
 *     message = "Expected sequence or array-like, got %s" % type(x)
 *     if hasattr(x, "fit") and callable(x.fit):             # <<<<<<<<<<<<<<
 *         # Don't get num_samples from an ensembles length!
 *         raise TypeError(message)
 */
  }

  /* "validator.pyx":3502
 *         raise TypeError(message)
 * 
 *     if not hasattr(x, "__len__") and not hasattr(x, "shape"):             # <<<<<<<<<<<<<<
 *         if hasattr(x, "__array__"):
 *             x = np.asarray(x)
 */
  __pyx_t_3 = __Pyx_HasAttr(__pyx_v_x, __pyx_n_u_len); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 3502, __pyx_L1_error)
  __pyx_t_4 = ((!(__pyx_t_3 != 0)) != 0);
  if (__pyx_t_4) {
  } else {
    __pyx_t_2 = __pyx_t_4;
    goto __pyx_L7_bool_binop_done;
  }
  __pyx_t_4 = __Pyx_HasAttr(__pyx_v_x, __pyx_n_u_shape); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 3502, __pyx_L1_error)
  __pyx_t_3 = ((!(__pyx_t_4 != 0)) != 0);
  __pyx_t_2 = __pyx_t_3;
  __pyx_L7_bool_binop_done:;
  if (__pyx_t_2) {

    /* "validator.pyx":3503
 * 
 *     if not hasattr(x, "__len__") and not hasattr(x, "shape"):
 *         if hasattr(x, "__array__"):             # <<<<<<<<<<<<<<
 *             x = np.asarray(x)
 *         else:
 */
    __pyx_t_2 = __Pyx_HasAttr(__pyx_v_x, __pyx_n_u_array_2); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 3503, __pyx_L1_error)
    __pyx_t_3 = (__pyx_t_2 != 0);
    if (likely(__pyx_t_3)) {

      /* "validator.pyx":3504
 *     if not hasattr(x, "__len__") and not hasattr(x, "shape"):
 *         if hasattr(x, "__array__"):
 *             x = np.asarray(x)             # <<<<<<<<<<<<<<
 *         else:
 *             raise TypeError(message)
 */
      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3504, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_asarray); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3504, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_5 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
        __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_6);
        if (likely(__pyx_t_5)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
          __Pyx_INCREF(__pyx_t_5);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_6, function);
        }
      }
      __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_5, __pyx_v_x) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_x);
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3504, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_DECREF_SET(__pyx_v_x, __pyx_t_1);
      __pyx_t_1 = 0;

      /* "validator.pyx":3503
 * 
 *     if not hasattr(x, "__len__") and not hasattr(x, "shape"):
 *         if hasattr(x, "__array__"):             # <<<<<<<<<<<<<<
 *             x = np.asarray(x)
 *         else:
 */
      goto __pyx_L9;
    }

    /* "validator.pyx":3506
 *             x = np.asarray(x)
 *         else:
 *             raise TypeError(message)             # <<<<<<<<<<<<<<
 * 
 *     if hasattr(x, "shape") and x.shape is not None:
 */
    /*else*/ {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_v_message); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3506, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 3506, __pyx_L1_error)
    }
    __pyx_L9:;

    /* "validator.pyx":3502
 *         raise TypeError(message)
 * 
 *     if not hasattr(x, "__len__") and not hasattr(x, "shape"):             # <<<<<<<<<<<<<<
 *         if hasattr(x, "__array__"):
 *             x = np.asarray(x)
 */
  }

  /* "validator.pyx":3508
 *             raise TypeError(message)
 * 
 *     if hasattr(x, "shape") and x.shape is not None:             # <<<<<<<<<<<<<<
 *         if len(x.shape) == 0:
 *             raise TypeError(
 */
  __pyx_t_2 = __Pyx_HasAttr(__pyx_v_x, __pyx_n_u_shape); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 3508, __pyx_L1_error)
  __pyx_t_4 = (__pyx_t_2 != 0);
  if (__pyx_t_4) {
  } else {
    __pyx_t_3 = __pyx_t_4;
    goto __pyx_L11_bool_binop_done;
  }
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_x, __pyx_n_s_shape); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3508, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = (__pyx_t_1 != Py_None);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_2 = (__pyx_t_4 != 0);
  __pyx_t_3 = __pyx_t_2;
  __pyx_L11_bool_binop_done:;
  if (__pyx_t_3) {

    /* "validator.pyx":3509
 * 
 *     if hasattr(x, "shape") and x.shape is not None:
 *         if len(x.shape) == 0:             # <<<<<<<<<<<<<<
 *             raise TypeError(
 *                 "Singleton array %r cannot be considered a valid collection." % x
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_x, __pyx_n_s_shape); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3509, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_7 = PyObject_Length(__pyx_t_1); if (unlikely(__pyx_t_7 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3509, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_3 = ((__pyx_t_7 == 0) != 0);
    if (unlikely(__pyx_t_3)) {

      /* "validator.pyx":3511
 *         if len(x.shape) == 0:
 *             raise TypeError(
 *                 "Singleton array %r cannot be considered a valid collection." % x             # <<<<<<<<<<<<<<
 *             )
 *         # Check that shape is returning an integer or default to len
 */
      __pyx_t_1 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_Singleton_array_r_cannot_be_cons, __pyx_v_x); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3511, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);

      /* "validator.pyx":3510
 *     if hasattr(x, "shape") and x.shape is not None:
 *         if len(x.shape) == 0:
 *             raise TypeError(             # <<<<<<<<<<<<<<
 *                 "Singleton array %r cannot be considered a valid collection." % x
 *             )
 */
      __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3510, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_Raise(__pyx_t_6, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __PYX_ERR(0, 3510, __pyx_L1_error)

      /* "validator.pyx":3509
 * 
 *     if hasattr(x, "shape") and x.shape is not None:
 *         if len(x.shape) == 0:             # <<<<<<<<<<<<<<
 *             raise TypeError(
 *                 "Singleton array %r cannot be considered a valid collection." % x
 */
    }

    /* "validator.pyx":3515
 *         # Check that shape is returning an integer or default to len
 *         # Dask dataframes may not return numeric shape[0] value
 *         if isinstance(x.shape[0], numbers.Integral):             # <<<<<<<<<<<<<<
 *             return x.shape[0]
 * 
 */
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_x, __pyx_n_s_shape); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3515, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_1 = __Pyx_GetItemInt(__pyx_t_6, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3515, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_numbers); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3515, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_Integral); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3515, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_3 = PyObject_IsInstance(__pyx_t_1, __pyx_t_5); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 3515, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_2 = (__pyx_t_3 != 0);
    if (__pyx_t_2) {

      /* "validator.pyx":3516
 *         # Dask dataframes may not return numeric shape[0] value
 *         if isinstance(x.shape[0], numbers.Integral):
 *             return x.shape[0]             # <<<<<<<<<<<<<<
 * 
 *     try:
 */
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_x, __pyx_n_s_shape); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3516, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_1 = __Pyx_GetItemInt(__pyx_t_5, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3516, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_r = __pyx_t_1;
      __pyx_t_1 = 0;
      goto __pyx_L0;

      /* "validator.pyx":3515
 *         # Check that shape is returning an integer or default to len
 *         # Dask dataframes may not return numeric shape[0] value
 *         if isinstance(x.shape[0], numbers.Integral):             # <<<<<<<<<<<<<<
 *             return x.shape[0]
 * 
 */
    }

    /* "validator.pyx":3508
 *             raise TypeError(message)
 * 
 *     if hasattr(x, "shape") and x.shape is not None:             # <<<<<<<<<<<<<<
 *         if len(x.shape) == 0:
 *             raise TypeError(
 */
  }

  /* "validator.pyx":3518
 *             return x.shape[0]
 * 
 *     try:             # <<<<<<<<<<<<<<
 *         return len(x)
 *     except TypeError as type_error:
 */
  {
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ExceptionSave(&__pyx_t_8, &__pyx_t_9, &__pyx_t_10);
    __Pyx_XGOTREF(__pyx_t_8);
    __Pyx_XGOTREF(__pyx_t_9);
    __Pyx_XGOTREF(__pyx_t_10);
    /*try:*/ {

      /* "validator.pyx":3519
 * 
 *     try:
 *         return len(x)             # <<<<<<<<<<<<<<
 *     except TypeError as type_error:
 *         raise TypeError(message) from type_error
 */
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_7 = PyObject_Length(__pyx_v_x); if (unlikely(__pyx_t_7 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3519, __pyx_L15_error)
      __pyx_t_1 = PyInt_FromSsize_t(__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3519, __pyx_L15_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_r = __pyx_t_1;
      __pyx_t_1 = 0;
      goto __pyx_L19_try_return;

      /* "validator.pyx":3518
 *             return x.shape[0]
 * 
 *     try:             # <<<<<<<<<<<<<<
 *         return len(x)
 *     except TypeError as type_error:
 */
    }
    __pyx_L15_error:;
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;

    /* "validator.pyx":3520
 *     try:
 *         return len(x)
 *     except TypeError as type_error:             # <<<<<<<<<<<<<<
 *         raise TypeError(message) from type_error
 * 
 */
    __pyx_t_11 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_TypeError);
    if (__pyx_t_11) {
      __Pyx_AddTraceback("validator._num_samples", __pyx_clineno, __pyx_lineno, __pyx_filename);
      if (__Pyx_GetException(&__pyx_t_1, &__pyx_t_5, &__pyx_t_6) < 0) __PYX_ERR(0, 3520, __pyx_L17_except_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_INCREF(__pyx_t_5);
      __pyx_v_type_error = __pyx_t_5;
      /*try:*/ {

        /* "validator.pyx":3521
 *         return len(x)
 *     except TypeError as type_error:
 *         raise TypeError(message) from type_error             # <<<<<<<<<<<<<<
 * 
 * 
 */
        __pyx_t_12 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_v_message); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 3521, __pyx_L26_error)
        __Pyx_GOTREF(__pyx_t_12);
        __Pyx_Raise(__pyx_t_12, 0, 0, __pyx_v_type_error);
        __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
        __PYX_ERR(0, 3521, __pyx_L26_error)
      }

      /* "validator.pyx":3520
 *     try:
 *         return len(x)
 *     except TypeError as type_error:             # <<<<<<<<<<<<<<
 *         raise TypeError(message) from type_error
 * 
 */
      /*finally:*/ {
        __pyx_L26_error:;
        /*exception exit:*/{
          __Pyx_PyThreadState_declare
          __Pyx_PyThreadState_assign
          __pyx_t_15 = 0; __pyx_t_16 = 0; __pyx_t_17 = 0; __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0;
          __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
          if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_18, &__pyx_t_19, &__pyx_t_20);
          if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_15, &__pyx_t_16, &__pyx_t_17) < 0)) __Pyx_ErrFetch(&__pyx_t_15, &__pyx_t_16, &__pyx_t_17);
          __Pyx_XGOTREF(__pyx_t_15);
          __Pyx_XGOTREF(__pyx_t_16);
          __Pyx_XGOTREF(__pyx_t_17);
          __Pyx_XGOTREF(__pyx_t_18);
          __Pyx_XGOTREF(__pyx_t_19);
          __Pyx_XGOTREF(__pyx_t_20);
          __pyx_t_11 = __pyx_lineno; __pyx_t_13 = __pyx_clineno; __pyx_t_14 = __pyx_filename;
          {
            __Pyx_DECREF(__pyx_v_type_error);
            __pyx_v_type_error = NULL;
          }
          if (PY_MAJOR_VERSION >= 3) {
            __Pyx_XGIVEREF(__pyx_t_18);
            __Pyx_XGIVEREF(__pyx_t_19);
            __Pyx_XGIVEREF(__pyx_t_20);
            __Pyx_ExceptionReset(__pyx_t_18, __pyx_t_19, __pyx_t_20);
          }
          __Pyx_XGIVEREF(__pyx_t_15);
          __Pyx_XGIVEREF(__pyx_t_16);
          __Pyx_XGIVEREF(__pyx_t_17);
          __Pyx_ErrRestore(__pyx_t_15, __pyx_t_16, __pyx_t_17);
          __pyx_t_15 = 0; __pyx_t_16 = 0; __pyx_t_17 = 0; __pyx_t_18 = 0; __pyx_t_19 = 0; __pyx_t_20 = 0;
          __pyx_lineno = __pyx_t_11; __pyx_clineno = __pyx_t_13; __pyx_filename = __pyx_t_14;
          goto __pyx_L17_except_error;
        }
      }
    }
    goto __pyx_L17_except_error;
    __pyx_L17_except_error:;

    /* "validator.pyx":3518
 *             return x.shape[0]
 * 
 *     try:             # <<<<<<<<<<<<<<
 *         return len(x)
 *     except TypeError as type_error:
 */
    __Pyx_XGIVEREF(__pyx_t_8);
    __Pyx_XGIVEREF(__pyx_t_9);
    __Pyx_XGIVEREF(__pyx_t_10);
    __Pyx_ExceptionReset(__pyx_t_8, __pyx_t_9, __pyx_t_10);
    goto __pyx_L1_error;
    __pyx_L19_try_return:;
    __Pyx_XGIVEREF(__pyx_t_8);
    __Pyx_XGIVEREF(__pyx_t_9);
    __Pyx_XGIVEREF(__pyx_t_10);
    __Pyx_ExceptionReset(__pyx_t_8, __pyx_t_9, __pyx_t_10);
    goto __pyx_L0;
  }

  /* "validator.pyx":3495
 * 
 * 
 * def _num_samples(x):             # <<<<<<<<<<<<<<
 *     """Return number of samples in array-like x."""
 *     message = "Expected sequence or array-like, got %s" % type(x)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_12);
  __Pyx_AddTraceback("validator._num_samples", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_message);
  __Pyx_XDECREF(__pyx_v_type_error);
  __Pyx_XDECREF(__pyx_v_x);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3524
 * 
 * 
 * def check_memory(memory):             # <<<<<<<<<<<<<<
 *     """Check that ``memory`` is joblib.Memory-like.
 *     joblib.Memory-like means that ``memory`` can be converted into a
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_117check_memory(PyObject *__pyx_self, PyObject *__pyx_v_memory); /*proto*/
static char __pyx_doc_9validator_116check_memory[] = "Check that ``memory`` is joblib.Memory-like.\n    joblib.Memory-like means that ``memory`` can be converted into a\n    joblib.Memory instance (typically a str denoting the ``location``)\n    or has the same interface (has a ``cache`` method).\n    Parameters\n    ----------\n    memory : None, str or object with the joblib.Memory interface\n        - If string, the location where to create the `joblib.Memory` interface.\n        - If None, no caching is done and the Memory object is completely transparent.\n    Returns\n    -------\n    memory : object with the joblib.Memory interface\n        A correct joblib.Memory object.\n    Raises\n    ------\n    ValueError\n        If ``memory`` is not joblib.Memory-like.\n    ";
static PyMethodDef __pyx_mdef_9validator_117check_memory = {"check_memory", (PyCFunction)__pyx_pw_9validator_117check_memory, METH_O, __pyx_doc_9validator_116check_memory};
static PyObject *__pyx_pw_9validator_117check_memory(PyObject *__pyx_self, PyObject *__pyx_v_memory) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("check_memory (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_116check_memory(__pyx_self, ((PyObject *)__pyx_v_memory));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_116check_memory(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_memory) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("check_memory", 0);
  __Pyx_INCREF(__pyx_v_memory);

  /* "validator.pyx":3543
 *         If ``memory`` is not joblib.Memory-like.
 *     """
 *     if memory is None or isinstance(memory, str):             # <<<<<<<<<<<<<<
 *         memory = joblib.Memory(location=memory, verbose=0)
 *     elif not hasattr(memory, "cache"):
 */
  __pyx_t_2 = (__pyx_v_memory == Py_None);
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (!__pyx_t_3) {
  } else {
    __pyx_t_1 = __pyx_t_3;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_3 = PyUnicode_Check(__pyx_v_memory); 
  __pyx_t_2 = (__pyx_t_3 != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L4_bool_binop_done:;
  if (__pyx_t_1) {

    /* "validator.pyx":3544
 *     """
 *     if memory is None or isinstance(memory, str):
 *         memory = joblib.Memory(location=memory, verbose=0)             # <<<<<<<<<<<<<<
 *     elif not hasattr(memory, "cache"):
 *         raise ValueError(
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_joblib); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3544, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_Memory); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3544, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3544, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_location, __pyx_v_memory) < 0) __PYX_ERR(0, 3544, __pyx_L1_error)
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_verbose, __pyx_int_0) < 0) __PYX_ERR(0, 3544, __pyx_L1_error)
    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_empty_tuple, __pyx_t_4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3544, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF_SET(__pyx_v_memory, __pyx_t_6);
    __pyx_t_6 = 0;

    /* "validator.pyx":3543
 *         If ``memory`` is not joblib.Memory-like.
 *     """
 *     if memory is None or isinstance(memory, str):             # <<<<<<<<<<<<<<
 *         memory = joblib.Memory(location=memory, verbose=0)
 *     elif not hasattr(memory, "cache"):
 */
    goto __pyx_L3;
  }

  /* "validator.pyx":3545
 *     if memory is None or isinstance(memory, str):
 *         memory = joblib.Memory(location=memory, verbose=0)
 *     elif not hasattr(memory, "cache"):             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             "'memory' should be None, a string or have the same"
 */
  __pyx_t_1 = __Pyx_HasAttr(__pyx_v_memory, __pyx_n_u_cache); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 3545, __pyx_L1_error)
  __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
  if (unlikely(__pyx_t_2)) {

    /* "validator.pyx":3549
 *             "'memory' should be None, a string or have the same"
 *             " interface as joblib.Memory."
 *             " Got memory='{}' instead.".format(memory)             # <<<<<<<<<<<<<<
 *         )
 *     return memory
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_kp_u_memory_should_be_None_a_string, __pyx_n_s_format); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3549, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_6 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_v_memory) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_memory);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3549, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "validator.pyx":3546
 *         memory = joblib.Memory(location=memory, verbose=0)
 *     elif not hasattr(memory, "cache"):
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             "'memory' should be None, a string or have the same"
 *             " interface as joblib.Memory."
 */
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3546, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 3546, __pyx_L1_error)

    /* "validator.pyx":3545
 *     if memory is None or isinstance(memory, str):
 *         memory = joblib.Memory(location=memory, verbose=0)
 *     elif not hasattr(memory, "cache"):             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             "'memory' should be None, a string or have the same"
 */
  }
  __pyx_L3:;

  /* "validator.pyx":3551
 *             " Got memory='{}' instead.".format(memory)
 *         )
 *     return memory             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_memory);
  __pyx_r = __pyx_v_memory;
  goto __pyx_L0;

  /* "validator.pyx":3524
 * 
 * 
 * def check_memory(memory):             # <<<<<<<<<<<<<<
 *     """Check that ``memory`` is joblib.Memory-like.
 *     joblib.Memory-like means that ``memory`` can be converted into a
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("validator.check_memory", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_memory);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3554
 * 
 * 
 * def check_consistent_length(*arrays):             # <<<<<<<<<<<<<<
 *     """Check that all arrays have consistent first dimensions.
 *     Checks whether all objects in arrays have the same shape or length.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_119check_consistent_length(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_118check_consistent_length[] = "Check that all arrays have consistent first dimensions.\n    Checks whether all objects in arrays have the same shape or length.\n    Parameters\n    ----------\n    *arrays : list or tuple of input objects.\n        Objects that will be checked for consistent length.\n    ";
static PyMethodDef __pyx_mdef_9validator_119check_consistent_length = {"check_consistent_length", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_119check_consistent_length, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_118check_consistent_length};
static PyObject *__pyx_pw_9validator_119check_consistent_length(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_arrays = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("check_consistent_length (wrapper)", 0);
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "check_consistent_length", 0))) return NULL;
  __Pyx_INCREF(__pyx_args);
  __pyx_v_arrays = __pyx_args;
  __pyx_r = __pyx_pf_9validator_118check_consistent_length(__pyx_self, __pyx_v_arrays);

  /* function exit code */
  __Pyx_XDECREF(__pyx_v_arrays);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_118check_consistent_length(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_arrays) {
  PyObject *__pyx_v_lengths = NULL;
  PyObject *__pyx_v_uniques = NULL;
  PyObject *__pyx_9genexpr19__pyx_v_X = NULL;
  PyObject *__pyx_9genexpr20__pyx_v_l = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  Py_ssize_t __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("check_consistent_length", 0);

  /* "validator.pyx":3563
 *     """
 * 
 *     lengths = [_num_samples(X) for X in arrays if X is not None]             # <<<<<<<<<<<<<<
 *     uniques = np.unique(lengths)
 *     if len(uniques) > 1:
 */
  { /* enter inner scope */
    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3563, __pyx_L5_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __pyx_v_arrays; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
    for (;;) {
      if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
      #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
      __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_4); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 3563, __pyx_L5_error)
      #else
      __pyx_t_4 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3563, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_4);
      #endif
      __Pyx_XDECREF_SET(__pyx_9genexpr19__pyx_v_X, __pyx_t_4);
      __pyx_t_4 = 0;
      __pyx_t_5 = (__pyx_9genexpr19__pyx_v_X != Py_None);
      __pyx_t_6 = (__pyx_t_5 != 0);
      if (__pyx_t_6) {
        __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_num_samples); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3563, __pyx_L5_error)
        __Pyx_GOTREF(__pyx_t_7);
        __pyx_t_8 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
          __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
          if (likely(__pyx_t_8)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
            __Pyx_INCREF(__pyx_t_8);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_7, function);
          }
        }
        __pyx_t_4 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_8, __pyx_9genexpr19__pyx_v_X) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_9genexpr19__pyx_v_X);
        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
        if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3563, __pyx_L5_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_4))) __PYX_ERR(0, 3563, __pyx_L5_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      }
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_9genexpr19__pyx_v_X); __pyx_9genexpr19__pyx_v_X = 0;
    goto __pyx_L9_exit_scope;
    __pyx_L5_error:;
    __Pyx_XDECREF(__pyx_9genexpr19__pyx_v_X); __pyx_9genexpr19__pyx_v_X = 0;
    goto __pyx_L1_error;
    __pyx_L9_exit_scope:;
  } /* exit inner scope */
  __pyx_v_lengths = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":3564
 * 
 *     lengths = [_num_samples(X) for X in arrays if X is not None]
 *     uniques = np.unique(lengths)             # <<<<<<<<<<<<<<
 *     if len(uniques) > 1:
 *         raise ValueError(
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3564, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_unique); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3564, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_2, __pyx_v_lengths) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_lengths);
  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3564, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_v_uniques = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":3565
 *     lengths = [_num_samples(X) for X in arrays if X is not None]
 *     uniques = np.unique(lengths)
 *     if len(uniques) > 1:             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             "Found input variables with inconsistent numbers of samples: %r"
 */
  __pyx_t_3 = PyObject_Length(__pyx_v_uniques); if (unlikely(__pyx_t_3 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3565, __pyx_L1_error)
  __pyx_t_6 = ((__pyx_t_3 > 1) != 0);
  if (unlikely(__pyx_t_6)) {

    /* "validator.pyx":3566
 *     uniques = np.unique(lengths)
 *     if len(uniques) > 1:
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             "Found input variables with inconsistent numbers of samples: %r"
 *             % [int(l) for l in lengths]
 */
    { /* enter inner scope */

      /* "validator.pyx":3568
 *         raise ValueError(
 *             "Found input variables with inconsistent numbers of samples: %r"
 *             % [int(l) for l in lengths]             # <<<<<<<<<<<<<<
 *         )
 * 
 */
      __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3568, __pyx_L13_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_4 = __pyx_v_lengths; __Pyx_INCREF(__pyx_t_4); __pyx_t_3 = 0;
      for (;;) {
        if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_4)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_2 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_3); __Pyx_INCREF(__pyx_t_2); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 3568, __pyx_L13_error)
        #else
        __pyx_t_2 = PySequence_ITEM(__pyx_t_4, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3568, __pyx_L13_error)
        __Pyx_GOTREF(__pyx_t_2);
        #endif
        __Pyx_XDECREF_SET(__pyx_9genexpr20__pyx_v_l, __pyx_t_2);
        __pyx_t_2 = 0;
        __pyx_t_2 = __Pyx_PyNumber_Int(__pyx_9genexpr20__pyx_v_l); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3568, __pyx_L13_error)
        __Pyx_GOTREF(__pyx_t_2);
        if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_2))) __PYX_ERR(0, 3568, __pyx_L13_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      }
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_9genexpr20__pyx_v_l); __pyx_9genexpr20__pyx_v_l = 0;
      goto __pyx_L16_exit_scope;
      __pyx_L13_error:;
      __Pyx_XDECREF(__pyx_9genexpr20__pyx_v_l); __pyx_9genexpr20__pyx_v_l = 0;
      goto __pyx_L1_error;
      __pyx_L16_exit_scope:;
    } /* exit inner scope */
    __pyx_t_4 = PyUnicode_Format(__pyx_kp_u_Found_input_variables_with_incon, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3568, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "validator.pyx":3566
 *     uniques = np.unique(lengths)
 *     if len(uniques) > 1:
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             "Found input variables with inconsistent numbers of samples: %r"
 *             % [int(l) for l in lengths]
 */
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3566, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 3566, __pyx_L1_error)

    /* "validator.pyx":3565
 *     lengths = [_num_samples(X) for X in arrays if X is not None]
 *     uniques = np.unique(lengths)
 *     if len(uniques) > 1:             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             "Found input variables with inconsistent numbers of samples: %r"
 */
  }

  /* "validator.pyx":3554
 * 
 * 
 * def check_consistent_length(*arrays):             # <<<<<<<<<<<<<<
 *     """Check that all arrays have consistent first dimensions.
 *     Checks whether all objects in arrays have the same shape or length.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("validator.check_consistent_length", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_lengths);
  __Pyx_XDECREF(__pyx_v_uniques);
  __Pyx_XDECREF(__pyx_9genexpr19__pyx_v_X);
  __Pyx_XDECREF(__pyx_9genexpr20__pyx_v_l);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3572
 * 
 * 
 * def check_random_state(seed):             # <<<<<<<<<<<<<<
 *     """Turn seed into a np.random.RandomState instance.
 *     Parameters
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_121check_random_state(PyObject *__pyx_self, PyObject *__pyx_v_seed); /*proto*/
static char __pyx_doc_9validator_120check_random_state[] = "Turn seed into a np.random.RandomState instance.\n    Parameters\n    ----------\n    seed : None, int or instance of RandomState\n        If seed is None, return the RandomState singleton used by np.random.\n        If seed is an int, return a new RandomState instance seeded with seed.\n        If seed is already a RandomState instance, return it.\n        Otherwise raise ValueError.\n    Returns\n    -------\n    :class:`numpy:numpy.random.RandomState`\n        The random state object based on `seed` parameter.\n    ";
static PyMethodDef __pyx_mdef_9validator_121check_random_state = {"check_random_state", (PyCFunction)__pyx_pw_9validator_121check_random_state, METH_O, __pyx_doc_9validator_120check_random_state};
static PyObject *__pyx_pw_9validator_121check_random_state(PyObject *__pyx_self, PyObject *__pyx_v_seed) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("check_random_state (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_120check_random_state(__pyx_self, ((PyObject *)__pyx_v_seed));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_120check_random_state(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_seed) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("check_random_state", 0);

  /* "validator.pyx":3586
 *         The random state object based on `seed` parameter.
 *     """
 *     if seed is None or seed is np.random:             # <<<<<<<<<<<<<<
 *         return np.random.mtrand._rand
 *     if isinstance(seed, numbers.Integral):
 */
  __pyx_t_2 = (__pyx_v_seed == Py_None);
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (!__pyx_t_3) {
  } else {
    __pyx_t_1 = __pyx_t_3;
    goto __pyx_L4_bool_binop_done;
  }
  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3586, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_random); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3586, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_3 = (__pyx_v_seed == __pyx_t_5);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_2 = (__pyx_t_3 != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L4_bool_binop_done:;
  if (__pyx_t_1) {

    /* "validator.pyx":3587
 *     """
 *     if seed is None or seed is np.random:
 *         return np.random.mtrand._rand             # <<<<<<<<<<<<<<
 *     if isinstance(seed, numbers.Integral):
 *         return np.random.RandomState(seed)
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3587, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_random); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3587, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_mtrand); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3587, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_rand_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3587, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "validator.pyx":3586
 *         The random state object based on `seed` parameter.
 *     """
 *     if seed is None or seed is np.random:             # <<<<<<<<<<<<<<
 *         return np.random.mtrand._rand
 *     if isinstance(seed, numbers.Integral):
 */
  }

  /* "validator.pyx":3588
 *     if seed is None or seed is np.random:
 *         return np.random.mtrand._rand
 *     if isinstance(seed, numbers.Integral):             # <<<<<<<<<<<<<<
 *         return np.random.RandomState(seed)
 *     if isinstance(seed, np.random.RandomState):
 */
  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_numbers); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3588, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_Integral); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3588, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_1 = PyObject_IsInstance(__pyx_v_seed, __pyx_t_5); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 3588, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "validator.pyx":3589
 *         return np.random.mtrand._rand
 *     if isinstance(seed, numbers.Integral):
 *         return np.random.RandomState(seed)             # <<<<<<<<<<<<<<
 *     if isinstance(seed, np.random.RandomState):
 *         return seed
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3589, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_random); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3589, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_RandomState); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3589, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_5 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_6, __pyx_v_seed) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_seed);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3589, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_r = __pyx_t_5;
    __pyx_t_5 = 0;
    goto __pyx_L0;

    /* "validator.pyx":3588
 *     if seed is None or seed is np.random:
 *         return np.random.mtrand._rand
 *     if isinstance(seed, numbers.Integral):             # <<<<<<<<<<<<<<
 *         return np.random.RandomState(seed)
 *     if isinstance(seed, np.random.RandomState):
 */
  }

  /* "validator.pyx":3590
 *     if isinstance(seed, numbers.Integral):
 *         return np.random.RandomState(seed)
 *     if isinstance(seed, np.random.RandomState):             # <<<<<<<<<<<<<<
 *         return seed
 *     raise ValueError(
 */
  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3590, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_random); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3590, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_RandomState); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3590, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_2 = PyObject_IsInstance(__pyx_v_seed, __pyx_t_5); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 3590, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "validator.pyx":3591
 *         return np.random.RandomState(seed)
 *     if isinstance(seed, np.random.RandomState):
 *         return seed             # <<<<<<<<<<<<<<
 *     raise ValueError(
 *         "%r cannot be used to seed a numpy.random.RandomState instance" % seed
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_v_seed);
    __pyx_r = __pyx_v_seed;
    goto __pyx_L0;

    /* "validator.pyx":3590
 *     if isinstance(seed, numbers.Integral):
 *         return np.random.RandomState(seed)
 *     if isinstance(seed, np.random.RandomState):             # <<<<<<<<<<<<<<
 *         return seed
 *     raise ValueError(
 */
  }

  /* "validator.pyx":3593
 *         return seed
 *     raise ValueError(
 *         "%r cannot be used to seed a numpy.random.RandomState instance" % seed             # <<<<<<<<<<<<<<
 *     )
 * 
 */
  __pyx_t_5 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_r_cannot_be_used_to_seed_a_nump, __pyx_v_seed); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3593, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);

  /* "validator.pyx":3592
 *     if isinstance(seed, np.random.RandomState):
 *         return seed
 *     raise ValueError(             # <<<<<<<<<<<<<<
 *         "%r cannot be used to seed a numpy.random.RandomState instance" % seed
 *     )
 */
  __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3592, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_Raise(__pyx_t_4, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __PYX_ERR(0, 3592, __pyx_L1_error)

  /* "validator.pyx":3572
 * 
 * 
 * def check_random_state(seed):             # <<<<<<<<<<<<<<
 *     """Turn seed into a np.random.RandomState instance.
 *     Parameters
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("validator.check_random_state", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3596
 *     )
 * 
 * def has_fit_parameter(estimator, parameter):             # <<<<<<<<<<<<<<
 *     """Check whether the estimator's fit method supports the given parameter.
 *     Parameters
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_123has_fit_parameter(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_122has_fit_parameter[] = "Check whether the estimator's fit method supports the given parameter.\n    Parameters\n    ----------\n    estimator : object\n        An estimator to inspect.\n    parameter : str\n        The searched parameter.\n    Returns\n    -------\n    is_parameter : bool\n        Whether the parameter was found to be a named parameter of the\n        estimator's fit method.\n    Examples\n    --------\n    >>> from sklearn.svm import SVC\n    >>> from sklearn.tools.validation import has_fit_parameter\n    >>> has_fit_parameter(SVC(), \"sample_weight\")\n    True\n    ";
static PyMethodDef __pyx_mdef_9validator_123has_fit_parameter = {"has_fit_parameter", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_123has_fit_parameter, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_122has_fit_parameter};
static PyObject *__pyx_pw_9validator_123has_fit_parameter(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_estimator = 0;
  PyObject *__pyx_v_parameter = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("has_fit_parameter (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_estimator,&__pyx_n_s_parameter,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_estimator)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_parameter)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("has_fit_parameter", 1, 2, 2, 1); __PYX_ERR(0, 3596, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "has_fit_parameter") < 0)) __PYX_ERR(0, 3596, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_estimator = values[0];
    __pyx_v_parameter = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("has_fit_parameter", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3596, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.has_fit_parameter", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_122has_fit_parameter(__pyx_self, __pyx_v_estimator, __pyx_v_parameter);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_122has_fit_parameter(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_estimator, PyObject *__pyx_v_parameter) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("has_fit_parameter", 0);

  /* "validator.pyx":3616
 *     True
 *     """
 *     return parameter in signature(estimator.fit).parameters             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_signature); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3616, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_estimator, __pyx_n_s_fit); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3616, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3616, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_parameters); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3616, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = (__Pyx_PySequence_ContainsTF(__pyx_v_parameter, __pyx_t_2, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 3616, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3616, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "validator.pyx":3596
 *     )
 * 
 * def has_fit_parameter(estimator, parameter):             # <<<<<<<<<<<<<<
 *     """Check whether the estimator's fit method supports the given parameter.
 *     Parameters
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("validator.has_fit_parameter", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3619
 * 
 * 
 * def check_symmetric(array, *, tol=1e-10, raise_warning=True, raise_exception=False):             # <<<<<<<<<<<<<<
 *     """Make sure that array is 2D, square and symmetric.
 *     If the array is not symmetric, then a symmetrized version is returned.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_125check_symmetric(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_124check_symmetric[] = "Make sure that array is 2D, square and symmetric.\n    If the array is not symmetric, then a symmetrized version is returned.\n    Optionally, a warning or exception is raised if the matrix is not\n    symmetric.\n    Parameters\n    ----------\n    array : {ndarray, sparse matrix}\n        Input object to check / convert. Must be two-dimensional and square,\n        otherwise a ValueError will be raised.\n    tol : float, default=1e-10\n        Absolute tolerance for equivalence of arrays. Default = 1E-10.\n    raise_warning : bool, default=True\n        If True then raise a warning if conversion is required.\n    raise_exception : bool, default=False\n        If True then raise an exception if array is not symmetric.\n    Returns\n    -------\n    array_sym : {ndarray, sparse matrix}\n        Symmetrized version of the input array, i.e. the average of array\n        and array.transpose(). If sparse, then duplicate entries are first\n        summed and zeros are eliminated.\n    ";
static PyMethodDef __pyx_mdef_9validator_125check_symmetric = {"check_symmetric", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_125check_symmetric, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_124check_symmetric};
static PyObject *__pyx_pw_9validator_125check_symmetric(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_array = 0;
  PyObject *__pyx_v_tol = 0;
  PyObject *__pyx_v_raise_warning = 0;
  PyObject *__pyx_v_raise_exception = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("check_symmetric (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_array,&__pyx_n_s_tol,&__pyx_n_s_raise_warning,&__pyx_n_s_raise_exception,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)__pyx_float_1eneg_10);
    values[2] = ((PyObject *)Py_True);
    values[3] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_array)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (kw_args > 0 && likely(kw_args <= 3)) {
        Py_ssize_t index;
        for (index = 1; index < 4 && kw_args > 0; index++) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
          if (value) { values[index] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "check_symmetric") < 0)) __PYX_ERR(0, 3619, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_array = values[0];
    __pyx_v_tol = values[1];
    __pyx_v_raise_warning = values[2];
    __pyx_v_raise_exception = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("check_symmetric", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3619, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.check_symmetric", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_124check_symmetric(__pyx_self, __pyx_v_array, __pyx_v_tol, __pyx_v_raise_warning, __pyx_v_raise_exception);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_124check_symmetric(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_array, PyObject *__pyx_v_tol, PyObject *__pyx_v_raise_warning, PyObject *__pyx_v_raise_exception) {
  PyObject *__pyx_v_diff = NULL;
  PyObject *__pyx_v_symmetric = NULL;
  PyObject *__pyx_v_conversion = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("check_symmetric", 0);
  __Pyx_INCREF(__pyx_v_array);

  /* "validator.pyx":3642
 *         summed and zeros are eliminated.
 *     """
 *     if (array.ndim != 2) or (array.shape[0] != array.shape[1]):             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             "array must be 2-dimensional and square. shape = {0}".format(array.shape)
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3642, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyInt_NeObjC(__pyx_t_2, __pyx_int_2, 2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3642, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 3642, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (!__pyx_t_4) {
  } else {
    __pyx_t_1 = __pyx_t_4;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_shape); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3642, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = __Pyx_GetItemInt(__pyx_t_3, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3642, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_shape); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3642, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_5 = __Pyx_GetItemInt(__pyx_t_3, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3642, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = PyObject_RichCompare(__pyx_t_2, __pyx_t_5, Py_NE); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3642, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 3642, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_1 = __pyx_t_4;
  __pyx_L4_bool_binop_done:;
  if (unlikely(__pyx_t_1)) {

    /* "validator.pyx":3644
 *     if (array.ndim != 2) or (array.shape[0] != array.shape[1]):
 *         raise ValueError(
 *             "array must be 2-dimensional and square. shape = {0}".format(array.shape)             # <<<<<<<<<<<<<<
 *         )
 * 
 */
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_kp_u_array_must_be_2_dimensional_and, __pyx_n_s_format); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3644, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_shape); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3644, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    __pyx_t_3 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_2);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3644, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

    /* "validator.pyx":3643
 *     """
 *     if (array.ndim != 2) or (array.shape[0] != array.shape[1]):
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             "array must be 2-dimensional and square. shape = {0}".format(array.shape)
 *         )
 */
    __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3643, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __PYX_ERR(0, 3643, __pyx_L1_error)

    /* "validator.pyx":3642
 *         summed and zeros are eliminated.
 *     """
 *     if (array.ndim != 2) or (array.shape[0] != array.shape[1]):             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             "array must be 2-dimensional and square. shape = {0}".format(array.shape)
 */
  }

  /* "validator.pyx":3647
 *         )
 * 
 *     if sp.issparse(array):             # <<<<<<<<<<<<<<
 *         diff = array - array.T
 *         # only csr, csc, and coo have `data` attribute
 */
  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_sp); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3647, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_issparse); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3647, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_5 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_array) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_array);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3647, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 3647, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  if (__pyx_t_1) {

    /* "validator.pyx":3648
 * 
 *     if sp.issparse(array):
 *         diff = array - array.T             # <<<<<<<<<<<<<<
 *         # only csr, csc, and coo have `data` attribute
 *         if diff.format not in ["csr", "csc", "coo"]:
 */
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_T); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3648, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_2 = PyNumber_Subtract(__pyx_v_array, __pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3648, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_v_diff = __pyx_t_2;
    __pyx_t_2 = 0;

    /* "validator.pyx":3650
 *         diff = array - array.T
 *         # only csr, csc, and coo have `data` attribute
 *         if diff.format not in ["csr", "csc", "coo"]:             # <<<<<<<<<<<<<<
 *             diff = diff.tocsr()
 *         symmetric = np.all(abs(diff.data) < tol)
 */
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_diff, __pyx_n_s_format); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3650, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_t_2, __pyx_n_u_csr, Py_NE)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 3650, __pyx_L1_error)
    if (__pyx_t_4) {
    } else {
      __pyx_t_1 = __pyx_t_4;
      goto __pyx_L8_bool_binop_done;
    }
    __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_t_2, __pyx_n_u_csc, Py_NE)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 3650, __pyx_L1_error)
    if (__pyx_t_4) {
    } else {
      __pyx_t_1 = __pyx_t_4;
      goto __pyx_L8_bool_binop_done;
    }
    __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_t_2, __pyx_n_u_coo, Py_NE)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 3650, __pyx_L1_error)
    __pyx_t_1 = __pyx_t_4;
    __pyx_L8_bool_binop_done:;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_4 = (__pyx_t_1 != 0);
    if (__pyx_t_4) {

      /* "validator.pyx":3651
 *         # only csr, csc, and coo have `data` attribute
 *         if diff.format not in ["csr", "csc", "coo"]:
 *             diff = diff.tocsr()             # <<<<<<<<<<<<<<
 *         symmetric = np.all(abs(diff.data) < tol)
 *     else:
 */
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_diff, __pyx_n_s_tocsr); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3651, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
        __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
        if (likely(__pyx_t_3)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
          __Pyx_INCREF(__pyx_t_3);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_5, function);
        }
      }
      __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_5);
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3651, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_DECREF_SET(__pyx_v_diff, __pyx_t_2);
      __pyx_t_2 = 0;

      /* "validator.pyx":3650
 *         diff = array - array.T
 *         # only csr, csc, and coo have `data` attribute
 *         if diff.format not in ["csr", "csc", "coo"]:             # <<<<<<<<<<<<<<
 *             diff = diff.tocsr()
 *         symmetric = np.all(abs(diff.data) < tol)
 */
    }

    /* "validator.pyx":3652
 *         if diff.format not in ["csr", "csc", "coo"]:
 *             diff = diff.tocsr()
 *         symmetric = np.all(abs(diff.data) < tol)             # <<<<<<<<<<<<<<
 *     else:
 *         symmetric = np.allclose(array, array.T, atol=tol)
 */
    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3652, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_all); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3652, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_diff, __pyx_n_s_data); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3652, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = __Pyx_PyNumber_Absolute(__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3652, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = PyObject_RichCompare(__pyx_t_6, __pyx_v_tol, Py_LT); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3652, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    __pyx_t_2 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_6, __pyx_t_5) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_5);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3652, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_v_symmetric = __pyx_t_2;
    __pyx_t_2 = 0;

    /* "validator.pyx":3647
 *         )
 * 
 *     if sp.issparse(array):             # <<<<<<<<<<<<<<
 *         diff = array - array.T
 *         # only csr, csc, and coo have `data` attribute
 */
    goto __pyx_L6;
  }

  /* "validator.pyx":3654
 *         symmetric = np.all(abs(diff.data) < tol)
 *     else:
 *         symmetric = np.allclose(array, array.T, atol=tol)             # <<<<<<<<<<<<<<
 * 
 *     if not symmetric:
 */
  /*else*/ {
    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3654, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_allclose); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3654, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_T); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3654, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3654, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_INCREF(__pyx_v_array);
    __Pyx_GIVEREF(__pyx_v_array);
    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_array);
    __Pyx_GIVEREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_2);
    __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3654, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_atol, __pyx_v_tol) < 0) __PYX_ERR(0, 3654, __pyx_L1_error)
    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, __pyx_t_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3654, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_v_symmetric = __pyx_t_6;
    __pyx_t_6 = 0;
  }
  __pyx_L6:;

  /* "validator.pyx":3656
 *         symmetric = np.allclose(array, array.T, atol=tol)
 * 
 *     if not symmetric:             # <<<<<<<<<<<<<<
 *         if raise_exception:
 *             raise ValueError("Array must be symmetric")
 */
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_symmetric); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 3656, __pyx_L1_error)
  __pyx_t_1 = ((!__pyx_t_4) != 0);
  if (__pyx_t_1) {

    /* "validator.pyx":3657
 * 
 *     if not symmetric:
 *         if raise_exception:             # <<<<<<<<<<<<<<
 *             raise ValueError("Array must be symmetric")
 *         if raise_warning:
 */
    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_raise_exception); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 3657, __pyx_L1_error)
    if (unlikely(__pyx_t_1)) {

      /* "validator.pyx":3658
 *     if not symmetric:
 *         if raise_exception:
 *             raise ValueError("Array must be symmetric")             # <<<<<<<<<<<<<<
 *         if raise_warning:
 *             warnings.warn(
 */
      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__88, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3658, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_Raise(__pyx_t_6, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __PYX_ERR(0, 3658, __pyx_L1_error)

      /* "validator.pyx":3657
 * 
 *     if not symmetric:
 *         if raise_exception:             # <<<<<<<<<<<<<<
 *             raise ValueError("Array must be symmetric")
 *         if raise_warning:
 */
    }

    /* "validator.pyx":3659
 *         if raise_exception:
 *             raise ValueError("Array must be symmetric")
 *         if raise_warning:             # <<<<<<<<<<<<<<
 *             warnings.warn(
 *                 "Array is not symmetric, and will be converted "
 */
    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_raise_warning); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 3659, __pyx_L1_error)
    if (__pyx_t_1) {

      /* "validator.pyx":3660
 *             raise ValueError("Array must be symmetric")
 *         if raise_warning:
 *             warnings.warn(             # <<<<<<<<<<<<<<
 *                 "Array is not symmetric, and will be converted "
 *                 "to symmetric by average with its transpose.",
 */
      __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_warnings); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3660, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_warn); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3660, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

      /* "validator.pyx":3663
 *                 "Array is not symmetric, and will be converted "
 *                 "to symmetric by average with its transpose.",
 *                 stacklevel=2,             # <<<<<<<<<<<<<<
 *             )
 *         if sp.issparse(array):
 */
      __pyx_t_6 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3663, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_stacklevel, __pyx_int_2) < 0) __PYX_ERR(0, 3663, __pyx_L1_error)

      /* "validator.pyx":3660
 *             raise ValueError("Array must be symmetric")
 *         if raise_warning:
 *             warnings.warn(             # <<<<<<<<<<<<<<
 *                 "Array is not symmetric, and will be converted "
 *                 "to symmetric by average with its transpose.",
 */
      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__89, __pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3660, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

      /* "validator.pyx":3659
 *         if raise_exception:
 *             raise ValueError("Array must be symmetric")
 *         if raise_warning:             # <<<<<<<<<<<<<<
 *             warnings.warn(
 *                 "Array is not symmetric, and will be converted "
 */
    }

    /* "validator.pyx":3665
 *                 stacklevel=2,
 *             )
 *         if sp.issparse(array):             # <<<<<<<<<<<<<<
 *             conversion = "to" + array.format
 *             array = getattr(0.5 * (array + array.T), conversion)()
 */
    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_sp); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3665, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_issparse); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3665, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    __pyx_t_5 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_6, __pyx_v_array) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_array);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3665, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 3665, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (__pyx_t_1) {

      /* "validator.pyx":3666
 *             )
 *         if sp.issparse(array):
 *             conversion = "to" + array.format             # <<<<<<<<<<<<<<
 *             array = getattr(0.5 * (array + array.T), conversion)()
 *         else:
 */
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_format); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3666, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_2 = PyNumber_Add(__pyx_n_u_to, __pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3666, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_v_conversion = __pyx_t_2;
      __pyx_t_2 = 0;

      /* "validator.pyx":3667
 *         if sp.issparse(array):
 *             conversion = "to" + array.format
 *             array = getattr(0.5 * (array + array.T), conversion)()             # <<<<<<<<<<<<<<
 *         else:
 *             array = 0.5 * (array + array.T)
 */
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_T); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3667, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_6 = PyNumber_Add(__pyx_v_array, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3667, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_5 = PyNumber_Multiply(__pyx_float_0_5, __pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3667, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_6 = __Pyx_GetAttr(__pyx_t_5, __pyx_v_conversion); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3667, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_5 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
        __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_6);
        if (likely(__pyx_t_5)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
          __Pyx_INCREF(__pyx_t_5);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_6, function);
        }
      }
      __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_6);
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3667, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_DECREF_SET(__pyx_v_array, __pyx_t_2);
      __pyx_t_2 = 0;

      /* "validator.pyx":3665
 *                 stacklevel=2,
 *             )
 *         if sp.issparse(array):             # <<<<<<<<<<<<<<
 *             conversion = "to" + array.format
 *             array = getattr(0.5 * (array + array.T), conversion)()
 */
      goto __pyx_L14;
    }

    /* "validator.pyx":3669
 *             array = getattr(0.5 * (array + array.T), conversion)()
 *         else:
 *             array = 0.5 * (array + array.T)             # <<<<<<<<<<<<<<
 * 
 *     return array
 */
    /*else*/ {
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_T); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3669, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_6 = PyNumber_Add(__pyx_v_array, __pyx_t_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3669, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_2 = PyNumber_Multiply(__pyx_float_0_5, __pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3669, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_DECREF_SET(__pyx_v_array, __pyx_t_2);
      __pyx_t_2 = 0;
    }
    __pyx_L14:;

    /* "validator.pyx":3656
 *         symmetric = np.allclose(array, array.T, atol=tol)
 * 
 *     if not symmetric:             # <<<<<<<<<<<<<<
 *         if raise_exception:
 *             raise ValueError("Array must be symmetric")
 */
  }

  /* "validator.pyx":3671
 *             array = 0.5 * (array + array.T)
 * 
 *     return array             # <<<<<<<<<<<<<<
 * 
 * def check_scalar(
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_array);
  __pyx_r = __pyx_v_array;
  goto __pyx_L0;

  /* "validator.pyx":3619
 * 
 * 
 * def check_symmetric(array, *, tol=1e-10, raise_warning=True, raise_exception=False):             # <<<<<<<<<<<<<<
 *     """Make sure that array is 2D, square and symmetric.
 *     If the array is not symmetric, then a symmetrized version is returned.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("validator.check_symmetric", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_diff);
  __Pyx_XDECREF(__pyx_v_symmetric);
  __Pyx_XDECREF(__pyx_v_conversion);
  __Pyx_XDECREF(__pyx_v_array);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3673
 *     return array
 * 
 * def check_scalar(             # <<<<<<<<<<<<<<
 *     x,
 *     name,
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_127check_scalar(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_126check_scalar[] = "Validate scalar parameters type and value.\n    Parameters\n    ----------\n    x : object\n        The scalar parameter to validate.\n    name : str\n        The name of the parameter to be printed in error messages.\n    target_type : type or tuple\n        Acceptable data types for the parameter.\n    min_val : float or int, default=None\n        The minimum valid value the parameter can take. If None (default) it\n        is implied that the parameter does not have a lower bound.\n    max_val : float or int, default=None\n        The maximum valid value the parameter can take. If None (default) it\n        is implied that the parameter does not have an upper bound.\n    include_boundaries : {\"left\", \"right\", \"both\", \"neither\"}, default=\"both\"\n        Whether the interval defined by `min_val` and `max_val` should include\n        the boundaries. Possible choices are:\n        - `\"left\"`: only `min_val` is included in the valid interval.\n          It is equivalent to the interval `[ min_val, max_val )`.\n        - `\"right\"`: only `max_val` is included in the valid interval.\n          It is equivalent to the interval `( min_val, max_val ]`.\n        - `\"both\"`: `min_val` and `max_val` are included in the valid interval.\n          It is equivalent to the interval `[ min_val, max_val ]`.\n        - `\"neither\"`: neither `min_val` nor `max_val` are included in the\n          valid interval. It is equivalent to the interval `( min_val, max_val )`.\n    Returns\n    -------\n    x : numbers.Number\n        The validated number.\n    Raises\n    ------\n    TypeError\n        If the parameter's type does not match the desired type.\n    ValueError\n        If the parameter's value violates the given bounds.\n        If `min_val`, `max_val` and `include_boundaries` are inconsistent.\n    ";
static PyMethodDef __pyx_mdef_9validator_127check_scalar = {"check_scalar", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_127check_scalar, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_126check_scalar};
static PyObject *__pyx_pw_9validator_127check_scalar(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_x = 0;
  PyObject *__pyx_v_name = 0;
  PyObject *__pyx_v_target_type = 0;
  PyObject *__pyx_v_min_val = 0;
  PyObject *__pyx_v_max_val = 0;
  PyObject *__pyx_v_include_boundaries = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("check_scalar (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_x,&__pyx_n_s_name_2,&__pyx_n_s_target_type,&__pyx_n_s_min_val,&__pyx_n_s_max_val,&__pyx_n_s_include_boundaries,0};
    PyObject* values[6] = {0,0,0,0,0,0};

    /* "validator.pyx":3678
 *     target_type,
 *     *,
 *     min_val=None,             # <<<<<<<<<<<<<<
 *     max_val=None,
 *     include_boundaries="both",
 */
    values[3] = ((PyObject *)Py_None);

    /* "validator.pyx":3679
 *     *,
 *     min_val=None,
 *     max_val=None,             # <<<<<<<<<<<<<<
 *     include_boundaries="both",
 * ):
 */
    values[4] = ((PyObject *)Py_None);
    values[5] = ((PyObject *)__pyx_n_u_both);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_x)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_name_2)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("check_scalar", 1, 3, 3, 1); __PYX_ERR(0, 3673, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_target_type)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("check_scalar", 1, 3, 3, 2); __PYX_ERR(0, 3673, __pyx_L3_error)
        }
      }
      if (kw_args > 0 && likely(kw_args <= 3)) {
        Py_ssize_t index;
        for (index = 3; index < 6 && kw_args > 0; index++) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
          if (value) { values[index] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "check_scalar") < 0)) __PYX_ERR(0, 3673, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_x = values[0];
    __pyx_v_name = values[1];
    __pyx_v_target_type = values[2];
    __pyx_v_min_val = values[3];
    __pyx_v_max_val = values[4];
    __pyx_v_include_boundaries = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("check_scalar", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3673, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.check_scalar", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_126check_scalar(__pyx_self, __pyx_v_x, __pyx_v_name, __pyx_v_target_type, __pyx_v_min_val, __pyx_v_max_val, __pyx_v_include_boundaries);

  /* "validator.pyx":3673
 *     return array
 * 
 * def check_scalar(             # <<<<<<<<<<<<<<
 *     x,
 *     name,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3721
 *     """
 * 
 *     def type_name(t):             # <<<<<<<<<<<<<<
 *         """Convert type into humman readable string."""
 *         module = t.__module__
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_12check_scalar_1type_name(PyObject *__pyx_self, PyObject *__pyx_v_t); /*proto*/
static char __pyx_doc_9validator_12check_scalar_type_name[] = "Convert type into humman readable string.";
static PyMethodDef __pyx_mdef_9validator_12check_scalar_1type_name = {"type_name", (PyCFunction)__pyx_pw_9validator_12check_scalar_1type_name, METH_O, __pyx_doc_9validator_12check_scalar_type_name};
static PyObject *__pyx_pw_9validator_12check_scalar_1type_name(PyObject *__pyx_self, PyObject *__pyx_v_t) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("type_name (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_12check_scalar_type_name(__pyx_self, ((PyObject *)__pyx_v_t));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_12check_scalar_type_name(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_t) {
  PyObject *__pyx_v_module = NULL;
  PyObject *__pyx_v_qualname = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  Py_ssize_t __pyx_t_4;
  Py_UCS4 __pyx_t_5;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("type_name", 0);

  /* "validator.pyx":3723
 *     def type_name(t):
 *         """Convert type into humman readable string."""
 *         module = t.__module__             # <<<<<<<<<<<<<<
 *         qualname = t.__qualname__
 *         if module == "builtins":
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_t, __pyx_n_s_module); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3723, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_module = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":3724
 *         """Convert type into humman readable string."""
 *         module = t.__module__
 *         qualname = t.__qualname__             # <<<<<<<<<<<<<<
 *         if module == "builtins":
 *             return qualname
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_t, __pyx_n_s_qualname); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3724, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_qualname = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":3725
 *         module = t.__module__
 *         qualname = t.__qualname__
 *         if module == "builtins":             # <<<<<<<<<<<<<<
 *             return qualname
 *         elif t == numbers.Real:
 */
  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_v_module, __pyx_n_u_builtins, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 3725, __pyx_L1_error)
  if (__pyx_t_2) {

    /* "validator.pyx":3726
 *         qualname = t.__qualname__
 *         if module == "builtins":
 *             return qualname             # <<<<<<<<<<<<<<
 *         elif t == numbers.Real:
 *             return "float"
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_v_qualname);
    __pyx_r = __pyx_v_qualname;
    goto __pyx_L0;

    /* "validator.pyx":3725
 *         module = t.__module__
 *         qualname = t.__qualname__
 *         if module == "builtins":             # <<<<<<<<<<<<<<
 *             return qualname
 *         elif t == numbers.Real:
 */
  }

  /* "validator.pyx":3727
 *         if module == "builtins":
 *             return qualname
 *         elif t == numbers.Real:             # <<<<<<<<<<<<<<
 *             return "float"
 *         elif t == numbers.Integral:
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_numbers); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3727, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_Real); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3727, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3727, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 3727, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_2) {

    /* "validator.pyx":3728
 *             return qualname
 *         elif t == numbers.Real:
 *             return "float"             # <<<<<<<<<<<<<<
 *         elif t == numbers.Integral:
 *             return "int"
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_n_u_float);
    __pyx_r = __pyx_n_u_float;
    goto __pyx_L0;

    /* "validator.pyx":3727
 *         if module == "builtins":
 *             return qualname
 *         elif t == numbers.Real:             # <<<<<<<<<<<<<<
 *             return "float"
 *         elif t == numbers.Integral:
 */
  }

  /* "validator.pyx":3729
 *         elif t == numbers.Real:
 *             return "float"
 *         elif t == numbers.Integral:             # <<<<<<<<<<<<<<
 *             return "int"
 *         return f"{module}.{qualname}"
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_numbers); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3729, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_Integral); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3729, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyObject_RichCompare(__pyx_v_t, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3729, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 3729, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_2) {

    /* "validator.pyx":3730
 *             return "float"
 *         elif t == numbers.Integral:
 *             return "int"             # <<<<<<<<<<<<<<
 *         return f"{module}.{qualname}"
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_n_u_int);
    __pyx_r = __pyx_n_u_int;
    goto __pyx_L0;

    /* "validator.pyx":3729
 *         elif t == numbers.Real:
 *             return "float"
 *         elif t == numbers.Integral:             # <<<<<<<<<<<<<<
 *             return "int"
 *         return f"{module}.{qualname}"
 */
  }

  /* "validator.pyx":3731
 *         elif t == numbers.Integral:
 *             return "int"
 *         return f"{module}.{qualname}"             # <<<<<<<<<<<<<<
 * 
 *     if not isinstance(x, target_type):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3731, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = 0;
  __pyx_t_5 = 127;
  __pyx_t_3 = __Pyx_PyObject_FormatSimple(__pyx_v_module, __pyx_empty_unicode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3731, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_5 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) > __pyx_t_5) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) : __pyx_t_5;
  __pyx_t_4 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_3);
  __pyx_t_3 = 0;
  __Pyx_INCREF(__pyx_kp_u__16);
  __pyx_t_4 += 1;
  __Pyx_GIVEREF(__pyx_kp_u__16);
  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_kp_u__16);
  __pyx_t_3 = __Pyx_PyObject_FormatSimple(__pyx_v_qualname, __pyx_empty_unicode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3731, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_5 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) > __pyx_t_5) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) : __pyx_t_5;
  __pyx_t_4 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_t_3);
  __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyUnicode_Join(__pyx_t_1, 3, __pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3731, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "validator.pyx":3721
 *     """
 * 
 *     def type_name(t):             # <<<<<<<<<<<<<<
 *         """Convert type into humman readable string."""
 *         module = t.__module__
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("validator.check_scalar.type_name", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_module);
  __Pyx_XDECREF(__pyx_v_qualname);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9validator_12check_scalar_4generator11(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */

/* "validator.pyx":3735
 *     if not isinstance(x, target_type):
 *         if isinstance(target_type, tuple):
 *             types_str = ", ".join(type_name(t) for t in target_type)             # <<<<<<<<<<<<<<
 *             target_type_str = f"{{{types_str}}}"
 *         else:
 */

static PyObject *__pyx_pf_9validator_12check_scalar_2genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_9validator___pyx_scope_struct_26_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_26_genexpr *)__pyx_tp_new_9validator___pyx_scope_struct_26_genexpr(__pyx_ptype_9validator___pyx_scope_struct_26_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_26_genexpr *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 3735, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_25_check_scalar *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9validator_12check_scalar_4generator11, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_check_scalar_locals_genexpr, __pyx_n_s_validator); if (unlikely(!gen)) __PYX_ERR(0, 3735, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("validator.check_scalar.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9validator_12check_scalar_4generator11(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9validator___pyx_scope_struct_26_genexpr *__pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_26_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *(*__pyx_t_3)(PyObject *);
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genexpr", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 3735, __pyx_L1_error)
  __pyx_r = PyList_New(0); if (unlikely(!__pyx_r)) __PYX_ERR(0, 3735, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_r);
  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_target_type)) { __Pyx_RaiseClosureNameError("target_type"); __PYX_ERR(0, 3735, __pyx_L1_error) }
  if (likely(PyList_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_target_type)) || PyTuple_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_target_type)) {
    __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_target_type; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
    __pyx_t_3 = NULL;
  } else {
    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_target_type); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3735, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3735, __pyx_L1_error)
  }
  for (;;) {
    if (likely(!__pyx_t_3)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 3735, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3735, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 3735, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3735, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_3(__pyx_t_1);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 3735, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_t);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_t, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_type_name)) { __Pyx_RaiseClosureNameError("type_name"); __PYX_ERR(0, 3735, __pyx_L1_error) }
    __pyx_t_4 = __pyx_pf_9validator_12check_scalar_type_name(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_type_name, __pyx_cur_scope->__pyx_v_t); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3735, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    if (unlikely(__Pyx_ListComp_Append(__pyx_r, (PyObject*)__pyx_t_4))) __PYX_ERR(0, 3735, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_r); __pyx_r = 0;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  #if !CYTHON_USE_EXC_INFO_STACK
  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
  #endif
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3673
 *     return array
 * 
 * def check_scalar(             # <<<<<<<<<<<<<<
 *     x,
 *     name,
 */

static PyObject *__pyx_pf_9validator_126check_scalar(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_x, PyObject *__pyx_v_name, PyObject *__pyx_v_target_type, PyObject *__pyx_v_min_val, PyObject *__pyx_v_max_val, PyObject *__pyx_v_include_boundaries) {
  struct __pyx_obj_9validator___pyx_scope_struct_25_check_scalar *__pyx_cur_scope;
  PyObject *__pyx_v_types_str = NULL;
  PyObject *__pyx_v_target_type_str = NULL;
  PyObject *__pyx_v_expected_include_boundaries = NULL;
  PyObject *__pyx_v_comparison_operator = NULL;
  PyObject *__pyx_gb_9validator_12check_scalar_4generator11 = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  Py_ssize_t __pyx_t_5;
  Py_UCS4 __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_t_8;
  int __pyx_t_9;
  PyObject *__pyx_t_10 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("check_scalar", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_25_check_scalar *)__pyx_tp_new_9validator___pyx_scope_struct_25_check_scalar(__pyx_ptype_9validator___pyx_scope_struct_25_check_scalar, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_25_check_scalar *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 3673, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_v_target_type = __pyx_v_target_type;
  __Pyx_INCREF(__pyx_cur_scope->__pyx_v_target_type);
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_v_target_type);

  /* "validator.pyx":3721
 *     """
 * 
 *     def type_name(t):             # <<<<<<<<<<<<<<
 *         """Convert type into humman readable string."""
 *         module = t.__module__
 */
  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_9validator_12check_scalar_1type_name, 0, __pyx_n_s_check_scalar_locals_type_name, NULL, __pyx_n_s_validator, __pyx_d, ((PyObject *)__pyx_codeobj__91)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3721, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_cur_scope->__pyx_v_type_name = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":3733
 *         return f"{module}.{qualname}"
 * 
 *     if not isinstance(x, target_type):             # <<<<<<<<<<<<<<
 *         if isinstance(target_type, tuple):
 *             types_str = ", ".join(type_name(t) for t in target_type)
 */
  __pyx_t_1 = __pyx_cur_scope->__pyx_v_target_type;
  __Pyx_INCREF(__pyx_t_1);
  __pyx_t_2 = PyObject_IsInstance(__pyx_v_x, __pyx_t_1); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 3733, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = ((!(__pyx_t_2 != 0)) != 0);
  if (__pyx_t_3) {

    /* "validator.pyx":3734
 * 
 *     if not isinstance(x, target_type):
 *         if isinstance(target_type, tuple):             # <<<<<<<<<<<<<<
 *             types_str = ", ".join(type_name(t) for t in target_type)
 *             target_type_str = f"{{{types_str}}}"
 */
    __pyx_t_1 = __pyx_cur_scope->__pyx_v_target_type;
    __Pyx_INCREF(__pyx_t_1);
    __pyx_t_3 = PyTuple_Check(__pyx_t_1); 
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_2 = (__pyx_t_3 != 0);
    if (__pyx_t_2) {

      /* "validator.pyx":3735
 *     if not isinstance(x, target_type):
 *         if isinstance(target_type, tuple):
 *             types_str = ", ".join(type_name(t) for t in target_type)             # <<<<<<<<<<<<<<
 *             target_type_str = f"{{{types_str}}}"
 *         else:
 */
      __pyx_t_1 = __pyx_pf_9validator_12check_scalar_2genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3735, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_4 = __Pyx_Generator_Next(__pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3735, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_1 = PyUnicode_Join(__pyx_kp_u__83, __pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3735, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_v_types_str = ((PyObject*)__pyx_t_1);
      __pyx_t_1 = 0;

      /* "validator.pyx":3736
 *         if isinstance(target_type, tuple):
 *             types_str = ", ".join(type_name(t) for t in target_type)
 *             target_type_str = f"{{{types_str}}}"             # <<<<<<<<<<<<<<
 *         else:
 *             target_type_str = type_name(target_type)
 */
      __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3736, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_5 = 0;
      __pyx_t_6 = 127;
      __Pyx_INCREF(__pyx_kp_u__92);
      __pyx_t_5 += 1;
      __Pyx_GIVEREF(__pyx_kp_u__92);
      PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u__92);
      __pyx_t_4 = __Pyx_PyUnicode_Unicode(__pyx_v_types_str); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3736, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) : __pyx_t_6;
      __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
      __Pyx_GIVEREF(__pyx_t_4);
      PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_4);
      __pyx_t_4 = 0;
      __Pyx_INCREF(__pyx_kp_u__93);
      __pyx_t_5 += 1;
      __Pyx_GIVEREF(__pyx_kp_u__93);
      PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u__93);
      __pyx_t_4 = __Pyx_PyUnicode_Join(__pyx_t_1, 3, __pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3736, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_v_target_type_str = __pyx_t_4;
      __pyx_t_4 = 0;

      /* "validator.pyx":3734
 * 
 *     if not isinstance(x, target_type):
 *         if isinstance(target_type, tuple):             # <<<<<<<<<<<<<<
 *             types_str = ", ".join(type_name(t) for t in target_type)
 *             target_type_str = f"{{{types_str}}}"
 */
      goto __pyx_L4;
    }

    /* "validator.pyx":3738
 *             target_type_str = f"{{{types_str}}}"
 *         else:
 *             target_type_str = type_name(target_type)             # <<<<<<<<<<<<<<
 * 
 *         raise TypeError(
 */
    /*else*/ {
      __pyx_t_4 = __pyx_cur_scope->__pyx_v_target_type;
      __Pyx_INCREF(__pyx_t_4);
      __pyx_t_1 = __pyx_pf_9validator_12check_scalar_type_name(__pyx_cur_scope->__pyx_v_type_name, __pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3738, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_v_target_type_str = __pyx_t_1;
      __pyx_t_1 = 0;
    }
    __pyx_L4:;

    /* "validator.pyx":3741
 * 
 *         raise TypeError(
 *             f"{name} must be an instance of {target_type_str}, not"             # <<<<<<<<<<<<<<
 *             f" {type(x).__qualname__}."
 *         )
 */
    __pyx_t_1 = PyTuple_New(6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3741, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_5 = 0;
    __pyx_t_6 = 127;
    __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_v_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3741, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) : __pyx_t_6;
    __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_4);
    __pyx_t_4 = 0;
    __Pyx_INCREF(__pyx_kp_u_must_be_an_instance_of);
    __pyx_t_5 += 24;
    __Pyx_GIVEREF(__pyx_kp_u_must_be_an_instance_of);
    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_kp_u_must_be_an_instance_of);
    __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_v_target_type_str, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3741, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) : __pyx_t_6;
    __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_t_4);
    __pyx_t_4 = 0;
    __Pyx_INCREF(__pyx_kp_u_not);
    __pyx_t_5 += 6;
    __Pyx_GIVEREF(__pyx_kp_u_not);
    PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_kp_u_not);

    /* "validator.pyx":3742
 *         raise TypeError(
 *             f"{name} must be an instance of {target_type_str}, not"
 *             f" {type(x).__qualname__}."             # <<<<<<<<<<<<<<
 *         )
 * 
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_x)), __pyx_n_s_qualname); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3742, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_7 = __Pyx_PyObject_FormatSimple(__pyx_t_4, __pyx_empty_unicode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3742, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) : __pyx_t_6;
    __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_7);
    __Pyx_GIVEREF(__pyx_t_7);
    PyTuple_SET_ITEM(__pyx_t_1, 4, __pyx_t_7);
    __pyx_t_7 = 0;
    __Pyx_INCREF(__pyx_kp_u__16);
    __pyx_t_5 += 1;
    __Pyx_GIVEREF(__pyx_kp_u__16);
    PyTuple_SET_ITEM(__pyx_t_1, 5, __pyx_kp_u__16);

    /* "validator.pyx":3741
 * 
 *         raise TypeError(
 *             f"{name} must be an instance of {target_type_str}, not"             # <<<<<<<<<<<<<<
 *             f" {type(x).__qualname__}."
 *         )
 */
    __pyx_t_7 = __Pyx_PyUnicode_Join(__pyx_t_1, 6, __pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3741, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "validator.pyx":3740
 *             target_type_str = type_name(target_type)
 * 
 *         raise TypeError(             # <<<<<<<<<<<<<<
 *             f"{name} must be an instance of {target_type_str}, not"
 *             f" {type(x).__qualname__}."
 */
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3740, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 3740, __pyx_L1_error)

    /* "validator.pyx":3733
 *         return f"{module}.{qualname}"
 * 
 *     if not isinstance(x, target_type):             # <<<<<<<<<<<<<<
 *         if isinstance(target_type, tuple):
 *             types_str = ", ".join(type_name(t) for t in target_type)
 */
  }

  /* "validator.pyx":3745
 *         )
 * 
 *     expected_include_boundaries = ("left", "right", "both", "neither")             # <<<<<<<<<<<<<<
 *     if include_boundaries not in expected_include_boundaries:
 *         raise ValueError(
 */
  __Pyx_INCREF(__pyx_tuple__94);
  __pyx_v_expected_include_boundaries = __pyx_tuple__94;

  /* "validator.pyx":3746
 * 
 *     expected_include_boundaries = ("left", "right", "both", "neither")
 *     if include_boundaries not in expected_include_boundaries:             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             f"Unknown value for `include_boundaries`: {repr(include_boundaries)}. "
 */
  __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_v_include_boundaries, __pyx_v_expected_include_boundaries, Py_NE)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 3746, __pyx_L1_error)
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (unlikely(__pyx_t_3)) {

    /* "validator.pyx":3748
 *     if include_boundaries not in expected_include_boundaries:
 *         raise ValueError(
 *             f"Unknown value for `include_boundaries`: {repr(include_boundaries)}. "             # <<<<<<<<<<<<<<
 *             f"Possible values are: {expected_include_boundaries}."
 *         )
 */
    __pyx_t_1 = PyTuple_New(5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3748, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_5 = 0;
    __pyx_t_6 = 127;
    __Pyx_INCREF(__pyx_kp_u_Unknown_value_for_include_bounda);
    __pyx_t_5 += 40;
    __Pyx_GIVEREF(__pyx_kp_u_Unknown_value_for_include_bounda);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_Unknown_value_for_include_bounda);
    __pyx_t_7 = PyObject_Repr(__pyx_v_include_boundaries); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3748, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_t_7, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3748, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) : __pyx_t_6;
    __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_4);
    __pyx_t_4 = 0;
    __Pyx_INCREF(__pyx_kp_u_Possible_values_are);
    __pyx_t_5 += 23;
    __Pyx_GIVEREF(__pyx_kp_u_Possible_values_are);
    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_Possible_values_are);

    /* "validator.pyx":3749
 *         raise ValueError(
 *             f"Unknown value for `include_boundaries`: {repr(include_boundaries)}. "
 *             f"Possible values are: {expected_include_boundaries}."             # <<<<<<<<<<<<<<
 *         )
 * 
 */
    __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_v_expected_include_boundaries, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3749, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) : __pyx_t_6;
    __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_t_4);
    __pyx_t_4 = 0;
    __Pyx_INCREF(__pyx_kp_u__16);
    __pyx_t_5 += 1;
    __Pyx_GIVEREF(__pyx_kp_u__16);
    PyTuple_SET_ITEM(__pyx_t_1, 4, __pyx_kp_u__16);

    /* "validator.pyx":3748
 *     if include_boundaries not in expected_include_boundaries:
 *         raise ValueError(
 *             f"Unknown value for `include_boundaries`: {repr(include_boundaries)}. "             # <<<<<<<<<<<<<<
 *             f"Possible values are: {expected_include_boundaries}."
 *         )
 */
    __pyx_t_4 = __Pyx_PyUnicode_Join(__pyx_t_1, 5, __pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3748, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "validator.pyx":3747
 *     expected_include_boundaries = ("left", "right", "both", "neither")
 *     if include_boundaries not in expected_include_boundaries:
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             f"Unknown value for `include_boundaries`: {repr(include_boundaries)}. "
 *             f"Possible values are: {expected_include_boundaries}."
 */
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3747, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 3747, __pyx_L1_error)

    /* "validator.pyx":3746
 * 
 *     expected_include_boundaries = ("left", "right", "both", "neither")
 *     if include_boundaries not in expected_include_boundaries:             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             f"Unknown value for `include_boundaries`: {repr(include_boundaries)}. "
 */
  }

  /* "validator.pyx":3752
 *         )
 * 
 *     if max_val is None and include_boundaries == "right":             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             "`include_boundaries`='right' without specifying explicitly `max_val` "
 */
  __pyx_t_2 = (__pyx_v_max_val == Py_None);
  __pyx_t_8 = (__pyx_t_2 != 0);
  if (__pyx_t_8) {
  } else {
    __pyx_t_3 = __pyx_t_8;
    goto __pyx_L7_bool_binop_done;
  }
  __pyx_t_8 = (__Pyx_PyUnicode_Equals(__pyx_v_include_boundaries, __pyx_n_u_right, Py_EQ)); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 3752, __pyx_L1_error)
  __pyx_t_3 = __pyx_t_8;
  __pyx_L7_bool_binop_done:;
  if (unlikely(__pyx_t_3)) {

    /* "validator.pyx":3753
 * 
 *     if max_val is None and include_boundaries == "right":
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             "`include_boundaries`='right' without specifying explicitly `max_val` "
 *             "is inconsistent."
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__95, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3753, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 3753, __pyx_L1_error)

    /* "validator.pyx":3752
 *         )
 * 
 *     if max_val is None and include_boundaries == "right":             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             "`include_boundaries`='right' without specifying explicitly `max_val` "
 */
  }

  /* "validator.pyx":3758
 *         )
 * 
 *     if min_val is None and include_boundaries == "left":             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             "`include_boundaries`='left' without specifying explicitly `min_val` "
 */
  __pyx_t_8 = (__pyx_v_min_val == Py_None);
  __pyx_t_2 = (__pyx_t_8 != 0);
  if (__pyx_t_2) {
  } else {
    __pyx_t_3 = __pyx_t_2;
    goto __pyx_L10_bool_binop_done;
  }
  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_v_include_boundaries, __pyx_n_u_left, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 3758, __pyx_L1_error)
  __pyx_t_3 = __pyx_t_2;
  __pyx_L10_bool_binop_done:;
  if (unlikely(__pyx_t_3)) {

    /* "validator.pyx":3759
 * 
 *     if min_val is None and include_boundaries == "left":
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             "`include_boundaries`='left' without specifying explicitly `min_val` "
 *             "is inconsistent."
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__96, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3759, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 3759, __pyx_L1_error)

    /* "validator.pyx":3758
 *         )
 * 
 *     if min_val is None and include_boundaries == "left":             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             "`include_boundaries`='left' without specifying explicitly `min_val` "
 */
  }

  /* "validator.pyx":3765
 * 
 *     comparison_operator = (
 *         operator.lt if include_boundaries in ("left", "both") else operator.le             # <<<<<<<<<<<<<<
 *     )
 *     if min_val is not None and comparison_operator(x, min_val):
 */
  __Pyx_INCREF(__pyx_v_include_boundaries);
  __pyx_t_4 = __pyx_v_include_boundaries;
  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_t_4, __pyx_n_u_left, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 3765, __pyx_L1_error)
  if (!__pyx_t_2) {
  } else {
    __pyx_t_3 = __pyx_t_2;
    goto __pyx_L12_bool_binop_done;
  }
  __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_t_4, __pyx_n_u_both, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 3765, __pyx_L1_error)
  __pyx_t_3 = __pyx_t_2;
  __pyx_L12_bool_binop_done:;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if ((__pyx_t_3 != 0)) {
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_operator); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3765, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_lt); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3765, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_1 = __pyx_t_7;
    __pyx_t_7 = 0;
  } else {
    __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_operator); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3765, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_7, __pyx_n_s_le); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3765, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_1 = __pyx_t_4;
    __pyx_t_4 = 0;
  }
  __pyx_v_comparison_operator = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":3767
 *         operator.lt if include_boundaries in ("left", "both") else operator.le
 *     )
 *     if min_val is not None and comparison_operator(x, min_val):             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             f"{name} == {x}, must be"
 */
  __pyx_t_2 = (__pyx_v_min_val != Py_None);
  __pyx_t_8 = (__pyx_t_2 != 0);
  if (__pyx_t_8) {
  } else {
    __pyx_t_3 = __pyx_t_8;
    goto __pyx_L15_bool_binop_done;
  }
  __Pyx_INCREF(__pyx_v_comparison_operator);
  __pyx_t_4 = __pyx_v_comparison_operator; __pyx_t_7 = NULL;
  __pyx_t_9 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_7)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_7);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
      __pyx_t_9 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_4)) {
    PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_v_x, __pyx_v_min_val};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_9, 2+__pyx_t_9); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3767, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
    PyObject *__pyx_temp[3] = {__pyx_t_7, __pyx_v_x, __pyx_v_min_val};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_9, 2+__pyx_t_9); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3767, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  {
    __pyx_t_10 = PyTuple_New(2+__pyx_t_9); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 3767, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    if (__pyx_t_7) {
      __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_7); __pyx_t_7 = NULL;
    }
    __Pyx_INCREF(__pyx_v_x);
    __Pyx_GIVEREF(__pyx_v_x);
    PyTuple_SET_ITEM(__pyx_t_10, 0+__pyx_t_9, __pyx_v_x);
    __Pyx_INCREF(__pyx_v_min_val);
    __Pyx_GIVEREF(__pyx_v_min_val);
    PyTuple_SET_ITEM(__pyx_t_10, 1+__pyx_t_9, __pyx_v_min_val);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_10, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3767, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
  }
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 3767, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = __pyx_t_8;
  __pyx_L15_bool_binop_done:;
  if (unlikely(__pyx_t_3)) {

    /* "validator.pyx":3769
 *     if min_val is not None and comparison_operator(x, min_val):
 *         raise ValueError(
 *             f"{name} == {x}, must be"             # <<<<<<<<<<<<<<
 *             f" {'>=' if include_boundaries in ('left', 'both') else '>'} {min_val}."
 *         )
 */
    __pyx_t_1 = PyTuple_New(8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3769, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_5 = 0;
    __pyx_t_6 = 127;
    __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_v_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3769, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) : __pyx_t_6;
    __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_4);
    __pyx_t_4 = 0;
    __Pyx_INCREF(__pyx_kp_u__97);
    __pyx_t_5 += 4;
    __Pyx_GIVEREF(__pyx_kp_u__97);
    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_kp_u__97);
    __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_v_x, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3769, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) : __pyx_t_6;
    __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_t_4);
    __pyx_t_4 = 0;
    __Pyx_INCREF(__pyx_kp_u_must_be_2);
    __pyx_t_5 += 10;
    __Pyx_GIVEREF(__pyx_kp_u_must_be_2);
    PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_kp_u_must_be_2);

    /* "validator.pyx":3770
 *         raise ValueError(
 *             f"{name} == {x}, must be"
 *             f" {'>=' if include_boundaries in ('left', 'both') else '>'} {min_val}."             # <<<<<<<<<<<<<<
 *         )
 * 
 */
    __Pyx_INCREF(__pyx_v_include_boundaries);
    __pyx_t_10 = __pyx_v_include_boundaries;
    __pyx_t_8 = (__Pyx_PyUnicode_Equals(__pyx_t_10, __pyx_n_u_left, Py_EQ)); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 3770, __pyx_L1_error)
    if (!__pyx_t_8) {
    } else {
      __pyx_t_3 = __pyx_t_8;
      goto __pyx_L17_bool_binop_done;
    }
    __pyx_t_8 = (__Pyx_PyUnicode_Equals(__pyx_t_10, __pyx_n_u_both, Py_EQ)); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 3770, __pyx_L1_error)
    __pyx_t_3 = __pyx_t_8;
    __pyx_L17_bool_binop_done:;
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    if ((__pyx_t_3 != 0)) {
      __Pyx_INCREF(__pyx_kp_u__98);
      __pyx_t_4 = __pyx_kp_u__98;
    } else {
      __Pyx_INCREF(__pyx_kp_u__99);
      __pyx_t_4 = __pyx_kp_u__99;
    }
    __pyx_t_10 = __Pyx_PyUnicode_Unicode(__pyx_t_4); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 3770, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_10) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_10) : __pyx_t_6;
    __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_10);
    __Pyx_GIVEREF(__pyx_t_10);
    PyTuple_SET_ITEM(__pyx_t_1, 4, __pyx_t_10);
    __pyx_t_10 = 0;
    __Pyx_INCREF(__pyx_kp_u__81);
    __pyx_t_5 += 1;
    __Pyx_GIVEREF(__pyx_kp_u__81);
    PyTuple_SET_ITEM(__pyx_t_1, 5, __pyx_kp_u__81);
    __pyx_t_10 = __Pyx_PyObject_FormatSimple(__pyx_v_min_val, __pyx_empty_unicode); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 3770, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_10) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_10) : __pyx_t_6;
    __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_10);
    __Pyx_GIVEREF(__pyx_t_10);
    PyTuple_SET_ITEM(__pyx_t_1, 6, __pyx_t_10);
    __pyx_t_10 = 0;
    __Pyx_INCREF(__pyx_kp_u__16);
    __pyx_t_5 += 1;
    __Pyx_GIVEREF(__pyx_kp_u__16);
    PyTuple_SET_ITEM(__pyx_t_1, 7, __pyx_kp_u__16);

    /* "validator.pyx":3769
 *     if min_val is not None and comparison_operator(x, min_val):
 *         raise ValueError(
 *             f"{name} == {x}, must be"             # <<<<<<<<<<<<<<
 *             f" {'>=' if include_boundaries in ('left', 'both') else '>'} {min_val}."
 *         )
 */
    __pyx_t_10 = __Pyx_PyUnicode_Join(__pyx_t_1, 8, __pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 3769, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "validator.pyx":3768
 *     )
 *     if min_val is not None and comparison_operator(x, min_val):
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             f"{name} == {x}, must be"
 *             f" {'>=' if include_boundaries in ('left', 'both') else '>'} {min_val}."
 */
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_10); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3768, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 3768, __pyx_L1_error)

    /* "validator.pyx":3767
 *         operator.lt if include_boundaries in ("left", "both") else operator.le
 *     )
 *     if min_val is not None and comparison_operator(x, min_val):             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             f"{name} == {x}, must be"
 */
  }

  /* "validator.pyx":3774
 * 
 *     comparison_operator = (
 *         operator.gt if include_boundaries in ("right", "both") else operator.ge             # <<<<<<<<<<<<<<
 *     )
 *     if max_val is not None and comparison_operator(x, max_val):
 */
  __Pyx_INCREF(__pyx_v_include_boundaries);
  __pyx_t_10 = __pyx_v_include_boundaries;
  __pyx_t_8 = (__Pyx_PyUnicode_Equals(__pyx_t_10, __pyx_n_u_right, Py_EQ)); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 3774, __pyx_L1_error)
  if (!__pyx_t_8) {
  } else {
    __pyx_t_3 = __pyx_t_8;
    goto __pyx_L19_bool_binop_done;
  }
  __pyx_t_8 = (__Pyx_PyUnicode_Equals(__pyx_t_10, __pyx_n_u_both, Py_EQ)); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 3774, __pyx_L1_error)
  __pyx_t_3 = __pyx_t_8;
  __pyx_L19_bool_binop_done:;
  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
  if ((__pyx_t_3 != 0)) {
    __Pyx_GetModuleGlobalName(__pyx_t_10, __pyx_n_s_operator); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 3774, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_10, __pyx_n_s_gt); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3774, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    __pyx_t_1 = __pyx_t_4;
    __pyx_t_4 = 0;
  } else {
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_operator); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3774, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_ge); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 3774, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_1 = __pyx_t_10;
    __pyx_t_10 = 0;
  }
  __Pyx_DECREF_SET(__pyx_v_comparison_operator, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":3776
 *         operator.gt if include_boundaries in ("right", "both") else operator.ge
 *     )
 *     if max_val is not None and comparison_operator(x, max_val):             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             f"{name} == {x}, must be"
 */
  __pyx_t_8 = (__pyx_v_max_val != Py_None);
  __pyx_t_2 = (__pyx_t_8 != 0);
  if (__pyx_t_2) {
  } else {
    __pyx_t_3 = __pyx_t_2;
    goto __pyx_L22_bool_binop_done;
  }
  __Pyx_INCREF(__pyx_v_comparison_operator);
  __pyx_t_10 = __pyx_v_comparison_operator; __pyx_t_4 = NULL;
  __pyx_t_9 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_10))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_10);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_10);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_10, function);
      __pyx_t_9 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_10)) {
    PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_x, __pyx_v_max_val};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_10, __pyx_temp+1-__pyx_t_9, 2+__pyx_t_9); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3776, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_10)) {
    PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_x, __pyx_v_max_val};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_10, __pyx_temp+1-__pyx_t_9, 2+__pyx_t_9); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3776, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GOTREF(__pyx_t_1);
  } else
  #endif
  {
    __pyx_t_7 = PyTuple_New(2+__pyx_t_9); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3776, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    if (__pyx_t_4) {
      __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4); __pyx_t_4 = NULL;
    }
    __Pyx_INCREF(__pyx_v_x);
    __Pyx_GIVEREF(__pyx_v_x);
    PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_9, __pyx_v_x);
    __Pyx_INCREF(__pyx_v_max_val);
    __Pyx_GIVEREF(__pyx_v_max_val);
    PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_9, __pyx_v_max_val);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_10, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3776, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  }
  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 3776, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = __pyx_t_2;
  __pyx_L22_bool_binop_done:;
  if (unlikely(__pyx_t_3)) {

    /* "validator.pyx":3778
 *     if max_val is not None and comparison_operator(x, max_val):
 *         raise ValueError(
 *             f"{name} == {x}, must be"             # <<<<<<<<<<<<<<
 *             f" {'<=' if include_boundaries in ('right', 'both') else '<'} {max_val}."
 *         )
 */
    __pyx_t_1 = PyTuple_New(8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3778, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_5 = 0;
    __pyx_t_6 = 127;
    __pyx_t_10 = __Pyx_PyObject_FormatSimple(__pyx_v_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 3778, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_10) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_10) : __pyx_t_6;
    __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_10);
    __Pyx_GIVEREF(__pyx_t_10);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_10);
    __pyx_t_10 = 0;
    __Pyx_INCREF(__pyx_kp_u__97);
    __pyx_t_5 += 4;
    __Pyx_GIVEREF(__pyx_kp_u__97);
    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_kp_u__97);
    __pyx_t_10 = __Pyx_PyObject_FormatSimple(__pyx_v_x, __pyx_empty_unicode); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 3778, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_10) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_10) : __pyx_t_6;
    __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_10);
    __Pyx_GIVEREF(__pyx_t_10);
    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_t_10);
    __pyx_t_10 = 0;
    __Pyx_INCREF(__pyx_kp_u_must_be_2);
    __pyx_t_5 += 10;
    __Pyx_GIVEREF(__pyx_kp_u_must_be_2);
    PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_kp_u_must_be_2);

    /* "validator.pyx":3779
 *         raise ValueError(
 *             f"{name} == {x}, must be"
 *             f" {'<=' if include_boundaries in ('right', 'both') else '<'} {max_val}."             # <<<<<<<<<<<<<<
 *         )
 * 
 */
    __Pyx_INCREF(__pyx_v_include_boundaries);
    __pyx_t_7 = __pyx_v_include_boundaries;
    __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_t_7, __pyx_n_u_right, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 3779, __pyx_L1_error)
    if (!__pyx_t_2) {
    } else {
      __pyx_t_3 = __pyx_t_2;
      goto __pyx_L24_bool_binop_done;
    }
    __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_t_7, __pyx_n_u_both, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 3779, __pyx_L1_error)
    __pyx_t_3 = __pyx_t_2;
    __pyx_L24_bool_binop_done:;
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    if ((__pyx_t_3 != 0)) {
      __Pyx_INCREF(__pyx_kp_u__100);
      __pyx_t_10 = __pyx_kp_u__100;
    } else {
      __Pyx_INCREF(__pyx_kp_u__101);
      __pyx_t_10 = __pyx_kp_u__101;
    }
    __pyx_t_7 = __Pyx_PyUnicode_Unicode(__pyx_t_10); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3779, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) : __pyx_t_6;
    __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_7);
    __Pyx_GIVEREF(__pyx_t_7);
    PyTuple_SET_ITEM(__pyx_t_1, 4, __pyx_t_7);
    __pyx_t_7 = 0;
    __Pyx_INCREF(__pyx_kp_u__81);
    __pyx_t_5 += 1;
    __Pyx_GIVEREF(__pyx_kp_u__81);
    PyTuple_SET_ITEM(__pyx_t_1, 5, __pyx_kp_u__81);
    __pyx_t_7 = __Pyx_PyObject_FormatSimple(__pyx_v_max_val, __pyx_empty_unicode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3779, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_6 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) > __pyx_t_6) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) : __pyx_t_6;
    __pyx_t_5 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_7);
    __Pyx_GIVEREF(__pyx_t_7);
    PyTuple_SET_ITEM(__pyx_t_1, 6, __pyx_t_7);
    __pyx_t_7 = 0;
    __Pyx_INCREF(__pyx_kp_u__16);
    __pyx_t_5 += 1;
    __Pyx_GIVEREF(__pyx_kp_u__16);
    PyTuple_SET_ITEM(__pyx_t_1, 7, __pyx_kp_u__16);

    /* "validator.pyx":3778
 *     if max_val is not None and comparison_operator(x, max_val):
 *         raise ValueError(
 *             f"{name} == {x}, must be"             # <<<<<<<<<<<<<<
 *             f" {'<=' if include_boundaries in ('right', 'both') else '<'} {max_val}."
 *         )
 */
    __pyx_t_7 = __Pyx_PyUnicode_Join(__pyx_t_1, 8, __pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 3778, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "validator.pyx":3777
 *     )
 *     if max_val is not None and comparison_operator(x, max_val):
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             f"{name} == {x}, must be"
 *             f" {'<=' if include_boundaries in ('right', 'both') else '<'} {max_val}."
 */
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3777, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 3777, __pyx_L1_error)

    /* "validator.pyx":3776
 *         operator.gt if include_boundaries in ("right", "both") else operator.ge
 *     )
 *     if max_val is not None and comparison_operator(x, max_val):             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             f"{name} == {x}, must be"
 */
  }

  /* "validator.pyx":3782
 *         )
 * 
 *     return x             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_x);
  __pyx_r = __pyx_v_x;
  goto __pyx_L0;

  /* "validator.pyx":3673
 *     return array
 * 
 * def check_scalar(             # <<<<<<<<<<<<<<
 *     x,
 *     name,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_AddTraceback("validator.check_scalar", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_types_str);
  __Pyx_XDECREF(__pyx_v_target_type_str);
  __Pyx_XDECREF(__pyx_v_expected_include_boundaries);
  __Pyx_XDECREF(__pyx_v_comparison_operator);
  __Pyx_XDECREF(__pyx_gb_9validator_12check_scalar_4generator11);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3785
 * 
 * 
 * def _get_feature_names(X):             # <<<<<<<<<<<<<<
 *     """Get feature names from X.
 *     Support for other array containers should place its implementation here.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_129_get_feature_names(PyObject *__pyx_self, PyObject *__pyx_v_X); /*proto*/
static char __pyx_doc_9validator_128_get_feature_names[] = "Get feature names from X.\n    Support for other array containers should place its implementation here.\n    Parameters\n    ----------\n    X : {ndarray, dataframe} of shape (n_samples, n_features)\n        Array container to extract feature names.\n        - pandas dataframe : The columns will be considered to be feature\n          names. If the dataframe contains non-string feature names, `None` is\n          returned.\n        - All other array containers will return `None`.\n    Returns\n    -------\n    names: ndarray or None\n        Feature names of `X`. Unrecognized array containers will return `None`.\n    ";
static PyMethodDef __pyx_mdef_9validator_129_get_feature_names = {"_get_feature_names", (PyCFunction)__pyx_pw_9validator_129_get_feature_names, METH_O, __pyx_doc_9validator_128_get_feature_names};
static PyObject *__pyx_pw_9validator_129_get_feature_names(PyObject *__pyx_self, PyObject *__pyx_v_X) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_get_feature_names (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_128_get_feature_names(__pyx_self, ((PyObject *)__pyx_v_X));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9validator_18_get_feature_names_2generator12(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */
static PyObject *__pyx_gb_9validator_18_get_feature_names_7genexpr_2generator13(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */

/* "validator.pyx":3810
 *         return
 * 
 *     types = sorted(t.__qualname__ for t in set(type(v) for v in feature_names))             # <<<<<<<<<<<<<<
 * 
 *     # mixed type of string and non-string is not supported
 */

static PyObject *__pyx_pf_9validator_18_get_feature_names_7genexpr_genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_9validator___pyx_scope_struct_29_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_29_genexpr *)__pyx_tp_new_9validator___pyx_scope_struct_29_genexpr(__pyx_ptype_9validator___pyx_scope_struct_29_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_29_genexpr *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 3810, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_28_genexpr *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9validator_18_get_feature_names_7genexpr_2generator13, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_get_feature_names_locals_genexp, __pyx_n_s_validator); if (unlikely(!gen)) __PYX_ERR(0, 3810, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("validator._get_feature_names.genexpr.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9validator_18_get_feature_names_7genexpr_2generator13(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9validator___pyx_scope_struct_29_genexpr *__pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_29_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *(*__pyx_t_3)(PyObject *);
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genexpr", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 3810, __pyx_L1_error)
  __pyx_r = PySet_New(NULL); if (unlikely(!__pyx_r)) __PYX_ERR(0, 3810, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_r);
  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_outer_scope->__pyx_v_feature_names)) { __Pyx_RaiseClosureNameError("feature_names"); __PYX_ERR(0, 3810, __pyx_L1_error) }
  if (likely(PyList_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_outer_scope->__pyx_v_feature_names)) || PyTuple_CheckExact(__pyx_cur_scope->__pyx_outer_scope->__pyx_outer_scope->__pyx_v_feature_names)) {
    __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_outer_scope->__pyx_v_feature_names; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
    __pyx_t_3 = NULL;
  } else {
    __pyx_t_2 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_cur_scope->__pyx_outer_scope->__pyx_outer_scope->__pyx_v_feature_names); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3810, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3810, __pyx_L1_error)
  }
  for (;;) {
    if (likely(!__pyx_t_3)) {
      if (likely(PyList_CheckExact(__pyx_t_1))) {
        if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 3810, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3810, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
        #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 3810, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3810, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_3(__pyx_t_1);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 3810, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_v);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_v, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_4 = 0;
    if (unlikely(PySet_Add(__pyx_r, (PyObject*)((PyObject *)Py_TYPE(__pyx_cur_scope->__pyx_v_v))))) __PYX_ERR(0, 3810, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_r); __pyx_r = 0;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  #if !CYTHON_USE_EXC_INFO_STACK
  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
  #endif
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_18_get_feature_names_genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_9validator___pyx_scope_struct_28_genexpr *__pyx_cur_scope;
  PyObject *__pyx_gb_9validator_18_get_feature_names_7genexpr_2generator13 = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_28_genexpr *)__pyx_tp_new_9validator___pyx_scope_struct_28_genexpr(__pyx_ptype_9validator___pyx_scope_struct_28_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_28_genexpr *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 3810, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_27__get_feature_names *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9validator_18_get_feature_names_2generator12, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_get_feature_names_locals_genexp_2, __pyx_n_s_validator); if (unlikely(!gen)) __PYX_ERR(0, 3810, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("validator._get_feature_names.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_XDECREF(__pyx_gb_9validator_18_get_feature_names_7genexpr_2generator13);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9validator_18_get_feature_names_2generator12(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9validator___pyx_scope_struct_28_genexpr *__pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_28_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  Py_ssize_t __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genexpr", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 3810, __pyx_L1_error)
  __pyx_r = PyList_New(0); if (unlikely(!__pyx_r)) __PYX_ERR(0, 3810, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_r);
  __pyx_t_2 = 0;
  __pyx_t_5 = __pyx_pf_9validator_18_get_feature_names_7genexpr_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3810, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = __Pyx_Generator_Next(__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3810, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = __Pyx_set_iterator(__pyx_t_6, 1, (&__pyx_t_3), (&__pyx_t_4)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3810, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __Pyx_XDECREF(__pyx_t_1);
  __pyx_t_1 = __pyx_t_5;
  __pyx_t_5 = 0;
  while (1) {
    __pyx_t_7 = __Pyx_set_iter_next(__pyx_t_1, __pyx_t_3, &__pyx_t_2, &__pyx_t_5, __pyx_t_4);
    if (unlikely(__pyx_t_7 == 0)) break;
    if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 3810, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_t);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_t, __pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_5);
    __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_cur_scope->__pyx_v_t, __pyx_n_s_qualname); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3810, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (unlikely(__Pyx_ListComp_Append(__pyx_r, (PyObject*)__pyx_t_5))) __PYX_ERR(0, 3810, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_r); __pyx_r = 0;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  #if !CYTHON_USE_EXC_INFO_STACK
  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
  #endif
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3785
 * 
 * 
 * def _get_feature_names(X):             # <<<<<<<<<<<<<<
 *     """Get feature names from X.
 *     Support for other array containers should place its implementation here.
 */

static PyObject *__pyx_pf_9validator_128_get_feature_names(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X) {
  struct __pyx_obj_9validator___pyx_scope_struct_27__get_feature_names *__pyx_cur_scope;
  PyObject *__pyx_v_types = NULL;
  PyObject *__pyx_gb_9validator_18_get_feature_names_2generator12 = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  Py_ssize_t __pyx_t_8;
  int __pyx_t_9;
  Py_UCS4 __pyx_t_10;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_get_feature_names", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_27__get_feature_names *)__pyx_tp_new_9validator___pyx_scope_struct_27__get_feature_names(__pyx_ptype_9validator___pyx_scope_struct_27__get_feature_names, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_27__get_feature_names *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 3785, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }

  /* "validator.pyx":3801
 *         Feature names of `X`. Unrecognized array containers will return `None`.
 *     """
 *     feature_names = None             # <<<<<<<<<<<<<<
 * 
 *     # extract feature names for support array containers
 */
  __Pyx_INCREF(Py_None);
  __Pyx_GIVEREF(Py_None);
  __pyx_cur_scope->__pyx_v_feature_names = Py_None;

  /* "validator.pyx":3804
 * 
 *     # extract feature names for support array containers
 *     if hasattr(X, "columns"):             # <<<<<<<<<<<<<<
 *         feature_names = np.asarray(X.columns, dtype=object)
 * 
 */
  __pyx_t_1 = __Pyx_HasAttr(__pyx_v_X, __pyx_n_u_columns); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 3804, __pyx_L1_error)
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "validator.pyx":3805
 *     # extract feature names for support array containers
 *     if hasattr(X, "columns"):
 *         feature_names = np.asarray(X.columns, dtype=object)             # <<<<<<<<<<<<<<
 * 
 *     if feature_names is None or len(feature_names) == 0:
 */
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3805, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_asarray); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3805, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_columns); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3805, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3805, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3805, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, __pyx_builtin_object) < 0) __PYX_ERR(0, 3805, __pyx_L1_error)
    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_5, __pyx_t_3); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3805, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GOTREF(__pyx_cur_scope->__pyx_v_feature_names);
    __Pyx_DECREF_SET(__pyx_cur_scope->__pyx_v_feature_names, __pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_6);
    __pyx_t_6 = 0;

    /* "validator.pyx":3804
 * 
 *     # extract feature names for support array containers
 *     if hasattr(X, "columns"):             # <<<<<<<<<<<<<<
 *         feature_names = np.asarray(X.columns, dtype=object)
 * 
 */
  }

  /* "validator.pyx":3807
 *         feature_names = np.asarray(X.columns, dtype=object)
 * 
 *     if feature_names is None or len(feature_names) == 0:             # <<<<<<<<<<<<<<
 *         return
 * 
 */
  __pyx_t_1 = (__pyx_cur_scope->__pyx_v_feature_names == Py_None);
  __pyx_t_7 = (__pyx_t_1 != 0);
  if (!__pyx_t_7) {
  } else {
    __pyx_t_2 = __pyx_t_7;
    goto __pyx_L5_bool_binop_done;
  }
  __pyx_t_6 = __pyx_cur_scope->__pyx_v_feature_names;
  __Pyx_INCREF(__pyx_t_6);
  __pyx_t_8 = PyObject_Length(__pyx_t_6); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3807, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_7 = ((__pyx_t_8 == 0) != 0);
  __pyx_t_2 = __pyx_t_7;
  __pyx_L5_bool_binop_done:;
  if (__pyx_t_2) {

    /* "validator.pyx":3808
 * 
 *     if feature_names is None or len(feature_names) == 0:
 *         return             # <<<<<<<<<<<<<<
 * 
 *     types = sorted(t.__qualname__ for t in set(type(v) for v in feature_names))
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_r = Py_None; __Pyx_INCREF(Py_None);
    goto __pyx_L0;

    /* "validator.pyx":3807
 *         feature_names = np.asarray(X.columns, dtype=object)
 * 
 *     if feature_names is None or len(feature_names) == 0:             # <<<<<<<<<<<<<<
 *         return
 * 
 */
  }

  /* "validator.pyx":3810
 *         return
 * 
 *     types = sorted(t.__qualname__ for t in set(type(v) for v in feature_names))             # <<<<<<<<<<<<<<
 * 
 *     # mixed type of string and non-string is not supported
 */
  __pyx_t_3 = __pyx_pf_9validator_18_get_feature_names_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3810, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_5 = __Pyx_Generator_Next(__pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3810, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_6 = ((PyObject*)__pyx_t_5);
  __pyx_t_5 = 0;
  __pyx_t_9 = PyList_Sort(__pyx_t_6); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(0, 3810, __pyx_L1_error)
  __pyx_v_types = ((PyObject*)__pyx_t_6);
  __pyx_t_6 = 0;

  /* "validator.pyx":3813
 * 
 *     # mixed type of string and non-string is not supported
 *     if len(types) > 1 and "str" in types:             # <<<<<<<<<<<<<<
 *         raise TypeError(
 *             "Feature names only support names that are all strings. "
 */
  if (unlikely(__pyx_v_types == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 3813, __pyx_L1_error)
  }
  __pyx_t_8 = PyList_GET_SIZE(__pyx_v_types); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3813, __pyx_L1_error)
  __pyx_t_7 = ((__pyx_t_8 > 1) != 0);
  if (__pyx_t_7) {
  } else {
    __pyx_t_2 = __pyx_t_7;
    goto __pyx_L8_bool_binop_done;
  }
  __pyx_t_7 = (__Pyx_PySequence_ContainsTF(__pyx_n_u_str, __pyx_v_types, Py_EQ)); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 3813, __pyx_L1_error)
  __pyx_t_1 = (__pyx_t_7 != 0);
  __pyx_t_2 = __pyx_t_1;
  __pyx_L8_bool_binop_done:;
  if (unlikely(__pyx_t_2)) {

    /* "validator.pyx":3815
 *     if len(types) > 1 and "str" in types:
 *         raise TypeError(
 *             "Feature names only support names that are all strings. "             # <<<<<<<<<<<<<<
 *             f"Got feature names with dtypes: {types}."
 *         )
 */
    __pyx_t_6 = PyTuple_New(3); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3815, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_8 = 0;
    __pyx_t_10 = 127;
    __Pyx_INCREF(__pyx_kp_u_Feature_names_only_support_names);
    __pyx_t_8 += 86;
    __Pyx_GIVEREF(__pyx_kp_u_Feature_names_only_support_names);
    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_kp_u_Feature_names_only_support_names);

    /* "validator.pyx":3816
 *         raise TypeError(
 *             "Feature names only support names that are all strings. "
 *             f"Got feature names with dtypes: {types}."             # <<<<<<<<<<<<<<
 *         )
 * 
 */
    __pyx_t_5 = __Pyx_PyObject_FormatSimple(__pyx_v_types, __pyx_empty_unicode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3816, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_10 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) > __pyx_t_10) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) : __pyx_t_10;
    __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_5);
    PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_5);
    __pyx_t_5 = 0;
    __Pyx_INCREF(__pyx_kp_u__16);
    __pyx_t_8 += 1;
    __Pyx_GIVEREF(__pyx_kp_u__16);
    PyTuple_SET_ITEM(__pyx_t_6, 2, __pyx_kp_u__16);

    /* "validator.pyx":3815
 *     if len(types) > 1 and "str" in types:
 *         raise TypeError(
 *             "Feature names only support names that are all strings. "             # <<<<<<<<<<<<<<
 *             f"Got feature names with dtypes: {types}."
 *         )
 */
    __pyx_t_5 = __Pyx_PyUnicode_Join(__pyx_t_6, 3, __pyx_t_8, __pyx_t_10); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3815, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

    /* "validator.pyx":3814
 *     # mixed type of string and non-string is not supported
 *     if len(types) > 1 and "str" in types:
 *         raise TypeError(             # <<<<<<<<<<<<<<
 *             "Feature names only support names that are all strings. "
 *             f"Got feature names with dtypes: {types}."
 */
    __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3814, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_Raise(__pyx_t_6, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __PYX_ERR(0, 3814, __pyx_L1_error)

    /* "validator.pyx":3813
 * 
 *     # mixed type of string and non-string is not supported
 *     if len(types) > 1 and "str" in types:             # <<<<<<<<<<<<<<
 *         raise TypeError(
 *             "Feature names only support names that are all strings. "
 */
  }

  /* "validator.pyx":3820
 * 
 *     # Only feature names of all strings are supported
 *     if len(types) == 1 and types[0] == "str":             # <<<<<<<<<<<<<<
 *         return feature_names
 * 
 */
  if (unlikely(__pyx_v_types == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    __PYX_ERR(0, 3820, __pyx_L1_error)
  }
  __pyx_t_8 = PyList_GET_SIZE(__pyx_v_types); if (unlikely(__pyx_t_8 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3820, __pyx_L1_error)
  __pyx_t_1 = ((__pyx_t_8 == 1) != 0);
  if (__pyx_t_1) {
  } else {
    __pyx_t_2 = __pyx_t_1;
    goto __pyx_L11_bool_binop_done;
  }
  if (unlikely(__pyx_v_types == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
    __PYX_ERR(0, 3820, __pyx_L1_error)
  }
  __pyx_t_6 = __Pyx_GetItemInt_List(__pyx_v_types, 0, long, 1, __Pyx_PyInt_From_long, 1, 0, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3820, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_t_6, __pyx_n_u_str, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 3820, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_2 = __pyx_t_1;
  __pyx_L11_bool_binop_done:;
  if (__pyx_t_2) {

    /* "validator.pyx":3821
 *     # Only feature names of all strings are supported
 *     if len(types) == 1 and types[0] == "str":
 *         return feature_names             # <<<<<<<<<<<<<<
 * 
 * def check_is_fitted(estimator, attributes=None, *, msg=None, all_or_any=all):
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_cur_scope->__pyx_v_feature_names);
    __pyx_r = __pyx_cur_scope->__pyx_v_feature_names;
    goto __pyx_L0;

    /* "validator.pyx":3820
 * 
 *     # Only feature names of all strings are supported
 *     if len(types) == 1 and types[0] == "str":             # <<<<<<<<<<<<<<
 *         return feature_names
 * 
 */
  }

  /* "validator.pyx":3785
 * 
 * 
 * def _get_feature_names(X):             # <<<<<<<<<<<<<<
 *     """Get feature names from X.
 *     Support for other array containers should place its implementation here.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("validator._get_feature_names", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_types);
  __Pyx_XDECREF(__pyx_gb_9validator_18_get_feature_names_2generator12);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3823
 *         return feature_names
 * 
 * def check_is_fitted(estimator, attributes=None, *, msg=None, all_or_any=all):             # <<<<<<<<<<<<<<
 *     """Perform is_fitted validation for estimator.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_131check_is_fitted(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_130check_is_fitted[] = "Perform is_fitted validation for estimator.\n\n    Checks if the estimator is fitted by verifying the presence of\n    fitted attributes (ending with a trailing underscore) and otherwise\n    raises a NotFittedError with the given message.\n\n    If an estimator does not set any attributes with a trailing underscore, it\n    can define a ``__sklearn_is_fitted__`` method returning a boolean to specify if the\n    estimator is fitted or not.\n\n    Parameters\n    ----------\n    estimator : estimator instance\n        Estimator instance for which the check is performed.\n\n    attributes : str, list or tuple of str, default=None\n        Attribute name(s) given as string or a list/tuple of strings\n        Eg.: ``[\"coef_\", \"estimator_\", ...], \"coef_\"``\n\n        If `None`, `estimator` is considered fitted if there exist an\n        attribute that ends with a underscore and does not start with double\n        underscore.\n\n    msg : str, default=None\n        The default error message is, \"This %(name)s instance is not fitted\n        yet. Call 'fit' with appropriate arguments before using this\n        estimator.\"\n\n        For custom messages if \"%(name)s\" is present in the message string,\n        it is substituted for the estimator name.\n\n        Eg. : \"Estimator, %(name)s, must be fitted before sparsifying\".\n\n    all_or_any : callable, {all, any}, default=all\n        Specify whether all or any of the given attributes must exist.\n\n    Raises\n    ------\n    TypeError\n        If the estimator is a class or not an estimator instance\n\n    NotFittedError\n        If the attributes are not found.\n    ";
static PyMethodDef __pyx_mdef_9validator_131check_is_fitted = {"check_is_fitted", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_131check_is_fitted, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_130check_is_fitted};
static PyObject *__pyx_pw_9validator_131check_is_fitted(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_estimator = 0;
  PyObject *__pyx_v_attributes = 0;
  PyObject *__pyx_v_msg = 0;
  PyObject *__pyx_v_all_or_any = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("check_is_fitted (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_estimator,&__pyx_n_s_attributes,&__pyx_n_s_msg,&__pyx_n_s_all_or_any,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)__pyx_builtin_all);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_estimator)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_attributes);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (kw_args > 0 && likely(kw_args <= 2)) {
        Py_ssize_t index;
        for (index = 2; index < 4 && kw_args > 0; index++) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
          if (value) { values[index] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "check_is_fitted") < 0)) __PYX_ERR(0, 3823, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_estimator = values[0];
    __pyx_v_attributes = values[1];
    __pyx_v_msg = values[2];
    __pyx_v_all_or_any = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("check_is_fitted", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3823, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.check_is_fitted", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_130check_is_fitted(__pyx_self, __pyx_v_estimator, __pyx_v_attributes, __pyx_v_msg, __pyx_v_all_or_any);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_130check_is_fitted(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_estimator, PyObject *__pyx_v_attributes, PyObject *__pyx_v_msg, PyObject *__pyx_v_all_or_any) {
  PyObject *__pyx_v_NotFittedError = NULL;
  PyObject *__pyx_v_fitted = NULL;
  PyObject *__pyx_9genexpr24__pyx_v_attr = NULL;
  PyObject *__pyx_9genexpr25__pyx_v_v = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_t_6;
  Py_ssize_t __pyx_t_7;
  PyObject *(*__pyx_t_8)(PyObject *);
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("check_is_fitted", 0);
  __Pyx_INCREF(__pyx_v_attributes);
  __Pyx_INCREF(__pyx_v_msg);

  /* "validator.pyx":3868
 *         If the attributes are not found.
 *     """
 *     from ..exceptions import NotFittedError             # <<<<<<<<<<<<<<
 *     if isclass(estimator):
 *         raise TypeError("{} is a class, not an instance.".format(estimator))
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3868, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_NotFittedError);
  __Pyx_GIVEREF(__pyx_n_s_NotFittedError);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_NotFittedError);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_exceptions, __pyx_t_1, 2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3868, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_NotFittedError); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3868, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_t_1);
  __pyx_v_NotFittedError = __pyx_t_1;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":3869
 *     """
 *     from ..exceptions import NotFittedError
 *     if isclass(estimator):             # <<<<<<<<<<<<<<
 *         raise TypeError("{} is a class, not an instance.".format(estimator))
 *     if msg is None:
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_isclass); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3869, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_3, __pyx_v_estimator) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_estimator);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3869, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 3869, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(__pyx_t_4)) {

    /* "validator.pyx":3870
 *     from ..exceptions import NotFittedError
 *     if isclass(estimator):
 *         raise TypeError("{} is a class, not an instance.".format(estimator))             # <<<<<<<<<<<<<<
 *     if msg is None:
 *         msg = (
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_kp_u_is_a_class_not_an_instance, __pyx_n_s_format); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3870, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_3, __pyx_v_estimator) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_estimator);
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3870, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3870, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 3870, __pyx_L1_error)

    /* "validator.pyx":3869
 *     """
 *     from ..exceptions import NotFittedError
 *     if isclass(estimator):             # <<<<<<<<<<<<<<
 *         raise TypeError("{} is a class, not an instance.".format(estimator))
 *     if msg is None:
 */
  }

  /* "validator.pyx":3871
 *     if isclass(estimator):
 *         raise TypeError("{} is a class, not an instance.".format(estimator))
 *     if msg is None:             # <<<<<<<<<<<<<<
 *         msg = (
 *             "This %(name)s instance is not fitted yet. Call 'fit' with "
 */
  __pyx_t_4 = (__pyx_v_msg == Py_None);
  __pyx_t_5 = (__pyx_t_4 != 0);
  if (__pyx_t_5) {

    /* "validator.pyx":3873
 *     if msg is None:
 *         msg = (
 *             "This %(name)s instance is not fitted yet. Call 'fit' with "             # <<<<<<<<<<<<<<
 *             "appropriate arguments before using this estimator."
 *         )
 */
    __Pyx_INCREF(__pyx_kp_u_This_name_s_instance_is_not_fitt);
    __Pyx_DECREF_SET(__pyx_v_msg, __pyx_kp_u_This_name_s_instance_is_not_fitt);

    /* "validator.pyx":3871
 *     if isclass(estimator):
 *         raise TypeError("{} is a class, not an instance.".format(estimator))
 *     if msg is None:             # <<<<<<<<<<<<<<
 *         msg = (
 *             "This %(name)s instance is not fitted yet. Call 'fit' with "
 */
  }

  /* "validator.pyx":3877
 *         )
 * 
 *     if not hasattr(estimator, "fit"):             # <<<<<<<<<<<<<<
 *         raise TypeError("%s is not an estimator instance." % (estimator))
 * 
 */
  __pyx_t_5 = __Pyx_HasAttr(__pyx_v_estimator, __pyx_n_u_fit); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(0, 3877, __pyx_L1_error)
  __pyx_t_4 = ((!(__pyx_t_5 != 0)) != 0);
  if (unlikely(__pyx_t_4)) {

    /* "validator.pyx":3878
 * 
 *     if not hasattr(estimator, "fit"):
 *         raise TypeError("%s is not an estimator instance." % (estimator))             # <<<<<<<<<<<<<<
 * 
 *     if attributes is not None:
 */
    __pyx_t_1 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_s_is_not_an_estimator_instance, __pyx_v_estimator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3878, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3878, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 3878, __pyx_L1_error)

    /* "validator.pyx":3877
 *         )
 * 
 *     if not hasattr(estimator, "fit"):             # <<<<<<<<<<<<<<
 *         raise TypeError("%s is not an estimator instance." % (estimator))
 * 
 */
  }

  /* "validator.pyx":3880
 *         raise TypeError("%s is not an estimator instance." % (estimator))
 * 
 *     if attributes is not None:             # <<<<<<<<<<<<<<
 *         if not isinstance(attributes, (list, tuple)):
 *             attributes = [attributes]
 */
  __pyx_t_4 = (__pyx_v_attributes != Py_None);
  __pyx_t_5 = (__pyx_t_4 != 0);
  if (__pyx_t_5) {

    /* "validator.pyx":3881
 * 
 *     if attributes is not None:
 *         if not isinstance(attributes, (list, tuple)):             # <<<<<<<<<<<<<<
 *             attributes = [attributes]
 *         fitted = all_or_any([hasattr(estimator, attr) for attr in attributes])
 */
    __pyx_t_4 = PyList_Check(__pyx_v_attributes); 
    __pyx_t_6 = (__pyx_t_4 != 0);
    if (!__pyx_t_6) {
    } else {
      __pyx_t_5 = __pyx_t_6;
      goto __pyx_L8_bool_binop_done;
    }
    __pyx_t_6 = PyTuple_Check(__pyx_v_attributes); 
    __pyx_t_4 = (__pyx_t_6 != 0);
    __pyx_t_5 = __pyx_t_4;
    __pyx_L8_bool_binop_done:;
    __pyx_t_4 = ((!(__pyx_t_5 != 0)) != 0);
    if (__pyx_t_4) {

      /* "validator.pyx":3882
 *     if attributes is not None:
 *         if not isinstance(attributes, (list, tuple)):
 *             attributes = [attributes]             # <<<<<<<<<<<<<<
 *         fitted = all_or_any([hasattr(estimator, attr) for attr in attributes])
 *     elif hasattr(estimator, "__sklearn_is_fitted__"):
 */
      __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3882, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_INCREF(__pyx_v_attributes);
      __Pyx_GIVEREF(__pyx_v_attributes);
      PyList_SET_ITEM(__pyx_t_2, 0, __pyx_v_attributes);
      __Pyx_DECREF_SET(__pyx_v_attributes, __pyx_t_2);
      __pyx_t_2 = 0;

      /* "validator.pyx":3881
 * 
 *     if attributes is not None:
 *         if not isinstance(attributes, (list, tuple)):             # <<<<<<<<<<<<<<
 *             attributes = [attributes]
 *         fitted = all_or_any([hasattr(estimator, attr) for attr in attributes])
 */
    }

    /* "validator.pyx":3883
 *         if not isinstance(attributes, (list, tuple)):
 *             attributes = [attributes]
 *         fitted = all_or_any([hasattr(estimator, attr) for attr in attributes])             # <<<<<<<<<<<<<<
 *     elif hasattr(estimator, "__sklearn_is_fitted__"):
 *         fitted = estimator.__sklearn_is_fitted__()
 */
    { /* enter inner scope */
      __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3883, __pyx_L12_error)
      __Pyx_GOTREF(__pyx_t_1);
      if (likely(PyList_CheckExact(__pyx_v_attributes)) || PyTuple_CheckExact(__pyx_v_attributes)) {
        __pyx_t_3 = __pyx_v_attributes; __Pyx_INCREF(__pyx_t_3); __pyx_t_7 = 0;
        __pyx_t_8 = NULL;
      } else {
        __pyx_t_7 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_v_attributes); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3883, __pyx_L12_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_8 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3883, __pyx_L12_error)
      }
      for (;;) {
        if (likely(!__pyx_t_8)) {
          if (likely(PyList_CheckExact(__pyx_t_3))) {
            if (__pyx_t_7 >= PyList_GET_SIZE(__pyx_t_3)) break;
            #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
            __pyx_t_9 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 3883, __pyx_L12_error)
            #else
            __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 3883, __pyx_L12_error)
            __Pyx_GOTREF(__pyx_t_9);
            #endif
          } else {
            if (__pyx_t_7 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
            #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
            __pyx_t_9 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_9); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 3883, __pyx_L12_error)
            #else
            __pyx_t_9 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 3883, __pyx_L12_error)
            __Pyx_GOTREF(__pyx_t_9);
            #endif
          }
        } else {
          __pyx_t_9 = __pyx_t_8(__pyx_t_3);
          if (unlikely(!__pyx_t_9)) {
            PyObject* exc_type = PyErr_Occurred();
            if (exc_type) {
              if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
              else __PYX_ERR(0, 3883, __pyx_L12_error)
            }
            break;
          }
          __Pyx_GOTREF(__pyx_t_9);
        }
        __Pyx_XDECREF_SET(__pyx_9genexpr24__pyx_v_attr, __pyx_t_9);
        __pyx_t_9 = 0;
        __pyx_t_4 = __Pyx_HasAttr(__pyx_v_estimator, __pyx_9genexpr24__pyx_v_attr); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 3883, __pyx_L12_error)
        __pyx_t_9 = __Pyx_PyBool_FromLong(__pyx_t_4); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 3883, __pyx_L12_error)
        __Pyx_GOTREF(__pyx_t_9);
        if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_9))) __PYX_ERR(0, 3883, __pyx_L12_error)
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      }
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_9genexpr24__pyx_v_attr); __pyx_9genexpr24__pyx_v_attr = 0;
      goto __pyx_L15_exit_scope;
      __pyx_L12_error:;
      __Pyx_XDECREF(__pyx_9genexpr24__pyx_v_attr); __pyx_9genexpr24__pyx_v_attr = 0;
      goto __pyx_L1_error;
      __pyx_L15_exit_scope:;
    } /* exit inner scope */
    __Pyx_INCREF(__pyx_v_all_or_any);
    __pyx_t_3 = __pyx_v_all_or_any; __pyx_t_9 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_9)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_9);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    __pyx_t_2 = (__pyx_t_9) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_9, __pyx_t_1) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_1);
    __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3883, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_v_fitted = __pyx_t_2;
    __pyx_t_2 = 0;

    /* "validator.pyx":3880
 *         raise TypeError("%s is not an estimator instance." % (estimator))
 * 
 *     if attributes is not None:             # <<<<<<<<<<<<<<
 *         if not isinstance(attributes, (list, tuple)):
 *             attributes = [attributes]
 */
    goto __pyx_L6;
  }

  /* "validator.pyx":3884
 *             attributes = [attributes]
 *         fitted = all_or_any([hasattr(estimator, attr) for attr in attributes])
 *     elif hasattr(estimator, "__sklearn_is_fitted__"):             # <<<<<<<<<<<<<<
 *         fitted = estimator.__sklearn_is_fitted__()
 *     else:
 */
  __pyx_t_4 = __Pyx_HasAttr(__pyx_v_estimator, __pyx_n_u_sklearn_is_fitted); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 3884, __pyx_L1_error)
  __pyx_t_5 = (__pyx_t_4 != 0);
  if (__pyx_t_5) {

    /* "validator.pyx":3885
 *         fitted = all_or_any([hasattr(estimator, attr) for attr in attributes])
 *     elif hasattr(estimator, "__sklearn_is_fitted__"):
 *         fitted = estimator.__sklearn_is_fitted__()             # <<<<<<<<<<<<<<
 *     else:
 *         fitted = [
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_estimator, __pyx_n_s_sklearn_is_fitted); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3885, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_1 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_1)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    __pyx_t_2 = (__pyx_t_1) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_1) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3885, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_v_fitted = __pyx_t_2;
    __pyx_t_2 = 0;

    /* "validator.pyx":3884
 *             attributes = [attributes]
 *         fitted = all_or_any([hasattr(estimator, attr) for attr in attributes])
 *     elif hasattr(estimator, "__sklearn_is_fitted__"):             # <<<<<<<<<<<<<<
 *         fitted = estimator.__sklearn_is_fitted__()
 *     else:
 */
    goto __pyx_L6;
  }

  /* "validator.pyx":3887
 *         fitted = estimator.__sklearn_is_fitted__()
 *     else:
 *         fitted = [             # <<<<<<<<<<<<<<
 *             v for v in vars(estimator) if v.endswith("_") and not v.startswith("__")
 *         ]
 */
  /*else*/ {
    { /* enter inner scope */
      __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3887, __pyx_L18_error)
      __Pyx_GOTREF(__pyx_t_2);

      /* "validator.pyx":3888
 *     else:
 *         fitted = [
 *             v for v in vars(estimator) if v.endswith("_") and not v.startswith("__")             # <<<<<<<<<<<<<<
 *         ]
 * 
 */
      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_vars, __pyx_v_estimator); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3888, __pyx_L18_error)
      __Pyx_GOTREF(__pyx_t_3);
      if (likely(PyList_CheckExact(__pyx_t_3)) || PyTuple_CheckExact(__pyx_t_3)) {
        __pyx_t_1 = __pyx_t_3; __Pyx_INCREF(__pyx_t_1); __pyx_t_7 = 0;
        __pyx_t_8 = NULL;
      } else {
        __pyx_t_7 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3888, __pyx_L18_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_8 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 3888, __pyx_L18_error)
      }
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      for (;;) {
        if (likely(!__pyx_t_8)) {
          if (likely(PyList_CheckExact(__pyx_t_1))) {
            if (__pyx_t_7 >= PyList_GET_SIZE(__pyx_t_1)) break;
            #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
            __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_7); __Pyx_INCREF(__pyx_t_3); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 3888, __pyx_L18_error)
            #else
            __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3888, __pyx_L18_error)
            __Pyx_GOTREF(__pyx_t_3);
            #endif
          } else {
            if (__pyx_t_7 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
            #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
            __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_7); __Pyx_INCREF(__pyx_t_3); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 3888, __pyx_L18_error)
            #else
            __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3888, __pyx_L18_error)
            __Pyx_GOTREF(__pyx_t_3);
            #endif
          }
        } else {
          __pyx_t_3 = __pyx_t_8(__pyx_t_1);
          if (unlikely(!__pyx_t_3)) {
            PyObject* exc_type = PyErr_Occurred();
            if (exc_type) {
              if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
              else __PYX_ERR(0, 3888, __pyx_L18_error)
            }
            break;
          }
          __Pyx_GOTREF(__pyx_t_3);
        }
        __Pyx_XDECREF_SET(__pyx_9genexpr25__pyx_v_v, __pyx_t_3);
        __pyx_t_3 = 0;
        __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_9genexpr25__pyx_v_v, __pyx_n_s_endswith); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 3888, __pyx_L18_error)
        __Pyx_GOTREF(__pyx_t_9);
        __pyx_t_10 = NULL;
        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_9))) {
          __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_9);
          if (likely(__pyx_t_10)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
            __Pyx_INCREF(__pyx_t_10);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_9, function);
          }
        }
        __pyx_t_3 = (__pyx_t_10) ? __Pyx_PyObject_Call2Args(__pyx_t_9, __pyx_t_10, __pyx_n_u__102) : __Pyx_PyObject_CallOneArg(__pyx_t_9, __pyx_n_u__102);
        __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
        if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3888, __pyx_L18_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 3888, __pyx_L18_error)
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        if (__pyx_t_4) {
        } else {
          __pyx_t_5 = __pyx_t_4;
          goto __pyx_L22_bool_binop_done;
        }
        __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_9genexpr25__pyx_v_v, __pyx_n_s_startswith); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 3888, __pyx_L18_error)
        __Pyx_GOTREF(__pyx_t_9);
        __pyx_t_10 = NULL;
        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_9))) {
          __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_9);
          if (likely(__pyx_t_10)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
            __Pyx_INCREF(__pyx_t_10);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_9, function);
          }
        }
        __pyx_t_3 = (__pyx_t_10) ? __Pyx_PyObject_Call2Args(__pyx_t_9, __pyx_t_10, __pyx_n_u__103) : __Pyx_PyObject_CallOneArg(__pyx_t_9, __pyx_n_u__103);
        __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
        if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3888, __pyx_L18_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 3888, __pyx_L18_error)
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_6 = ((!__pyx_t_4) != 0);
        __pyx_t_5 = __pyx_t_6;
        __pyx_L22_bool_binop_done:;
        if (__pyx_t_5) {
          if (unlikely(__Pyx_ListComp_Append(__pyx_t_2, (PyObject*)__pyx_9genexpr25__pyx_v_v))) __PYX_ERR(0, 3887, __pyx_L18_error)
        }
      }
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_9genexpr25__pyx_v_v); __pyx_9genexpr25__pyx_v_v = 0;
      goto __pyx_L24_exit_scope;
      __pyx_L18_error:;
      __Pyx_XDECREF(__pyx_9genexpr25__pyx_v_v); __pyx_9genexpr25__pyx_v_v = 0;
      goto __pyx_L1_error;
      __pyx_L24_exit_scope:;
    } /* exit inner scope */
    __pyx_v_fitted = __pyx_t_2;
    __pyx_t_2 = 0;
  }
  __pyx_L6:;

  /* "validator.pyx":3891
 *         ]
 * 
 *     if not fitted:             # <<<<<<<<<<<<<<
 *         raise NotFittedError(msg % {"name": type(estimator).__name__})
 * 
 */
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_v_fitted); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 3891, __pyx_L1_error)
  __pyx_t_6 = ((!__pyx_t_5) != 0);
  if (unlikely(__pyx_t_6)) {

    /* "validator.pyx":3892
 * 
 *     if not fitted:
 *         raise NotFittedError(msg % {"name": type(estimator).__name__})             # <<<<<<<<<<<<<<
 * 
 * def _check_feature_names_in(estimator, input_features=None, *, generate_names=True):
 */
    __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3892, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_estimator)), __pyx_n_s_name); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3892, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    if (PyDict_SetItem(__pyx_t_1, __pyx_n_u_name_2, __pyx_t_3) < 0) __PYX_ERR(0, 3892, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = PyNumber_Remainder(__pyx_v_msg, __pyx_t_1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3892, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_INCREF(__pyx_v_NotFittedError);
    __pyx_t_1 = __pyx_v_NotFittedError; __pyx_t_9 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_9)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_9);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    __pyx_t_2 = (__pyx_t_9) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_9, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_3);
    __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3892, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 3892, __pyx_L1_error)

    /* "validator.pyx":3891
 *         ]
 * 
 *     if not fitted:             # <<<<<<<<<<<<<<
 *         raise NotFittedError(msg % {"name": type(estimator).__name__})
 * 
 */
  }

  /* "validator.pyx":3823
 *         return feature_names
 * 
 * def check_is_fitted(estimator, attributes=None, *, msg=None, all_or_any=all):             # <<<<<<<<<<<<<<
 *     """Perform is_fitted validation for estimator.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_AddTraceback("validator.check_is_fitted", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_NotFittedError);
  __Pyx_XDECREF(__pyx_v_fitted);
  __Pyx_XDECREF(__pyx_9genexpr24__pyx_v_attr);
  __Pyx_XDECREF(__pyx_9genexpr25__pyx_v_v);
  __Pyx_XDECREF(__pyx_v_attributes);
  __Pyx_XDECREF(__pyx_v_msg);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3894
 *         raise NotFittedError(msg % {"name": type(estimator).__name__})
 * 
 * def _check_feature_names_in(estimator, input_features=None, *, generate_names=True):             # <<<<<<<<<<<<<<
 *     """Check `input_features` and generate names if needed.
 *     Commonly used in :term:`get_feature_names_out`.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_133_check_feature_names_in(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_132_check_feature_names_in[] = "Check `input_features` and generate names if needed.\n    Commonly used in :term:`get_feature_names_out`.\n    Parameters\n    ----------\n    input_features : array-like of str or None, default=None\n        Input features.\n        - If `input_features` is `None`, then `feature_names_in_` is\n          used as feature names in. If `feature_names_in_` is not defined,\n          then the following input feature names are generated:\n          `[\"x0\", \"x1\", ..., \"x(n_features_in_ - 1)\"]`.\n        - If `input_features` is an array-like, then `input_features` must\n          match `feature_names_in_` if `feature_names_in_` is defined.\n    generate_names : bool, default=True\n        Whether to generate names when `input_features` is `None` and\n        `estimator.feature_names_in_` is not defined. This is useful for transformers\n        that validates `input_features` but do not require them in\n        :term:`get_feature_names_out` e.g. `PCA`.\n    Returns\n    -------\n    feature_names_in : ndarray of str or `None`\n        Feature names in.\n    ";
static PyMethodDef __pyx_mdef_9validator_133_check_feature_names_in = {"_check_feature_names_in", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_133_check_feature_names_in, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_132_check_feature_names_in};
static PyObject *__pyx_pw_9validator_133_check_feature_names_in(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_estimator = 0;
  PyObject *__pyx_v_input_features = 0;
  PyObject *__pyx_v_generate_names = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_check_feature_names_in (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_estimator,&__pyx_n_s_input_features,&__pyx_n_s_generate_names,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_None);
    values[2] = ((PyObject *)Py_True);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_estimator)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_input_features);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (kw_args == 1) {
        const Py_ssize_t index = 2;
        PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
        if (value) { values[index] = value; kw_args--; }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_check_feature_names_in") < 0)) __PYX_ERR(0, 3894, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_estimator = values[0];
    __pyx_v_input_features = values[1];
    __pyx_v_generate_names = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_check_feature_names_in", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 3894, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator._check_feature_names_in", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_132_check_feature_names_in(__pyx_self, __pyx_v_estimator, __pyx_v_input_features, __pyx_v_generate_names);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_132_check_feature_names_in(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_estimator, PyObject *__pyx_v_input_features, PyObject *__pyx_v_generate_names) {
  PyObject *__pyx_v_feature_names_in_ = NULL;
  PyObject *__pyx_v_n_features_in_ = NULL;
  PyObject *__pyx_9genexpr26__pyx_v_i = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  int __pyx_t_8;
  Py_ssize_t __pyx_t_9;
  Py_UCS4 __pyx_t_10;
  Py_ssize_t __pyx_t_11;
  PyObject *(*__pyx_t_12)(PyObject *);
  PyObject *__pyx_t_13 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_check_feature_names_in", 0);
  __Pyx_INCREF(__pyx_v_input_features);

  /* "validator.pyx":3918
 *     """
 * 
 *     feature_names_in_ = getattr(estimator, "feature_names_in_", None)             # <<<<<<<<<<<<<<
 *     n_features_in_ = getattr(estimator, "n_features_in_", None)
 * 
 */
  __pyx_t_1 = __Pyx_GetAttr3(__pyx_v_estimator, __pyx_n_u_feature_names_in, Py_None); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3918, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_feature_names_in_ = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":3919
 * 
 *     feature_names_in_ = getattr(estimator, "feature_names_in_", None)
 *     n_features_in_ = getattr(estimator, "n_features_in_", None)             # <<<<<<<<<<<<<<
 * 
 *     if input_features is not None:
 */
  __pyx_t_1 = __Pyx_GetAttr3(__pyx_v_estimator, __pyx_n_u_n_features_in, Py_None); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3919, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_n_features_in_ = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":3921
 *     n_features_in_ = getattr(estimator, "n_features_in_", None)
 * 
 *     if input_features is not None:             # <<<<<<<<<<<<<<
 *         input_features = np.asarray(input_features, dtype=object)
 *         if feature_names_in_ is not None and not np.array_equal(
 */
  __pyx_t_2 = (__pyx_v_input_features != Py_None);
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (__pyx_t_3) {

    /* "validator.pyx":3922
 * 
 *     if input_features is not None:
 *         input_features = np.asarray(input_features, dtype=object)             # <<<<<<<<<<<<<<
 *         if feature_names_in_ is not None and not np.array_equal(
 *             feature_names_in_, input_features
 */
    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3922, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_asarray); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3922, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3922, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_INCREF(__pyx_v_input_features);
    __Pyx_GIVEREF(__pyx_v_input_features);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_input_features);
    __pyx_t_5 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3922, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_dtype, __pyx_builtin_object) < 0) __PYX_ERR(0, 3922, __pyx_L1_error)
    __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_1, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3922, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF_SET(__pyx_v_input_features, __pyx_t_6);
    __pyx_t_6 = 0;

    /* "validator.pyx":3923
 *     if input_features is not None:
 *         input_features = np.asarray(input_features, dtype=object)
 *         if feature_names_in_ is not None and not np.array_equal(             # <<<<<<<<<<<<<<
 *             feature_names_in_, input_features
 *         ):
 */
    __pyx_t_2 = (__pyx_v_feature_names_in_ != Py_None);
    __pyx_t_7 = (__pyx_t_2 != 0);
    if (__pyx_t_7) {
    } else {
      __pyx_t_3 = __pyx_t_7;
      goto __pyx_L5_bool_binop_done;
    }
    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3923, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_array_equal); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3923, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

    /* "validator.pyx":3924
 *         input_features = np.asarray(input_features, dtype=object)
 *         if feature_names_in_ is not None and not np.array_equal(
 *             feature_names_in_, input_features             # <<<<<<<<<<<<<<
 *         ):
 *             raise ValueError("input_features is not equal to feature_names_in_")
 */
    __pyx_t_5 = NULL;
    __pyx_t_8 = 0;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
        __pyx_t_8 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_1)) {
      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_feature_names_in_, __pyx_v_input_features};
      __pyx_t_6 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3923, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_6);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
      PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_feature_names_in_, __pyx_v_input_features};
      __pyx_t_6 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3923, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GOTREF(__pyx_t_6);
    } else
    #endif
    {
      __pyx_t_4 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3923, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      if (__pyx_t_5) {
        __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_5); __pyx_t_5 = NULL;
      }
      __Pyx_INCREF(__pyx_v_feature_names_in_);
      __Pyx_GIVEREF(__pyx_v_feature_names_in_);
      PyTuple_SET_ITEM(__pyx_t_4, 0+__pyx_t_8, __pyx_v_feature_names_in_);
      __Pyx_INCREF(__pyx_v_input_features);
      __Pyx_GIVEREF(__pyx_v_input_features);
      PyTuple_SET_ITEM(__pyx_t_4, 1+__pyx_t_8, __pyx_v_input_features);
      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_4, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3923, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "validator.pyx":3923
 *     if input_features is not None:
 *         input_features = np.asarray(input_features, dtype=object)
 *         if feature_names_in_ is not None and not np.array_equal(             # <<<<<<<<<<<<<<
 *             feature_names_in_, input_features
 *         ):
 */
    __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 3923, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_2 = ((!__pyx_t_7) != 0);
    __pyx_t_3 = __pyx_t_2;
    __pyx_L5_bool_binop_done:;
    if (unlikely(__pyx_t_3)) {

      /* "validator.pyx":3926
 *             feature_names_in_, input_features
 *         ):
 *             raise ValueError("input_features is not equal to feature_names_in_")             # <<<<<<<<<<<<<<
 * 
 *         if n_features_in_ is not None and len(input_features) != n_features_in_:
 */
      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__104, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3926, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_Raise(__pyx_t_6, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __PYX_ERR(0, 3926, __pyx_L1_error)

      /* "validator.pyx":3923
 *     if input_features is not None:
 *         input_features = np.asarray(input_features, dtype=object)
 *         if feature_names_in_ is not None and not np.array_equal(             # <<<<<<<<<<<<<<
 *             feature_names_in_, input_features
 *         ):
 */
    }

    /* "validator.pyx":3928
 *             raise ValueError("input_features is not equal to feature_names_in_")
 * 
 *         if n_features_in_ is not None and len(input_features) != n_features_in_:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 "input_features should have length equal to number of "
 */
    __pyx_t_2 = (__pyx_v_n_features_in_ != Py_None);
    __pyx_t_7 = (__pyx_t_2 != 0);
    if (__pyx_t_7) {
    } else {
      __pyx_t_3 = __pyx_t_7;
      goto __pyx_L8_bool_binop_done;
    }
    __pyx_t_9 = PyObject_Length(__pyx_v_input_features); if (unlikely(__pyx_t_9 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3928, __pyx_L1_error)
    __pyx_t_6 = PyInt_FromSsize_t(__pyx_t_9); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3928, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_1 = PyObject_RichCompare(__pyx_t_6, __pyx_v_n_features_in_, Py_NE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3928, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 3928, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_3 = __pyx_t_7;
    __pyx_L8_bool_binop_done:;
    if (unlikely(__pyx_t_3)) {

      /* "validator.pyx":3930
 *         if n_features_in_ is not None and len(input_features) != n_features_in_:
 *             raise ValueError(
 *                 "input_features should have length equal to number of "             # <<<<<<<<<<<<<<
 *                 f"features ({n_features_in_}), got {len(input_features)}"
 *             )
 */
      __pyx_t_1 = PyTuple_New(4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3930, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_9 = 0;
      __pyx_t_10 = 127;
      __Pyx_INCREF(__pyx_kp_u_input_features_should_have_lengt);
      __pyx_t_9 += 63;
      __Pyx_GIVEREF(__pyx_kp_u_input_features_should_have_lengt);
      PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_input_features_should_have_lengt);

      /* "validator.pyx":3931
 *             raise ValueError(
 *                 "input_features should have length equal to number of "
 *                 f"features ({n_features_in_}), got {len(input_features)}"             # <<<<<<<<<<<<<<
 *             )
 *         return input_features
 */
      __pyx_t_6 = __Pyx_PyObject_FormatSimple(__pyx_v_n_features_in_, __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3931, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_10 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) > __pyx_t_10) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) : __pyx_t_10;
      __pyx_t_9 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
      __Pyx_GIVEREF(__pyx_t_6);
      PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_6);
      __pyx_t_6 = 0;
      __Pyx_INCREF(__pyx_kp_u_got_2);
      __pyx_t_9 += 7;
      __Pyx_GIVEREF(__pyx_kp_u_got_2);
      PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_got_2);
      __pyx_t_11 = PyObject_Length(__pyx_v_input_features); if (unlikely(__pyx_t_11 == ((Py_ssize_t)-1))) __PYX_ERR(0, 3931, __pyx_L1_error)
      __pyx_t_6 = __Pyx_PyUnicode_From_Py_ssize_t(__pyx_t_11, 0, ' ', 'd'); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3931, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_9 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
      __Pyx_GIVEREF(__pyx_t_6);
      PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_t_6);
      __pyx_t_6 = 0;

      /* "validator.pyx":3930
 *         if n_features_in_ is not None and len(input_features) != n_features_in_:
 *             raise ValueError(
 *                 "input_features should have length equal to number of "             # <<<<<<<<<<<<<<
 *                 f"features ({n_features_in_}), got {len(input_features)}"
 *             )
 */
      __pyx_t_6 = __Pyx_PyUnicode_Join(__pyx_t_1, 4, __pyx_t_9, __pyx_t_10); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3930, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "validator.pyx":3929
 * 
 *         if n_features_in_ is not None and len(input_features) != n_features_in_:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "input_features should have length equal to number of "
 *                 f"features ({n_features_in_}), got {len(input_features)}"
 */
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3929, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 3929, __pyx_L1_error)

      /* "validator.pyx":3928
 *             raise ValueError("input_features is not equal to feature_names_in_")
 * 
 *         if n_features_in_ is not None and len(input_features) != n_features_in_:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 "input_features should have length equal to number of "
 */
    }

    /* "validator.pyx":3933
 *                 f"features ({n_features_in_}), got {len(input_features)}"
 *             )
 *         return input_features             # <<<<<<<<<<<<<<
 * 
 *     if feature_names_in_ is not None:
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_v_input_features);
    __pyx_r = __pyx_v_input_features;
    goto __pyx_L0;

    /* "validator.pyx":3921
 *     n_features_in_ = getattr(estimator, "n_features_in_", None)
 * 
 *     if input_features is not None:             # <<<<<<<<<<<<<<
 *         input_features = np.asarray(input_features, dtype=object)
 *         if feature_names_in_ is not None and not np.array_equal(
 */
  }

  /* "validator.pyx":3935
 *         return input_features
 * 
 *     if feature_names_in_ is not None:             # <<<<<<<<<<<<<<
 *         return feature_names_in_
 * 
 */
  __pyx_t_3 = (__pyx_v_feature_names_in_ != Py_None);
  __pyx_t_7 = (__pyx_t_3 != 0);
  if (__pyx_t_7) {

    /* "validator.pyx":3936
 * 
 *     if feature_names_in_ is not None:
 *         return feature_names_in_             # <<<<<<<<<<<<<<
 * 
 *     if not generate_names:
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_v_feature_names_in_);
    __pyx_r = __pyx_v_feature_names_in_;
    goto __pyx_L0;

    /* "validator.pyx":3935
 *         return input_features
 * 
 *     if feature_names_in_ is not None:             # <<<<<<<<<<<<<<
 *         return feature_names_in_
 * 
 */
  }

  /* "validator.pyx":3938
 *         return feature_names_in_
 * 
 *     if not generate_names:             # <<<<<<<<<<<<<<
 *         return
 * 
 */
  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_generate_names); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 3938, __pyx_L1_error)
  __pyx_t_3 = ((!__pyx_t_7) != 0);
  if (__pyx_t_3) {

    /* "validator.pyx":3939
 * 
 *     if not generate_names:
 *         return             # <<<<<<<<<<<<<<
 * 
 *     # Generates feature names if `n_features_in_` is defined
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_r = Py_None; __Pyx_INCREF(Py_None);
    goto __pyx_L0;

    /* "validator.pyx":3938
 *         return feature_names_in_
 * 
 *     if not generate_names:             # <<<<<<<<<<<<<<
 *         return
 * 
 */
  }

  /* "validator.pyx":3942
 * 
 *     # Generates feature names if `n_features_in_` is defined
 *     if n_features_in_ is None:             # <<<<<<<<<<<<<<
 *         raise ValueError("Unable to generate feature names without n_features_in_")
 * 
 */
  __pyx_t_3 = (__pyx_v_n_features_in_ == Py_None);
  __pyx_t_7 = (__pyx_t_3 != 0);
  if (unlikely(__pyx_t_7)) {

    /* "validator.pyx":3943
 *     # Generates feature names if `n_features_in_` is defined
 *     if n_features_in_ is None:
 *         raise ValueError("Unable to generate feature names without n_features_in_")             # <<<<<<<<<<<<<<
 * 
 *     return np.asarray([f"x{i}" for i in range(n_features_in_)], dtype=object)
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__105, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3943, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 3943, __pyx_L1_error)

    /* "validator.pyx":3942
 * 
 *     # Generates feature names if `n_features_in_` is defined
 *     if n_features_in_ is None:             # <<<<<<<<<<<<<<
 *         raise ValueError("Unable to generate feature names without n_features_in_")
 * 
 */
  }

  /* "validator.pyx":3945
 *         raise ValueError("Unable to generate feature names without n_features_in_")
 * 
 *     return np.asarray([f"x{i}" for i in range(n_features_in_)], dtype=object)             # <<<<<<<<<<<<<<
 * 
 * def _pandas_dtype_needs_early_conversion(pd_dtype):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3945, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_asarray); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 3945, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  { /* enter inner scope */
    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3945, __pyx_L15_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_range, __pyx_v_n_features_in_); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3945, __pyx_L15_error)
    __Pyx_GOTREF(__pyx_t_4);
    if (likely(PyList_CheckExact(__pyx_t_4)) || PyTuple_CheckExact(__pyx_t_4)) {
      __pyx_t_5 = __pyx_t_4; __Pyx_INCREF(__pyx_t_5); __pyx_t_9 = 0;
      __pyx_t_12 = NULL;
    } else {
      __pyx_t_9 = -1; __pyx_t_5 = PyObject_GetIter(__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3945, __pyx_L15_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_12 = Py_TYPE(__pyx_t_5)->tp_iternext; if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 3945, __pyx_L15_error)
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    for (;;) {
      if (likely(!__pyx_t_12)) {
        if (likely(PyList_CheckExact(__pyx_t_5))) {
          if (__pyx_t_9 >= PyList_GET_SIZE(__pyx_t_5)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_4 = PyList_GET_ITEM(__pyx_t_5, __pyx_t_9); __Pyx_INCREF(__pyx_t_4); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 3945, __pyx_L15_error)
          #else
          __pyx_t_4 = PySequence_ITEM(__pyx_t_5, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3945, __pyx_L15_error)
          __Pyx_GOTREF(__pyx_t_4);
          #endif
        } else {
          if (__pyx_t_9 >= PyTuple_GET_SIZE(__pyx_t_5)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_5, __pyx_t_9); __Pyx_INCREF(__pyx_t_4); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 3945, __pyx_L15_error)
          #else
          __pyx_t_4 = PySequence_ITEM(__pyx_t_5, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3945, __pyx_L15_error)
          __Pyx_GOTREF(__pyx_t_4);
          #endif
        }
      } else {
        __pyx_t_4 = __pyx_t_12(__pyx_t_5);
        if (unlikely(!__pyx_t_4)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else __PYX_ERR(0, 3945, __pyx_L15_error)
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_4);
      }
      __Pyx_XDECREF_SET(__pyx_9genexpr26__pyx_v_i, __pyx_t_4);
      __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_9genexpr26__pyx_v_i, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3945, __pyx_L15_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_13 = __Pyx_PyUnicode_Concat(__pyx_n_u_x, __pyx_t_4); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 3945, __pyx_L15_error)
      __Pyx_GOTREF(__pyx_t_13);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_13))) __PYX_ERR(0, 3945, __pyx_L15_error)
      __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
    }
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_XDECREF(__pyx_9genexpr26__pyx_v_i); __pyx_9genexpr26__pyx_v_i = 0;
    goto __pyx_L18_exit_scope;
    __pyx_L15_error:;
    __Pyx_XDECREF(__pyx_9genexpr26__pyx_v_i); __pyx_9genexpr26__pyx_v_i = 0;
    goto __pyx_L1_error;
    __pyx_L18_exit_scope:;
  } /* exit inner scope */
  __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3945, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3945, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_dtype, __pyx_builtin_object) < 0) __PYX_ERR(0, 3945, __pyx_L1_error)
  __pyx_t_13 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_5, __pyx_t_1); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 3945, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_13);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_13;
  __pyx_t_13 = 0;
  goto __pyx_L0;

  /* "validator.pyx":3894
 *         raise NotFittedError(msg % {"name": type(estimator).__name__})
 * 
 * def _check_feature_names_in(estimator, input_features=None, *, generate_names=True):             # <<<<<<<<<<<<<<
 *     """Check `input_features` and generate names if needed.
 *     Commonly used in :term:`get_feature_names_out`.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_13);
  __Pyx_AddTraceback("validator._check_feature_names_in", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_feature_names_in_);
  __Pyx_XDECREF(__pyx_v_n_features_in_);
  __Pyx_XDECREF(__pyx_9genexpr26__pyx_v_i);
  __Pyx_XDECREF(__pyx_v_input_features);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3947
 *     return np.asarray([f"x{i}" for i in range(n_features_in_)], dtype=object)
 * 
 * def _pandas_dtype_needs_early_conversion(pd_dtype):             # <<<<<<<<<<<<<<
 *     """Return True if pandas extension pd_dtype need to be converted early."""
 *     # Check these early for pandas versions without extension dtypes
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_135_pandas_dtype_needs_early_conversion(PyObject *__pyx_self, PyObject *__pyx_v_pd_dtype); /*proto*/
static char __pyx_doc_9validator_134_pandas_dtype_needs_early_conversion[] = "Return True if pandas extension pd_dtype need to be converted early.";
static PyMethodDef __pyx_mdef_9validator_135_pandas_dtype_needs_early_conversion = {"_pandas_dtype_needs_early_conversion", (PyCFunction)__pyx_pw_9validator_135_pandas_dtype_needs_early_conversion, METH_O, __pyx_doc_9validator_134_pandas_dtype_needs_early_conversion};
static PyObject *__pyx_pw_9validator_135_pandas_dtype_needs_early_conversion(PyObject *__pyx_self, PyObject *__pyx_v_pd_dtype) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_pandas_dtype_needs_early_conversion (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_134_pandas_dtype_needs_early_conversion(__pyx_self, ((PyObject *)__pyx_v_pd_dtype));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_134_pandas_dtype_needs_early_conversion(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_pd_dtype) {
  PyObject *__pyx_v_is_bool_dtype = NULL;
  PyObject *__pyx_v_is_float_dtype = NULL;
  PyObject *__pyx_v_is_integer_dtype = NULL;
  PyObject *__pyx_v_is_extension_array_dtype = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_t_9;
  int __pyx_t_10;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_pandas_dtype_needs_early_conversion", 0);

  /* "validator.pyx":3951
 *     # Check these early for pandas versions without extension dtypes
 *     from pandas.api.types import (
 *         is_bool_dtype,             # <<<<<<<<<<<<<<
 *         # is_sparse,
 *         is_float_dtype,
 */
  __pyx_t_1 = PyList_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3951, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_is_bool_dtype);
  __Pyx_GIVEREF(__pyx_n_s_is_bool_dtype);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_is_bool_dtype);
  __Pyx_INCREF(__pyx_n_s_is_float_dtype);
  __Pyx_GIVEREF(__pyx_n_s_is_float_dtype);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_is_float_dtype);
  __Pyx_INCREF(__pyx_n_s_is_integer_dtype);
  __Pyx_GIVEREF(__pyx_n_s_is_integer_dtype);
  PyList_SET_ITEM(__pyx_t_1, 2, __pyx_n_s_is_integer_dtype);

  /* "validator.pyx":3950
 *     """Return True if pandas extension pd_dtype need to be converted early."""
 *     # Check these early for pandas versions without extension dtypes
 *     from pandas.api.types import (             # <<<<<<<<<<<<<<
 *         is_bool_dtype,
 *         # is_sparse,
 */
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_pandas_api_types, __pyx_t_1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3950, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_is_bool_dtype); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3950, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_t_1);
  __pyx_v_is_bool_dtype = __pyx_t_1;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_is_float_dtype); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3950, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_t_1);
  __pyx_v_is_float_dtype = __pyx_t_1;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_is_integer_dtype); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3950, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_t_1);
  __pyx_v_is_integer_dtype = __pyx_t_1;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":3957
 *     )
 * 
 *     if is_bool_dtype(pd_dtype):             # <<<<<<<<<<<<<<
 *         # bool and extension booleans need early converstion because __array__
 *         # converts mixed dtype dataframes into object dtypes
 */
  __Pyx_INCREF(__pyx_v_is_bool_dtype);
  __pyx_t_1 = __pyx_v_is_bool_dtype; __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_3, __pyx_v_pd_dtype) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_pd_dtype);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3957, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 3957, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (__pyx_t_4) {

    /* "validator.pyx":3960
 *         # bool and extension booleans need early converstion because __array__
 *         # converts mixed dtype dataframes into object dtypes
 *         return True             # <<<<<<<<<<<<<<
 * 
 *     if  isinstance(pd_dtype, pd.SparseDtype ):
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_True);
    __pyx_r = Py_True;
    goto __pyx_L0;

    /* "validator.pyx":3957
 *     )
 * 
 *     if is_bool_dtype(pd_dtype):             # <<<<<<<<<<<<<<
 *         # bool and extension booleans need early converstion because __array__
 *         # converts mixed dtype dataframes into object dtypes
 */
  }

  /* "validator.pyx":3962
 *         return True
 * 
 *     if  isinstance(pd_dtype, pd.SparseDtype ):             # <<<<<<<<<<<<<<
 *         # Sparse arrays will be converted later in `check_array`
 *         return False
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_pd); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3962, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_SparseDtype); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3962, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = PyObject_IsInstance(__pyx_v_pd_dtype, __pyx_t_1); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 3962, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = (__pyx_t_4 != 0);
  if (__pyx_t_5) {

    /* "validator.pyx":3964
 *     if  isinstance(pd_dtype, pd.SparseDtype ):
 *         # Sparse arrays will be converted later in `check_array`
 *         return False             # <<<<<<<<<<<<<<
 * 
 *     try:
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    goto __pyx_L0;

    /* "validator.pyx":3962
 *         return True
 * 
 *     if  isinstance(pd_dtype, pd.SparseDtype ):             # <<<<<<<<<<<<<<
 *         # Sparse arrays will be converted later in `check_array`
 *         return False
 */
  }

  /* "validator.pyx":3966
 *         return False
 * 
 *     try:             # <<<<<<<<<<<<<<
 *         from pandas.api.types import is_extension_array_dtype
 *     except ImportError:
 */
  {
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ExceptionSave(&__pyx_t_6, &__pyx_t_7, &__pyx_t_8);
    __Pyx_XGOTREF(__pyx_t_6);
    __Pyx_XGOTREF(__pyx_t_7);
    __Pyx_XGOTREF(__pyx_t_8);
    /*try:*/ {

      /* "validator.pyx":3967
 * 
 *     try:
 *         from pandas.api.types import is_extension_array_dtype             # <<<<<<<<<<<<<<
 *     except ImportError:
 *         return False
 */
      __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3967, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_INCREF(__pyx_n_s_is_extension_array_dtype);
      __Pyx_GIVEREF(__pyx_n_s_is_extension_array_dtype);
      PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_is_extension_array_dtype);
      __pyx_t_2 = __Pyx_Import(__pyx_n_s_pandas_api_types, __pyx_t_1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 3967, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_is_extension_array_dtype); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3967, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_1);
      __pyx_v_is_extension_array_dtype = __pyx_t_1;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

      /* "validator.pyx":3966
 *         return False
 * 
 *     try:             # <<<<<<<<<<<<<<
 *         from pandas.api.types import is_extension_array_dtype
 *     except ImportError:
 */
    }
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
    goto __pyx_L10_try_end;
    __pyx_L5_error:;
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "validator.pyx":3968
 *     try:
 *         from pandas.api.types import is_extension_array_dtype
 *     except ImportError:             # <<<<<<<<<<<<<<
 *         return False
 * 
 */
    __pyx_t_9 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_ImportError);
    if (__pyx_t_9) {
      __Pyx_AddTraceback("validator._pandas_dtype_needs_early_conversion", __pyx_clineno, __pyx_lineno, __pyx_filename);
      if (__Pyx_GetException(&__pyx_t_2, &__pyx_t_1, &__pyx_t_3) < 0) __PYX_ERR(0, 3968, __pyx_L7_except_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_GOTREF(__pyx_t_3);

      /* "validator.pyx":3969
 *         from pandas.api.types import is_extension_array_dtype
 *     except ImportError:
 *         return False             # <<<<<<<<<<<<<<
 * 
 *     # if is_sparse(pd_dtype) or not is_extension_array_dtype(pd_dtype): # deprecated
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_False);
      __pyx_r = Py_False;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      goto __pyx_L8_except_return;
    }
    goto __pyx_L7_except_error;
    __pyx_L7_except_error:;

    /* "validator.pyx":3966
 *         return False
 * 
 *     try:             # <<<<<<<<<<<<<<
 *         from pandas.api.types import is_extension_array_dtype
 *     except ImportError:
 */
    __Pyx_XGIVEREF(__pyx_t_6);
    __Pyx_XGIVEREF(__pyx_t_7);
    __Pyx_XGIVEREF(__pyx_t_8);
    __Pyx_ExceptionReset(__pyx_t_6, __pyx_t_7, __pyx_t_8);
    goto __pyx_L1_error;
    __pyx_L8_except_return:;
    __Pyx_XGIVEREF(__pyx_t_6);
    __Pyx_XGIVEREF(__pyx_t_7);
    __Pyx_XGIVEREF(__pyx_t_8);
    __Pyx_ExceptionReset(__pyx_t_6, __pyx_t_7, __pyx_t_8);
    goto __pyx_L0;
    __pyx_L10_try_end:;
  }

  /* "validator.pyx":3972
 * 
 *     # if is_sparse(pd_dtype) or not is_extension_array_dtype(pd_dtype): # deprecated
 *     if isinstance(pd_dtype, pd.SparseDtype ) or not is_extension_array_dtype(pd_dtype):             # <<<<<<<<<<<<<<
 *         # Sparse arrays will be converted later in `check_array`
 *         # Only handle extension arrays for integer and floats
 */
  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_pd); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 3972, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_SparseDtype); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3972, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_4 = PyObject_IsInstance(__pyx_v_pd_dtype, __pyx_t_1); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 3972, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_10 = (__pyx_t_4 != 0);
  if (!__pyx_t_10) {
  } else {
    __pyx_t_5 = __pyx_t_10;
    goto __pyx_L14_bool_binop_done;
  }
  __Pyx_INCREF(__pyx_v_is_extension_array_dtype);
  __pyx_t_3 = __pyx_v_is_extension_array_dtype; __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_v_pd_dtype) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_pd_dtype);
  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3972, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 3972, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_4 = ((!__pyx_t_10) != 0);
  __pyx_t_5 = __pyx_t_4;
  __pyx_L14_bool_binop_done:;
  if (__pyx_t_5) {

    /* "validator.pyx":3975
 *         # Sparse arrays will be converted later in `check_array`
 *         # Only handle extension arrays for integer and floats
 *         return False             # <<<<<<<<<<<<<<
 *     elif is_float_dtype(pd_dtype):
 *         # Float ndarrays can normally support nans. They need to be converted
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    goto __pyx_L0;

    /* "validator.pyx":3972
 * 
 *     # if is_sparse(pd_dtype) or not is_extension_array_dtype(pd_dtype): # deprecated
 *     if isinstance(pd_dtype, pd.SparseDtype ) or not is_extension_array_dtype(pd_dtype):             # <<<<<<<<<<<<<<
 *         # Sparse arrays will be converted later in `check_array`
 *         # Only handle extension arrays for integer and floats
 */
  }

  /* "validator.pyx":3976
 *         # Only handle extension arrays for integer and floats
 *         return False
 *     elif is_float_dtype(pd_dtype):             # <<<<<<<<<<<<<<
 *         # Float ndarrays can normally support nans. They need to be converted
 *         # first to map pd.NA to np.nan
 */
  __Pyx_INCREF(__pyx_v_is_float_dtype);
  __pyx_t_3 = __pyx_v_is_float_dtype; __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_v_pd_dtype) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_pd_dtype);
  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3976, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 3976, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_5) {

    /* "validator.pyx":3979
 *         # Float ndarrays can normally support nans. They need to be converted
 *         # first to map pd.NA to np.nan
 *         return True             # <<<<<<<<<<<<<<
 *     elif is_integer_dtype(pd_dtype):
 *         # XXX: Warn when converting from a high integer to a float
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_True);
    __pyx_r = Py_True;
    goto __pyx_L0;

    /* "validator.pyx":3976
 *         # Only handle extension arrays for integer and floats
 *         return False
 *     elif is_float_dtype(pd_dtype):             # <<<<<<<<<<<<<<
 *         # Float ndarrays can normally support nans. They need to be converted
 *         # first to map pd.NA to np.nan
 */
  }

  /* "validator.pyx":3980
 *         # first to map pd.NA to np.nan
 *         return True
 *     elif is_integer_dtype(pd_dtype):             # <<<<<<<<<<<<<<
 *         # XXX: Warn when converting from a high integer to a float
 *         return True
 */
  __Pyx_INCREF(__pyx_v_is_integer_dtype);
  __pyx_t_3 = __pyx_v_is_integer_dtype; __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_v_pd_dtype) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_pd_dtype);
  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3980, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 3980, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_5) {

    /* "validator.pyx":3982
 *     elif is_integer_dtype(pd_dtype):
 *         # XXX: Warn when converting from a high integer to a float
 *         return True             # <<<<<<<<<<<<<<
 * 
 *     return False
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_True);
    __pyx_r = Py_True;
    goto __pyx_L0;

    /* "validator.pyx":3980
 *         # first to map pd.NA to np.nan
 *         return True
 *     elif is_integer_dtype(pd_dtype):             # <<<<<<<<<<<<<<
 *         # XXX: Warn when converting from a high integer to a float
 *         return True
 */
  }

  /* "validator.pyx":3984
 *         return True
 * 
 *     return False             # <<<<<<<<<<<<<<
 * 
 * def _ensure_no_complex_data(array):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_False);
  __pyx_r = Py_False;
  goto __pyx_L0;

  /* "validator.pyx":3947
 *     return np.asarray([f"x{i}" for i in range(n_features_in_)], dtype=object)
 * 
 * def _pandas_dtype_needs_early_conversion(pd_dtype):             # <<<<<<<<<<<<<<
 *     """Return True if pandas extension pd_dtype need to be converted early."""
 *     # Check these early for pandas versions without extension dtypes
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("validator._pandas_dtype_needs_early_conversion", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_is_bool_dtype);
  __Pyx_XDECREF(__pyx_v_is_float_dtype);
  __Pyx_XDECREF(__pyx_v_is_integer_dtype);
  __Pyx_XDECREF(__pyx_v_is_extension_array_dtype);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3986
 *     return False
 * 
 * def _ensure_no_complex_data(array):             # <<<<<<<<<<<<<<
 *     if (
 *         hasattr(array, "dtype")
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_137_ensure_no_complex_data(PyObject *__pyx_self, PyObject *__pyx_v_array); /*proto*/
static PyMethodDef __pyx_mdef_9validator_137_ensure_no_complex_data = {"_ensure_no_complex_data", (PyCFunction)__pyx_pw_9validator_137_ensure_no_complex_data, METH_O, 0};
static PyObject *__pyx_pw_9validator_137_ensure_no_complex_data(PyObject *__pyx_self, PyObject *__pyx_v_array) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_ensure_no_complex_data (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_136_ensure_no_complex_data(__pyx_self, ((PyObject *)__pyx_v_array));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_136_ensure_no_complex_data(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_array) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_ensure_no_complex_data", 0);

  /* "validator.pyx":3988
 * def _ensure_no_complex_data(array):
 *     if (
 *         hasattr(array, "dtype")             # <<<<<<<<<<<<<<
 *         and array.dtype is not None
 *         and hasattr(array.dtype, "kind")
 */
  __pyx_t_2 = __Pyx_HasAttr(__pyx_v_array, __pyx_n_u_dtype); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 3988, __pyx_L1_error)
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (__pyx_t_3) {
  } else {
    __pyx_t_1 = __pyx_t_3;
    goto __pyx_L4_bool_binop_done;
  }

  /* "validator.pyx":3989
 *     if (
 *         hasattr(array, "dtype")
 *         and array.dtype is not None             # <<<<<<<<<<<<<<
 *         and hasattr(array.dtype, "kind")
 *         and array.dtype.kind == "c"
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_dtype); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3989, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = (__pyx_t_4 != Py_None);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_2 = (__pyx_t_3 != 0);
  if (__pyx_t_2) {
  } else {
    __pyx_t_1 = __pyx_t_2;
    goto __pyx_L4_bool_binop_done;
  }

  /* "validator.pyx":3990
 *         hasattr(array, "dtype")
 *         and array.dtype is not None
 *         and hasattr(array.dtype, "kind")             # <<<<<<<<<<<<<<
 *         and array.dtype.kind == "c"
 *     ):
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_dtype); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3990, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = __Pyx_HasAttr(__pyx_t_4, __pyx_n_u_kind); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 3990, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (__pyx_t_3) {
  } else {
    __pyx_t_1 = __pyx_t_3;
    goto __pyx_L4_bool_binop_done;
  }

  /* "validator.pyx":3991
 *         and array.dtype is not None
 *         and hasattr(array.dtype, "kind")
 *         and array.dtype.kind == "c"             # <<<<<<<<<<<<<<
 *     ):
 *         raise ValueError("Complex data not supported\n{}\n".format(array))
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_dtype); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3991, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_kind); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3991, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_3 = (__Pyx_PyUnicode_Equals(__pyx_t_5, __pyx_n_u_c, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 3991, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_1 = __pyx_t_3;
  __pyx_L4_bool_binop_done:;

  /* "validator.pyx":3987
 * 
 * def _ensure_no_complex_data(array):
 *     if (             # <<<<<<<<<<<<<<
 *         hasattr(array, "dtype")
 *         and array.dtype is not None
 */
  if (unlikely(__pyx_t_1)) {

    /* "validator.pyx":3993
 *         and array.dtype.kind == "c"
 *     ):
 *         raise ValueError("Complex data not supported\n{}\n".format(array))             # <<<<<<<<<<<<<<
 * 
 * 
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_kp_u_Complex_data_not_supported, __pyx_n_s_format); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3993, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_5 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_6, __pyx_v_array) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_array);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 3993, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 3993, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 3993, __pyx_L1_error)

    /* "validator.pyx":3987
 * 
 * def _ensure_no_complex_data(array):
 *     if (             # <<<<<<<<<<<<<<
 *         hasattr(array, "dtype")
 *         and array.dtype is not None
 */
  }

  /* "validator.pyx":3986
 *     return False
 * 
 * def _ensure_no_complex_data(array):             # <<<<<<<<<<<<<<
 *     if (
 *         hasattr(array, "dtype")
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("validator._ensure_no_complex_data", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":3996
 * 
 * 
 * def _check_estimator_name(estimator):             # <<<<<<<<<<<<<<
 *     if estimator is not None:
 *         if isinstance(estimator, str):
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_139_check_estimator_name(PyObject *__pyx_self, PyObject *__pyx_v_estimator); /*proto*/
static PyMethodDef __pyx_mdef_9validator_139_check_estimator_name = {"_check_estimator_name", (PyCFunction)__pyx_pw_9validator_139_check_estimator_name, METH_O, 0};
static PyObject *__pyx_pw_9validator_139_check_estimator_name(PyObject *__pyx_self, PyObject *__pyx_v_estimator) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_check_estimator_name (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_138_check_estimator_name(__pyx_self, ((PyObject *)__pyx_v_estimator));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_138_check_estimator_name(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_estimator) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_check_estimator_name", 0);

  /* "validator.pyx":3997
 * 
 * def _check_estimator_name(estimator):
 *     if estimator is not None:             # <<<<<<<<<<<<<<
 *         if isinstance(estimator, str):
 *             return estimator
 */
  __pyx_t_1 = (__pyx_v_estimator != Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "validator.pyx":3998
 * def _check_estimator_name(estimator):
 *     if estimator is not None:
 *         if isinstance(estimator, str):             # <<<<<<<<<<<<<<
 *             return estimator
 *         else:
 */
    __pyx_t_2 = PyUnicode_Check(__pyx_v_estimator); 
    __pyx_t_1 = (__pyx_t_2 != 0);
    if (__pyx_t_1) {

      /* "validator.pyx":3999
 *     if estimator is not None:
 *         if isinstance(estimator, str):
 *             return estimator             # <<<<<<<<<<<<<<
 *         else:
 *             return estimator.__class__.__name__
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_v_estimator);
      __pyx_r = __pyx_v_estimator;
      goto __pyx_L0;

      /* "validator.pyx":3998
 * def _check_estimator_name(estimator):
 *     if estimator is not None:
 *         if isinstance(estimator, str):             # <<<<<<<<<<<<<<
 *             return estimator
 *         else:
 */
    }

    /* "validator.pyx":4001
 *             return estimator
 *         else:
 *             return estimator.__class__.__name__             # <<<<<<<<<<<<<<
 *     return None
 * 
 */
    /*else*/ {
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_estimator, __pyx_n_s_class); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4001, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4001, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_r = __pyx_t_4;
      __pyx_t_4 = 0;
      goto __pyx_L0;
    }

    /* "validator.pyx":3997
 * 
 * def _check_estimator_name(estimator):
 *     if estimator is not None:             # <<<<<<<<<<<<<<
 *         if isinstance(estimator, str):
 *             return estimator
 */
  }

  /* "validator.pyx":4002
 *         else:
 *             return estimator.__class__.__name__
 *     return None             # <<<<<<<<<<<<<<
 * 
 * def set_array_back (X, *,  to_frame=False, columns = None, input_name ='X'):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;

  /* "validator.pyx":3996
 * 
 * 
 * def _check_estimator_name(estimator):             # <<<<<<<<<<<<<<
 *     if estimator is not None:
 *         if isinstance(estimator, str):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("validator._check_estimator_name", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":4004
 *     return None
 * 
 * def set_array_back (X, *,  to_frame=False, columns = None, input_name ='X'):             # <<<<<<<<<<<<<<
 *     """ Set array back to frame, reconvert the Numpy array to pandas series
 *     or dataframe.
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_141set_array_back(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_140set_array_back[] = " Set array back to frame, reconvert the Numpy array to pandas series \n    or dataframe. \n    \n    Parameters \n    ----------\n    X: Array-like \n        Array to convert to frame. \n    columns: str or list of str \n        Series name or columns names for pandas.Series and DataFrame. \n        \n    to_frame: str, default=False\n        If ``True`` , reconvert the array to frame using the columns ortherwise \n        no-action is performed and return the same array.\n    input_name : str, default=\"\"\n        The data name used to construct the error message. \n    force: bool, default=False, \n        Force columns creating using the combination ``input_name`` and \n        columns range if `columns` is not supplied. \n    Returns \n    -------\n    X, columns : Array-like \n        columns if `X` is dataframe and  name if Series. Otherwwise returns None.  \n        \n    ";
static PyMethodDef __pyx_mdef_9validator_141set_array_back = {"set_array_back", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_141set_array_back, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_140set_array_back};
static PyObject *__pyx_pw_9validator_141set_array_back(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_X = 0;
  PyObject *__pyx_v_to_frame = 0;
  PyObject *__pyx_v_columns = 0;
  PyObject *__pyx_v_input_name = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("set_array_back (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_X,&__pyx_n_s_to_frame,&__pyx_n_s_columns,&__pyx_n_s_input_name,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)Py_False);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)__pyx_n_u_X);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_X)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (kw_args > 0 && likely(kw_args <= 3)) {
        Py_ssize_t index;
        for (index = 1; index < 4 && kw_args > 0; index++) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
          if (value) { values[index] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "set_array_back") < 0)) __PYX_ERR(0, 4004, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_X = values[0];
    __pyx_v_to_frame = values[1];
    __pyx_v_columns = values[2];
    __pyx_v_input_name = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("set_array_back", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4004, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.set_array_back", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_140set_array_back(__pyx_self, __pyx_v_X, __pyx_v_to_frame, __pyx_v_columns, __pyx_v_input_name);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_140set_array_back(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X, PyObject *__pyx_v_to_frame, PyObject *__pyx_v_columns, PyObject *__pyx_v_input_name) {
  PyObject *__pyx_v_type_col_name = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  Py_ssize_t __pyx_t_7;
  Py_UCS4 __pyx_t_8;
  PyObject *__pyx_t_9 = NULL;
  Py_ssize_t __pyx_t_10;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("set_array_back", 0);
  __Pyx_INCREF(__pyx_v_X);
  __Pyx_INCREF(__pyx_v_columns);

  /* "validator.pyx":4032
 *     # set_back =('out', 'back','reconvert', 'to_frame',
 *     #            'export', 'step back')
 *     type_col_name = type (columns).__name__             # <<<<<<<<<<<<<<
 * 
 *     if not  (hasattr (X, '__array__') or sp.issparse (X)):
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_columns)), __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4032, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_type_col_name = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":4034
 *     type_col_name = type (columns).__name__
 * 
 *     if not  (hasattr (X, '__array__') or sp.issparse (X)):             # <<<<<<<<<<<<<<
 *         raise TypeError (f"{input_name + ' o' if input_name!='' else 'O'}nly "
 *                         f"supports array, got: {type (X).__name__!r}")
 */
  __pyx_t_3 = __Pyx_HasAttr(__pyx_v_X, __pyx_n_u_array_2); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 4034, __pyx_L1_error)
  __pyx_t_4 = (__pyx_t_3 != 0);
  if (!__pyx_t_4) {
  } else {
    __pyx_t_2 = __pyx_t_4;
    goto __pyx_L4_bool_binop_done;
  }
  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_sp); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4034, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_issparse); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4034, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_6);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_6, function);
    }
  }
  __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_5, __pyx_v_X) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_X);
  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4034, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 4034, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_2 = __pyx_t_4;
  __pyx_L4_bool_binop_done:;
  __pyx_t_4 = ((!__pyx_t_2) != 0);
  if (unlikely(__pyx_t_4)) {

    /* "validator.pyx":4035
 * 
 *     if not  (hasattr (X, '__array__') or sp.issparse (X)):
 *         raise TypeError (f"{input_name + ' o' if input_name!='' else 'O'}nly "             # <<<<<<<<<<<<<<
 *                         f"supports array, got: {type (X).__name__!r}")
 * 
 */
    __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4035, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_7 = 0;
    __pyx_t_8 = 127;
    __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_v_input_name, __pyx_kp_u__7, Py_NE)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 4035, __pyx_L1_error)
    if (__pyx_t_4) {
      __pyx_t_5 = PyNumber_Add(__pyx_v_input_name, __pyx_kp_u_o_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4035, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_6 = __pyx_t_5;
      __pyx_t_5 = 0;
    } else {
      __Pyx_INCREF(__pyx_n_u_O);
      __pyx_t_6 = __pyx_n_u_O;
    }
    __pyx_t_5 = __Pyx_PyObject_FormatSimple(__pyx_t_6, __pyx_empty_unicode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4035, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_8 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) > __pyx_t_8) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) : __pyx_t_8;
    __pyx_t_7 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_5);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_5);
    __pyx_t_5 = 0;
    __Pyx_INCREF(__pyx_kp_u_nly_supports_array_got);
    __pyx_t_7 += 25;
    __Pyx_GIVEREF(__pyx_kp_u_nly_supports_array_got);
    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_kp_u_nly_supports_array_got);

    /* "validator.pyx":4036
 *     if not  (hasattr (X, '__array__') or sp.issparse (X)):
 *         raise TypeError (f"{input_name + ' o' if input_name!='' else 'O'}nly "
 *                         f"supports array, got: {type (X).__name__!r}")             # <<<<<<<<<<<<<<
 * 
 *     if hasattr (X, 'columns'):
 */
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_X)), __pyx_n_s_name); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4036, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_t_5), __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4036, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_8 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) > __pyx_t_8) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) : __pyx_t_8;
    __pyx_t_7 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_t_6);
    __pyx_t_6 = 0;

    /* "validator.pyx":4035
 * 
 *     if not  (hasattr (X, '__array__') or sp.issparse (X)):
 *         raise TypeError (f"{input_name + ' o' if input_name!='' else 'O'}nly "             # <<<<<<<<<<<<<<
 *                         f"supports array, got: {type (X).__name__!r}")
 * 
 */
    __pyx_t_6 = __Pyx_PyUnicode_Join(__pyx_t_1, 3, __pyx_t_7, __pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4035, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4035, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 4035, __pyx_L1_error)

    /* "validator.pyx":4034
 *     type_col_name = type (columns).__name__
 * 
 *     if not  (hasattr (X, '__array__') or sp.issparse (X)):             # <<<<<<<<<<<<<<
 *         raise TypeError (f"{input_name + ' o' if input_name!='' else 'O'}nly "
 *                         f"supports array, got: {type (X).__name__!r}")
 */
  }

  /* "validator.pyx":4038
 *                         f"supports array, got: {type (X).__name__!r}")
 * 
 *     if hasattr (X, 'columns'):             # <<<<<<<<<<<<<<
 *         # keep the columns
 *         columns = X.columns
 */
  __pyx_t_4 = __Pyx_HasAttr(__pyx_v_X, __pyx_n_u_columns); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 4038, __pyx_L1_error)
  __pyx_t_2 = (__pyx_t_4 != 0);
  if (__pyx_t_2) {

    /* "validator.pyx":4040
 *     if hasattr (X, 'columns'):
 *         # keep the columns
 *         columns = X.columns             # <<<<<<<<<<<<<<
 *     elif hasattr (X, 'name') :
 *         # keep the name of series
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_columns); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4040, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF_SET(__pyx_v_columns, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "validator.pyx":4038
 *                         f"supports array, got: {type (X).__name__!r}")
 * 
 *     if hasattr (X, 'columns'):             # <<<<<<<<<<<<<<
 *         # keep the columns
 *         columns = X.columns
 */
    goto __pyx_L6;
  }

  /* "validator.pyx":4041
 *         # keep the columns
 *         columns = X.columns
 *     elif hasattr (X, 'name') :             # <<<<<<<<<<<<<<
 *         # keep the name of series
 *         columns = X.name
 */
  __pyx_t_2 = __Pyx_HasAttr(__pyx_v_X, __pyx_n_u_name_2); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 4041, __pyx_L1_error)
  __pyx_t_4 = (__pyx_t_2 != 0);
  if (__pyx_t_4) {

    /* "validator.pyx":4043
 *     elif hasattr (X, 'name') :
 *         # keep the name of series
 *         columns = X.name             # <<<<<<<<<<<<<<
 * 
 *     if (to_frame
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_name_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4043, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF_SET(__pyx_v_columns, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "validator.pyx":4041
 *         # keep the columns
 *         columns = X.columns
 *     elif hasattr (X, 'name') :             # <<<<<<<<<<<<<<
 *         # keep the name of series
 *         columns = X.name
 */
  }
  __pyx_L6:;

  /* "validator.pyx":4045
 *         columns = X.name
 * 
 *     if (to_frame             # <<<<<<<<<<<<<<
 *         and not sp.issparse (X)
 *         ):
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_to_frame); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4045, __pyx_L1_error)
  if (__pyx_t_2) {
  } else {
    __pyx_t_4 = __pyx_t_2;
    goto __pyx_L8_bool_binop_done;
  }

  /* "validator.pyx":4046
 * 
 *     if (to_frame
 *         and not sp.issparse (X)             # <<<<<<<<<<<<<<
 *         ):
 *         if columns is None :
 */
  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_sp); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4046, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_issparse); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4046, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_6 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
    }
  }
  __pyx_t_1 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_v_X) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_X);
  __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4046, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4046, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = ((!__pyx_t_2) != 0);
  __pyx_t_4 = __pyx_t_3;
  __pyx_L8_bool_binop_done:;

  /* "validator.pyx":4045
 *         columns = X.name
 * 
 *     if (to_frame             # <<<<<<<<<<<<<<
 *         and not sp.issparse (X)
 *         ):
 */
  if (__pyx_t_4) {

    /* "validator.pyx":4048
 *         and not sp.issparse (X)
 *         ):
 *         if columns is None :             # <<<<<<<<<<<<<<
 *             raise ValueError ("Name or columns must be supplied for"
 *                               " frame conversion.")
 */
    __pyx_t_4 = (__pyx_v_columns == Py_None);
    __pyx_t_3 = (__pyx_t_4 != 0);
    if (unlikely(__pyx_t_3)) {

      /* "validator.pyx":4049
 *         ):
 *         if columns is None :
 *             raise ValueError ("Name or columns must be supplied for"             # <<<<<<<<<<<<<<
 *                               " frame conversion.")
 *         # if not string is given as name
 */
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__106, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4049, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 4049, __pyx_L1_error)

      /* "validator.pyx":4048
 *         and not sp.issparse (X)
 *         ):
 *         if columns is None :             # <<<<<<<<<<<<<<
 *             raise ValueError ("Name or columns must be supplied for"
 *                               " frame conversion.")
 */
    }

    /* "validator.pyx":4055
 *         # value and use it as name to skip
 *         # TypeError: Series.name must be a hashable type
 *         if _is_arraylike_1d(X) :             # <<<<<<<<<<<<<<
 *             if not isinstance (columns, str ) and hasattr (columns, '__len__') :
 *                 if len(columns ) > 1:
 */
    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_is_arraylike_1d); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4055, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    __pyx_t_1 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_v_X) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_X);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4055, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 4055, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (__pyx_t_3) {

      /* "validator.pyx":4056
 *         # TypeError: Series.name must be a hashable type
 *         if _is_arraylike_1d(X) :
 *             if not isinstance (columns, str ) and hasattr (columns, '__len__') :             # <<<<<<<<<<<<<<
 *                 if len(columns ) > 1:
 *                     raise ValueError (
 */
      __pyx_t_4 = PyUnicode_Check(__pyx_v_columns); 
      __pyx_t_2 = ((!(__pyx_t_4 != 0)) != 0);
      if (__pyx_t_2) {
      } else {
        __pyx_t_3 = __pyx_t_2;
        goto __pyx_L13_bool_binop_done;
      }
      __pyx_t_2 = __Pyx_HasAttr(__pyx_v_columns, __pyx_n_u_len); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 4056, __pyx_L1_error)
      __pyx_t_4 = (__pyx_t_2 != 0);
      __pyx_t_3 = __pyx_t_4;
      __pyx_L13_bool_binop_done:;
      if (__pyx_t_3) {

        /* "validator.pyx":4057
 *         if _is_arraylike_1d(X) :
 *             if not isinstance (columns, str ) and hasattr (columns, '__len__') :
 *                 if len(columns ) > 1:             # <<<<<<<<<<<<<<
 *                     raise ValueError (
 *                         f"{input_name} is 1d-array, only pandas.Series "
 */
        __pyx_t_7 = PyObject_Length(__pyx_v_columns); if (unlikely(__pyx_t_7 == ((Py_ssize_t)-1))) __PYX_ERR(0, 4057, __pyx_L1_error)
        __pyx_t_3 = ((__pyx_t_7 > 1) != 0);
        if (unlikely(__pyx_t_3)) {

          /* "validator.pyx":4059
 *                 if len(columns ) > 1:
 *                     raise ValueError (
 *                         f"{input_name} is 1d-array, only pandas.Series "             # <<<<<<<<<<<<<<
 *                         "conversion can be performed while name must be a"
 *                          f" hashable type: got {type_col_name!r}")
 */
          __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4059, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_1);
          __pyx_t_7 = 0;
          __pyx_t_8 = 127;
          __pyx_t_5 = __Pyx_PyObject_FormatSimple(__pyx_v_input_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4059, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_5);
          __pyx_t_8 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) > __pyx_t_8) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) : __pyx_t_8;
          __pyx_t_7 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_5);
          __Pyx_GIVEREF(__pyx_t_5);
          PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_5);
          __pyx_t_5 = 0;
          __Pyx_INCREF(__pyx_kp_u_is_1d_array_only_pandas_Series);
          __pyx_t_7 += 101;
          __Pyx_GIVEREF(__pyx_kp_u_is_1d_array_only_pandas_Series);
          PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_kp_u_is_1d_array_only_pandas_Series);

          /* "validator.pyx":4061
 *                         f"{input_name} is 1d-array, only pandas.Series "
 *                         "conversion can be performed while name must be a"
 *                          f" hashable type: got {type_col_name!r}")             # <<<<<<<<<<<<<<
 *                 columns = columns [0]
 * 
 */
          __pyx_t_5 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_v_type_col_name), __pyx_empty_unicode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4061, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_5);
          __pyx_t_8 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) > __pyx_t_8) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) : __pyx_t_8;
          __pyx_t_7 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_5);
          __Pyx_GIVEREF(__pyx_t_5);
          PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_t_5);
          __pyx_t_5 = 0;

          /* "validator.pyx":4059
 *                 if len(columns ) > 1:
 *                     raise ValueError (
 *                         f"{input_name} is 1d-array, only pandas.Series "             # <<<<<<<<<<<<<<
 *                         "conversion can be performed while name must be a"
 *                          f" hashable type: got {type_col_name!r}")
 */
          __pyx_t_5 = __Pyx_PyUnicode_Join(__pyx_t_1, 3, __pyx_t_7, __pyx_t_8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4059, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_5);
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

          /* "validator.pyx":4058
 *             if not isinstance (columns, str ) and hasattr (columns, '__len__') :
 *                 if len(columns ) > 1:
 *                     raise ValueError (             # <<<<<<<<<<<<<<
 *                         f"{input_name} is 1d-array, only pandas.Series "
 *                         "conversion can be performed while name must be a"
 */
          __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4058, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_Raise(__pyx_t_1, 0, 0, 0);
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
          __PYX_ERR(0, 4058, __pyx_L1_error)

          /* "validator.pyx":4057
 *         if _is_arraylike_1d(X) :
 *             if not isinstance (columns, str ) and hasattr (columns, '__len__') :
 *                 if len(columns ) > 1:             # <<<<<<<<<<<<<<
 *                     raise ValueError (
 *                         f"{input_name} is 1d-array, only pandas.Series "
 */
        }

        /* "validator.pyx":4062
 *                         "conversion can be performed while name must be a"
 *                          f" hashable type: got {type_col_name!r}")
 *                 columns = columns [0]             # <<<<<<<<<<<<<<
 * 
 *             X= pd.Series (X, name =columns )
 */
        __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_columns, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4062, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF_SET(__pyx_v_columns, __pyx_t_1);
        __pyx_t_1 = 0;

        /* "validator.pyx":4056
 *         # TypeError: Series.name must be a hashable type
 *         if _is_arraylike_1d(X) :
 *             if not isinstance (columns, str ) and hasattr (columns, '__len__') :             # <<<<<<<<<<<<<<
 *                 if len(columns ) > 1:
 *                     raise ValueError (
 */
      }

      /* "validator.pyx":4064
 *                 columns = columns [0]
 * 
 *             X= pd.Series (X, name =columns )             # <<<<<<<<<<<<<<
 *         else:
 *             # columns is str , reconvert to a list
 */
      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pd); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4064, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_Series); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4064, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4064, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_INCREF(__pyx_v_X);
      __Pyx_GIVEREF(__pyx_v_X);
      PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_X);
      __pyx_t_6 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4064, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_name_2, __pyx_v_columns) < 0) __PYX_ERR(0, 4064, __pyx_L1_error)
      __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_1, __pyx_t_6); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 4064, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_9);
      __pyx_t_9 = 0;

      /* "validator.pyx":4055
 *         # value and use it as name to skip
 *         # TypeError: Series.name must be a hashable type
 *         if _is_arraylike_1d(X) :             # <<<<<<<<<<<<<<
 *             if not isinstance (columns, str ) and hasattr (columns, '__len__') :
 *                 if len(columns ) > 1:
 */
      goto __pyx_L11;
    }

    /* "validator.pyx":4069
 *             # and check whether the columns match
 *             # the shape [1]
 *             if isinstance (columns, str ):             # <<<<<<<<<<<<<<
 *                 columns = [columns ]
 *             if not hasattr (columns, '__len__'):
 */
    /*else*/ {
      __pyx_t_3 = PyUnicode_Check(__pyx_v_columns); 
      __pyx_t_4 = (__pyx_t_3 != 0);
      if (__pyx_t_4) {

        /* "validator.pyx":4070
 *             # the shape [1]
 *             if isinstance (columns, str ):
 *                 columns = [columns ]             # <<<<<<<<<<<<<<
 *             if not hasattr (columns, '__len__'):
 *                 raise TypeError (" Columns for {input_name!r} expects "
 */
        __pyx_t_9 = PyList_New(1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 4070, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_INCREF(__pyx_v_columns);
        __Pyx_GIVEREF(__pyx_v_columns);
        PyList_SET_ITEM(__pyx_t_9, 0, __pyx_v_columns);
        __Pyx_DECREF_SET(__pyx_v_columns, __pyx_t_9);
        __pyx_t_9 = 0;

        /* "validator.pyx":4069
 *             # and check whether the columns match
 *             # the shape [1]
 *             if isinstance (columns, str ):             # <<<<<<<<<<<<<<
 *                 columns = [columns ]
 *             if not hasattr (columns, '__len__'):
 */
      }

      /* "validator.pyx":4071
 *             if isinstance (columns, str ):
 *                 columns = [columns ]
 *             if not hasattr (columns, '__len__'):             # <<<<<<<<<<<<<<
 *                 raise TypeError (" Columns for {input_name!r} expects "
 *                                   f"a list or tuple. Got {type_col_name!r}")
 */
      __pyx_t_4 = __Pyx_HasAttr(__pyx_v_columns, __pyx_n_u_len); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 4071, __pyx_L1_error)
      __pyx_t_3 = ((!(__pyx_t_4 != 0)) != 0);
      if (unlikely(__pyx_t_3)) {

        /* "validator.pyx":4073
 *             if not hasattr (columns, '__len__'):
 *                 raise TypeError (" Columns for {input_name!r} expects "
 *                                   f"a list or tuple. Got {type_col_name!r}")             # <<<<<<<<<<<<<<
 *             if X.shape [1] != len(columns):
 *                 raise ValueError (
 */
        __pyx_t_9 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_v_type_col_name), __pyx_empty_unicode); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 4073, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_9);

        /* "validator.pyx":4072
 *                 columns = [columns ]
 *             if not hasattr (columns, '__len__'):
 *                 raise TypeError (" Columns for {input_name!r} expects "             # <<<<<<<<<<<<<<
 *                                   f"a list or tuple. Got {type_col_name!r}")
 *             if X.shape [1] != len(columns):
 */
        __pyx_t_6 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Columns_for_input_name_r_expect, __pyx_t_9); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4072, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        __pyx_t_9 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_6); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 4072, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_Raise(__pyx_t_9, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        __PYX_ERR(0, 4072, __pyx_L1_error)

        /* "validator.pyx":4071
 *             if isinstance (columns, str ):
 *                 columns = [columns ]
 *             if not hasattr (columns, '__len__'):             # <<<<<<<<<<<<<<
 *                 raise TypeError (" Columns for {input_name!r} expects "
 *                                   f"a list or tuple. Got {type_col_name!r}")
 */
      }

      /* "validator.pyx":4074
 *                 raise TypeError (" Columns for {input_name!r} expects "
 *                                   f"a list or tuple. Got {type_col_name!r}")
 *             if X.shape [1] != len(columns):             # <<<<<<<<<<<<<<
 *                 raise ValueError (
 *                     f"Shape of passed values for {input_name} is"
 */
      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 4074, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      __pyx_t_6 = __Pyx_GetItemInt(__pyx_t_9, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4074, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      __pyx_t_7 = PyObject_Length(__pyx_v_columns); if (unlikely(__pyx_t_7 == ((Py_ssize_t)-1))) __PYX_ERR(0, 4074, __pyx_L1_error)
      __pyx_t_9 = PyInt_FromSsize_t(__pyx_t_7); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 4074, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      __pyx_t_1 = PyObject_RichCompare(__pyx_t_6, __pyx_t_9, Py_NE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4074, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 4074, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (unlikely(__pyx_t_3)) {

        /* "validator.pyx":4076
 *             if X.shape [1] != len(columns):
 *                 raise ValueError (
 *                     f"Shape of passed values for {input_name} is"             # <<<<<<<<<<<<<<
 *                     f" {X.shape}. Columns indices imply {X.shape[1]},"
 *                     f" got {len(columns)}"
 */
        __pyx_t_1 = PyTuple_New(8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4076, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_7 = 0;
        __pyx_t_8 = 127;
        __Pyx_INCREF(__pyx_kp_u_Shape_of_passed_values_for);
        __pyx_t_7 += 27;
        __Pyx_GIVEREF(__pyx_kp_u_Shape_of_passed_values_for);
        PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_Shape_of_passed_values_for);
        __pyx_t_9 = __Pyx_PyObject_FormatSimple(__pyx_v_input_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 4076, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_9);
        __pyx_t_8 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_9) > __pyx_t_8) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_9) : __pyx_t_8;
        __pyx_t_7 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_9);
        __Pyx_GIVEREF(__pyx_t_9);
        PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_9);
        __pyx_t_9 = 0;
        __Pyx_INCREF(__pyx_kp_u_is);
        __pyx_t_7 += 4;
        __Pyx_GIVEREF(__pyx_kp_u_is);
        PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_is);

        /* "validator.pyx":4077
 *                 raise ValueError (
 *                     f"Shape of passed values for {input_name} is"
 *                     f" {X.shape}. Columns indices imply {X.shape[1]},"             # <<<<<<<<<<<<<<
 *                     f" got {len(columns)}"
 *                                   )
 */
        __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 4077, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_9);
        __pyx_t_6 = __Pyx_PyObject_FormatSimple(__pyx_t_9, __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4077, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        __pyx_t_8 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) > __pyx_t_8) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) : __pyx_t_8;
        __pyx_t_7 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
        __Pyx_GIVEREF(__pyx_t_6);
        PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_t_6);
        __pyx_t_6 = 0;
        __Pyx_INCREF(__pyx_kp_u_Columns_indices_imply);
        __pyx_t_7 += 24;
        __Pyx_GIVEREF(__pyx_kp_u_Columns_indices_imply);
        PyTuple_SET_ITEM(__pyx_t_1, 4, __pyx_kp_u_Columns_indices_imply);
        __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4077, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __pyx_t_9 = __Pyx_GetItemInt(__pyx_t_6, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 4077, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        __pyx_t_6 = __Pyx_PyObject_FormatSimple(__pyx_t_9, __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4077, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
        __pyx_t_8 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) > __pyx_t_8) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) : __pyx_t_8;
        __pyx_t_7 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
        __Pyx_GIVEREF(__pyx_t_6);
        PyTuple_SET_ITEM(__pyx_t_1, 5, __pyx_t_6);
        __pyx_t_6 = 0;
        __Pyx_INCREF(__pyx_kp_u_got);
        __pyx_t_7 += 6;
        __Pyx_GIVEREF(__pyx_kp_u_got);
        PyTuple_SET_ITEM(__pyx_t_1, 6, __pyx_kp_u_got);

        /* "validator.pyx":4078
 *                     f"Shape of passed values for {input_name} is"
 *                     f" {X.shape}. Columns indices imply {X.shape[1]},"
 *                     f" got {len(columns)}"             # <<<<<<<<<<<<<<
 *                                   )
 * 
 */
        __pyx_t_10 = PyObject_Length(__pyx_v_columns); if (unlikely(__pyx_t_10 == ((Py_ssize_t)-1))) __PYX_ERR(0, 4078, __pyx_L1_error)
        __pyx_t_6 = __Pyx_PyUnicode_From_Py_ssize_t(__pyx_t_10, 0, ' ', 'd'); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4078, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __pyx_t_7 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
        __Pyx_GIVEREF(__pyx_t_6);
        PyTuple_SET_ITEM(__pyx_t_1, 7, __pyx_t_6);
        __pyx_t_6 = 0;

        /* "validator.pyx":4076
 *             if X.shape [1] != len(columns):
 *                 raise ValueError (
 *                     f"Shape of passed values for {input_name} is"             # <<<<<<<<<<<<<<
 *                     f" {X.shape}. Columns indices imply {X.shape[1]},"
 *                     f" got {len(columns)}"
 */
        __pyx_t_6 = __Pyx_PyUnicode_Join(__pyx_t_1, 8, __pyx_t_7, __pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4076, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "validator.pyx":4075
 *                                   f"a list or tuple. Got {type_col_name!r}")
 *             if X.shape [1] != len(columns):
 *                 raise ValueError (             # <<<<<<<<<<<<<<
 *                     f"Shape of passed values for {input_name} is"
 *                     f" {X.shape}. Columns indices imply {X.shape[1]},"
 */
        __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4075, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_Raise(__pyx_t_1, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __PYX_ERR(0, 4075, __pyx_L1_error)

        /* "validator.pyx":4074
 *                 raise TypeError (" Columns for {input_name!r} expects "
 *                                   f"a list or tuple. Got {type_col_name!r}")
 *             if X.shape [1] != len(columns):             # <<<<<<<<<<<<<<
 *                 raise ValueError (
 *                     f"Shape of passed values for {input_name} is"
 */
      }

      /* "validator.pyx":4081
 *                                   )
 * 
 *             X= pd.DataFrame (X, columns = columns )             # <<<<<<<<<<<<<<
 * 
 *     return X, columns
 */
      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pd); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4081, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_DataFrame); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4081, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4081, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_INCREF(__pyx_v_X);
      __Pyx_GIVEREF(__pyx_v_X);
      PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_X);
      __pyx_t_9 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 4081, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      if (PyDict_SetItem(__pyx_t_9, __pyx_n_s_columns, __pyx_v_columns) < 0) __PYX_ERR(0, 4081, __pyx_L1_error)
      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_1, __pyx_t_9); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4081, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_5);
      __pyx_t_5 = 0;
    }
    __pyx_L11:;

    /* "validator.pyx":4045
 *         columns = X.name
 * 
 *     if (to_frame             # <<<<<<<<<<<<<<
 *         and not sp.issparse (X)
 *         ):
 */
  }

  /* "validator.pyx":4083
 *             X= pd.DataFrame (X, columns = columns )
 * 
 *     return X, columns             # <<<<<<<<<<<<<<
 * 
 * def convert_array_to_pandas(X, *, to_frame=False, columns=None, input_name='X'):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4083, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_INCREF(__pyx_v_X);
  __Pyx_GIVEREF(__pyx_v_X);
  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_X);
  __Pyx_INCREF(__pyx_v_columns);
  __Pyx_GIVEREF(__pyx_v_columns);
  PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_v_columns);
  __pyx_r = __pyx_t_5;
  __pyx_t_5 = 0;
  goto __pyx_L0;

  /* "validator.pyx":4004
 *     return None
 * 
 * def set_array_back (X, *,  to_frame=False, columns = None, input_name ='X'):             # <<<<<<<<<<<<<<
 *     """ Set array back to frame, reconvert the Numpy array to pandas series
 *     or dataframe.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("validator.set_array_back", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_type_col_name);
  __Pyx_XDECREF(__pyx_v_X);
  __Pyx_XDECREF(__pyx_v_columns);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":4085
 *     return X, columns
 * 
 * def convert_array_to_pandas(X, *, to_frame=False, columns=None, input_name='X'):             # <<<<<<<<<<<<<<
 *     """
 *     Converts an array-like object to a pandas DataFrame or Series, applying
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_143convert_array_to_pandas(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_142convert_array_to_pandas[] = "\n    Converts an array-like object to a pandas DataFrame or Series, applying\n    provided column names or series name.\n\n    Parameters\n    ----------\n    X : array-like\n        The array to convert to a DataFrame or Series.\n    to_frame : bool, default=False\n        If True, converts the array to a DataFrame. Otherwise, returns the array unchanged.\n    columns : str or list of str, optional\n        Name(s) for the columns of the resulting DataFrame or the name of the Series.\n    input_name : str, default='X'\n        The name of the input variable; used in constructing error messages.\n\n    Returns\n    -------\n    pd.DataFrame or pd.Series\n        The converted DataFrame or Series. If `to_frame` is False, returns `X` unchanged.\n    columns : str or list of str\n        The column names of the DataFrame or the name of the Series, if applicable.\n\n    Raises\n    ------\n    TypeError\n        If `X` is not array-like or if `columns` is neither a string nor a list of strings.\n    ValueError\n        If the conversion to DataFrame is requested but `columns` is not provided,\n        or if the length of `columns` does not match the number of columns in `X`.\n    ";
static PyMethodDef __pyx_mdef_9validator_143convert_array_to_pandas = {"convert_array_to_pandas", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_143convert_array_to_pandas, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_142convert_array_to_pandas};
static PyObject *__pyx_pw_9validator_143convert_array_to_pandas(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_X = 0;
  PyObject *__pyx_v_to_frame = 0;
  PyObject *__pyx_v_columns = 0;
  PyObject *__pyx_v_input_name = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("convert_array_to_pandas (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_X,&__pyx_n_s_to_frame,&__pyx_n_s_columns,&__pyx_n_s_input_name,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)Py_False);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)__pyx_n_u_X);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_X)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (kw_args > 0 && likely(kw_args <= 3)) {
        Py_ssize_t index;
        for (index = 1; index < 4 && kw_args > 0; index++) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
          if (value) { values[index] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "convert_array_to_pandas") < 0)) __PYX_ERR(0, 4085, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_X = values[0];
    __pyx_v_to_frame = values[1];
    __pyx_v_columns = values[2];
    __pyx_v_input_name = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("convert_array_to_pandas", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4085, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.convert_array_to_pandas", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_142convert_array_to_pandas(__pyx_self, __pyx_v_X, __pyx_v_to_frame, __pyx_v_columns, __pyx_v_input_name);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_142convert_array_to_pandas(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X, PyObject *__pyx_v_to_frame, PyObject *__pyx_v_columns, PyObject *__pyx_v_input_name) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  Py_ssize_t __pyx_t_4;
  Py_UCS4 __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_t_9;
  Py_ssize_t __pyx_t_10;
  PyObject *__pyx_t_11 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("convert_array_to_pandas", 0);
  __Pyx_INCREF(__pyx_v_X);
  __Pyx_INCREF(__pyx_v_columns);

  /* "validator.pyx":4117
 *     """
 *     # Check if the input is string, which is a common mistake
 *     if isinstance(X, str):             # <<<<<<<<<<<<<<
 *         raise TypeError(f"The parameter '{input_name}' should be an array-like"
 *                         " or sparse matrix, but a string was passed.")
 */
  __pyx_t_1 = PyUnicode_Check(__pyx_v_X); 
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (unlikely(__pyx_t_2)) {

    /* "validator.pyx":4118
 *     # Check if the input is string, which is a common mistake
 *     if isinstance(X, str):
 *         raise TypeError(f"The parameter '{input_name}' should be an array-like"             # <<<<<<<<<<<<<<
 *                         " or sparse matrix, but a string was passed.")
 * 
 */
    __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4118, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = 0;
    __pyx_t_5 = 127;
    __Pyx_INCREF(__pyx_kp_u_The_parameter);
    __pyx_t_4 += 15;
    __Pyx_GIVEREF(__pyx_kp_u_The_parameter);
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_kp_u_The_parameter);
    __pyx_t_6 = __Pyx_PyObject_FormatSimple(__pyx_v_input_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4118, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_5 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) > __pyx_t_5) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) : __pyx_t_5;
    __pyx_t_4 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_6);
    __pyx_t_6 = 0;
    __Pyx_INCREF(__pyx_kp_u_should_be_an_array_like_or_spar);
    __pyx_t_4 += 68;
    __Pyx_GIVEREF(__pyx_kp_u_should_be_an_array_like_or_spar);
    PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_kp_u_should_be_an_array_like_or_spar);
    __pyx_t_6 = __Pyx_PyUnicode_Join(__pyx_t_3, 3, __pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4118, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4118, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 4118, __pyx_L1_error)

    /* "validator.pyx":4117
 *     """
 *     # Check if the input is string, which is a common mistake
 *     if isinstance(X, str):             # <<<<<<<<<<<<<<
 *         raise TypeError(f"The parameter '{input_name}' should be an array-like"
 *                         " or sparse matrix, but a string was passed.")
 */
  }

  /* "validator.pyx":4122
 * 
 *     # Validate the type of X
 *     if not (hasattr(X, '__array__') or isinstance(             # <<<<<<<<<<<<<<
 *             X, (np.ndarray, pd.Series, list)) or sp.issparse(X)):
 *         raise TypeError(f"The parameter '{input_name}' should be array-like"
 */
  __pyx_t_1 = __Pyx_HasAttr(__pyx_v_X, __pyx_n_u_array_2); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 4122, __pyx_L1_error)
  __pyx_t_7 = (__pyx_t_1 != 0);
  if (!__pyx_t_7) {
  } else {
    __pyx_t_2 = __pyx_t_7;
    goto __pyx_L5_bool_binop_done;
  }

  /* "validator.pyx":4123
 *     # Validate the type of X
 *     if not (hasattr(X, '__array__') or isinstance(
 *             X, (np.ndarray, pd.Series, list)) or sp.issparse(X)):             # <<<<<<<<<<<<<<
 *         raise TypeError(f"The parameter '{input_name}' should be array-like"
 *                         f" or a sparse matrix. Received: {type(X).__name__!r}")
 */
  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4123, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_ndarray); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4123, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_pd); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4123, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_Series); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 4123, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "validator.pyx":4122
 * 
 *     # Validate the type of X
 *     if not (hasattr(X, '__array__') or isinstance(             # <<<<<<<<<<<<<<
 *             X, (np.ndarray, pd.Series, list)) or sp.issparse(X)):
 *         raise TypeError(f"The parameter '{input_name}' should be array-like"
 */
  __pyx_t_1 = PyObject_IsInstance(__pyx_v_X, __pyx_t_6); 

  /* "validator.pyx":4123
 *     # Validate the type of X
 *     if not (hasattr(X, '__array__') or isinstance(
 *             X, (np.ndarray, pd.Series, list)) or sp.issparse(X)):             # <<<<<<<<<<<<<<
 *         raise TypeError(f"The parameter '{input_name}' should be array-like"
 *                         f" or a sparse matrix. Received: {type(X).__name__!r}")
 */
  __pyx_t_9 = (__pyx_t_1 != 0);
  if (!__pyx_t_9) {
  } else {
    __pyx_t_7 = __pyx_t_9;
    goto __pyx_L8_bool_binop_done;
  }
  __pyx_t_9 = PyObject_IsInstance(__pyx_v_X, __pyx_t_8); 
  __pyx_t_1 = (__pyx_t_9 != 0);
  if (!__pyx_t_1) {
  } else {
    __pyx_t_7 = __pyx_t_1;
    goto __pyx_L8_bool_binop_done;
  }
  __pyx_t_1 = PyList_Check(__pyx_v_X); 
  __pyx_t_9 = (__pyx_t_1 != 0);
  __pyx_t_7 = __pyx_t_9;
  __pyx_L8_bool_binop_done:;
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

  /* "validator.pyx":4122
 * 
 *     # Validate the type of X
 *     if not (hasattr(X, '__array__') or isinstance(             # <<<<<<<<<<<<<<
 *             X, (np.ndarray, pd.Series, list)) or sp.issparse(X)):
 *         raise TypeError(f"The parameter '{input_name}' should be array-like"
 */
  __pyx_t_9 = (__pyx_t_7 != 0);
  if (!__pyx_t_9) {
  } else {
    __pyx_t_2 = __pyx_t_9;
    goto __pyx_L5_bool_binop_done;
  }

  /* "validator.pyx":4123
 *     # Validate the type of X
 *     if not (hasattr(X, '__array__') or isinstance(
 *             X, (np.ndarray, pd.Series, list)) or sp.issparse(X)):             # <<<<<<<<<<<<<<
 *         raise TypeError(f"The parameter '{input_name}' should be array-like"
 *                         f" or a sparse matrix. Received: {type(X).__name__!r}")
 */
  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_sp); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 4123, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_issparse); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4123, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __pyx_t_8 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_8)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_8);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_6 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_8, __pyx_v_X) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_X);
  __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
  if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4123, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 4123, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_2 = __pyx_t_9;
  __pyx_L5_bool_binop_done:;

  /* "validator.pyx":4122
 * 
 *     # Validate the type of X
 *     if not (hasattr(X, '__array__') or isinstance(             # <<<<<<<<<<<<<<
 *             X, (np.ndarray, pd.Series, list)) or sp.issparse(X)):
 *         raise TypeError(f"The parameter '{input_name}' should be array-like"
 */
  __pyx_t_9 = ((!__pyx_t_2) != 0);
  if (unlikely(__pyx_t_9)) {

    /* "validator.pyx":4124
 *     if not (hasattr(X, '__array__') or isinstance(
 *             X, (np.ndarray, pd.Series, list)) or sp.issparse(X)):
 *         raise TypeError(f"The parameter '{input_name}' should be array-like"             # <<<<<<<<<<<<<<
 *                         f" or a sparse matrix. Received: {type(X).__name__!r}")
 * 
 */
    __pyx_t_6 = PyTuple_New(4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4124, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_4 = 0;
    __pyx_t_5 = 127;
    __Pyx_INCREF(__pyx_kp_u_The_parameter);
    __pyx_t_4 += 15;
    __Pyx_GIVEREF(__pyx_kp_u_The_parameter);
    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_kp_u_The_parameter);
    __pyx_t_3 = __Pyx_PyObject_FormatSimple(__pyx_v_input_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4124, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) > __pyx_t_5) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) : __pyx_t_5;
    __pyx_t_4 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_3);
    __pyx_t_3 = 0;
    __Pyx_INCREF(__pyx_kp_u_should_be_array_like_or_a_spars);
    __pyx_t_4 += 53;
    __Pyx_GIVEREF(__pyx_kp_u_should_be_array_like_or_a_spars);
    PyTuple_SET_ITEM(__pyx_t_6, 2, __pyx_kp_u_should_be_array_like_or_a_spars);

    /* "validator.pyx":4125
 *             X, (np.ndarray, pd.Series, list)) or sp.issparse(X)):
 *         raise TypeError(f"The parameter '{input_name}' should be array-like"
 *                         f" or a sparse matrix. Received: {type(X).__name__!r}")             # <<<<<<<<<<<<<<
 * 
 *     # Preserve existing DataFrame or Series column names
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_X)), __pyx_n_s_name); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4125, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_8 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_t_3), __pyx_empty_unicode); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 4125, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_5 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_8) > __pyx_t_5) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_8) : __pyx_t_5;
    __pyx_t_4 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_8);
    __Pyx_GIVEREF(__pyx_t_8);
    PyTuple_SET_ITEM(__pyx_t_6, 3, __pyx_t_8);
    __pyx_t_8 = 0;

    /* "validator.pyx":4124
 *     if not (hasattr(X, '__array__') or isinstance(
 *             X, (np.ndarray, pd.Series, list)) or sp.issparse(X)):
 *         raise TypeError(f"The parameter '{input_name}' should be array-like"             # <<<<<<<<<<<<<<
 *                         f" or a sparse matrix. Received: {type(X).__name__!r}")
 * 
 */
    __pyx_t_8 = __Pyx_PyUnicode_Join(__pyx_t_6, 4, __pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 4124, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4124, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __Pyx_Raise(__pyx_t_6, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __PYX_ERR(0, 4124, __pyx_L1_error)

    /* "validator.pyx":4122
 * 
 *     # Validate the type of X
 *     if not (hasattr(X, '__array__') or isinstance(             # <<<<<<<<<<<<<<
 *             X, (np.ndarray, pd.Series, list)) or sp.issparse(X)):
 *         raise TypeError(f"The parameter '{input_name}' should be array-like"
 */
  }

  /* "validator.pyx":4128
 * 
 *     # Preserve existing DataFrame or Series column names
 *     if hasattr(X, 'columns'):             # <<<<<<<<<<<<<<
 *         columns = X.columns
 *     elif hasattr(X, 'name'):
 */
  __pyx_t_9 = __Pyx_HasAttr(__pyx_v_X, __pyx_n_u_columns); if (unlikely(__pyx_t_9 == ((int)-1))) __PYX_ERR(0, 4128, __pyx_L1_error)
  __pyx_t_2 = (__pyx_t_9 != 0);
  if (__pyx_t_2) {

    /* "validator.pyx":4129
 *     # Preserve existing DataFrame or Series column names
 *     if hasattr(X, 'columns'):
 *         columns = X.columns             # <<<<<<<<<<<<<<
 *     elif hasattr(X, 'name'):
 *         columns = X.name
 */
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_columns); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4129, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF_SET(__pyx_v_columns, __pyx_t_6);
    __pyx_t_6 = 0;

    /* "validator.pyx":4128
 * 
 *     # Preserve existing DataFrame or Series column names
 *     if hasattr(X, 'columns'):             # <<<<<<<<<<<<<<
 *         columns = X.columns
 *     elif hasattr(X, 'name'):
 */
    goto __pyx_L11;
  }

  /* "validator.pyx":4130
 *     if hasattr(X, 'columns'):
 *         columns = X.columns
 *     elif hasattr(X, 'name'):             # <<<<<<<<<<<<<<
 *         columns = X.name
 * 
 */
  __pyx_t_2 = __Pyx_HasAttr(__pyx_v_X, __pyx_n_u_name_2); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 4130, __pyx_L1_error)
  __pyx_t_9 = (__pyx_t_2 != 0);
  if (__pyx_t_9) {

    /* "validator.pyx":4131
 *         columns = X.columns
 *     elif hasattr(X, 'name'):
 *         columns = X.name             # <<<<<<<<<<<<<<
 * 
 *     if to_frame and not sp.issparse(X):
 */
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_name_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4131, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF_SET(__pyx_v_columns, __pyx_t_6);
    __pyx_t_6 = 0;

    /* "validator.pyx":4130
 *     if hasattr(X, 'columns'):
 *         columns = X.columns
 *     elif hasattr(X, 'name'):             # <<<<<<<<<<<<<<
 *         columns = X.name
 * 
 */
  }
  __pyx_L11:;

  /* "validator.pyx":4133
 *         columns = X.name
 * 
 *     if to_frame and not sp.issparse(X):             # <<<<<<<<<<<<<<
 *         if columns is None:
 *             raise ValueError("Columns must be provided for DataFrame conversion.")
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_to_frame); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4133, __pyx_L1_error)
  if (__pyx_t_2) {
  } else {
    __pyx_t_9 = __pyx_t_2;
    goto __pyx_L13_bool_binop_done;
  }
  __Pyx_GetModuleGlobalName(__pyx_t_8, __pyx_n_s_sp); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 4133, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_issparse); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4133, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __pyx_t_8 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_8)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_8);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_6 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_8, __pyx_v_X) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_X);
  __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
  if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4133, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4133, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_7 = ((!__pyx_t_2) != 0);
  __pyx_t_9 = __pyx_t_7;
  __pyx_L13_bool_binop_done:;
  if (__pyx_t_9) {

    /* "validator.pyx":4134
 * 
 *     if to_frame and not sp.issparse(X):
 *         if columns is None:             # <<<<<<<<<<<<<<
 *             raise ValueError("Columns must be provided for DataFrame conversion.")
 * 
 */
    __pyx_t_9 = (__pyx_v_columns == Py_None);
    __pyx_t_7 = (__pyx_t_9 != 0);
    if (unlikely(__pyx_t_7)) {

      /* "validator.pyx":4135
 *     if to_frame and not sp.issparse(X):
 *         if columns is None:
 *             raise ValueError("Columns must be provided for DataFrame conversion.")             # <<<<<<<<<<<<<<
 * 
 *         # Ensure columns is list-like for DataFrame conversion, single string for Series
 */
      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__107, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4135, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_Raise(__pyx_t_6, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __PYX_ERR(0, 4135, __pyx_L1_error)

      /* "validator.pyx":4134
 * 
 *     if to_frame and not sp.issparse(X):
 *         if columns is None:             # <<<<<<<<<<<<<<
 *             raise ValueError("Columns must be provided for DataFrame conversion.")
 * 
 */
    }

    /* "validator.pyx":4138
 * 
 *         # Ensure columns is list-like for DataFrame conversion, single string for Series
 *         if isinstance(columns, str):             # <<<<<<<<<<<<<<
 *             columns = [columns]
 * 
 */
    __pyx_t_7 = PyUnicode_Check(__pyx_v_columns); 
    __pyx_t_9 = (__pyx_t_7 != 0);
    if (__pyx_t_9) {

      /* "validator.pyx":4139
 *         # Ensure columns is list-like for DataFrame conversion, single string for Series
 *         if isinstance(columns, str):
 *             columns = [columns]             # <<<<<<<<<<<<<<
 * 
 *         if not hasattr(columns, '__len__') or isinstance(columns, str):
 */
      __pyx_t_6 = PyList_New(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4139, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_INCREF(__pyx_v_columns);
      __Pyx_GIVEREF(__pyx_v_columns);
      PyList_SET_ITEM(__pyx_t_6, 0, __pyx_v_columns);
      __Pyx_DECREF_SET(__pyx_v_columns, __pyx_t_6);
      __pyx_t_6 = 0;

      /* "validator.pyx":4138
 * 
 *         # Ensure columns is list-like for DataFrame conversion, single string for Series
 *         if isinstance(columns, str):             # <<<<<<<<<<<<<<
 *             columns = [columns]
 * 
 */
    }

    /* "validator.pyx":4141
 *             columns = [columns]
 * 
 *         if not hasattr(columns, '__len__') or isinstance(columns, str):             # <<<<<<<<<<<<<<
 *             raise TypeError(f"Columns for {input_name} must be a list or a single string.")
 * 
 */
    __pyx_t_7 = __Pyx_HasAttr(__pyx_v_columns, __pyx_n_u_len); if (unlikely(__pyx_t_7 == ((int)-1))) __PYX_ERR(0, 4141, __pyx_L1_error)
    __pyx_t_2 = ((!(__pyx_t_7 != 0)) != 0);
    if (!__pyx_t_2) {
    } else {
      __pyx_t_9 = __pyx_t_2;
      goto __pyx_L18_bool_binop_done;
    }
    __pyx_t_2 = PyUnicode_Check(__pyx_v_columns); 
    __pyx_t_7 = (__pyx_t_2 != 0);
    __pyx_t_9 = __pyx_t_7;
    __pyx_L18_bool_binop_done:;
    if (unlikely(__pyx_t_9)) {

      /* "validator.pyx":4142
 * 
 *         if not hasattr(columns, '__len__') or isinstance(columns, str):
 *             raise TypeError(f"Columns for {input_name} must be a list or a single string.")             # <<<<<<<<<<<<<<
 * 
 *         # Convert to Series or DataFrame based on dimensionality
 */
      __pyx_t_6 = PyTuple_New(3); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4142, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_4 = 0;
      __pyx_t_5 = 127;
      __Pyx_INCREF(__pyx_kp_u_Columns_for);
      __pyx_t_4 += 12;
      __Pyx_GIVEREF(__pyx_kp_u_Columns_for);
      PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_kp_u_Columns_for);
      __pyx_t_3 = __Pyx_PyObject_FormatSimple(__pyx_v_input_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4142, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) > __pyx_t_5) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) : __pyx_t_5;
      __pyx_t_4 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_3);
      __Pyx_GIVEREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_3);
      __pyx_t_3 = 0;
      __Pyx_INCREF(__pyx_kp_u_must_be_a_list_or_a_single_stri);
      __pyx_t_4 += 35;
      __Pyx_GIVEREF(__pyx_kp_u_must_be_a_list_or_a_single_stri);
      PyTuple_SET_ITEM(__pyx_t_6, 2, __pyx_kp_u_must_be_a_list_or_a_single_stri);
      __pyx_t_3 = __Pyx_PyUnicode_Join(__pyx_t_6, 3, __pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4142, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_3); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4142, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_Raise(__pyx_t_6, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __PYX_ERR(0, 4142, __pyx_L1_error)

      /* "validator.pyx":4141
 *             columns = [columns]
 * 
 *         if not hasattr(columns, '__len__') or isinstance(columns, str):             # <<<<<<<<<<<<<<
 *             raise TypeError(f"Columns for {input_name} must be a list or a single string.")
 * 
 */
    }

    /* "validator.pyx":4145
 * 
 *         # Convert to Series or DataFrame based on dimensionality
 *         if X.ndim == 1 or len(X) == len(columns) == 1:  # 1D array or single-column DataFrame             # <<<<<<<<<<<<<<
 *             X = pd.Series(X, name=columns[0])
 *         elif X.ndim == 2:  # 2D array to DataFrame
 */
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_ndim); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4145, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_3 = __Pyx_PyInt_EqObjC(__pyx_t_6, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4145, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 4145, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (!__pyx_t_7) {
    } else {
      __pyx_t_9 = __pyx_t_7;
      goto __pyx_L21_bool_binop_done;
    }
    __pyx_t_4 = PyObject_Length(__pyx_v_X); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 4145, __pyx_L1_error)
    __pyx_t_10 = PyObject_Length(__pyx_v_columns); if (unlikely(__pyx_t_10 == ((Py_ssize_t)-1))) __PYX_ERR(0, 4145, __pyx_L1_error)
    __pyx_t_7 = (__pyx_t_4 == __pyx_t_10);
    if (__pyx_t_7) {
      __pyx_t_7 = (__pyx_t_10 == 1);
    }
    __pyx_t_2 = (__pyx_t_7 != 0);
    __pyx_t_9 = __pyx_t_2;
    __pyx_L21_bool_binop_done:;
    if (__pyx_t_9) {

      /* "validator.pyx":4146
 *         # Convert to Series or DataFrame based on dimensionality
 *         if X.ndim == 1 or len(X) == len(columns) == 1:  # 1D array or single-column DataFrame
 *             X = pd.Series(X, name=columns[0])             # <<<<<<<<<<<<<<
 *         elif X.ndim == 2:  # 2D array to DataFrame
 *             if X.shape[1] != len(columns):
 */
      __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_pd); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4146, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_Series); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4146, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4146, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_INCREF(__pyx_v_X);
      __Pyx_GIVEREF(__pyx_v_X);
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_X);
      __pyx_t_8 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 4146, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_11 = __Pyx_GetItemInt(__pyx_v_columns, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 4146, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_11);
      if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_name_2, __pyx_t_11) < 0) __PYX_ERR(0, 4146, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
      __pyx_t_11 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_3, __pyx_t_8); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 4146, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_11);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_11);
      __pyx_t_11 = 0;

      /* "validator.pyx":4145
 * 
 *         # Convert to Series or DataFrame based on dimensionality
 *         if X.ndim == 1 or len(X) == len(columns) == 1:  # 1D array or single-column DataFrame             # <<<<<<<<<<<<<<
 *             X = pd.Series(X, name=columns[0])
 *         elif X.ndim == 2:  # 2D array to DataFrame
 */
      goto __pyx_L20;
    }

    /* "validator.pyx":4147
 *         if X.ndim == 1 or len(X) == len(columns) == 1:  # 1D array or single-column DataFrame
 *             X = pd.Series(X, name=columns[0])
 *         elif X.ndim == 2:  # 2D array to DataFrame             # <<<<<<<<<<<<<<
 *             if X.shape[1] != len(columns):
 *                 raise ValueError(f"Shape of passed values is {X.shape},"
 */
    __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_ndim); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 4147, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_11);
    __pyx_t_8 = __Pyx_PyInt_EqObjC(__pyx_t_11, __pyx_int_2, 2, 0); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 4147, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
    __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_8); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 4147, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    if (likely(__pyx_t_9)) {

      /* "validator.pyx":4148
 *             X = pd.Series(X, name=columns[0])
 *         elif X.ndim == 2:  # 2D array to DataFrame
 *             if X.shape[1] != len(columns):             # <<<<<<<<<<<<<<
 *                 raise ValueError(f"Shape of passed values is {X.shape},"
 *                                  f" but columns implied {len(columns)}")
 */
      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 4148, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_11 = __Pyx_GetItemInt(__pyx_t_8, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 4148, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_11);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __pyx_t_10 = PyObject_Length(__pyx_v_columns); if (unlikely(__pyx_t_10 == ((Py_ssize_t)-1))) __PYX_ERR(0, 4148, __pyx_L1_error)
      __pyx_t_8 = PyInt_FromSsize_t(__pyx_t_10); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 4148, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_3 = PyObject_RichCompare(__pyx_t_11, __pyx_t_8, Py_NE); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4148, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 4148, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (unlikely(__pyx_t_9)) {

        /* "validator.pyx":4149
 *         elif X.ndim == 2:  # 2D array to DataFrame
 *             if X.shape[1] != len(columns):
 *                 raise ValueError(f"Shape of passed values is {X.shape},"             # <<<<<<<<<<<<<<
 *                                  f" but columns implied {len(columns)}")
 *             X = pd.DataFrame(X, columns=columns)
 */
        __pyx_t_3 = PyTuple_New(4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4149, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_10 = 0;
        __pyx_t_5 = 127;
        __Pyx_INCREF(__pyx_kp_u_Shape_of_passed_values_is);
        __pyx_t_10 += 26;
        __Pyx_GIVEREF(__pyx_kp_u_Shape_of_passed_values_is);
        PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_kp_u_Shape_of_passed_values_is);
        __pyx_t_8 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 4149, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
        __pyx_t_11 = __Pyx_PyObject_FormatSimple(__pyx_t_8, __pyx_empty_unicode); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 4149, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_11);
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
        __pyx_t_5 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_11) > __pyx_t_5) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_11) : __pyx_t_5;
        __pyx_t_10 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_11);
        __Pyx_GIVEREF(__pyx_t_11);
        PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_11);
        __pyx_t_11 = 0;
        __Pyx_INCREF(__pyx_kp_u_but_columns_implied);
        __pyx_t_10 += 22;
        __Pyx_GIVEREF(__pyx_kp_u_but_columns_implied);
        PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_kp_u_but_columns_implied);

        /* "validator.pyx":4150
 *             if X.shape[1] != len(columns):
 *                 raise ValueError(f"Shape of passed values is {X.shape},"
 *                                  f" but columns implied {len(columns)}")             # <<<<<<<<<<<<<<
 *             X = pd.DataFrame(X, columns=columns)
 *         else:
 */
        __pyx_t_4 = PyObject_Length(__pyx_v_columns); if (unlikely(__pyx_t_4 == ((Py_ssize_t)-1))) __PYX_ERR(0, 4150, __pyx_L1_error)
        __pyx_t_11 = __Pyx_PyUnicode_From_Py_ssize_t(__pyx_t_4, 0, ' ', 'd'); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 4150, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_11);
        __pyx_t_10 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_11);
        __Pyx_GIVEREF(__pyx_t_11);
        PyTuple_SET_ITEM(__pyx_t_3, 3, __pyx_t_11);
        __pyx_t_11 = 0;

        /* "validator.pyx":4149
 *         elif X.ndim == 2:  # 2D array to DataFrame
 *             if X.shape[1] != len(columns):
 *                 raise ValueError(f"Shape of passed values is {X.shape},"             # <<<<<<<<<<<<<<
 *                                  f" but columns implied {len(columns)}")
 *             X = pd.DataFrame(X, columns=columns)
 */
        __pyx_t_11 = __Pyx_PyUnicode_Join(__pyx_t_3, 4, __pyx_t_10, __pyx_t_5); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 4149, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_11);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_11); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4149, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
        __Pyx_Raise(__pyx_t_3, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __PYX_ERR(0, 4149, __pyx_L1_error)

        /* "validator.pyx":4148
 *             X = pd.Series(X, name=columns[0])
 *         elif X.ndim == 2:  # 2D array to DataFrame
 *             if X.shape[1] != len(columns):             # <<<<<<<<<<<<<<
 *                 raise ValueError(f"Shape of passed values is {X.shape},"
 *                                  f" but columns implied {len(columns)}")
 */
      }

      /* "validator.pyx":4151
 *                 raise ValueError(f"Shape of passed values is {X.shape},"
 *                                  f" but columns implied {len(columns)}")
 *             X = pd.DataFrame(X, columns=columns)             # <<<<<<<<<<<<<<
 *         else:
 *             raise ValueError(f"{input_name} cannot be converted to DataFrame with given columns.")
 */
      __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_pd); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4151, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_11 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_DataFrame); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 4151, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_11);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4151, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_INCREF(__pyx_v_X);
      __Pyx_GIVEREF(__pyx_v_X);
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_X);
      __pyx_t_8 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 4151, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_columns, __pyx_v_columns) < 0) __PYX_ERR(0, 4151, __pyx_L1_error)
      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_11, __pyx_t_3, __pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4151, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_6);
      __pyx_t_6 = 0;

      /* "validator.pyx":4147
 *         if X.ndim == 1 or len(X) == len(columns) == 1:  # 1D array or single-column DataFrame
 *             X = pd.Series(X, name=columns[0])
 *         elif X.ndim == 2:  # 2D array to DataFrame             # <<<<<<<<<<<<<<
 *             if X.shape[1] != len(columns):
 *                 raise ValueError(f"Shape of passed values is {X.shape},"
 */
      goto __pyx_L20;
    }

    /* "validator.pyx":4153
 *             X = pd.DataFrame(X, columns=columns)
 *         else:
 *             raise ValueError(f"{input_name} cannot be converted to DataFrame with given columns.")             # <<<<<<<<<<<<<<
 * 
 *     return X, columns
 */
    /*else*/ {
      __pyx_t_6 = __Pyx_PyObject_FormatSimple(__pyx_v_input_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4153, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_8 = __Pyx_PyUnicode_Concat(__pyx_t_6, __pyx_kp_u_cannot_be_converted_to_DataFram); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 4153, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_8); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4153, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_Raise(__pyx_t_6, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __PYX_ERR(0, 4153, __pyx_L1_error)
    }
    __pyx_L20:;

    /* "validator.pyx":4133
 *         columns = X.name
 * 
 *     if to_frame and not sp.issparse(X):             # <<<<<<<<<<<<<<
 *         if columns is None:
 *             raise ValueError("Columns must be provided for DataFrame conversion.")
 */
  }

  /* "validator.pyx":4155
 *             raise ValueError(f"{input_name} cannot be converted to DataFrame with given columns.")
 * 
 *     return X, columns             # <<<<<<<<<<<<<<
 * 
 * def is_frame (arr, df_only =False, raise_exception: bool=False,
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4155, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_INCREF(__pyx_v_X);
  __Pyx_GIVEREF(__pyx_v_X);
  PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_v_X);
  __Pyx_INCREF(__pyx_v_columns);
  __Pyx_GIVEREF(__pyx_v_columns);
  PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_v_columns);
  __pyx_r = __pyx_t_6;
  __pyx_t_6 = 0;
  goto __pyx_L0;

  /* "validator.pyx":4085
 *     return X, columns
 * 
 * def convert_array_to_pandas(X, *, to_frame=False, columns=None, input_name='X'):             # <<<<<<<<<<<<<<
 *     """
 *     Converts an array-like object to a pandas DataFrame or Series, applying
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_11);
  __Pyx_AddTraceback("validator.convert_array_to_pandas", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_X);
  __Pyx_XDECREF(__pyx_v_columns);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":4157
 *     return X, columns
 * 
 * def is_frame (arr, df_only =False, raise_exception: bool=False,             # <<<<<<<<<<<<<<
 *               objname=None  ):
 *     """ Return bool wether array is a frame ( pd.Series or pd.DataFrame )
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_145is_frame(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_144is_frame[] = " Return bool wether array is a frame ( pd.Series or pd.DataFrame )\n    \n    To verify whether `arr` is typically a dataframe, set ``df_only =True``. \n    Isolated part of :func:`~.array_to_frame` dedicated to X and y frame\n    reconversion validation.\n    ";
static PyMethodDef __pyx_mdef_9validator_145is_frame = {"is_frame", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_145is_frame, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_144is_frame};
static PyObject *__pyx_pw_9validator_145is_frame(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_arr = 0;
  PyObject *__pyx_v_df_only = 0;
  PyObject *__pyx_v_raise_exception = 0;
  PyObject *__pyx_v_objname = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("is_frame (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_arr,&__pyx_n_s_df_only,&__pyx_n_s_raise_exception,&__pyx_n_s_objname,0};
    PyObject* values[4] = {0,0,0,0};
    values[1] = ((PyObject *)Py_False);
    values[2] = ((PyObject *)Py_False);

    /* "validator.pyx":4158
 * 
 * def is_frame (arr, df_only =False, raise_exception: bool=False,
 *               objname=None  ):             # <<<<<<<<<<<<<<
 *     """ Return bool wether array is a frame ( pd.Series or pd.DataFrame )
 * 
 */
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_arr)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_df_only);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_raise_exception);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_objname);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "is_frame") < 0)) __PYX_ERR(0, 4157, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_arr = values[0];
    __pyx_v_df_only = values[1];
    __pyx_v_raise_exception = values[2];
    __pyx_v_objname = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("is_frame", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4157, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.is_frame", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_144is_frame(__pyx_self, __pyx_v_arr, __pyx_v_df_only, __pyx_v_raise_exception, __pyx_v_objname);

  /* "validator.pyx":4157
 *     return X, columns
 * 
 * def is_frame (arr, df_only =False, raise_exception: bool=False,             # <<<<<<<<<<<<<<
 *               objname=None  ):
 *     """ Return bool wether array is a frame ( pd.Series or pd.DataFrame )
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_144is_frame(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_arr, PyObject *__pyx_v_df_only, PyObject *__pyx_v_raise_exception, PyObject *__pyx_v_objname) {
  int __pyx_v_isf;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  Py_ssize_t __pyx_t_8;
  Py_UCS4 __pyx_t_9;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("is_frame", 0);
  __Pyx_INCREF(__pyx_v_objname);

  /* "validator.pyx":4167
 *     isf= ( hasattr (arr, '__array__') and (
 *                 (hasattr ( arr, 'name') or hasattr (arr, 'columns'))
 *                 ) if not df_only else (             # <<<<<<<<<<<<<<
 *                 hasattr (arr, '__array__') and hasattr(arr, 'columns'))
 *             )
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_df_only); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4167, __pyx_L1_error)
  if (((!__pyx_t_2) != 0)) {

    /* "validator.pyx":4165
 *     reconversion validation.
 *     """
 *     isf= ( hasattr (arr, '__array__') and (             # <<<<<<<<<<<<<<
 *                 (hasattr ( arr, 'name') or hasattr (arr, 'columns'))
 *                 ) if not df_only else (
 */
    __pyx_t_4 = __Pyx_HasAttr(__pyx_v_arr, __pyx_n_u_array_2); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 4165, __pyx_L1_error)
    if (__pyx_t_4) {
    } else {
      __pyx_t_3 = __pyx_t_4;
      goto __pyx_L3_bool_binop_done;
    }

    /* "validator.pyx":4166
 *     """
 *     isf= ( hasattr (arr, '__array__') and (
 *                 (hasattr ( arr, 'name') or hasattr (arr, 'columns'))             # <<<<<<<<<<<<<<
 *                 ) if not df_only else (
 *                 hasattr (arr, '__array__') and hasattr(arr, 'columns'))
 */
    __pyx_t_4 = __Pyx_HasAttr(__pyx_v_arr, __pyx_n_u_name_2); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 4166, __pyx_L1_error)
    if (!__pyx_t_4) {
    } else {
      __pyx_t_3 = __pyx_t_4;
      goto __pyx_L3_bool_binop_done;
    }
    __pyx_t_4 = __Pyx_HasAttr(__pyx_v_arr, __pyx_n_u_columns); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 4166, __pyx_L1_error)
    __pyx_t_3 = __pyx_t_4;
    __pyx_L3_bool_binop_done:;
    __pyx_t_1 = __pyx_t_3;
  } else {

    /* "validator.pyx":4168
 *                 (hasattr ( arr, 'name') or hasattr (arr, 'columns'))
 *                 ) if not df_only else (
 *                 hasattr (arr, '__array__') and hasattr(arr, 'columns'))             # <<<<<<<<<<<<<<
 *             )
 *     if not isf and raise_exception :
 */
    __pyx_t_4 = __Pyx_HasAttr(__pyx_v_arr, __pyx_n_u_array_2); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 4168, __pyx_L1_error)
    if (__pyx_t_4) {
    } else {
      __pyx_t_3 = __pyx_t_4;
      goto __pyx_L6_bool_binop_done;
    }
    __pyx_t_4 = __Pyx_HasAttr(__pyx_v_arr, __pyx_n_u_columns); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 4168, __pyx_L1_error)
    __pyx_t_3 = __pyx_t_4;
    __pyx_L6_bool_binop_done:;
    __pyx_t_1 = __pyx_t_3;
  }
  __pyx_v_isf = __pyx_t_1;

  /* "validator.pyx":4170
 *                 hasattr (arr, '__array__') and hasattr(arr, 'columns'))
 *             )
 *     if not isf and raise_exception :             # <<<<<<<<<<<<<<
 *         # then check only
 *         objname='Expect' if not objname else f'{objname} expects'
 */
  __pyx_t_2 = ((!(__pyx_v_isf != 0)) != 0);
  if (__pyx_t_2) {
  } else {
    __pyx_t_1 = __pyx_t_2;
    goto __pyx_L9_bool_binop_done;
  }
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_raise_exception); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4170, __pyx_L1_error)
  __pyx_t_1 = __pyx_t_2;
  __pyx_L9_bool_binop_done:;
  if (unlikely(__pyx_t_1)) {

    /* "validator.pyx":4172
 *     if not isf and raise_exception :
 *         # then check only
 *         objname='Expect' if not objname else f'{objname} expects'             # <<<<<<<<<<<<<<
 *         raise TypeError(
 *             f"{objname} a {'DataFrame' if df_only else 'data frame or series'}."
 */
    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_objname); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 4172, __pyx_L1_error)
    if (((!__pyx_t_1) != 0)) {
      __Pyx_INCREF(__pyx_n_u_Expect);
      __pyx_t_5 = __pyx_n_u_Expect;
    } else {
      __pyx_t_6 = __Pyx_PyObject_FormatSimple(__pyx_v_objname, __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4172, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_7 = __Pyx_PyUnicode_Concat(__pyx_t_6, __pyx_kp_u_expects); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4172, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_5 = __pyx_t_7;
      __pyx_t_7 = 0;
    }
    __Pyx_DECREF_SET(__pyx_v_objname, __pyx_t_5);
    __pyx_t_5 = 0;

    /* "validator.pyx":4174
 *         objname='Expect' if not objname else f'{objname} expects'
 *         raise TypeError(
 *             f"{objname} a {'DataFrame' if df_only else 'data frame or series'}."             # <<<<<<<<<<<<<<
 *               f" Got {type(arr).__name__!r}")
 *     return isf
 */
    __pyx_t_5 = PyTuple_New(5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4174, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_8 = 0;
    __pyx_t_9 = 127;
    __pyx_t_7 = __Pyx_PyObject_FormatSimple(__pyx_v_objname, __pyx_empty_unicode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4174, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __pyx_t_9 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) > __pyx_t_9) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) : __pyx_t_9;
    __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_7);
    __Pyx_GIVEREF(__pyx_t_7);
    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_7);
    __pyx_t_7 = 0;
    __Pyx_INCREF(__pyx_kp_u_a);
    __pyx_t_8 += 3;
    __Pyx_GIVEREF(__pyx_kp_u_a);
    PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_kp_u_a);
    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_df_only); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 4174, __pyx_L1_error)
    if (__pyx_t_1) {
      __Pyx_INCREF(__pyx_n_u_DataFrame);
      __pyx_t_7 = __pyx_n_u_DataFrame;
    } else {
      __Pyx_INCREF(__pyx_kp_u_data_frame_or_series);
      __pyx_t_7 = __pyx_kp_u_data_frame_or_series;
    }
    __pyx_t_6 = __Pyx_PyUnicode_Unicode(__pyx_t_7); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4174, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __pyx_t_9 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) > __pyx_t_9) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) : __pyx_t_9;
    __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
    __Pyx_GIVEREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_t_6);
    __pyx_t_6 = 0;
    __Pyx_INCREF(__pyx_kp_u_Got);
    __pyx_t_8 += 6;
    __Pyx_GIVEREF(__pyx_kp_u_Got);
    PyTuple_SET_ITEM(__pyx_t_5, 3, __pyx_kp_u_Got);

    /* "validator.pyx":4175
 *         raise TypeError(
 *             f"{objname} a {'DataFrame' if df_only else 'data frame or series'}."
 *               f" Got {type(arr).__name__!r}")             # <<<<<<<<<<<<<<
 *     return isf
 * 
 */
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_arr)), __pyx_n_s_name); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4175, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_7 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_t_6), __pyx_empty_unicode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4175, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_9 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) > __pyx_t_9) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_7) : __pyx_t_9;
    __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_7);
    __Pyx_GIVEREF(__pyx_t_7);
    PyTuple_SET_ITEM(__pyx_t_5, 4, __pyx_t_7);
    __pyx_t_7 = 0;

    /* "validator.pyx":4174
 *         objname='Expect' if not objname else f'{objname} expects'
 *         raise TypeError(
 *             f"{objname} a {'DataFrame' if df_only else 'data frame or series'}."             # <<<<<<<<<<<<<<
 *               f" Got {type(arr).__name__!r}")
 *     return isf
 */
    __pyx_t_7 = __Pyx_PyUnicode_Join(__pyx_t_5, 5, __pyx_t_8, __pyx_t_9); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4174, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

    /* "validator.pyx":4173
 *         # then check only
 *         objname='Expect' if not objname else f'{objname} expects'
 *         raise TypeError(             # <<<<<<<<<<<<<<
 *             f"{objname} a {'DataFrame' if df_only else 'data frame or series'}."
 *               f" Got {type(arr).__name__!r}")
 */
    __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_7); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4173, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __PYX_ERR(0, 4173, __pyx_L1_error)

    /* "validator.pyx":4170
 *                 hasattr (arr, '__array__') and hasattr(arr, 'columns'))
 *             )
 *     if not isf and raise_exception :             # <<<<<<<<<<<<<<
 *         # then check only
 *         objname='Expect' if not objname else f'{objname} expects'
 */
  }

  /* "validator.pyx":4176
 *             f"{objname} a {'DataFrame' if df_only else 'data frame or series'}."
 *               f" Got {type(arr).__name__!r}")
 *     return isf             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_5 = __Pyx_PyBool_FromLong(__pyx_v_isf); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4176, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_r = __pyx_t_5;
  __pyx_t_5 = 0;
  goto __pyx_L0;

  /* "validator.pyx":4157
 *     return X, columns
 * 
 * def is_frame (arr, df_only =False, raise_exception: bool=False,             # <<<<<<<<<<<<<<
 *               objname=None  ):
 *     """ Return bool wether array is a frame ( pd.Series or pd.DataFrame )
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("validator.is_frame", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_objname);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":4179
 * 
 * 
 * def check_array(             # <<<<<<<<<<<<<<
 *     array,
 *     *,
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_147check_array(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_146check_array[] = "Input validation on an array, list, or similar.\n    By default, the input is checked to be a non-empty 2D array containing\n    only finite values. If the dtype of the array is object, attempt\n    converting to float, raising on failure.\n\n    Parameters\n    ----------\n    array : object\n        Input object to check / convert.\n        \n    accept_sparse : str, bool or list/tuple of str, default=False\n        String[s] representing allowed sparse matrix formats, such as 'csc',\n        'csr', etc. If the input is sparse but not in the allowed format,\n        it will be converted to the first listed format. True allows the input\n        to be any format. False means that a sparse matrix input will\n        raise an error.\n    accept_large_sparse : bool, default=True\n        If a CSR, CSC, COO or BSR sparse matrix is supplied and accepted by\n        accept_sparse, accept_large_sparse=False will cause it to be accepted\n        only if its indices are stored with a 32-bit dtype.\n\n    dtype : 'numeric', type, list of type or None, default='numeric'\n        Data type of result. If None, the dtype of the input is preserved.\n        If \"numeric\", dtype is preserved unless array.dtype is object.\n        If dtype is a list of types, conversion on the first type is only\n        performed if the dtype of the input is not in the list.\n    order : {'F', 'C'} or None, default=None\n        Whether an array will be forced to be fortran or c-style.\n        When order is None (default), then if copy=False, nothing is ensured\n        about the memory layout of the output array; otherwise (copy=True)\n        the memory layout of the returned array is kept as close as possible\n        to the original array.\n    copy : bool, default=False\n        Whether a forced copy will be triggered. If copy=False, a copy might\n        be triggered by a conversion.\n    force_all_finite : bool or 'allow-nan', default=True\n        Whether to raise an error on np.inf, np.""nan, pd.NA in array. The\n        possibilities are:\n        - True: Force all values of array to be finite.\n        - False: accepts np.inf, np.nan, pd.NA in array.\n        - 'allow-nan': accepts only np.nan and pd.NA values in array. Values\n          cannot be infinite.\n          ``force_all_finite`` accepts the string ``'allow-nan'``.\n           Accepts `pd.NA` and converts it into `np.nan`\n    ensure_2d : bool, default=True\n        Whether to raise a value error if array is not 2D.\n    ensure_min_samples : int, default=1\n        Make sure that the array has a minimum number of samples in its first\n        axis (rows for a 2D array). Setting to 0 disables this check.\n    ensure_min_features : int, default=1\n        Make sure that the 2D array has some minimum number of features\n        (columns). The default value of 1 rejects empty datasets.\n        This check is only enforced when the input data has effectively 2\n        dimensions or is originally 1D and ``ensure_2d`` is True. Setting to 0\n        disables this check.\n    estimator : str or estimator instance, default=None\n        If passed, include the name of the estimator in warning messages.\n    input_name : str, default=\"\"\n        The data name used to construct the error message. In particular\n        if `input_name` is \"X\" and the data has NaN values and\n        allow_nan is False, the error message will link to the imputer\n        documentation.\n        \n    to_frame: bool, default=False\n        Reconvert array back to pd.Series or pd.DataFrame if \n        the original array is pd.Series or pd.DataFrame.\n        \n    Returns\n    -------\n    array_converted : object\n        The converted and validated array.\n    ";
static PyMethodDef __pyx_mdef_9validator_147check_array = {"check_array", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_147check_array, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_146check_array};
static PyObject *__pyx_pw_9validator_147check_array(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_array = 0;
  PyObject *__pyx_v_accept_large_sparse = 0;
  PyObject *__pyx_v_dtype = 0;
  PyObject *__pyx_v_accept_sparse = 0;
  PyObject *__pyx_v_order = 0;
  PyObject *__pyx_v_copy = 0;
  PyObject *__pyx_v_force_all_finite = 0;
  PyObject *__pyx_v_ensure_2d = 0;
  PyObject *__pyx_v_allow_nd = 0;
  PyObject *__pyx_v_ensure_min_samples = 0;
  PyObject *__pyx_v_ensure_min_features = 0;
  PyObject *__pyx_v_estimator = 0;
  PyObject *__pyx_v_input_name = 0;
  PyObject *__pyx_v_to_frame = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("check_array (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_array,&__pyx_n_s_accept_large_sparse,&__pyx_n_s_dtype,&__pyx_n_s_accept_sparse,&__pyx_n_s_order,&__pyx_n_s_copy,&__pyx_n_s_force_all_finite,&__pyx_n_s_ensure_2d,&__pyx_n_s_allow_nd,&__pyx_n_s_ensure_min_samples,&__pyx_n_s_ensure_min_features,&__pyx_n_s_estimator,&__pyx_n_s_input_name,&__pyx_n_s_to_frame,0};
    PyObject* values[14] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0};

    /* "validator.pyx":4182
 *     array,
 *     *,
 *     accept_large_sparse=True,             # <<<<<<<<<<<<<<
 *     dtype="numeric",
 *     accept_sparse=False,
 */
    values[1] = ((PyObject *)Py_True);
    values[2] = ((PyObject *)__pyx_n_u_numeric);

    /* "validator.pyx":4184
 *     accept_large_sparse=True,
 *     dtype="numeric",
 *     accept_sparse=False,             # <<<<<<<<<<<<<<
 *     order=None,
 *     copy=False,
 */
    values[3] = ((PyObject *)Py_False);

    /* "validator.pyx":4185
 *     dtype="numeric",
 *     accept_sparse=False,
 *     order=None,             # <<<<<<<<<<<<<<
 *     copy=False,
 *     force_all_finite=True,
 */
    values[4] = ((PyObject *)Py_None);

    /* "validator.pyx":4186
 *     accept_sparse=False,
 *     order=None,
 *     copy=False,             # <<<<<<<<<<<<<<
 *     force_all_finite=True,
 *     ensure_2d=True,
 */
    values[5] = ((PyObject *)Py_False);

    /* "validator.pyx":4187
 *     order=None,
 *     copy=False,
 *     force_all_finite=True,             # <<<<<<<<<<<<<<
 *     ensure_2d=True,
 *     allow_nd=False,
 */
    values[6] = ((PyObject *)Py_True);

    /* "validator.pyx":4188
 *     copy=False,
 *     force_all_finite=True,
 *     ensure_2d=True,             # <<<<<<<<<<<<<<
 *     allow_nd=False,
 *     ensure_min_samples=1,
 */
    values[7] = ((PyObject *)Py_True);

    /* "validator.pyx":4189
 *     force_all_finite=True,
 *     ensure_2d=True,
 *     allow_nd=False,             # <<<<<<<<<<<<<<
 *     ensure_min_samples=1,
 *     ensure_min_features=1,
 */
    values[8] = ((PyObject *)Py_False);
    values[9] = ((PyObject *)__pyx_int_1);
    values[10] = ((PyObject *)__pyx_int_1);

    /* "validator.pyx":4192
 *     ensure_min_samples=1,
 *     ensure_min_features=1,
 *     estimator=None,             # <<<<<<<<<<<<<<
 *     input_name="",
 *     to_frame=True,
 */
    values[11] = ((PyObject *)Py_None);
    values[12] = ((PyObject *)__pyx_kp_u__7);

    /* "validator.pyx":4194
 *     estimator=None,
 *     input_name="",
 *     to_frame=True,             # <<<<<<<<<<<<<<
 * ):
 * 
 */
    values[13] = ((PyObject *)Py_True);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_array)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (kw_args > 0 && likely(kw_args <= 13)) {
        Py_ssize_t index;
        for (index = 1; index < 14 && kw_args > 0; index++) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
          if (value) { values[index] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "check_array") < 0)) __PYX_ERR(0, 4179, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_array = values[0];
    __pyx_v_accept_large_sparse = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_accept_sparse = values[3];
    __pyx_v_order = values[4];
    __pyx_v_copy = values[5];
    __pyx_v_force_all_finite = values[6];
    __pyx_v_ensure_2d = values[7];
    __pyx_v_allow_nd = values[8];
    __pyx_v_ensure_min_samples = values[9];
    __pyx_v_ensure_min_features = values[10];
    __pyx_v_estimator = values[11];
    __pyx_v_input_name = values[12];
    __pyx_v_to_frame = values[13];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("check_array", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4179, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.check_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_146check_array(__pyx_self, __pyx_v_array, __pyx_v_accept_large_sparse, __pyx_v_dtype, __pyx_v_accept_sparse, __pyx_v_order, __pyx_v_copy, __pyx_v_force_all_finite, __pyx_v_ensure_2d, __pyx_v_allow_nd, __pyx_v_ensure_min_samples, __pyx_v_ensure_min_features, __pyx_v_estimator, __pyx_v_input_name, __pyx_v_to_frame);

  /* "validator.pyx":4179
 * 
 * 
 * def check_array(             # <<<<<<<<<<<<<<
 *     array,
 *     *,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9validator_11check_array_2generator14(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */

/* "validator.pyx":4315
 *         dtypes_orig = list(array.dtypes)
 *         pandas_requires_conversion = any(
 *             _pandas_dtype_needs_early_conversion(i) for i in dtypes_orig             # <<<<<<<<<<<<<<
 *         )
 *         if all(isinstance(dtype_iter, np.dtype) for dtype_iter in dtypes_orig):
 */

static PyObject *__pyx_pf_9validator_11check_array_genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_9validator___pyx_scope_struct_31_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_31_genexpr *)__pyx_tp_new_9validator___pyx_scope_struct_31_genexpr(__pyx_ptype_9validator___pyx_scope_struct_31_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_31_genexpr *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 4315, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_30_check_array *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9validator_11check_array_2generator14, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_check_array_locals_genexpr, __pyx_n_s_validator); if (unlikely(!gen)) __PYX_ERR(0, 4315, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("validator.check_array.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9validator_11check_array_2generator14(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9validator___pyx_scope_struct_31_genexpr *__pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_31_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genexpr", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 4315, __pyx_L1_error)
  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_dtypes_orig)) { __Pyx_RaiseClosureNameError("dtypes_orig"); __PYX_ERR(0, 4315, __pyx_L1_error) }
  if (unlikely(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_dtypes_orig == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
    __PYX_ERR(0, 4315, __pyx_L1_error)
  }
  __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_dtypes_orig; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
  for (;;) {
    if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 4315, __pyx_L1_error)
    #else
    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4315, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    #endif
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_i);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_i, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_pandas_dtype_needs_early_conver); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4315, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_cur_scope->__pyx_v_i) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_cur_scope->__pyx_v_i);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4315, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 4315, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (__pyx_t_6) {

      /* "validator.pyx":4314
 * 
 *         dtypes_orig = list(array.dtypes)
 *         pandas_requires_conversion = any(             # <<<<<<<<<<<<<<
 *             _pandas_dtype_needs_early_conversion(i) for i in dtypes_orig
 *         )
 */
      __Pyx_XDECREF(__pyx_r);

      /* "validator.pyx":4315
 *         dtypes_orig = list(array.dtypes)
 *         pandas_requires_conversion = any(
 *             _pandas_dtype_needs_early_conversion(i) for i in dtypes_orig             # <<<<<<<<<<<<<<
 *         )
 *         if all(isinstance(dtype_iter, np.dtype) for dtype_iter in dtypes_orig):
 */
      __Pyx_INCREF(Py_True);
      __pyx_r = Py_True;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
  }
  /*else*/ {

    /* "validator.pyx":4314
 * 
 *         dtypes_orig = list(array.dtypes)
 *         pandas_requires_conversion = any(             # <<<<<<<<<<<<<<
 *             _pandas_dtype_needs_early_conversion(i) for i in dtypes_orig
 *         )
 */
    __Pyx_XDECREF(__pyx_r);

    /* "validator.pyx":4315
 *         dtypes_orig = list(array.dtypes)
 *         pandas_requires_conversion = any(
 *             _pandas_dtype_needs_early_conversion(i) for i in dtypes_orig             # <<<<<<<<<<<<<<
 *         )
 *         if all(isinstance(dtype_iter, np.dtype) for dtype_iter in dtypes_orig):
 */
    __Pyx_INCREF(Py_False);
    __pyx_r = Py_False;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    goto __pyx_L0;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  #if !CYTHON_USE_EXC_INFO_STACK
  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
  #endif
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_9validator_11check_array_5generator15(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value); /* proto */

/* "validator.pyx":4317
 *             _pandas_dtype_needs_early_conversion(i) for i in dtypes_orig
 *         )
 *         if all(isinstance(dtype_iter, np.dtype) for dtype_iter in dtypes_orig):             # <<<<<<<<<<<<<<
 *             dtype_orig = np.result_type(*dtypes_orig)
 *     #xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 */

static PyObject *__pyx_pf_9validator_11check_array_3genexpr(PyObject *__pyx_self) {
  struct __pyx_obj_9validator___pyx_scope_struct_32_genexpr *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("genexpr", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_32_genexpr *)__pyx_tp_new_9validator___pyx_scope_struct_32_genexpr(__pyx_ptype_9validator___pyx_scope_struct_32_genexpr, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_32_genexpr *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 4317, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __pyx_cur_scope->__pyx_outer_scope = (struct __pyx_obj_9validator___pyx_scope_struct_30_check_array *) __pyx_self;
  __Pyx_INCREF(((PyObject *)__pyx_cur_scope->__pyx_outer_scope));
  __Pyx_GIVEREF(__pyx_cur_scope->__pyx_outer_scope);
  {
    __pyx_CoroutineObject *gen = __Pyx_Generator_New((__pyx_coroutine_body_t) __pyx_gb_9validator_11check_array_5generator15, NULL, (PyObject *) __pyx_cur_scope, __pyx_n_s_genexpr, __pyx_n_s_check_array_locals_genexpr, __pyx_n_s_validator); if (unlikely(!gen)) __PYX_ERR(0, 4317, __pyx_L1_error)
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("validator.check_array.genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_9validator_11check_array_5generator15(__pyx_CoroutineObject *__pyx_generator, CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_9validator___pyx_scope_struct_32_genexpr *__pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_32_genexpr *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("genexpr", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) __PYX_ERR(0, 4317, __pyx_L1_error)
  if (unlikely(!__pyx_cur_scope->__pyx_outer_scope->__pyx_v_dtypes_orig)) { __Pyx_RaiseClosureNameError("dtypes_orig"); __PYX_ERR(0, 4317, __pyx_L1_error) }
  if (unlikely(__pyx_cur_scope->__pyx_outer_scope->__pyx_v_dtypes_orig == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
    __PYX_ERR(0, 4317, __pyx_L1_error)
  }
  __pyx_t_1 = __pyx_cur_scope->__pyx_outer_scope->__pyx_v_dtypes_orig; __Pyx_INCREF(__pyx_t_1); __pyx_t_2 = 0;
  for (;;) {
    if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_1)) break;
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    __pyx_t_3 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_2); __Pyx_INCREF(__pyx_t_3); __pyx_t_2++; if (unlikely(0 < 0)) __PYX_ERR(0, 4317, __pyx_L1_error)
    #else
    __pyx_t_3 = PySequence_ITEM(__pyx_t_1, __pyx_t_2); __pyx_t_2++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4317, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    #endif
    __Pyx_XGOTREF(__pyx_cur_scope->__pyx_v_dtype_iter);
    __Pyx_XDECREF_SET(__pyx_cur_scope->__pyx_v_dtype_iter, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4317, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_dtype); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4317, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_5 = PyObject_IsInstance(__pyx_cur_scope->__pyx_v_dtype_iter, __pyx_t_4); if (unlikely(__pyx_t_5 == ((int)-1))) __PYX_ERR(0, 4317, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_6 = ((!(__pyx_t_5 != 0)) != 0);
    if (__pyx_t_6) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(Py_False);
      __pyx_r = Py_False;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
  }
  /*else*/ {
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(Py_True);
    __pyx_r = Py_True;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    goto __pyx_L0;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  CYTHON_MAYBE_UNUSED_VAR(__pyx_cur_scope);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("genexpr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  #if !CYTHON_USE_EXC_INFO_STACK
  __Pyx_Coroutine_ResetAndClearException(__pyx_generator);
  #endif
  __pyx_generator->resume_label = -1;
  __Pyx_Coroutine_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":4179
 * 
 * 
 * def check_array(             # <<<<<<<<<<<<<<
 *     array,
 *     *,
 */

static PyObject *__pyx_pf_9validator_146check_array(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_array, PyObject *__pyx_v_accept_large_sparse, PyObject *__pyx_v_dtype, PyObject *__pyx_v_accept_sparse, PyObject *__pyx_v_order, PyObject *__pyx_v_copy, PyObject *__pyx_v_force_all_finite, PyObject *__pyx_v_ensure_2d, PyObject *__pyx_v_allow_nd, PyObject *__pyx_v_ensure_min_samples, PyObject *__pyx_v_ensure_min_features, PyObject *__pyx_v_estimator, PyObject *__pyx_v_input_name, PyObject *__pyx_v_to_frame) {
  struct __pyx_obj_9validator___pyx_scope_struct_30_check_array *__pyx_cur_scope;
  PyObject *__pyx_v_xp = NULL;
  CYTHON_UNUSED PyObject *__pyx_v_is_array_api = NULL;
  PyObject *__pyx_v_column_orig = NULL;
  PyObject *__pyx_v_array_orig = NULL;
  PyObject *__pyx_v_dtype_numeric = NULL;
  PyObject *__pyx_v_dtype_orig = NULL;
  PyObject *__pyx_v_pandas_requires_conversion = NULL;
  PyObject *__pyx_v_new_dtype = NULL;
  PyObject *__pyx_v_estimator_name = NULL;
  PyObject *__pyx_v_complex_warning = NULL;
  PyObject *__pyx_v_n_samples = NULL;
  PyObject *__pyx_v_n_features = NULL;
  PyObject *__pyx_gb_9validator_11check_array_2generator14 = 0;
  PyObject *__pyx_gb_9validator_11check_array_5generator15 = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *(*__pyx_t_7)(PyObject *);
  int __pyx_t_8;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  PyObject *__pyx_t_15 = NULL;
  int __pyx_t_16;
  PyObject *__pyx_t_17 = NULL;
  PyObject *__pyx_t_18 = NULL;
  int __pyx_t_19;
  char const *__pyx_t_20;
  PyObject *__pyx_t_21 = NULL;
  PyObject *__pyx_t_22 = NULL;
  PyObject *__pyx_t_23 = NULL;
  PyObject *__pyx_t_24 = NULL;
  PyObject *__pyx_t_25 = NULL;
  PyObject *__pyx_t_26 = NULL;
  Py_ssize_t __pyx_t_27;
  Py_UCS4 __pyx_t_28;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("check_array", 0);
  __pyx_cur_scope = (struct __pyx_obj_9validator___pyx_scope_struct_30_check_array *)__pyx_tp_new_9validator___pyx_scope_struct_30_check_array(__pyx_ptype_9validator___pyx_scope_struct_30_check_array, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __pyx_cur_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_30_check_array *)Py_None);
    __Pyx_INCREF(Py_None);
    __PYX_ERR(0, 4179, __pyx_L1_error)
  } else {
    __Pyx_GOTREF(__pyx_cur_scope);
  }
  __Pyx_INCREF(__pyx_v_array);
  __Pyx_INCREF(__pyx_v_dtype);

  /* "validator.pyx":4269
 *         The converted and validated array.
 *     """
 *     if isinstance(array, np.matrix):             # <<<<<<<<<<<<<<
 *         raise TypeError(
 *             "np.matrix is not supported. Please convert to a numpy array with "
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4269, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_matrix); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4269, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = PyObject_IsInstance(__pyx_v_array, __pyx_t_2); if (unlikely(__pyx_t_3 == ((int)-1))) __PYX_ERR(0, 4269, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = (__pyx_t_3 != 0);
  if (unlikely(__pyx_t_4)) {

    /* "validator.pyx":4270
 *     """
 *     if isinstance(array, np.matrix):
 *         raise TypeError(             # <<<<<<<<<<<<<<
 *             "np.matrix is not supported. Please convert to a numpy array with "
 *             "np.asarray. For more information see: "
 */
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__108, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4270, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 4270, __pyx_L1_error)

    /* "validator.pyx":4269
 *         The converted and validated array.
 *     """
 *     if isinstance(array, np.matrix):             # <<<<<<<<<<<<<<
 *         raise TypeError(
 *             "np.matrix is not supported. Please convert to a numpy array with "
 */
  }

  /* "validator.pyx":4275
 *             "https://numpy.org/doc/stable/reference/generated/numpy.matrix.html"
 *         )
 *     xp, is_array_api = get_namespace(array)             # <<<<<<<<<<<<<<
 * 
 *     # collect the name or series if
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_get_namespace); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4275, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_5 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_5, __pyx_v_array) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_array);
  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4275, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if ((likely(PyTuple_CheckExact(__pyx_t_2))) || (PyList_CheckExact(__pyx_t_2))) {
    PyObject* sequence = __pyx_t_2;
    Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
    if (unlikely(size != 2)) {
      if (size > 2) __Pyx_RaiseTooManyValuesError(2);
      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
      __PYX_ERR(0, 4275, __pyx_L1_error)
    }
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    if (likely(PyTuple_CheckExact(sequence))) {
      __pyx_t_1 = PyTuple_GET_ITEM(sequence, 0); 
      __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
    } else {
      __pyx_t_1 = PyList_GET_ITEM(sequence, 0); 
      __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
    }
    __Pyx_INCREF(__pyx_t_1);
    __Pyx_INCREF(__pyx_t_5);
    #else
    __pyx_t_1 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4275, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4275, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    #endif
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  } else {
    Py_ssize_t index = -1;
    __pyx_t_6 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4275, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_7 = Py_TYPE(__pyx_t_6)->tp_iternext;
    index = 0; __pyx_t_1 = __pyx_t_7(__pyx_t_6); if (unlikely(!__pyx_t_1)) goto __pyx_L4_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_1);
    index = 1; __pyx_t_5 = __pyx_t_7(__pyx_t_6); if (unlikely(!__pyx_t_5)) goto __pyx_L4_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_5);
    if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_6), 2) < 0) __PYX_ERR(0, 4275, __pyx_L1_error)
    __pyx_t_7 = NULL;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    goto __pyx_L5_unpacking_done;
    __pyx_L4_unpacking_failed:;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_7 = NULL;
    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
    __PYX_ERR(0, 4275, __pyx_L1_error)
    __pyx_L5_unpacking_done:;
  }
  __pyx_v_xp = __pyx_t_1;
  __pyx_t_1 = 0;
  __pyx_v_is_array_api = __pyx_t_5;
  __pyx_t_5 = 0;

  /* "validator.pyx":4281
 *     # and reconvert by to series or dataframe
 *     # array is series or dataframe.
 *     array, column_orig = convert_array_to_pandas(array, input_name=input_name)             # <<<<<<<<<<<<<<
 * 
 *     # store reference to original array to check if copy is needed when
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_convert_array_to_pandas); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4281, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4281, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_INCREF(__pyx_v_array);
  __Pyx_GIVEREF(__pyx_v_array);
  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_array);
  __pyx_t_1 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4281, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_input_name, __pyx_v_input_name) < 0) __PYX_ERR(0, 4281, __pyx_L1_error)
  __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_5, __pyx_t_1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4281, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if ((likely(PyTuple_CheckExact(__pyx_t_6))) || (PyList_CheckExact(__pyx_t_6))) {
    PyObject* sequence = __pyx_t_6;
    Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
    if (unlikely(size != 2)) {
      if (size > 2) __Pyx_RaiseTooManyValuesError(2);
      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
      __PYX_ERR(0, 4281, __pyx_L1_error)
    }
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    if (likely(PyTuple_CheckExact(sequence))) {
      __pyx_t_1 = PyTuple_GET_ITEM(sequence, 0); 
      __pyx_t_5 = PyTuple_GET_ITEM(sequence, 1); 
    } else {
      __pyx_t_1 = PyList_GET_ITEM(sequence, 0); 
      __pyx_t_5 = PyList_GET_ITEM(sequence, 1); 
    }
    __Pyx_INCREF(__pyx_t_1);
    __Pyx_INCREF(__pyx_t_5);
    #else
    __pyx_t_1 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4281, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_5 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4281, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    #endif
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  } else {
    Py_ssize_t index = -1;
    __pyx_t_2 = PyObject_GetIter(__pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4281, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_7 = Py_TYPE(__pyx_t_2)->tp_iternext;
    index = 0; __pyx_t_1 = __pyx_t_7(__pyx_t_2); if (unlikely(!__pyx_t_1)) goto __pyx_L6_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_1);
    index = 1; __pyx_t_5 = __pyx_t_7(__pyx_t_2); if (unlikely(!__pyx_t_5)) goto __pyx_L6_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_5);
    if (__Pyx_IternextUnpackEndCheck(__pyx_t_7(__pyx_t_2), 2) < 0) __PYX_ERR(0, 4281, __pyx_L1_error)
    __pyx_t_7 = NULL;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    goto __pyx_L7_unpacking_done;
    __pyx_L6_unpacking_failed:;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_7 = NULL;
    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
    __PYX_ERR(0, 4281, __pyx_L1_error)
    __pyx_L7_unpacking_done:;
  }
  __Pyx_DECREF_SET(__pyx_v_array, __pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_v_column_orig = __pyx_t_5;
  __pyx_t_5 = 0;

  /* "validator.pyx":4285
 *     # store reference to original array to check if copy is needed when
 *     # function returns
 *     array_orig = array             # <<<<<<<<<<<<<<
 * 
 *     # store whether originally we wanted numeric dtype
 */
  __Pyx_INCREF(__pyx_v_array);
  __pyx_v_array_orig = __pyx_v_array;

  /* "validator.pyx":4288
 * 
 *     # store whether originally we wanted numeric dtype
 *     dtype_numeric = isinstance(dtype, str) and dtype == "numeric"             # <<<<<<<<<<<<<<
 * 
 *     dtype_orig = getattr(array, "dtype", None)
 */
  __pyx_t_4 = PyUnicode_Check(__pyx_v_dtype); 
  if (__pyx_t_4) {
  } else {
    __pyx_t_5 = __Pyx_PyBool_FromLong(__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4288, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = __pyx_t_5;
    __pyx_t_5 = 0;
    goto __pyx_L8_bool_binop_done;
  }
  __pyx_t_5 = PyObject_RichCompare(__pyx_v_dtype, __pyx_n_u_numeric, Py_EQ); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4288, __pyx_L1_error)
  __Pyx_INCREF(__pyx_t_5);
  __pyx_t_6 = __pyx_t_5;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_L8_bool_binop_done:;
  __pyx_v_dtype_numeric = __pyx_t_6;
  __pyx_t_6 = 0;

  /* "validator.pyx":4290
 *     dtype_numeric = isinstance(dtype, str) and dtype == "numeric"
 * 
 *     dtype_orig = getattr(array, "dtype", None)             # <<<<<<<<<<<<<<
 *     if not hasattr(dtype_orig, "kind"):
 *         # not a data type (e.g. a column named dtype in a pandas DataFrame)
 */
  __pyx_t_6 = __Pyx_GetAttr3(__pyx_v_array, __pyx_n_u_dtype, Py_None); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4290, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_v_dtype_orig = __pyx_t_6;
  __pyx_t_6 = 0;

  /* "validator.pyx":4291
 * 
 *     dtype_orig = getattr(array, "dtype", None)
 *     if not hasattr(dtype_orig, "kind"):             # <<<<<<<<<<<<<<
 *         # not a data type (e.g. a column named dtype in a pandas DataFrame)
 *         dtype_orig = None
 */
  __pyx_t_4 = __Pyx_HasAttr(__pyx_v_dtype_orig, __pyx_n_u_kind); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 4291, __pyx_L1_error)
  __pyx_t_3 = ((!(__pyx_t_4 != 0)) != 0);
  if (__pyx_t_3) {

    /* "validator.pyx":4293
 *     if not hasattr(dtype_orig, "kind"):
 *         # not a data type (e.g. a column named dtype in a pandas DataFrame)
 *         dtype_orig = None             # <<<<<<<<<<<<<<
 * 
 *     # check if the object contains several dtypes (typically a pandas
 */
    __Pyx_INCREF(Py_None);
    __Pyx_DECREF_SET(__pyx_v_dtype_orig, Py_None);

    /* "validator.pyx":4291
 * 
 *     dtype_orig = getattr(array, "dtype", None)
 *     if not hasattr(dtype_orig, "kind"):             # <<<<<<<<<<<<<<
 *         # not a data type (e.g. a column named dtype in a pandas DataFrame)
 *         dtype_orig = None
 */
  }

  /* "validator.pyx":4297
 *     # check if the object contains several dtypes (typically a pandas
 *     # DataFrame), and store them. If not, store None.
 *     dtypes_orig = None             # <<<<<<<<<<<<<<
 *     pandas_requires_conversion = False
 * 
 */
  __Pyx_INCREF(Py_None);
  __Pyx_GIVEREF(Py_None);
  __pyx_cur_scope->__pyx_v_dtypes_orig = ((PyObject*)Py_None);

  /* "validator.pyx":4298
 *     # DataFrame), and store them. If not, store None.
 *     dtypes_orig = None
 *     pandas_requires_conversion = False             # <<<<<<<<<<<<<<
 * 
 *     #xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 */
  __Pyx_INCREF(Py_False);
  __pyx_v_pandas_requires_conversion = Py_False;

  /* "validator.pyx":4301
 * 
 *     #xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 *     if hasattr(array, "dtypes") and hasattr(array.dtypes, "__array__"):             # <<<<<<<<<<<<<<
 *         # throw warning if columns are sparse. If all columns are sparse, then
 *         # array.sparse exists and sparsity will be preserved (later).
 */
  __pyx_t_4 = __Pyx_HasAttr(__pyx_v_array, __pyx_n_u_dtypes); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 4301, __pyx_L1_error)
  __pyx_t_8 = (__pyx_t_4 != 0);
  if (__pyx_t_8) {
  } else {
    __pyx_t_3 = __pyx_t_8;
    goto __pyx_L12_bool_binop_done;
  }
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_dtypes); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4301, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __pyx_t_8 = __Pyx_HasAttr(__pyx_t_6, __pyx_n_u_array_2); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(0, 4301, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_4 = (__pyx_t_8 != 0);
  __pyx_t_3 = __pyx_t_4;
  __pyx_L12_bool_binop_done:;
  if (__pyx_t_3) {

    /* "validator.pyx":4304
 *         # throw warning if columns are sparse. If all columns are sparse, then
 *         # array.sparse exists and sparsity will be preserved (later).
 *         with suppress(ImportError):             # <<<<<<<<<<<<<<
 *             # from pandas.api.types import is_sparse
 * 
 */
    /*with:*/ {
      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_suppress); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4304, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_1 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
        __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_5);
        if (likely(__pyx_t_1)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
          __Pyx_INCREF(__pyx_t_1);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_5, function);
        }
      }
      __pyx_t_6 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_1, __pyx_builtin_ImportError) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_builtin_ImportError);
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4304, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_9 = __Pyx_PyObject_LookupSpecial(__pyx_t_6, __pyx_n_s_exit); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 4304, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      __pyx_t_1 = __Pyx_PyObject_LookupSpecial(__pyx_t_6, __pyx_n_s_enter); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4304, __pyx_L14_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_2 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
        __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_1);
        if (likely(__pyx_t_2)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
          __Pyx_INCREF(__pyx_t_2);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_1, function);
        }
      }
      __pyx_t_5 = (__pyx_t_2) ? __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_2) : __Pyx_PyObject_CallNoArg(__pyx_t_1);
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4304, __pyx_L14_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      /*try:*/ {
        {
          __Pyx_PyThreadState_declare
          __Pyx_PyThreadState_assign
          __Pyx_ExceptionSave(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12);
          __Pyx_XGOTREF(__pyx_t_10);
          __Pyx_XGOTREF(__pyx_t_11);
          __Pyx_XGOTREF(__pyx_t_12);
          /*try:*/ {

            /* "validator.pyx":4307
 *             # from pandas.api.types import is_sparse
 * 
 *             if not hasattr(array, "sparse") and isinstance(array, pd.SparseDtype ):             # <<<<<<<<<<<<<<
 *                 warnings.warn(
 *                     "pandas.DataFrame with sparse columns found."
 */
            __pyx_t_4 = __Pyx_HasAttr(__pyx_v_array, __pyx_n_u_sparse); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 4307, __pyx_L18_error)
            __pyx_t_8 = ((!(__pyx_t_4 != 0)) != 0);
            if (__pyx_t_8) {
            } else {
              __pyx_t_3 = __pyx_t_8;
              goto __pyx_L25_bool_binop_done;
            }
            __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_pd); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4307, __pyx_L18_error)
            __Pyx_GOTREF(__pyx_t_6);
            __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_SparseDtype); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4307, __pyx_L18_error)
            __Pyx_GOTREF(__pyx_t_5);
            __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
            __pyx_t_8 = PyObject_IsInstance(__pyx_v_array, __pyx_t_5); if (unlikely(__pyx_t_8 == ((int)-1))) __PYX_ERR(0, 4307, __pyx_L18_error)
            __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
            __pyx_t_4 = (__pyx_t_8 != 0);
            __pyx_t_3 = __pyx_t_4;
            __pyx_L25_bool_binop_done:;
            if (__pyx_t_3) {

              /* "validator.pyx":4308
 * 
 *             if not hasattr(array, "sparse") and isinstance(array, pd.SparseDtype ):
 *                 warnings.warn(             # <<<<<<<<<<<<<<
 *                     "pandas.DataFrame with sparse columns found."
 *                     "It will be converted to a dense numpy array."
 */
              __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_warnings); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4308, __pyx_L18_error)
              __Pyx_GOTREF(__pyx_t_6);
              __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_warn); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4308, __pyx_L18_error)
              __Pyx_GOTREF(__pyx_t_1);
              __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
              __pyx_t_6 = NULL;
              if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
                __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_1);
                if (likely(__pyx_t_6)) {
                  PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
                  __Pyx_INCREF(__pyx_t_6);
                  __Pyx_INCREF(function);
                  __Pyx_DECREF_SET(__pyx_t_1, function);
                }
              }
              __pyx_t_5 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_6, __pyx_kp_u_pandas_DataFrame_with_sparse_col) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_kp_u_pandas_DataFrame_with_sparse_col);
              __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
              if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4308, __pyx_L18_error)
              __Pyx_GOTREF(__pyx_t_5);
              __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
              __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

              /* "validator.pyx":4307
 *             # from pandas.api.types import is_sparse
 * 
 *             if not hasattr(array, "sparse") and isinstance(array, pd.SparseDtype ):             # <<<<<<<<<<<<<<
 *                 warnings.warn(
 *                     "pandas.DataFrame with sparse columns found."
 */
            }

            /* "validator.pyx":4304
 *         # throw warning if columns are sparse. If all columns are sparse, then
 *         # array.sparse exists and sparsity will be preserved (later).
 *         with suppress(ImportError):             # <<<<<<<<<<<<<<
 *             # from pandas.api.types import is_sparse
 * 
 */
          }
          __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
          __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
          __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
          goto __pyx_L23_try_end;
          __pyx_L18_error:;
          __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
          __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
          __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
          /*except:*/ {
            __Pyx_AddTraceback("validator.check_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
            if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_1, &__pyx_t_6) < 0) __PYX_ERR(0, 4304, __pyx_L20_except_error)
            __Pyx_GOTREF(__pyx_t_5);
            __Pyx_GOTREF(__pyx_t_1);
            __Pyx_GOTREF(__pyx_t_6);
            __pyx_t_2 = PyTuple_Pack(3, __pyx_t_5, __pyx_t_1, __pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4304, __pyx_L20_except_error)
            __Pyx_GOTREF(__pyx_t_2);
            __pyx_t_13 = __Pyx_PyObject_Call(__pyx_t_9, __pyx_t_2, NULL);
            __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
            __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
            if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 4304, __pyx_L20_except_error)
            __Pyx_GOTREF(__pyx_t_13);
            __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_13);
            __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
            if (__pyx_t_3 < 0) __PYX_ERR(0, 4304, __pyx_L20_except_error)
            __pyx_t_4 = ((!(__pyx_t_3 != 0)) != 0);
            if (__pyx_t_4) {
              __Pyx_GIVEREF(__pyx_t_5);
              __Pyx_GIVEREF(__pyx_t_1);
              __Pyx_XGIVEREF(__pyx_t_6);
              __Pyx_ErrRestoreWithState(__pyx_t_5, __pyx_t_1, __pyx_t_6);
              __pyx_t_5 = 0; __pyx_t_1 = 0; __pyx_t_6 = 0; 
              __PYX_ERR(0, 4304, __pyx_L20_except_error)
            }
            __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
            __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
            __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
            goto __pyx_L19_exception_handled;
          }
          __pyx_L20_except_error:;
          __Pyx_XGIVEREF(__pyx_t_10);
          __Pyx_XGIVEREF(__pyx_t_11);
          __Pyx_XGIVEREF(__pyx_t_12);
          __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_11, __pyx_t_12);
          goto __pyx_L1_error;
          __pyx_L19_exception_handled:;
          __Pyx_XGIVEREF(__pyx_t_10);
          __Pyx_XGIVEREF(__pyx_t_11);
          __Pyx_XGIVEREF(__pyx_t_12);
          __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_11, __pyx_t_12);
          __pyx_L23_try_end:;
        }
      }
      /*finally:*/ {
        /*normal exit:*/{
          if (__pyx_t_9) {
            __pyx_t_12 = __Pyx_PyObject_Call(__pyx_t_9, __pyx_tuple__109, NULL);
            __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
            if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 4304, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_12);
            __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
          }
          goto __pyx_L17;
        }
        __pyx_L17:;
      }
      goto __pyx_L30;
      __pyx_L14_error:;
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      goto __pyx_L1_error;
      __pyx_L30:;
    }

    /* "validator.pyx":4313
 *                 )
 * 
 *         dtypes_orig = list(array.dtypes)             # <<<<<<<<<<<<<<
 *         pandas_requires_conversion = any(
 *             _pandas_dtype_needs_early_conversion(i) for i in dtypes_orig
 */
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_dtypes); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4313, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_1 = PySequence_List(__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4313, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_GOTREF(__pyx_cur_scope->__pyx_v_dtypes_orig);
    __Pyx_DECREF_SET(__pyx_cur_scope->__pyx_v_dtypes_orig, ((PyObject*)__pyx_t_1));
    __Pyx_GIVEREF(__pyx_t_1);
    __pyx_t_1 = 0;

    /* "validator.pyx":4315
 *         dtypes_orig = list(array.dtypes)
 *         pandas_requires_conversion = any(
 *             _pandas_dtype_needs_early_conversion(i) for i in dtypes_orig             # <<<<<<<<<<<<<<
 *         )
 *         if all(isinstance(dtype_iter, np.dtype) for dtype_iter in dtypes_orig):
 */
    __pyx_t_1 = __pyx_pf_9validator_11check_array_genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4315, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_6 = __Pyx_Generator_Next(__pyx_t_1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4315, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF_SET(__pyx_v_pandas_requires_conversion, __pyx_t_6);
    __pyx_t_6 = 0;

    /* "validator.pyx":4317
 *             _pandas_dtype_needs_early_conversion(i) for i in dtypes_orig
 *         )
 *         if all(isinstance(dtype_iter, np.dtype) for dtype_iter in dtypes_orig):             # <<<<<<<<<<<<<<
 *             dtype_orig = np.result_type(*dtypes_orig)
 *     #xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 */
    __pyx_t_6 = __pyx_pf_9validator_11check_array_3genexpr(((PyObject*)__pyx_cur_scope)); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4317, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_1 = __Pyx_Generator_Next(__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4317, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 4317, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (__pyx_t_4) {

      /* "validator.pyx":4318
 *         )
 *         if all(isinstance(dtype_iter, np.dtype) for dtype_iter in dtypes_orig):
 *             dtype_orig = np.result_type(*dtypes_orig)             # <<<<<<<<<<<<<<
 *     #xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 *     if dtype_numeric:
 */
      __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4318, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_result_type); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4318, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_1 = PySequence_Tuple(__pyx_cur_scope->__pyx_v_dtypes_orig); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4318, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_1, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4318, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_DECREF_SET(__pyx_v_dtype_orig, __pyx_t_5);
      __pyx_t_5 = 0;

      /* "validator.pyx":4317
 *             _pandas_dtype_needs_early_conversion(i) for i in dtypes_orig
 *         )
 *         if all(isinstance(dtype_iter, np.dtype) for dtype_iter in dtypes_orig):             # <<<<<<<<<<<<<<
 *             dtype_orig = np.result_type(*dtypes_orig)
 *     #xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 */
    }

    /* "validator.pyx":4301
 * 
 *     #xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 *     if hasattr(array, "dtypes") and hasattr(array.dtypes, "__array__"):             # <<<<<<<<<<<<<<
 *         # throw warning if columns are sparse. If all columns are sparse, then
 *         # array.sparse exists and sparsity will be preserved (later).
 */
  }

  /* "validator.pyx":4320
 *             dtype_orig = np.result_type(*dtypes_orig)
 *     #xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 *     if dtype_numeric:             # <<<<<<<<<<<<<<
 *         if dtype_orig is not None and dtype_orig.kind == "O":
 *             # if input is object, convert to float.
 */
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_dtype_numeric); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 4320, __pyx_L1_error)
  if (__pyx_t_4) {

    /* "validator.pyx":4321
 *     #xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 *     if dtype_numeric:
 *         if dtype_orig is not None and dtype_orig.kind == "O":             # <<<<<<<<<<<<<<
 *             # if input is object, convert to float.
 *             dtype = xp.float64
 */
    __pyx_t_3 = (__pyx_v_dtype_orig != Py_None);
    __pyx_t_8 = (__pyx_t_3 != 0);
    if (__pyx_t_8) {
    } else {
      __pyx_t_4 = __pyx_t_8;
      goto __pyx_L34_bool_binop_done;
    }
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_dtype_orig, __pyx_n_s_kind); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4321, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_8 = (__Pyx_PyUnicode_Equals(__pyx_t_5, __pyx_n_u_O, Py_EQ)); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 4321, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_4 = __pyx_t_8;
    __pyx_L34_bool_binop_done:;
    if (__pyx_t_4) {

      /* "validator.pyx":4323
 *         if dtype_orig is not None and dtype_orig.kind == "O":
 *             # if input is object, convert to float.
 *             dtype = xp.float64             # <<<<<<<<<<<<<<
 *         else:
 *             dtype = None
 */
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_xp, __pyx_n_s_float64); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4323, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF_SET(__pyx_v_dtype, __pyx_t_5);
      __pyx_t_5 = 0;

      /* "validator.pyx":4321
 *     #xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 *     if dtype_numeric:
 *         if dtype_orig is not None and dtype_orig.kind == "O":             # <<<<<<<<<<<<<<
 *             # if input is object, convert to float.
 *             dtype = xp.float64
 */
      goto __pyx_L33;
    }

    /* "validator.pyx":4325
 *             dtype = xp.float64
 *         else:
 *             dtype = None             # <<<<<<<<<<<<<<
 * 
 *     if isinstance(dtype, (list, tuple)):
 */
    /*else*/ {
      __Pyx_INCREF(Py_None);
      __Pyx_DECREF_SET(__pyx_v_dtype, Py_None);
    }
    __pyx_L33:;

    /* "validator.pyx":4320
 *             dtype_orig = np.result_type(*dtypes_orig)
 *     #xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 *     if dtype_numeric:             # <<<<<<<<<<<<<<
 *         if dtype_orig is not None and dtype_orig.kind == "O":
 *             # if input is object, convert to float.
 */
  }

  /* "validator.pyx":4327
 *             dtype = None
 * 
 *     if isinstance(dtype, (list, tuple)):             # <<<<<<<<<<<<<<
 *         if dtype_orig is not None and dtype_orig in dtype:
 *             # no dtype conversion required
 */
  __pyx_t_8 = PyList_Check(__pyx_v_dtype); 
  __pyx_t_3 = (__pyx_t_8 != 0);
  if (!__pyx_t_3) {
  } else {
    __pyx_t_4 = __pyx_t_3;
    goto __pyx_L37_bool_binop_done;
  }
  __pyx_t_3 = PyTuple_Check(__pyx_v_dtype); 
  __pyx_t_8 = (__pyx_t_3 != 0);
  __pyx_t_4 = __pyx_t_8;
  __pyx_L37_bool_binop_done:;
  __pyx_t_8 = (__pyx_t_4 != 0);
  if (__pyx_t_8) {

    /* "validator.pyx":4328
 * 
 *     if isinstance(dtype, (list, tuple)):
 *         if dtype_orig is not None and dtype_orig in dtype:             # <<<<<<<<<<<<<<
 *             # no dtype conversion required
 *             dtype = None
 */
    __pyx_t_4 = (__pyx_v_dtype_orig != Py_None);
    __pyx_t_3 = (__pyx_t_4 != 0);
    if (__pyx_t_3) {
    } else {
      __pyx_t_8 = __pyx_t_3;
      goto __pyx_L40_bool_binop_done;
    }
    __pyx_t_3 = (__Pyx_PySequence_ContainsTF(__pyx_v_dtype_orig, __pyx_v_dtype, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 4328, __pyx_L1_error)
    __pyx_t_4 = (__pyx_t_3 != 0);
    __pyx_t_8 = __pyx_t_4;
    __pyx_L40_bool_binop_done:;
    if (__pyx_t_8) {

      /* "validator.pyx":4330
 *         if dtype_orig is not None and dtype_orig in dtype:
 *             # no dtype conversion required
 *             dtype = None             # <<<<<<<<<<<<<<
 *         else:
 *             # dtype conversion required. Let's select the first element of the
 */
      __Pyx_INCREF(Py_None);
      __Pyx_DECREF_SET(__pyx_v_dtype, Py_None);

      /* "validator.pyx":4328
 * 
 *     if isinstance(dtype, (list, tuple)):
 *         if dtype_orig is not None and dtype_orig in dtype:             # <<<<<<<<<<<<<<
 *             # no dtype conversion required
 *             dtype = None
 */
      goto __pyx_L39;
    }

    /* "validator.pyx":4334
 *             # dtype conversion required. Let's select the first element of the
 *             # list of accepted types.
 *             dtype = dtype[0]             # <<<<<<<<<<<<<<
 * 
 *     if pandas_requires_conversion:
 */
    /*else*/ {
      __pyx_t_5 = __Pyx_GetItemInt(__pyx_v_dtype, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4334, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF_SET(__pyx_v_dtype, __pyx_t_5);
      __pyx_t_5 = 0;
    }
    __pyx_L39:;

    /* "validator.pyx":4327
 *             dtype = None
 * 
 *     if isinstance(dtype, (list, tuple)):             # <<<<<<<<<<<<<<
 *         if dtype_orig is not None and dtype_orig in dtype:
 *             # no dtype conversion required
 */
  }

  /* "validator.pyx":4336
 *             dtype = dtype[0]
 * 
 *     if pandas_requires_conversion:             # <<<<<<<<<<<<<<
 *         # pandas dataframe requires conversion earlier to handle extension dtypes with
 *         # nans
 */
  __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_v_pandas_requires_conversion); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 4336, __pyx_L1_error)
  if (__pyx_t_8) {

    /* "validator.pyx":4340
 *         # nans
 *         # Use the original dtype for conversion if dtype is None
 *         new_dtype = dtype_orig if dtype is None else dtype             # <<<<<<<<<<<<<<
 *         array = array.astype(new_dtype)
 *         # Since we converted here, we do not need to convert again later
 */
    __pyx_t_8 = (__pyx_v_dtype == Py_None);
    if ((__pyx_t_8 != 0)) {
      __Pyx_INCREF(__pyx_v_dtype_orig);
      __pyx_t_5 = __pyx_v_dtype_orig;
    } else {
      __Pyx_INCREF(__pyx_v_dtype);
      __pyx_t_5 = __pyx_v_dtype;
    }
    __pyx_v_new_dtype = __pyx_t_5;
    __pyx_t_5 = 0;

    /* "validator.pyx":4341
 *         # Use the original dtype for conversion if dtype is None
 *         new_dtype = dtype_orig if dtype is None else dtype
 *         array = array.astype(new_dtype)             # <<<<<<<<<<<<<<
 *         # Since we converted here, we do not need to convert again later
 *         dtype = None
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_astype); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4341, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    __pyx_t_5 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_6, __pyx_v_new_dtype) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_new_dtype);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4341, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF_SET(__pyx_v_array, __pyx_t_5);
    __pyx_t_5 = 0;

    /* "validator.pyx":4343
 *         array = array.astype(new_dtype)
 *         # Since we converted here, we do not need to convert again later
 *         dtype = None             # <<<<<<<<<<<<<<
 * 
 *     if force_all_finite not in (True, False, "allow-nan"):
 */
    __Pyx_INCREF(Py_None);
    __Pyx_DECREF_SET(__pyx_v_dtype, Py_None);

    /* "validator.pyx":4336
 *             dtype = dtype[0]
 * 
 *     if pandas_requires_conversion:             # <<<<<<<<<<<<<<
 *         # pandas dataframe requires conversion earlier to handle extension dtypes with
 *         # nans
 */
  }

  /* "validator.pyx":4345
 *         dtype = None
 * 
 *     if force_all_finite not in (True, False, "allow-nan"):             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             'force_all_finite should be a bool or "allow-nan". Got {!r} instead'.format(
 */
  __Pyx_INCREF(__pyx_v_force_all_finite);
  __pyx_t_5 = __pyx_v_force_all_finite;
  __pyx_t_1 = PyObject_RichCompare(__pyx_t_5, Py_True, Py_NE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4345, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 4345, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_4) {
  } else {
    __pyx_t_8 = __pyx_t_4;
    goto __pyx_L44_bool_binop_done;
  }
  __pyx_t_1 = PyObject_RichCompare(__pyx_t_5, Py_False, Py_NE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4345, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 4345, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_4) {
  } else {
    __pyx_t_8 = __pyx_t_4;
    goto __pyx_L44_bool_binop_done;
  }
  __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_t_5, __pyx_kp_u_allow_nan, Py_NE)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 4345, __pyx_L1_error)
  __pyx_t_8 = __pyx_t_4;
  __pyx_L44_bool_binop_done:;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_4 = (__pyx_t_8 != 0);
  if (unlikely(__pyx_t_4)) {

    /* "validator.pyx":4347
 *     if force_all_finite not in (True, False, "allow-nan"):
 *         raise ValueError(
 *             'force_all_finite should be a bool or "allow-nan". Got {!r} instead'.format(             # <<<<<<<<<<<<<<
 *                 force_all_finite
 *             )
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_kp_u_force_all_finite_should_be_a_boo, __pyx_n_s_format); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4347, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);

    /* "validator.pyx":4348
 *         raise ValueError(
 *             'force_all_finite should be a bool or "allow-nan". Got {!r} instead'.format(
 *                 force_all_finite             # <<<<<<<<<<<<<<
 *             )
 *         )
 */
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    __pyx_t_5 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_6, __pyx_v_force_all_finite) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_force_all_finite);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4347, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "validator.pyx":4346
 * 
 *     if force_all_finite not in (True, False, "allow-nan"):
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             'force_all_finite should be a bool or "allow-nan". Got {!r} instead'.format(
 *                 force_all_finite
 */
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4346, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 4346, __pyx_L1_error)

    /* "validator.pyx":4345
 *         dtype = None
 * 
 *     if force_all_finite not in (True, False, "allow-nan"):             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             'force_all_finite should be a bool or "allow-nan". Got {!r} instead'.format(
 */
  }

  /* "validator.pyx":4351
 *             )
 *         )
 *     estimator_name = _check_estimator_name(estimator)             # <<<<<<<<<<<<<<
 *     #context = " by %s" % estimator_name if estimator is not None else ""
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_check_estimator_name); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4351, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
    }
  }
  __pyx_t_1 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_v_estimator) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_estimator);
  __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4351, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_v_estimator_name = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":4354
 *     #context = " by %s" % estimator_name if estimator is not None else ""
 * 
 *     if sp.issparse(array):             # <<<<<<<<<<<<<<
 *         _ensure_no_complex_data(array)
 *         array = _ensure_sparse_format(
 */
  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_sp); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4354, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_issparse); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4354, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_5 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_6);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_6, function);
    }
  }
  __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_5, __pyx_v_array) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_array);
  __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4354, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 4354, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_4) {

    /* "validator.pyx":4355
 * 
 *     if sp.issparse(array):
 *         _ensure_no_complex_data(array)             # <<<<<<<<<<<<<<
 *         array = _ensure_sparse_format(
 *            array,
 */
    __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_ensure_no_complex_data); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4355, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_6);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_6, function);
      }
    }
    __pyx_t_1 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_5, __pyx_v_array) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_array);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4355, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "validator.pyx":4356
 *     if sp.issparse(array):
 *         _ensure_no_complex_data(array)
 *         array = _ensure_sparse_format(             # <<<<<<<<<<<<<<
 *            array,
 *            accept_sparse=accept_sparse,
 */
    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_ensure_sparse_format); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4356, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);

    /* "validator.pyx":4357
 *         _ensure_no_complex_data(array)
 *         array = _ensure_sparse_format(
 *            array,             # <<<<<<<<<<<<<<
 *            accept_sparse=accept_sparse,
 *            dtype=dtype,
 */
    __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4356, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_INCREF(__pyx_v_array);
    __Pyx_GIVEREF(__pyx_v_array);
    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_v_array);

    /* "validator.pyx":4358
 *         array = _ensure_sparse_format(
 *            array,
 *            accept_sparse=accept_sparse,             # <<<<<<<<<<<<<<
 *            dtype=dtype,
 *            copy=copy,
 */
    __pyx_t_5 = __Pyx_PyDict_NewPresized(7); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4358, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_accept_sparse, __pyx_v_accept_sparse) < 0) __PYX_ERR(0, 4358, __pyx_L1_error)

    /* "validator.pyx":4359
 *            array,
 *            accept_sparse=accept_sparse,
 *            dtype=dtype,             # <<<<<<<<<<<<<<
 *            copy=copy,
 *            force_all_finite=force_all_finite,
 */
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_dtype, __pyx_v_dtype) < 0) __PYX_ERR(0, 4358, __pyx_L1_error)

    /* "validator.pyx":4360
 *            accept_sparse=accept_sparse,
 *            dtype=dtype,
 *            copy=copy,             # <<<<<<<<<<<<<<
 *            force_all_finite=force_all_finite,
 *            accept_large_sparse=accept_large_sparse,
 */
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_copy, __pyx_v_copy) < 0) __PYX_ERR(0, 4358, __pyx_L1_error)

    /* "validator.pyx":4361
 *            dtype=dtype,
 *            copy=copy,
 *            force_all_finite=force_all_finite,             # <<<<<<<<<<<<<<
 *            accept_large_sparse=accept_large_sparse,
 *            estimator_name=estimator_name,
 */
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_force_all_finite, __pyx_v_force_all_finite) < 0) __PYX_ERR(0, 4358, __pyx_L1_error)

    /* "validator.pyx":4362
 *            copy=copy,
 *            force_all_finite=force_all_finite,
 *            accept_large_sparse=accept_large_sparse,             # <<<<<<<<<<<<<<
 *            estimator_name=estimator_name,
 *            input_name=input_name,
 */
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_accept_large_sparse, __pyx_v_accept_large_sparse) < 0) __PYX_ERR(0, 4358, __pyx_L1_error)

    /* "validator.pyx":4363
 *            force_all_finite=force_all_finite,
 *            accept_large_sparse=accept_large_sparse,
 *            estimator_name=estimator_name,             # <<<<<<<<<<<<<<
 *            input_name=input_name,
 *        )
 */
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_estimator_name, __pyx_v_estimator_name) < 0) __PYX_ERR(0, 4358, __pyx_L1_error)

    /* "validator.pyx":4364
 *            accept_large_sparse=accept_large_sparse,
 *            estimator_name=estimator_name,
 *            input_name=input_name,             # <<<<<<<<<<<<<<
 *        )
 * 
 */
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_input_name, __pyx_v_input_name) < 0) __PYX_ERR(0, 4358, __pyx_L1_error)

    /* "validator.pyx":4356
 *     if sp.issparse(array):
 *         _ensure_no_complex_data(array)
 *         array = _ensure_sparse_format(             # <<<<<<<<<<<<<<
 *            array,
 *            accept_sparse=accept_sparse,
 */
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, __pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4356, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF_SET(__pyx_v_array, __pyx_t_2);
    __pyx_t_2 = 0;

    /* "validator.pyx":4354
 *     #context = " by %s" % estimator_name if estimator is not None else ""
 * 
 *     if sp.issparse(array):             # <<<<<<<<<<<<<<
 *         _ensure_no_complex_data(array)
 *         array = _ensure_sparse_format(
 */
    goto __pyx_L47;
  }

  /* "validator.pyx":4373
 *         # thereby passing the test made in the lines following the scope
 *         # of warnings context manager.
 *         with warnings.catch_warnings():             # <<<<<<<<<<<<<<
 *             try:
 *                 warnings.simplefilter("error", ComplexWarning)
 */
  /*else*/ {
    /*with:*/ {
      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_warnings); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4373, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_catch_warnings); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4373, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_5 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
        __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_6);
        if (likely(__pyx_t_5)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
          __Pyx_INCREF(__pyx_t_5);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_6, function);
        }
      }
      __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_6);
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4373, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_9 = __Pyx_PyObject_LookupSpecial(__pyx_t_2, __pyx_n_s_exit); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 4373, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      __pyx_t_5 = __Pyx_PyObject_LookupSpecial(__pyx_t_2, __pyx_n_s_enter); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4373, __pyx_L48_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_1 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
        __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_5);
        if (likely(__pyx_t_1)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
          __Pyx_INCREF(__pyx_t_1);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_5, function);
        }
      }
      __pyx_t_6 = (__pyx_t_1) ? __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_1) : __Pyx_PyObject_CallNoArg(__pyx_t_5);
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4373, __pyx_L48_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      /*try:*/ {
        {
          __Pyx_PyThreadState_declare
          __Pyx_PyThreadState_assign
          __Pyx_ExceptionSave(&__pyx_t_12, &__pyx_t_11, &__pyx_t_10);
          __Pyx_XGOTREF(__pyx_t_12);
          __Pyx_XGOTREF(__pyx_t_11);
          __Pyx_XGOTREF(__pyx_t_10);
          /*try:*/ {

            /* "validator.pyx":4374
 *         # of warnings context manager.
 *         with warnings.catch_warnings():
 *             try:             # <<<<<<<<<<<<<<
 *                 warnings.simplefilter("error", ComplexWarning)
 *                 if dtype is not None and np.dtype(dtype).kind in "iu":
 */
            {
              __Pyx_PyThreadState_declare
              __Pyx_PyThreadState_assign
              __Pyx_ExceptionSave(&__pyx_t_13, &__pyx_t_14, &__pyx_t_15);
              __Pyx_XGOTREF(__pyx_t_13);
              __Pyx_XGOTREF(__pyx_t_14);
              __Pyx_XGOTREF(__pyx_t_15);
              /*try:*/ {

                /* "validator.pyx":4375
 *         with warnings.catch_warnings():
 *             try:
 *                 warnings.simplefilter("error", ComplexWarning)             # <<<<<<<<<<<<<<
 *                 if dtype is not None and np.dtype(dtype).kind in "iu":
 *                     # Conversion float -> int should not contain NaN or
 */
                __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_warnings); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4375, __pyx_L58_error)
                __Pyx_GOTREF(__pyx_t_6);
                __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_simplefilter); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4375, __pyx_L58_error)
                __Pyx_GOTREF(__pyx_t_5);
                __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
                __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_ComplexWarning); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4375, __pyx_L58_error)
                __Pyx_GOTREF(__pyx_t_6);
                __pyx_t_1 = NULL;
                __pyx_t_16 = 0;
                if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
                  __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_5);
                  if (likely(__pyx_t_1)) {
                    PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
                    __Pyx_INCREF(__pyx_t_1);
                    __Pyx_INCREF(function);
                    __Pyx_DECREF_SET(__pyx_t_5, function);
                    __pyx_t_16 = 1;
                  }
                }
                #if CYTHON_FAST_PYCALL
                if (PyFunction_Check(__pyx_t_5)) {
                  PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_n_u_error, __pyx_t_6};
                  __pyx_t_2 = __Pyx_PyFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_16, 2+__pyx_t_16); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4375, __pyx_L58_error)
                  __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
                  __Pyx_GOTREF(__pyx_t_2);
                  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
                } else
                #endif
                #if CYTHON_FAST_PYCCALL
                if (__Pyx_PyFastCFunction_Check(__pyx_t_5)) {
                  PyObject *__pyx_temp[3] = {__pyx_t_1, __pyx_n_u_error, __pyx_t_6};
                  __pyx_t_2 = __Pyx_PyCFunction_FastCall(__pyx_t_5, __pyx_temp+1-__pyx_t_16, 2+__pyx_t_16); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4375, __pyx_L58_error)
                  __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
                  __Pyx_GOTREF(__pyx_t_2);
                  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
                } else
                #endif
                {
                  __pyx_t_17 = PyTuple_New(2+__pyx_t_16); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 4375, __pyx_L58_error)
                  __Pyx_GOTREF(__pyx_t_17);
                  if (__pyx_t_1) {
                    __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_17, 0, __pyx_t_1); __pyx_t_1 = NULL;
                  }
                  __Pyx_INCREF(__pyx_n_u_error);
                  __Pyx_GIVEREF(__pyx_n_u_error);
                  PyTuple_SET_ITEM(__pyx_t_17, 0+__pyx_t_16, __pyx_n_u_error);
                  __Pyx_GIVEREF(__pyx_t_6);
                  PyTuple_SET_ITEM(__pyx_t_17, 1+__pyx_t_16, __pyx_t_6);
                  __pyx_t_6 = 0;
                  __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_17, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4375, __pyx_L58_error)
                  __Pyx_GOTREF(__pyx_t_2);
                  __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
                }
                __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
                __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

                /* "validator.pyx":4376
 *             try:
 *                 warnings.simplefilter("error", ComplexWarning)
 *                 if dtype is not None and np.dtype(dtype).kind in "iu":             # <<<<<<<<<<<<<<
 *                     # Conversion float -> int should not contain NaN or
 *                     # inf (numpy#14412). We cannot use casting='safe' because
 */
                __pyx_t_8 = (__pyx_v_dtype != Py_None);
                __pyx_t_3 = (__pyx_t_8 != 0);
                if (__pyx_t_3) {
                } else {
                  __pyx_t_4 = __pyx_t_3;
                  goto __pyx_L65_bool_binop_done;
                }
                __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_np); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4376, __pyx_L58_error)
                __Pyx_GOTREF(__pyx_t_5);
                __pyx_t_17 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_dtype); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 4376, __pyx_L58_error)
                __Pyx_GOTREF(__pyx_t_17);
                __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
                __pyx_t_5 = NULL;
                if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_17))) {
                  __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_17);
                  if (likely(__pyx_t_5)) {
                    PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_17);
                    __Pyx_INCREF(__pyx_t_5);
                    __Pyx_INCREF(function);
                    __Pyx_DECREF_SET(__pyx_t_17, function);
                  }
                }
                __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_17, __pyx_t_5, __pyx_v_dtype) : __Pyx_PyObject_CallOneArg(__pyx_t_17, __pyx_v_dtype);
                __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
                if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4376, __pyx_L58_error)
                __Pyx_GOTREF(__pyx_t_2);
                __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
                __pyx_t_17 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_kind); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 4376, __pyx_L58_error)
                __Pyx_GOTREF(__pyx_t_17);
                __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                __pyx_t_3 = (__Pyx_PyUnicode_ContainsTF(__pyx_t_17, __pyx_n_u_iu, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 4376, __pyx_L58_error)
                __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
                __pyx_t_8 = (__pyx_t_3 != 0);
                __pyx_t_4 = __pyx_t_8;
                __pyx_L65_bool_binop_done:;
                if (__pyx_t_4) {

                  /* "validator.pyx":4380
 *                     # inf (numpy#14412). We cannot use casting='safe' because
 *                     # then conversion float -> int would be disallowed.
 *                     array = _asarray_with_order(array, order=order, xp=xp)             # <<<<<<<<<<<<<<
 *                     if array.dtype.kind == "f":
 *                         _assert_all_finite(
 */
                  __Pyx_GetModuleGlobalName(__pyx_t_17, __pyx_n_s_asarray_with_order); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 4380, __pyx_L58_error)
                  __Pyx_GOTREF(__pyx_t_17);
                  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4380, __pyx_L58_error)
                  __Pyx_GOTREF(__pyx_t_2);
                  __Pyx_INCREF(__pyx_v_array);
                  __Pyx_GIVEREF(__pyx_v_array);
                  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_array);
                  __pyx_t_5 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4380, __pyx_L58_error)
                  __Pyx_GOTREF(__pyx_t_5);
                  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_order, __pyx_v_order) < 0) __PYX_ERR(0, 4380, __pyx_L58_error)
                  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_xp, __pyx_v_xp) < 0) __PYX_ERR(0, 4380, __pyx_L58_error)
                  __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_17, __pyx_t_2, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4380, __pyx_L58_error)
                  __Pyx_GOTREF(__pyx_t_6);
                  __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
                  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
                  __Pyx_DECREF_SET(__pyx_v_array, __pyx_t_6);
                  __pyx_t_6 = 0;

                  /* "validator.pyx":4381
 *                     # then conversion float -> int would be disallowed.
 *                     array = _asarray_with_order(array, order=order, xp=xp)
 *                     if array.dtype.kind == "f":             # <<<<<<<<<<<<<<
 *                         _assert_all_finite(
 *                             array,
 */
                  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_dtype); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4381, __pyx_L58_error)
                  __Pyx_GOTREF(__pyx_t_6);
                  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_kind); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4381, __pyx_L58_error)
                  __Pyx_GOTREF(__pyx_t_5);
                  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
                  __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_t_5, __pyx_n_u_f, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 4381, __pyx_L58_error)
                  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
                  if (__pyx_t_4) {

                    /* "validator.pyx":4382
 *                     array = _asarray_with_order(array, order=order, xp=xp)
 *                     if array.dtype.kind == "f":
 *                         _assert_all_finite(             # <<<<<<<<<<<<<<
 *                             array,
 *                             allow_nan=False,
 */
                    __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_assert_all_finite); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4382, __pyx_L58_error)
                    __Pyx_GOTREF(__pyx_t_5);

                    /* "validator.pyx":4383
 *                     if array.dtype.kind == "f":
 *                         _assert_all_finite(
 *                             array,             # <<<<<<<<<<<<<<
 *                             allow_nan=False,
 *                             msg_dtype=dtype,
 */
                    __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4382, __pyx_L58_error)
                    __Pyx_GOTREF(__pyx_t_6);
                    __Pyx_INCREF(__pyx_v_array);
                    __Pyx_GIVEREF(__pyx_v_array);
                    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_v_array);

                    /* "validator.pyx":4384
 *                         _assert_all_finite(
 *                             array,
 *                             allow_nan=False,             # <<<<<<<<<<<<<<
 *                             msg_dtype=dtype,
 *                             estimator_name=estimator_name,
 */
                    __pyx_t_2 = __Pyx_PyDict_NewPresized(4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4384, __pyx_L58_error)
                    __Pyx_GOTREF(__pyx_t_2);
                    if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_allow_nan_2, Py_False) < 0) __PYX_ERR(0, 4384, __pyx_L58_error)

                    /* "validator.pyx":4385
 *                             array,
 *                             allow_nan=False,
 *                             msg_dtype=dtype,             # <<<<<<<<<<<<<<
 *                             estimator_name=estimator_name,
 *                             input_name=input_name,
 */
                    if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_msg_dtype, __pyx_v_dtype) < 0) __PYX_ERR(0, 4384, __pyx_L58_error)

                    /* "validator.pyx":4386
 *                             allow_nan=False,
 *                             msg_dtype=dtype,
 *                             estimator_name=estimator_name,             # <<<<<<<<<<<<<<
 *                             input_name=input_name,
 *                         )
 */
                    if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_estimator_name, __pyx_v_estimator_name) < 0) __PYX_ERR(0, 4384, __pyx_L58_error)

                    /* "validator.pyx":4387
 *                             msg_dtype=dtype,
 *                             estimator_name=estimator_name,
 *                             input_name=input_name,             # <<<<<<<<<<<<<<
 *                         )
 *                     array = xp.astype(array, dtype, copy=False)
 */
                    if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_input_name, __pyx_v_input_name) < 0) __PYX_ERR(0, 4384, __pyx_L58_error)

                    /* "validator.pyx":4382
 *                     array = _asarray_with_order(array, order=order, xp=xp)
 *                     if array.dtype.kind == "f":
 *                         _assert_all_finite(             # <<<<<<<<<<<<<<
 *                             array,
 *                             allow_nan=False,
 */
                    __pyx_t_17 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, __pyx_t_2); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 4382, __pyx_L58_error)
                    __Pyx_GOTREF(__pyx_t_17);
                    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
                    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
                    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                    __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;

                    /* "validator.pyx":4381
 *                     # then conversion float -> int would be disallowed.
 *                     array = _asarray_with_order(array, order=order, xp=xp)
 *                     if array.dtype.kind == "f":             # <<<<<<<<<<<<<<
 *                         _assert_all_finite(
 *                             array,
 */
                  }

                  /* "validator.pyx":4389
 *                             input_name=input_name,
 *                         )
 *                     array = xp.astype(array, dtype, copy=False)             # <<<<<<<<<<<<<<
 *                 else:
 *                     array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)
 */
                  __pyx_t_17 = __Pyx_PyObject_GetAttrStr(__pyx_v_xp, __pyx_n_s_astype); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 4389, __pyx_L58_error)
                  __Pyx_GOTREF(__pyx_t_17);
                  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4389, __pyx_L58_error)
                  __Pyx_GOTREF(__pyx_t_2);
                  __Pyx_INCREF(__pyx_v_array);
                  __Pyx_GIVEREF(__pyx_v_array);
                  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_array);
                  __Pyx_INCREF(__pyx_v_dtype);
                  __Pyx_GIVEREF(__pyx_v_dtype);
                  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_dtype);
                  __pyx_t_6 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4389, __pyx_L58_error)
                  __Pyx_GOTREF(__pyx_t_6);
                  if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_copy, Py_False) < 0) __PYX_ERR(0, 4389, __pyx_L58_error)
                  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_17, __pyx_t_2, __pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4389, __pyx_L58_error)
                  __Pyx_GOTREF(__pyx_t_5);
                  __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
                  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
                  __Pyx_DECREF_SET(__pyx_v_array, __pyx_t_5);
                  __pyx_t_5 = 0;

                  /* "validator.pyx":4376
 *             try:
 *                 warnings.simplefilter("error", ComplexWarning)
 *                 if dtype is not None and np.dtype(dtype).kind in "iu":             # <<<<<<<<<<<<<<
 *                     # Conversion float -> int should not contain NaN or
 *                     # inf (numpy#14412). We cannot use casting='safe' because
 */
                  goto __pyx_L64;
                }

                /* "validator.pyx":4391
 *                     array = xp.astype(array, dtype, copy=False)
 *                 else:
 *                     array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)             # <<<<<<<<<<<<<<
 *             except ComplexWarning as complex_warning:
 *                 raise ValueError(
 */
                /*else*/ {
                  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_asarray_with_order); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4391, __pyx_L58_error)
                  __Pyx_GOTREF(__pyx_t_5);
                  __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4391, __pyx_L58_error)
                  __Pyx_GOTREF(__pyx_t_6);
                  __Pyx_INCREF(__pyx_v_array);
                  __Pyx_GIVEREF(__pyx_v_array);
                  PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_v_array);
                  __pyx_t_2 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4391, __pyx_L58_error)
                  __Pyx_GOTREF(__pyx_t_2);
                  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_order, __pyx_v_order) < 0) __PYX_ERR(0, 4391, __pyx_L58_error)
                  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_dtype, __pyx_v_dtype) < 0) __PYX_ERR(0, 4391, __pyx_L58_error)
                  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_xp, __pyx_v_xp) < 0) __PYX_ERR(0, 4391, __pyx_L58_error)
                  __pyx_t_17 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_6, __pyx_t_2); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 4391, __pyx_L58_error)
                  __Pyx_GOTREF(__pyx_t_17);
                  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
                  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
                  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                  __Pyx_DECREF_SET(__pyx_v_array, __pyx_t_17);
                  __pyx_t_17 = 0;
                }
                __pyx_L64:;

                /* "validator.pyx":4374
 *         # of warnings context manager.
 *         with warnings.catch_warnings():
 *             try:             # <<<<<<<<<<<<<<
 *                 warnings.simplefilter("error", ComplexWarning)
 *                 if dtype is not None and np.dtype(dtype).kind in "iu":
 */
              }
              __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
              __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;
              __Pyx_XDECREF(__pyx_t_15); __pyx_t_15 = 0;
              goto __pyx_L63_try_end;
              __pyx_L58_error:;
              __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
              __Pyx_XDECREF(__pyx_t_17); __pyx_t_17 = 0;
              __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
              __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
              __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;

              /* "validator.pyx":4392
 *                 else:
 *                     array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)
 *             except ComplexWarning as complex_warning:             # <<<<<<<<<<<<<<
 *                 raise ValueError(
 *                     "Complex data not supported\n{}\n".format(array)
 */
              __Pyx_ErrFetch(&__pyx_t_17, &__pyx_t_2, &__pyx_t_6);
              __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_ComplexWarning); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4392, __pyx_L60_except_error)
              __Pyx_GOTREF(__pyx_t_5);
              __pyx_t_16 = __Pyx_PyErr_GivenExceptionMatches(__pyx_t_17, __pyx_t_5);
              __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
              __Pyx_ErrRestore(__pyx_t_17, __pyx_t_2, __pyx_t_6);
              __pyx_t_17 = 0; __pyx_t_2 = 0; __pyx_t_6 = 0;
              if (__pyx_t_16) {
                __Pyx_AddTraceback("validator.check_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
                if (__Pyx_GetException(&__pyx_t_6, &__pyx_t_2, &__pyx_t_17) < 0) __PYX_ERR(0, 4392, __pyx_L60_except_error)
                __Pyx_GOTREF(__pyx_t_6);
                __Pyx_GOTREF(__pyx_t_2);
                __Pyx_GOTREF(__pyx_t_17);
                __Pyx_INCREF(__pyx_t_2);
                __pyx_v_complex_warning = __pyx_t_2;
                /*try:*/ {

                  /* "validator.pyx":4394
 *             except ComplexWarning as complex_warning:
 *                 raise ValueError(
 *                     "Complex data not supported\n{}\n".format(array)             # <<<<<<<<<<<<<<
 *                 ) from complex_warning
 * 
 */
                  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_kp_u_Complex_data_not_supported, __pyx_n_s_format); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4394, __pyx_L73_error)
                  __Pyx_GOTREF(__pyx_t_1);
                  __pyx_t_18 = NULL;
                  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
                    __pyx_t_18 = PyMethod_GET_SELF(__pyx_t_1);
                    if (likely(__pyx_t_18)) {
                      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
                      __Pyx_INCREF(__pyx_t_18);
                      __Pyx_INCREF(function);
                      __Pyx_DECREF_SET(__pyx_t_1, function);
                    }
                  }
                  __pyx_t_5 = (__pyx_t_18) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_18, __pyx_v_array) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_array);
                  __Pyx_XDECREF(__pyx_t_18); __pyx_t_18 = 0;
                  if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4394, __pyx_L73_error)
                  __Pyx_GOTREF(__pyx_t_5);
                  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

                  /* "validator.pyx":4393
 *                     array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)
 *             except ComplexWarning as complex_warning:
 *                 raise ValueError(             # <<<<<<<<<<<<<<
 *                     "Complex data not supported\n{}\n".format(array)
 *                 ) from complex_warning
 */
                  __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4393, __pyx_L73_error)
                  __Pyx_GOTREF(__pyx_t_1);
                  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

                  /* "validator.pyx":4395
 *                 raise ValueError(
 *                     "Complex data not supported\n{}\n".format(array)
 *                 ) from complex_warning             # <<<<<<<<<<<<<<
 * 
 *         # It is possible that the np.array(..) gave no warning. This happens
 */
                  __Pyx_Raise(__pyx_t_1, 0, 0, __pyx_v_complex_warning);
                  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
                  __PYX_ERR(0, 4393, __pyx_L73_error)
                }

                /* "validator.pyx":4392
 *                 else:
 *                     array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)
 *             except ComplexWarning as complex_warning:             # <<<<<<<<<<<<<<
 *                 raise ValueError(
 *                     "Complex data not supported\n{}\n".format(array)
 */
                /*finally:*/ {
                  __pyx_L73_error:;
                  /*exception exit:*/{
                    __Pyx_PyThreadState_declare
                    __Pyx_PyThreadState_assign
                    __pyx_t_21 = 0; __pyx_t_22 = 0; __pyx_t_23 = 0; __pyx_t_24 = 0; __pyx_t_25 = 0; __pyx_t_26 = 0;
                    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
                    __Pyx_XDECREF(__pyx_t_18); __pyx_t_18 = 0;
                    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
                    if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_24, &__pyx_t_25, &__pyx_t_26);
                    if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_21, &__pyx_t_22, &__pyx_t_23) < 0)) __Pyx_ErrFetch(&__pyx_t_21, &__pyx_t_22, &__pyx_t_23);
                    __Pyx_XGOTREF(__pyx_t_21);
                    __Pyx_XGOTREF(__pyx_t_22);
                    __Pyx_XGOTREF(__pyx_t_23);
                    __Pyx_XGOTREF(__pyx_t_24);
                    __Pyx_XGOTREF(__pyx_t_25);
                    __Pyx_XGOTREF(__pyx_t_26);
                    __pyx_t_16 = __pyx_lineno; __pyx_t_19 = __pyx_clineno; __pyx_t_20 = __pyx_filename;
                    {
                      __Pyx_DECREF(__pyx_v_complex_warning);
                      __pyx_v_complex_warning = NULL;
                    }
                    if (PY_MAJOR_VERSION >= 3) {
                      __Pyx_XGIVEREF(__pyx_t_24);
                      __Pyx_XGIVEREF(__pyx_t_25);
                      __Pyx_XGIVEREF(__pyx_t_26);
                      __Pyx_ExceptionReset(__pyx_t_24, __pyx_t_25, __pyx_t_26);
                    }
                    __Pyx_XGIVEREF(__pyx_t_21);
                    __Pyx_XGIVEREF(__pyx_t_22);
                    __Pyx_XGIVEREF(__pyx_t_23);
                    __Pyx_ErrRestore(__pyx_t_21, __pyx_t_22, __pyx_t_23);
                    __pyx_t_21 = 0; __pyx_t_22 = 0; __pyx_t_23 = 0; __pyx_t_24 = 0; __pyx_t_25 = 0; __pyx_t_26 = 0;
                    __pyx_lineno = __pyx_t_16; __pyx_clineno = __pyx_t_19; __pyx_filename = __pyx_t_20;
                    goto __pyx_L60_except_error;
                  }
                }
              }
              goto __pyx_L60_except_error;
              __pyx_L60_except_error:;

              /* "validator.pyx":4374
 *         # of warnings context manager.
 *         with warnings.catch_warnings():
 *             try:             # <<<<<<<<<<<<<<
 *                 warnings.simplefilter("error", ComplexWarning)
 *                 if dtype is not None and np.dtype(dtype).kind in "iu":
 */
              __Pyx_XGIVEREF(__pyx_t_13);
              __Pyx_XGIVEREF(__pyx_t_14);
              __Pyx_XGIVEREF(__pyx_t_15);
              __Pyx_ExceptionReset(__pyx_t_13, __pyx_t_14, __pyx_t_15);
              goto __pyx_L52_error;
              __pyx_L63_try_end:;
            }

            /* "validator.pyx":4373
 *         # thereby passing the test made in the lines following the scope
 *         # of warnings context manager.
 *         with warnings.catch_warnings():             # <<<<<<<<<<<<<<
 *             try:
 *                 warnings.simplefilter("error", ComplexWarning)
 */
          }
          __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
          __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
          __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
          goto __pyx_L57_try_end;
          __pyx_L52_error:;
          __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
          __Pyx_XDECREF(__pyx_t_17); __pyx_t_17 = 0;
          __Pyx_XDECREF(__pyx_t_18); __pyx_t_18 = 0;
          __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
          __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
          /*except:*/ {
            __Pyx_AddTraceback("validator.check_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
            if (__Pyx_GetException(&__pyx_t_17, &__pyx_t_2, &__pyx_t_6) < 0) __PYX_ERR(0, 4373, __pyx_L54_except_error)
            __Pyx_GOTREF(__pyx_t_17);
            __Pyx_GOTREF(__pyx_t_2);
            __Pyx_GOTREF(__pyx_t_6);
            __pyx_t_1 = PyTuple_Pack(3, __pyx_t_17, __pyx_t_2, __pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4373, __pyx_L54_except_error)
            __Pyx_GOTREF(__pyx_t_1);
            __pyx_t_15 = __Pyx_PyObject_Call(__pyx_t_9, __pyx_t_1, NULL);
            __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
            __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
            if (unlikely(!__pyx_t_15)) __PYX_ERR(0, 4373, __pyx_L54_except_error)
            __Pyx_GOTREF(__pyx_t_15);
            __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_15);
            __Pyx_DECREF(__pyx_t_15); __pyx_t_15 = 0;
            if (__pyx_t_4 < 0) __PYX_ERR(0, 4373, __pyx_L54_except_error)
            __pyx_t_8 = ((!(__pyx_t_4 != 0)) != 0);
            if (__pyx_t_8) {
              __Pyx_GIVEREF(__pyx_t_17);
              __Pyx_GIVEREF(__pyx_t_2);
              __Pyx_XGIVEREF(__pyx_t_6);
              __Pyx_ErrRestoreWithState(__pyx_t_17, __pyx_t_2, __pyx_t_6);
              __pyx_t_17 = 0; __pyx_t_2 = 0; __pyx_t_6 = 0; 
              __PYX_ERR(0, 4373, __pyx_L54_except_error)
            }
            __Pyx_XDECREF(__pyx_t_17); __pyx_t_17 = 0;
            __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
            __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
            goto __pyx_L53_exception_handled;
          }
          __pyx_L54_except_error:;
          __Pyx_XGIVEREF(__pyx_t_12);
          __Pyx_XGIVEREF(__pyx_t_11);
          __Pyx_XGIVEREF(__pyx_t_10);
          __Pyx_ExceptionReset(__pyx_t_12, __pyx_t_11, __pyx_t_10);
          goto __pyx_L1_error;
          __pyx_L53_exception_handled:;
          __Pyx_XGIVEREF(__pyx_t_12);
          __Pyx_XGIVEREF(__pyx_t_11);
          __Pyx_XGIVEREF(__pyx_t_10);
          __Pyx_ExceptionReset(__pyx_t_12, __pyx_t_11, __pyx_t_10);
          __pyx_L57_try_end:;
        }
      }
      /*finally:*/ {
        /*normal exit:*/{
          if (__pyx_t_9) {
            __pyx_t_10 = __Pyx_PyObject_Call(__pyx_t_9, __pyx_tuple__109, NULL);
            __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
            if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 4373, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_10);
            __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
          }
          goto __pyx_L51;
        }
        __pyx_L51:;
      }
      goto __pyx_L82;
      __pyx_L48_error:;
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      goto __pyx_L1_error;
      __pyx_L82:;
    }

    /* "validator.pyx":4401
 *         # result is that np.array(..) produces an array of complex dtype
 *         # and we need to catch and raise exception for such cases.
 *         _ensure_no_complex_data(array)             # <<<<<<<<<<<<<<
 * 
 *         if len(array) ==0:
 */
    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_ensure_no_complex_data); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4401, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_17 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_17 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_17)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_17);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    __pyx_t_6 = (__pyx_t_17) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_17, __pyx_v_array) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_array);
    __Pyx_XDECREF(__pyx_t_17); __pyx_t_17 = 0;
    if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4401, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

    /* "validator.pyx":4403
 *         _ensure_no_complex_data(array)
 * 
 *         if len(array) ==0:             # <<<<<<<<<<<<<<
 *            raise ValueError (
 *                "Found array with 0 length while a minimum of 1 is required." )
 */
    __pyx_t_27 = PyObject_Length(__pyx_v_array); if (unlikely(__pyx_t_27 == ((Py_ssize_t)-1))) __PYX_ERR(0, 4403, __pyx_L1_error)
    __pyx_t_8 = ((__pyx_t_27 == 0) != 0);
    if (unlikely(__pyx_t_8)) {

      /* "validator.pyx":4404
 * 
 *         if len(array) ==0:
 *            raise ValueError (             # <<<<<<<<<<<<<<
 *                "Found array with 0 length while a minimum of 1 is required." )
 *         if ensure_2d:
 */
      __pyx_t_6 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__110, NULL); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4404, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_Raise(__pyx_t_6, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __PYX_ERR(0, 4404, __pyx_L1_error)

      /* "validator.pyx":4403
 *         _ensure_no_complex_data(array)
 * 
 *         if len(array) ==0:             # <<<<<<<<<<<<<<
 *            raise ValueError (
 *                "Found array with 0 length while a minimum of 1 is required." )
 */
    }

    /* "validator.pyx":4406
 *            raise ValueError (
 *                "Found array with 0 length while a minimum of 1 is required." )
 *         if ensure_2d:             # <<<<<<<<<<<<<<
 *             # If input is scalar raise error
 *             if  array.ndim == 0:
 */
    __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_v_ensure_2d); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 4406, __pyx_L1_error)
    if (__pyx_t_8) {

      /* "validator.pyx":4408
 *         if ensure_2d:
 *             # If input is scalar raise error
 *             if  array.ndim == 0:             # <<<<<<<<<<<<<<
 *                 raise ValueError(
 *                     "Expected 2D array, got scalar array instead:\narray={}.\n"
 */
      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_ndim); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4408, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_2 = __Pyx_PyInt_EqObjC(__pyx_t_6, __pyx_int_0, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4408, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 4408, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      if (unlikely(__pyx_t_8)) {

        /* "validator.pyx":4413
 *                     "Reshape your data either using array.reshape(-1, 1) if "
 *                     "your data has a single feature or array.reshape(1, -1) "
 *                     "if it contains a single sample.".format(array)             # <<<<<<<<<<<<<<
 *                 )
 *             # If input is 1D raise error
 */
        __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_kp_u_Expected_2D_array_got_scalar_arr, __pyx_n_s_format); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4413, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __pyx_t_17 = NULL;
        if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_6))) {
          __pyx_t_17 = PyMethod_GET_SELF(__pyx_t_6);
          if (likely(__pyx_t_17)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
            __Pyx_INCREF(__pyx_t_17);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_6, function);
          }
        }
        __pyx_t_2 = (__pyx_t_17) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_17, __pyx_v_array) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_array);
        __Pyx_XDECREF(__pyx_t_17); __pyx_t_17 = 0;
        if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4413, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

        /* "validator.pyx":4409
 *             # If input is scalar raise error
 *             if  array.ndim == 0:
 *                 raise ValueError(             # <<<<<<<<<<<<<<
 *                     "Expected 2D array, got scalar array instead:\narray={}.\n"
 *                     "Reshape your data either using array.reshape(-1, 1) if "
 */
        __pyx_t_6 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4409, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_Raise(__pyx_t_6, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        __PYX_ERR(0, 4409, __pyx_L1_error)

        /* "validator.pyx":4408
 *         if ensure_2d:
 *             # If input is scalar raise error
 *             if  array.ndim == 0:             # <<<<<<<<<<<<<<
 *                 raise ValueError(
 *                     "Expected 2D array, got scalar array instead:\narray={}.\n"
 */
      }

      /* "validator.pyx":4416
 *                 )
 *             # If input is 1D raise error
 *             if array.ndim == 1:             # <<<<<<<<<<<<<<
 *                 raise ValueError(
 *                     "Expected 2D array, got 1D array instead. "
 */
      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_ndim); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4416, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_2 = __Pyx_PyInt_EqObjC(__pyx_t_6, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4416, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 4416, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      if (unlikely(__pyx_t_8)) {

        /* "validator.pyx":4417
 *             # If input is 1D raise error
 *             if array.ndim == 1:
 *                 raise ValueError(             # <<<<<<<<<<<<<<
 *                     "Expected 2D array, got 1D array instead. "
 *                     "Reshape your data either using array.reshape(-1, 1) if "
 */
        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__111, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4417, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_Raise(__pyx_t_2, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __PYX_ERR(0, 4417, __pyx_L1_error)

        /* "validator.pyx":4416
 *                 )
 *             # If input is 1D raise error
 *             if array.ndim == 1:             # <<<<<<<<<<<<<<
 *                 raise ValueError(
 *                     "Expected 2D array, got 1D array instead. "
 */
      }

      /* "validator.pyx":4406
 *            raise ValueError (
 *                "Found array with 0 length while a minimum of 1 is required." )
 *         if ensure_2d:             # <<<<<<<<<<<<<<
 *             # If input is scalar raise error
 *             if  array.ndim == 0:
 */
    }

    /* "validator.pyx":4424
 *                 )
 * 
 *         if  ( dtype_numeric             # <<<<<<<<<<<<<<
 *              and ( array.values.dtype.kind if hasattr(array, 'columns')
 *                   else array.dtype.kind)
 */
    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_dtype_numeric); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 4424, __pyx_L1_error)
    if (__pyx_t_4) {
    } else {
      __pyx_t_8 = __pyx_t_4;
      goto __pyx_L88_bool_binop_done;
    }

    /* "validator.pyx":4425
 * 
 *         if  ( dtype_numeric
 *              and ( array.values.dtype.kind if hasattr(array, 'columns')             # <<<<<<<<<<<<<<
 *                   else array.dtype.kind)
 *              in "USV"
 */
    __pyx_t_4 = __Pyx_HasAttr(__pyx_v_array, __pyx_n_u_columns); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(0, 4425, __pyx_L1_error)
    if ((__pyx_t_4 != 0)) {
      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_values); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4425, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_17 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_dtype); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 4425, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_17);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_17, __pyx_n_s_kind); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4425, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
      __pyx_t_2 = __pyx_t_6;
      __pyx_t_6 = 0;
    } else {

      /* "validator.pyx":4426
 *         if  ( dtype_numeric
 *              and ( array.values.dtype.kind if hasattr(array, 'columns')
 *                   else array.dtype.kind)             # <<<<<<<<<<<<<<
 *              in "USV"
 *              ):
 */
      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_dtype); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4426, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_17 = __Pyx_PyObject_GetAttrStr(__pyx_t_6, __pyx_n_s_kind); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 4426, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_17);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_2 = __pyx_t_17;
      __pyx_t_17 = 0;
    }
    __pyx_t_4 = (__Pyx_PyUnicode_ContainsTF(__pyx_t_2, __pyx_n_u_USV, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 4427, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

    /* "validator.pyx":4427
 *              and ( array.values.dtype.kind if hasattr(array, 'columns')
 *                   else array.dtype.kind)
 *              in "USV"             # <<<<<<<<<<<<<<
 *              ):
 *             raise ValueError(
 */
    __pyx_t_3 = (__pyx_t_4 != 0);
    __pyx_t_8 = __pyx_t_3;
    __pyx_L88_bool_binop_done:;

    /* "validator.pyx":4424
 *                 )
 * 
 *         if  ( dtype_numeric             # <<<<<<<<<<<<<<
 *              and ( array.values.dtype.kind if hasattr(array, 'columns')
 *                   else array.dtype.kind)
 */
    if (unlikely(__pyx_t_8)) {

      /* "validator.pyx":4429
 *              in "USV"
 *              ):
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "dtype='numeric' is not compatible with arrays of bytes/strings."
 *                 "Convert your data to numeric values explicitly instead."
 */
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__112, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4429, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_Raise(__pyx_t_2, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __PYX_ERR(0, 4429, __pyx_L1_error)

      /* "validator.pyx":4424
 *                 )
 * 
 *         if  ( dtype_numeric             # <<<<<<<<<<<<<<
 *              and ( array.values.dtype.kind if hasattr(array, 'columns')
 *                   else array.dtype.kind)
 */
    }

    /* "validator.pyx":4433
 *                 "Convert your data to numeric values explicitly instead."
 *             )
 *         if not allow_nd and array.ndim >= 3:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 "Found array with dim %d. %s expected <= 2."
 */
    __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_v_allow_nd); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 4433, __pyx_L1_error)
    __pyx_t_4 = ((!__pyx_t_3) != 0);
    if (__pyx_t_4) {
    } else {
      __pyx_t_8 = __pyx_t_4;
      goto __pyx_L91_bool_binop_done;
    }
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4433, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_17 = PyObject_RichCompare(__pyx_t_2, __pyx_int_3, Py_GE); __Pyx_XGOTREF(__pyx_t_17); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 4433, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_17); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 4433, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
    __pyx_t_8 = __pyx_t_4;
    __pyx_L91_bool_binop_done:;
    if (unlikely(__pyx_t_8)) {

      /* "validator.pyx":4435
 *         if not allow_nd and array.ndim >= 3:
 *             raise ValueError(
 *                 "Found array with dim %d. %s expected <= 2."             # <<<<<<<<<<<<<<
 *                 % (array.ndim, estimator_name)
 *             )
 */
      __pyx_t_17 = PyTuple_New(5); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 4435, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_17);
      __pyx_t_27 = 0;
      __pyx_t_28 = 127;
      __Pyx_INCREF(__pyx_kp_u_Found_array_with_dim);
      __pyx_t_27 += 21;
      __Pyx_GIVEREF(__pyx_kp_u_Found_array_with_dim);
      PyTuple_SET_ITEM(__pyx_t_17, 0, __pyx_kp_u_Found_array_with_dim);

      /* "validator.pyx":4436
 *             raise ValueError(
 *                 "Found array with dim %d. %s expected <= 2."
 *                 % (array.ndim, estimator_name)             # <<<<<<<<<<<<<<
 *             )
 *         if force_all_finite:
 */
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_ndim); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4436, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_6 = __Pyx_PyObject_FormatAndDecref(__Pyx_PyNumber_IntOrLong(__pyx_t_2), __pyx_n_u_d); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4436, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_28 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) > __pyx_t_28) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) : __pyx_t_28;
      __pyx_t_27 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
      __Pyx_GIVEREF(__pyx_t_6);
      PyTuple_SET_ITEM(__pyx_t_17, 1, __pyx_t_6);
      __pyx_t_6 = 0;
      __Pyx_INCREF(__pyx_kp_u__113);
      __pyx_t_27 += 2;
      __Pyx_GIVEREF(__pyx_kp_u__113);
      PyTuple_SET_ITEM(__pyx_t_17, 2, __pyx_kp_u__113);
      __pyx_t_6 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Unicode(__pyx_v_estimator_name), __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4436, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_28 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) > __pyx_t_28) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) : __pyx_t_28;
      __pyx_t_27 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
      __Pyx_GIVEREF(__pyx_t_6);
      PyTuple_SET_ITEM(__pyx_t_17, 3, __pyx_t_6);
      __pyx_t_6 = 0;
      __Pyx_INCREF(__pyx_kp_u_expected_2);
      __pyx_t_27 += 15;
      __Pyx_GIVEREF(__pyx_kp_u_expected_2);
      PyTuple_SET_ITEM(__pyx_t_17, 4, __pyx_kp_u_expected_2);

      /* "validator.pyx":4435
 *         if not allow_nd and array.ndim >= 3:
 *             raise ValueError(
 *                 "Found array with dim %d. %s expected <= 2."             # <<<<<<<<<<<<<<
 *                 % (array.ndim, estimator_name)
 *             )
 */
      __pyx_t_6 = __Pyx_PyUnicode_Join(__pyx_t_17, 5, __pyx_t_27, __pyx_t_28); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4435, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;

      /* "validator.pyx":4434
 *             )
 *         if not allow_nd and array.ndim >= 3:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "Found array with dim %d. %s expected <= 2."
 *                 % (array.ndim, estimator_name)
 */
      __pyx_t_17 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_6); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 4434, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_17);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_Raise(__pyx_t_17, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
      __PYX_ERR(0, 4434, __pyx_L1_error)

      /* "validator.pyx":4433
 *                 "Convert your data to numeric values explicitly instead."
 *             )
 *         if not allow_nd and array.ndim >= 3:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 "Found array with dim %d. %s expected <= 2."
 */
    }

    /* "validator.pyx":4438
 *                 % (array.ndim, estimator_name)
 *             )
 *         if force_all_finite:             # <<<<<<<<<<<<<<
 *             _assert_all_finite(
 *                 array,
 */
    __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_v_force_all_finite); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 4438, __pyx_L1_error)
    if (__pyx_t_8) {

      /* "validator.pyx":4439
 *             )
 *         if force_all_finite:
 *             _assert_all_finite(             # <<<<<<<<<<<<<<
 *                 array,
 *                 input_name=input_name,
 */
      __Pyx_GetModuleGlobalName(__pyx_t_17, __pyx_n_s_assert_all_finite); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 4439, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_17);

      /* "validator.pyx":4440
 *         if force_all_finite:
 *             _assert_all_finite(
 *                 array,             # <<<<<<<<<<<<<<
 *                 input_name=input_name,
 *                 estimator_name=estimator_name,
 */
      __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4439, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_INCREF(__pyx_v_array);
      __Pyx_GIVEREF(__pyx_v_array);
      PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_v_array);

      /* "validator.pyx":4441
 *             _assert_all_finite(
 *                 array,
 *                 input_name=input_name,             # <<<<<<<<<<<<<<
 *                 estimator_name=estimator_name,
 *                 allow_nan= force_all_finite == "allow-nan",
 */
      __pyx_t_2 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4441, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_input_name, __pyx_v_input_name) < 0) __PYX_ERR(0, 4441, __pyx_L1_error)

      /* "validator.pyx":4442
 *                 array,
 *                 input_name=input_name,
 *                 estimator_name=estimator_name,             # <<<<<<<<<<<<<<
 *                 allow_nan= force_all_finite == "allow-nan",
 *             )
 */
      if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_estimator_name, __pyx_v_estimator_name) < 0) __PYX_ERR(0, 4441, __pyx_L1_error)

      /* "validator.pyx":4443
 *                 input_name=input_name,
 *                 estimator_name=estimator_name,
 *                 allow_nan= force_all_finite == "allow-nan",             # <<<<<<<<<<<<<<
 *             )
 * 
 */
      __pyx_t_1 = PyObject_RichCompare(__pyx_v_force_all_finite, __pyx_kp_u_allow_nan, Py_EQ); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4443, __pyx_L1_error)
      if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_allow_nan_2, __pyx_t_1) < 0) __PYX_ERR(0, 4441, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "validator.pyx":4439
 *             )
 *         if force_all_finite:
 *             _assert_all_finite(             # <<<<<<<<<<<<<<
 *                 array,
 *                 input_name=input_name,
 */
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_17, __pyx_t_6, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4439, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "validator.pyx":4438
 *                 % (array.ndim, estimator_name)
 *             )
 *         if force_all_finite:             # <<<<<<<<<<<<<<
 *             _assert_all_finite(
 *                 array,
 */
    }
  }
  __pyx_L47:;

  /* "validator.pyx":4446
 *             )
 * 
 *     if ensure_min_samples > 0:             # <<<<<<<<<<<<<<
 *         n_samples = _num_samples(array)
 *         if n_samples < ensure_min_samples:
 */
  __pyx_t_1 = PyObject_RichCompare(__pyx_v_ensure_min_samples, __pyx_int_0, Py_GT); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4446, __pyx_L1_error)
  __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 4446, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_8) {

    /* "validator.pyx":4447
 * 
 *     if ensure_min_samples > 0:
 *         n_samples = _num_samples(array)             # <<<<<<<<<<<<<<
 *         if n_samples < ensure_min_samples:
 *             raise ValueError(
 */
    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_num_samples); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4447, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_6 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    __pyx_t_1 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_6, __pyx_v_array) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_array);
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4447, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_v_n_samples = __pyx_t_1;
    __pyx_t_1 = 0;

    /* "validator.pyx":4448
 *     if ensure_min_samples > 0:
 *         n_samples = _num_samples(array)
 *         if n_samples < ensure_min_samples:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 "Found array with %d sample(s) (shape=%s) while a"
 */
    __pyx_t_1 = PyObject_RichCompare(__pyx_v_n_samples, __pyx_v_ensure_min_samples, Py_LT); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4448, __pyx_L1_error)
    __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 4448, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(__pyx_t_8)) {

      /* "validator.pyx":4450
 *         if n_samples < ensure_min_samples:
 *             raise ValueError(
 *                 "Found array with %d sample(s) (shape=%s) while a"             # <<<<<<<<<<<<<<
 *                 " minimum of %d is required."
 *                 % (n_samples, array.shape, ensure_min_samples)
 */
      __pyx_t_1 = PyTuple_New(7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4450, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_27 = 0;
      __pyx_t_28 = 127;
      __Pyx_INCREF(__pyx_kp_u_Found_array_with);
      __pyx_t_27 += 17;
      __Pyx_GIVEREF(__pyx_kp_u_Found_array_with);
      PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_Found_array_with);

      /* "validator.pyx":4452
 *                 "Found array with %d sample(s) (shape=%s) while a"
 *                 " minimum of %d is required."
 *                 % (n_samples, array.shape, ensure_min_samples)             # <<<<<<<<<<<<<<
 *             )
 * 
 */
      __pyx_t_2 = __Pyx_PyObject_FormatAndDecref(__Pyx_PyNumber_IntOrLong(__pyx_v_n_samples), __pyx_n_u_d); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4452, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_28 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) > __pyx_t_28) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) : __pyx_t_28;
      __pyx_t_27 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_2);
      __Pyx_GIVEREF(__pyx_t_2);
      PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_2);
      __pyx_t_2 = 0;
      __Pyx_INCREF(__pyx_kp_u_sample_s_shape);
      __pyx_t_27 += 18;
      __Pyx_GIVEREF(__pyx_kp_u_sample_s_shape);
      PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_sample_s_shape);
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_shape); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4452, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_6 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Unicode(__pyx_t_2), __pyx_empty_unicode); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4452, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_28 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) > __pyx_t_28) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) : __pyx_t_28;
      __pyx_t_27 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
      __Pyx_GIVEREF(__pyx_t_6);
      PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_t_6);
      __pyx_t_6 = 0;
      __Pyx_INCREF(__pyx_kp_u_while_a_minimum_of);
      __pyx_t_27 += 21;
      __Pyx_GIVEREF(__pyx_kp_u_while_a_minimum_of);
      PyTuple_SET_ITEM(__pyx_t_1, 4, __pyx_kp_u_while_a_minimum_of);
      __pyx_t_6 = __Pyx_PyObject_FormatAndDecref(__Pyx_PyNumber_IntOrLong(__pyx_v_ensure_min_samples), __pyx_n_u_d); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4452, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_28 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) > __pyx_t_28) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) : __pyx_t_28;
      __pyx_t_27 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
      __Pyx_GIVEREF(__pyx_t_6);
      PyTuple_SET_ITEM(__pyx_t_1, 5, __pyx_t_6);
      __pyx_t_6 = 0;
      __Pyx_INCREF(__pyx_kp_u_is_required);
      __pyx_t_27 += 13;
      __Pyx_GIVEREF(__pyx_kp_u_is_required);
      PyTuple_SET_ITEM(__pyx_t_1, 6, __pyx_kp_u_is_required);

      /* "validator.pyx":4450
 *         if n_samples < ensure_min_samples:
 *             raise ValueError(
 *                 "Found array with %d sample(s) (shape=%s) while a"             # <<<<<<<<<<<<<<
 *                 " minimum of %d is required."
 *                 % (n_samples, array.shape, ensure_min_samples)
 */
      __pyx_t_6 = __Pyx_PyUnicode_Join(__pyx_t_1, 7, __pyx_t_27, __pyx_t_28); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4450, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "validator.pyx":4449
 *         n_samples = _num_samples(array)
 *         if n_samples < ensure_min_samples:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "Found array with %d sample(s) (shape=%s) while a"
 *                 " minimum of %d is required."
 */
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4449, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 4449, __pyx_L1_error)

      /* "validator.pyx":4448
 *     if ensure_min_samples > 0:
 *         n_samples = _num_samples(array)
 *         if n_samples < ensure_min_samples:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 "Found array with %d sample(s) (shape=%s) while a"
 */
    }

    /* "validator.pyx":4446
 *             )
 * 
 *     if ensure_min_samples > 0:             # <<<<<<<<<<<<<<
 *         n_samples = _num_samples(array)
 *         if n_samples < ensure_min_samples:
 */
  }

  /* "validator.pyx":4455
 *             )
 * 
 *     if ensure_min_features > 0 and array.ndim == 2:             # <<<<<<<<<<<<<<
 *         n_features = array.shape[1]
 *         if n_features < ensure_min_features:
 */
  __pyx_t_1 = PyObject_RichCompare(__pyx_v_ensure_min_features, __pyx_int_0, Py_GT); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4455, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 4455, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_4) {
  } else {
    __pyx_t_8 = __pyx_t_4;
    goto __pyx_L97_bool_binop_done;
  }
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_ndim); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4455, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_6 = __Pyx_PyInt_EqObjC(__pyx_t_1, __pyx_int_2, 2, 0); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4455, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 4455, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __pyx_t_8 = __pyx_t_4;
  __pyx_L97_bool_binop_done:;
  if (__pyx_t_8) {

    /* "validator.pyx":4456
 * 
 *     if ensure_min_features > 0 and array.ndim == 2:
 *         n_features = array.shape[1]             # <<<<<<<<<<<<<<
 *         if n_features < ensure_min_features:
 *             raise ValueError(
 */
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_shape); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4456, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_1 = __Pyx_GetItemInt(__pyx_t_6, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4456, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_v_n_features = __pyx_t_1;
    __pyx_t_1 = 0;

    /* "validator.pyx":4457
 *     if ensure_min_features > 0 and array.ndim == 2:
 *         n_features = array.shape[1]
 *         if n_features < ensure_min_features:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 "Found array with %d feature(s) (shape=%s) while"
 */
    __pyx_t_1 = PyObject_RichCompare(__pyx_v_n_features, __pyx_v_ensure_min_features, Py_LT); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4457, __pyx_L1_error)
    __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 4457, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(__pyx_t_8)) {

      /* "validator.pyx":4459
 *         if n_features < ensure_min_features:
 *             raise ValueError(
 *                 "Found array with %d feature(s) (shape=%s) while"             # <<<<<<<<<<<<<<
 *                 " a minimum of %d is required."
 *                 % (n_features, array.shape, ensure_min_features)
 */
      __pyx_t_1 = PyTuple_New(7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4459, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_27 = 0;
      __pyx_t_28 = 127;
      __Pyx_INCREF(__pyx_kp_u_Found_array_with);
      __pyx_t_27 += 17;
      __Pyx_GIVEREF(__pyx_kp_u_Found_array_with);
      PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_Found_array_with);

      /* "validator.pyx":4461
 *                 "Found array with %d feature(s) (shape=%s) while"
 *                 " a minimum of %d is required."
 *                 % (n_features, array.shape, ensure_min_features)             # <<<<<<<<<<<<<<
 *             )
 * 
 */
      __pyx_t_6 = __Pyx_PyObject_FormatAndDecref(__Pyx_PyNumber_IntOrLong(__pyx_v_n_features), __pyx_n_u_d); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4461, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_28 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) > __pyx_t_28) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_6) : __pyx_t_28;
      __pyx_t_27 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_6);
      __Pyx_GIVEREF(__pyx_t_6);
      PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_6);
      __pyx_t_6 = 0;
      __Pyx_INCREF(__pyx_kp_u_feature_s_shape);
      __pyx_t_27 += 19;
      __Pyx_GIVEREF(__pyx_kp_u_feature_s_shape);
      PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_feature_s_shape);
      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_array, __pyx_n_s_shape); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4461, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_2 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Unicode(__pyx_t_6), __pyx_empty_unicode); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4461, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_28 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) > __pyx_t_28) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) : __pyx_t_28;
      __pyx_t_27 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_2);
      __Pyx_GIVEREF(__pyx_t_2);
      PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_t_2);
      __pyx_t_2 = 0;
      __Pyx_INCREF(__pyx_kp_u_while_a_minimum_of);
      __pyx_t_27 += 21;
      __Pyx_GIVEREF(__pyx_kp_u_while_a_minimum_of);
      PyTuple_SET_ITEM(__pyx_t_1, 4, __pyx_kp_u_while_a_minimum_of);
      __pyx_t_2 = __Pyx_PyObject_FormatAndDecref(__Pyx_PyNumber_IntOrLong(__pyx_v_ensure_min_features), __pyx_n_u_d); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4461, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_28 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) > __pyx_t_28) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) : __pyx_t_28;
      __pyx_t_27 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_2);
      __Pyx_GIVEREF(__pyx_t_2);
      PyTuple_SET_ITEM(__pyx_t_1, 5, __pyx_t_2);
      __pyx_t_2 = 0;
      __Pyx_INCREF(__pyx_kp_u_is_required);
      __pyx_t_27 += 13;
      __Pyx_GIVEREF(__pyx_kp_u_is_required);
      PyTuple_SET_ITEM(__pyx_t_1, 6, __pyx_kp_u_is_required);

      /* "validator.pyx":4459
 *         if n_features < ensure_min_features:
 *             raise ValueError(
 *                 "Found array with %d feature(s) (shape=%s) while"             # <<<<<<<<<<<<<<
 *                 " a minimum of %d is required."
 *                 % (n_features, array.shape, ensure_min_features)
 */
      __pyx_t_2 = __Pyx_PyUnicode_Join(__pyx_t_1, 7, __pyx_t_27, __pyx_t_28); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4459, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "validator.pyx":4458
 *         n_features = array.shape[1]
 *         if n_features < ensure_min_features:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "Found array with %d feature(s) (shape=%s) while"
 *                 " a minimum of %d is required."
 */
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4458, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 4458, __pyx_L1_error)

      /* "validator.pyx":4457
 *     if ensure_min_features > 0 and array.ndim == 2:
 *         n_features = array.shape[1]
 *         if n_features < ensure_min_features:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 "Found array with %d feature(s) (shape=%s) while"
 */
    }

    /* "validator.pyx":4455
 *             )
 * 
 *     if ensure_min_features > 0 and array.ndim == 2:             # <<<<<<<<<<<<<<
 *         n_features = array.shape[1]
 *         if n_features < ensure_min_features:
 */
  }

  /* "validator.pyx":4465
 * 
 * 
 *     if copy:             # <<<<<<<<<<<<<<
 *         if xp.__name__ in {"numpy", "numpy.array_api"}:
 *             # only make a copy if `array` and `array_orig` may share memory`
 */
  __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_v_copy); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 4465, __pyx_L1_error)
  if (__pyx_t_8) {

    /* "validator.pyx":4466
 * 
 *     if copy:
 *         if xp.__name__ in {"numpy", "numpy.array_api"}:             # <<<<<<<<<<<<<<
 *             # only make a copy if `array` and `array_orig` may share memory`
 *             if np.may_share_memory(array, array_orig):
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_xp, __pyx_n_s_name); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4466, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_t_1, __pyx_n_u_numpy, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 4466, __pyx_L1_error)
    if (!__pyx_t_4) {
    } else {
      __pyx_t_8 = __pyx_t_4;
      goto __pyx_L102_bool_binop_done;
    }
    __pyx_t_4 = (__Pyx_PyUnicode_Equals(__pyx_t_1, __pyx_kp_u_numpy_array_api, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 4466, __pyx_L1_error)
    __pyx_t_8 = __pyx_t_4;
    __pyx_L102_bool_binop_done:;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_4 = (__pyx_t_8 != 0);
    if (__pyx_t_4) {

      /* "validator.pyx":4468
 *         if xp.__name__ in {"numpy", "numpy.array_api"}:
 *             # only make a copy if `array` and `array_orig` may share memory`
 *             if np.may_share_memory(array, array_orig):             # <<<<<<<<<<<<<<
 *                 array = _asarray_with_order(
 *                     array, dtype=dtype, order=order, copy=True, xp=xp
 */
      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4468, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_may_share_memory); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4468, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_2 = NULL;
      __pyx_t_19 = 0;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_6))) {
        __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_6);
        if (likely(__pyx_t_2)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6);
          __Pyx_INCREF(__pyx_t_2);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_6, function);
          __pyx_t_19 = 1;
        }
      }
      #if CYTHON_FAST_PYCALL
      if (PyFunction_Check(__pyx_t_6)) {
        PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_array, __pyx_v_array_orig};
        __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_19, 2+__pyx_t_19); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4468, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_GOTREF(__pyx_t_1);
      } else
      #endif
      #if CYTHON_FAST_PYCCALL
      if (__Pyx_PyFastCFunction_Check(__pyx_t_6)) {
        PyObject *__pyx_temp[3] = {__pyx_t_2, __pyx_v_array, __pyx_v_array_orig};
        __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_6, __pyx_temp+1-__pyx_t_19, 2+__pyx_t_19); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4468, __pyx_L1_error)
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_GOTREF(__pyx_t_1);
      } else
      #endif
      {
        __pyx_t_17 = PyTuple_New(2+__pyx_t_19); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 4468, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_17);
        if (__pyx_t_2) {
          __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_17, 0, __pyx_t_2); __pyx_t_2 = NULL;
        }
        __Pyx_INCREF(__pyx_v_array);
        __Pyx_GIVEREF(__pyx_v_array);
        PyTuple_SET_ITEM(__pyx_t_17, 0+__pyx_t_19, __pyx_v_array);
        __Pyx_INCREF(__pyx_v_array_orig);
        __Pyx_GIVEREF(__pyx_v_array_orig);
        PyTuple_SET_ITEM(__pyx_t_17, 1+__pyx_t_19, __pyx_v_array_orig);
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_17, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4468, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
      }
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 4468, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (__pyx_t_4) {

        /* "validator.pyx":4469
 *             # only make a copy if `array` and `array_orig` may share memory`
 *             if np.may_share_memory(array, array_orig):
 *                 array = _asarray_with_order(             # <<<<<<<<<<<<<<
 *                     array, dtype=dtype, order=order, copy=True, xp=xp
 *                 )
 */
        __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_asarray_with_order); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4469, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);

        /* "validator.pyx":4470
 *             if np.may_share_memory(array, array_orig):
 *                 array = _asarray_with_order(
 *                     array, dtype=dtype, order=order, copy=True, xp=xp             # <<<<<<<<<<<<<<
 *                 )
 *         else:
 */
        __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4469, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_6);
        __Pyx_INCREF(__pyx_v_array);
        __Pyx_GIVEREF(__pyx_v_array);
        PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_v_array);
        __pyx_t_17 = __Pyx_PyDict_NewPresized(4); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 4470, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_17);
        if (PyDict_SetItem(__pyx_t_17, __pyx_n_s_dtype, __pyx_v_dtype) < 0) __PYX_ERR(0, 4470, __pyx_L1_error)
        if (PyDict_SetItem(__pyx_t_17, __pyx_n_s_order, __pyx_v_order) < 0) __PYX_ERR(0, 4470, __pyx_L1_error)
        if (PyDict_SetItem(__pyx_t_17, __pyx_n_s_copy, Py_True) < 0) __PYX_ERR(0, 4470, __pyx_L1_error)
        if (PyDict_SetItem(__pyx_t_17, __pyx_n_s_xp, __pyx_v_xp) < 0) __PYX_ERR(0, 4470, __pyx_L1_error)

        /* "validator.pyx":4469
 *             # only make a copy if `array` and `array_orig` may share memory`
 *             if np.may_share_memory(array, array_orig):
 *                 array = _asarray_with_order(             # <<<<<<<<<<<<<<
 *                     array, dtype=dtype, order=order, copy=True, xp=xp
 *                 )
 */
        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, __pyx_t_17); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4469, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
        __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
        __Pyx_DECREF_SET(__pyx_v_array, __pyx_t_2);
        __pyx_t_2 = 0;

        /* "validator.pyx":4468
 *         if xp.__name__ in {"numpy", "numpy.array_api"}:
 *             # only make a copy if `array` and `array_orig` may share memory`
 *             if np.may_share_memory(array, array_orig):             # <<<<<<<<<<<<<<
 *                 array = _asarray_with_order(
 *                     array, dtype=dtype, order=order, copy=True, xp=xp
 */
      }

      /* "validator.pyx":4466
 * 
 *     if copy:
 *         if xp.__name__ in {"numpy", "numpy.array_api"}:             # <<<<<<<<<<<<<<
 *             # only make a copy if `array` and `array_orig` may share memory`
 *             if np.may_share_memory(array, array_orig):
 */
      goto __pyx_L101;
    }

    /* "validator.pyx":4474
 *         else:
 *             # always make a copy for non-numpy arrays
 *             array = _asarray_with_order(             # <<<<<<<<<<<<<<
 *                 array, dtype=dtype, order=order, copy=True, xp=xp
 *             )
 */
    /*else*/ {
      __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_asarray_with_order); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4474, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);

      /* "validator.pyx":4475
 *             # always make a copy for non-numpy arrays
 *             array = _asarray_with_order(
 *                 array, dtype=dtype, order=order, copy=True, xp=xp             # <<<<<<<<<<<<<<
 *             )
 * 
 */
      __pyx_t_17 = PyTuple_New(1); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 4474, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_17);
      __Pyx_INCREF(__pyx_v_array);
      __Pyx_GIVEREF(__pyx_v_array);
      PyTuple_SET_ITEM(__pyx_t_17, 0, __pyx_v_array);
      __pyx_t_6 = __Pyx_PyDict_NewPresized(4); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4475, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_dtype, __pyx_v_dtype) < 0) __PYX_ERR(0, 4475, __pyx_L1_error)
      if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_order, __pyx_v_order) < 0) __PYX_ERR(0, 4475, __pyx_L1_error)
      if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_copy, Py_True) < 0) __PYX_ERR(0, 4475, __pyx_L1_error)
      if (PyDict_SetItem(__pyx_t_6, __pyx_n_s_xp, __pyx_v_xp) < 0) __PYX_ERR(0, 4475, __pyx_L1_error)

      /* "validator.pyx":4474
 *         else:
 *             # always make a copy for non-numpy arrays
 *             array = _asarray_with_order(             # <<<<<<<<<<<<<<
 *                 array, dtype=dtype, order=order, copy=True, xp=xp
 *             )
 */
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_17, __pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4474, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_DECREF_SET(__pyx_v_array, __pyx_t_1);
      __pyx_t_1 = 0;
    }
    __pyx_L101:;

    /* "validator.pyx":4465
 * 
 * 
 *     if copy:             # <<<<<<<<<<<<<<
 *         if xp.__name__ in {"numpy", "numpy.array_api"}:
 *             # only make a copy if `array` and `array_orig` may share memory`
 */
  }

  /* "validator.pyx":4478
 *             )
 * 
 *     if to_frame:             # <<<<<<<<<<<<<<
 *         array= array_to_frame(
 *                 array,
 */
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_to_frame); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 4478, __pyx_L1_error)
  if (__pyx_t_4) {

    /* "validator.pyx":4479
 * 
 *     if to_frame:
 *         array= array_to_frame(             # <<<<<<<<<<<<<<
 *                 array,
 *                 to_frame =to_frame ,
 */
    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_array_to_frame); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4479, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);

    /* "validator.pyx":4480
 *     if to_frame:
 *         array= array_to_frame(
 *                 array,             # <<<<<<<<<<<<<<
 *                 to_frame =to_frame ,
 *                 columns = column_orig,
 */
    __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4479, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_INCREF(__pyx_v_array);
    __Pyx_GIVEREF(__pyx_v_array);
    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_v_array);

    /* "validator.pyx":4481
 *         array= array_to_frame(
 *                 array,
 *                 to_frame =to_frame ,             # <<<<<<<<<<<<<<
 *                 columns = column_orig,
 *                 input_name= input_name,
 */
    __pyx_t_17 = __Pyx_PyDict_NewPresized(4); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 4481, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_17);
    if (PyDict_SetItem(__pyx_t_17, __pyx_n_s_to_frame, __pyx_v_to_frame) < 0) __PYX_ERR(0, 4481, __pyx_L1_error)

    /* "validator.pyx":4482
 *                 array,
 *                 to_frame =to_frame ,
 *                 columns = column_orig,             # <<<<<<<<<<<<<<
 *                 input_name= input_name,
 *                 raise_warning="silence",
 */
    if (PyDict_SetItem(__pyx_t_17, __pyx_n_s_columns, __pyx_v_column_orig) < 0) __PYX_ERR(0, 4481, __pyx_L1_error)

    /* "validator.pyx":4483
 *                 to_frame =to_frame ,
 *                 columns = column_orig,
 *                 input_name= input_name,             # <<<<<<<<<<<<<<
 *                 raise_warning="silence",
 *             )
 */
    if (PyDict_SetItem(__pyx_t_17, __pyx_n_s_input_name, __pyx_v_input_name) < 0) __PYX_ERR(0, 4481, __pyx_L1_error)
    if (PyDict_SetItem(__pyx_t_17, __pyx_n_s_raise_warning, __pyx_n_u_silence) < 0) __PYX_ERR(0, 4481, __pyx_L1_error)

    /* "validator.pyx":4479
 * 
 *     if to_frame:
 *         array= array_to_frame(             # <<<<<<<<<<<<<<
 *                 array,
 *                 to_frame =to_frame ,
 */
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_6, __pyx_t_17); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4479, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
    __Pyx_DECREF_SET(__pyx_v_array, __pyx_t_2);
    __pyx_t_2 = 0;

    /* "validator.pyx":4478
 *             )
 * 
 *     if to_frame:             # <<<<<<<<<<<<<<
 *         array= array_to_frame(
 *                 array,
 */
  }

  /* "validator.pyx":4487
 *             )
 * 
 *     return array             # <<<<<<<<<<<<<<
 * 
 * def check_X_y(
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_array);
  __pyx_r = __pyx_v_array;
  goto __pyx_L0;

  /* "validator.pyx":4179
 * 
 * 
 * def check_array(             # <<<<<<<<<<<<<<
 *     array,
 *     *,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_17);
  __Pyx_XDECREF(__pyx_t_18);
  __Pyx_AddTraceback("validator.check_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_xp);
  __Pyx_XDECREF(__pyx_v_is_array_api);
  __Pyx_XDECREF(__pyx_v_column_orig);
  __Pyx_XDECREF(__pyx_v_array_orig);
  __Pyx_XDECREF(__pyx_v_dtype_numeric);
  __Pyx_XDECREF(__pyx_v_dtype_orig);
  __Pyx_XDECREF(__pyx_v_pandas_requires_conversion);
  __Pyx_XDECREF(__pyx_v_new_dtype);
  __Pyx_XDECREF(__pyx_v_estimator_name);
  __Pyx_XDECREF(__pyx_v_complex_warning);
  __Pyx_XDECREF(__pyx_v_n_samples);
  __Pyx_XDECREF(__pyx_v_n_features);
  __Pyx_XDECREF(__pyx_gb_9validator_11check_array_2generator14);
  __Pyx_XDECREF(__pyx_gb_9validator_11check_array_5generator15);
  __Pyx_XDECREF(__pyx_v_array);
  __Pyx_XDECREF(__pyx_v_dtype);
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":4489
 *     return array
 * 
 * def check_X_y(             # <<<<<<<<<<<<<<
 *     X,
 *     y,
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_149check_X_y(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_148check_X_y[] = "Input validation for standard estimators.\n    Checks X and y for consistent length, enforces X to be 2D and y 1D. By\n    default, X is checked to be non-empty and containing only finite values.\n    Standard input checks are also applied to y, such as checking that y\n    does not have np.nan or np.inf targets. For multi-label y, set\n    multi_output=True to allow 2D and sparse y. If the dtype of X is\n    object, attempt converting to float, raising on failure.\n    Parameters\n    ----------\n    X : {ndarray, list, sparse matrix}\n        Input data.\n    y : {ndarray, list, sparse matrix}\n        Labels.\n    accept_sparse : str, bool or list of str, default=False\n        String[s] representing allowed sparse matrix formats, such as 'csc',\n        'csr', etc. If the input is sparse but not in the allowed format,\n        it will be converted to the first listed format. True allows the input\n        to be any format. False means that a sparse matrix input will\n        raise an error.\n    accept_large_sparse : bool, default=True\n        If a CSR, CSC, COO or BSR sparse matrix is supplied and accepted by\n        accept_sparse, accept_large_sparse will cause it to be accepted only\n        if its indices are stored with a 32-bit dtype.\n    dtype : 'numeric', type, list of type or None, default='numeric'\n        Data type of result. If None, the dtype of the input is preserved.\n        If \"numeric\", dtype is preserved unless array.dtype is object.\n        If dtype is a list of types, conversion on the first type is only\n        performed if the dtype of the input is not in the list.\n    order : {'F', 'C'}, default=None\n        Whether an array will be forced to be fortran or c-style.\n    copy : bool, default=False\n        Whether a forced copy will be triggered. If copy=False, a copy might\n        be triggered by a conversion.\n    force_all_finite : bool or 'allow-nan', default=True\n        Whether to raise an error on np.inf, np.nan, pd.NA i""n X. This parameter\n        does not influence whether y can have np.inf, np.nan, pd.NA values.\n        The possibilities are:\n        - True: Force all values of X to be finite.\n        - False: accepts np.inf, np.nan, pd.NA in X.\n        - 'allow-nan': accepts only np.nan or pd.NA values in X. Values cannot\n          be infinite.\n        .. versionadded:: 0.20\n           ``force_all_finite`` accepts the string ``'allow-nan'``.\n        .. versionchanged:: 0.23\n           Accepts `pd.NA` and converts it into `np.nan`\n    ensure_2d : bool, default=True\n        Whether to raise a value error if X is not 2D.\n    allow_nd : bool, default=False\n        Whether to allow X.ndim > 2.\n    multi_output : bool, default=False\n        Whether to allow 2D y (array or sparse matrix). If false, y will be\n        validated as a vector. y cannot have np.nan or np.inf values if\n        multi_output=True.\n    ensure_min_samples : int, default=1\n        Make sure that X has a minimum number of samples in its first\n        axis (rows for a 2D array).\n    ensure_min_features : int, default=1\n        Make sure that the 2D array has some minimum number of features\n        (columns). The default value of 1 rejects empty datasets.\n        This check is only enforced when X has effectively 2 dimensions or\n        is originally 1D and ``ensure_2d`` is True. Setting to 0 disables\n        this check.\n    y_numeric : bool, default=False\n        Whether to ensure that y has a numeric type. If dtype of y is object,\n        it is converted to float64. Should only be used for regression\n        algorithms.\n    estimator : str or estimator instance, default=None\n        If passed, include the name of the estimator in warning messages.\n        \n    Returns\n    -------\n    X_converted : object\n        The converted and validated X.\n    y_converted : object\n        The converted and validated y.\n    ";
static PyMethodDef __pyx_mdef_9validator_149check_X_y = {"check_X_y", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_149check_X_y, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_148check_X_y};
static PyObject *__pyx_pw_9validator_149check_X_y(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_X = 0;
  PyObject *__pyx_v_y = 0;
  PyObject *__pyx_v_accept_sparse = 0;
  PyObject *__pyx_v_accept_large_sparse = 0;
  PyObject *__pyx_v_dtype = 0;
  PyObject *__pyx_v_order = 0;
  PyObject *__pyx_v_copy = 0;
  PyObject *__pyx_v_force_all_finite = 0;
  PyObject *__pyx_v_ensure_2d = 0;
  PyObject *__pyx_v_allow_nd = 0;
  PyObject *__pyx_v_multi_output = 0;
  PyObject *__pyx_v_ensure_min_samples = 0;
  PyObject *__pyx_v_ensure_min_features = 0;
  PyObject *__pyx_v_y_numeric = 0;
  PyObject *__pyx_v_estimator = 0;
  PyObject *__pyx_v_to_frame = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("check_X_y (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_X,&__pyx_n_s_y,&__pyx_n_s_accept_sparse,&__pyx_n_s_accept_large_sparse,&__pyx_n_s_dtype,&__pyx_n_s_order,&__pyx_n_s_copy,&__pyx_n_s_force_all_finite,&__pyx_n_s_ensure_2d,&__pyx_n_s_allow_nd,&__pyx_n_s_multi_output,&__pyx_n_s_ensure_min_samples,&__pyx_n_s_ensure_min_features,&__pyx_n_s_y_numeric,&__pyx_n_s_estimator,&__pyx_n_s_to_frame,0};
    PyObject* values[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

    /* "validator.pyx":4492
 *     X,
 *     y,
 *     accept_sparse=False,             # <<<<<<<<<<<<<<
 *     *,
 *     accept_large_sparse=True,
 */
    values[2] = ((PyObject *)Py_False);

    /* "validator.pyx":4494
 *     accept_sparse=False,
 *     *,
 *     accept_large_sparse=True,             # <<<<<<<<<<<<<<
 *     dtype="numeric",
 *     order=None,
 */
    values[3] = ((PyObject *)Py_True);
    values[4] = ((PyObject *)__pyx_n_u_numeric);

    /* "validator.pyx":4496
 *     accept_large_sparse=True,
 *     dtype="numeric",
 *     order=None,             # <<<<<<<<<<<<<<
 *     copy=False,
 *     force_all_finite=True,
 */
    values[5] = ((PyObject *)Py_None);

    /* "validator.pyx":4497
 *     dtype="numeric",
 *     order=None,
 *     copy=False,             # <<<<<<<<<<<<<<
 *     force_all_finite=True,
 *     ensure_2d=True,
 */
    values[6] = ((PyObject *)Py_False);

    /* "validator.pyx":4498
 *     order=None,
 *     copy=False,
 *     force_all_finite=True,             # <<<<<<<<<<<<<<
 *     ensure_2d=True,
 *     allow_nd=False,
 */
    values[7] = ((PyObject *)Py_True);

    /* "validator.pyx":4499
 *     copy=False,
 *     force_all_finite=True,
 *     ensure_2d=True,             # <<<<<<<<<<<<<<
 *     allow_nd=False,
 *     multi_output=False,
 */
    values[8] = ((PyObject *)Py_True);

    /* "validator.pyx":4500
 *     force_all_finite=True,
 *     ensure_2d=True,
 *     allow_nd=False,             # <<<<<<<<<<<<<<
 *     multi_output=False,
 *     ensure_min_samples=1,
 */
    values[9] = ((PyObject *)Py_False);

    /* "validator.pyx":4501
 *     ensure_2d=True,
 *     allow_nd=False,
 *     multi_output=False,             # <<<<<<<<<<<<<<
 *     ensure_min_samples=1,
 *     ensure_min_features=1,
 */
    values[10] = ((PyObject *)Py_False);
    values[11] = ((PyObject *)__pyx_int_1);
    values[12] = ((PyObject *)__pyx_int_1);

    /* "validator.pyx":4504
 *     ensure_min_samples=1,
 *     ensure_min_features=1,
 *     y_numeric=False,             # <<<<<<<<<<<<<<
 *     estimator=None,
 *     to_frame= False,
 */
    values[13] = ((PyObject *)Py_False);

    /* "validator.pyx":4505
 *     ensure_min_features=1,
 *     y_numeric=False,
 *     estimator=None,             # <<<<<<<<<<<<<<
 *     to_frame= False,
 * ):
 */
    values[14] = ((PyObject *)Py_None);

    /* "validator.pyx":4506
 *     y_numeric=False,
 *     estimator=None,
 *     to_frame= False,             # <<<<<<<<<<<<<<
 * ):
 *     """Input validation for standard estimators.
 */
    values[15] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_X)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("check_X_y", 0, 2, 3, 1); __PYX_ERR(0, 4489, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_accept_sparse);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (kw_args > 0 && likely(kw_args <= 13)) {
        Py_ssize_t index;
        for (index = 3; index < 16 && kw_args > 0; index++) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
          if (value) { values[index] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "check_X_y") < 0)) __PYX_ERR(0, 4489, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_X = values[0];
    __pyx_v_y = values[1];
    __pyx_v_accept_sparse = values[2];
    __pyx_v_accept_large_sparse = values[3];
    __pyx_v_dtype = values[4];
    __pyx_v_order = values[5];
    __pyx_v_copy = values[6];
    __pyx_v_force_all_finite = values[7];
    __pyx_v_ensure_2d = values[8];
    __pyx_v_allow_nd = values[9];
    __pyx_v_multi_output = values[10];
    __pyx_v_ensure_min_samples = values[11];
    __pyx_v_ensure_min_features = values[12];
    __pyx_v_y_numeric = values[13];
    __pyx_v_estimator = values[14];
    __pyx_v_to_frame = values[15];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("check_X_y", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4489, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.check_X_y", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_148check_X_y(__pyx_self, __pyx_v_X, __pyx_v_y, __pyx_v_accept_sparse, __pyx_v_accept_large_sparse, __pyx_v_dtype, __pyx_v_order, __pyx_v_copy, __pyx_v_force_all_finite, __pyx_v_ensure_2d, __pyx_v_allow_nd, __pyx_v_multi_output, __pyx_v_ensure_min_samples, __pyx_v_ensure_min_features, __pyx_v_y_numeric, __pyx_v_estimator, __pyx_v_to_frame);

  /* "validator.pyx":4489
 *     return array
 * 
 * def check_X_y(             # <<<<<<<<<<<<<<
 *     X,
 *     y,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_148check_X_y(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X, PyObject *__pyx_v_y, PyObject *__pyx_v_accept_sparse, PyObject *__pyx_v_accept_large_sparse, PyObject *__pyx_v_dtype, PyObject *__pyx_v_order, PyObject *__pyx_v_copy, PyObject *__pyx_v_force_all_finite, PyObject *__pyx_v_ensure_2d, PyObject *__pyx_v_allow_nd, PyObject *__pyx_v_multi_output, PyObject *__pyx_v_ensure_min_samples, PyObject *__pyx_v_ensure_min_features, PyObject *__pyx_v_y_numeric, PyObject *__pyx_v_estimator, PyObject *__pyx_v_to_frame) {
  PyObject *__pyx_v_estimator_name = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_t_7;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("check_X_y", 0);
  __Pyx_INCREF(__pyx_v_X);
  __Pyx_INCREF(__pyx_v_y);

  /* "validator.pyx":4584
 *         The converted and validated y.
 *     """
 *     if y is None:             # <<<<<<<<<<<<<<
 *         if estimator is None:
 *             estimator_name = "estimator"
 */
  __pyx_t_1 = (__pyx_v_y == Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "validator.pyx":4585
 *     """
 *     if y is None:
 *         if estimator is None:             # <<<<<<<<<<<<<<
 *             estimator_name = "estimator"
 *         else:
 */
    __pyx_t_2 = (__pyx_v_estimator == Py_None);
    __pyx_t_1 = (__pyx_t_2 != 0);
    if (__pyx_t_1) {

      /* "validator.pyx":4586
 *     if y is None:
 *         if estimator is None:
 *             estimator_name = "estimator"             # <<<<<<<<<<<<<<
 *         else:
 *             estimator_name = _check_estimator_name(estimator)
 */
      __Pyx_INCREF(__pyx_n_u_estimator);
      __pyx_v_estimator_name = __pyx_n_u_estimator;

      /* "validator.pyx":4585
 *     """
 *     if y is None:
 *         if estimator is None:             # <<<<<<<<<<<<<<
 *             estimator_name = "estimator"
 *         else:
 */
      goto __pyx_L4;
    }

    /* "validator.pyx":4588
 *             estimator_name = "estimator"
 *         else:
 *             estimator_name = _check_estimator_name(estimator)             # <<<<<<<<<<<<<<
 *         raise ValueError(
 *             f"{estimator_name} requires y to be passed, but the target y is None"
 */
    /*else*/ {
      __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_check_estimator_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4588, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_5 = NULL;
      if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
        __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
        if (likely(__pyx_t_5)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
          __Pyx_INCREF(__pyx_t_5);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_4, function);
        }
      }
      __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_v_estimator) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_estimator);
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4588, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_v_estimator_name = __pyx_t_3;
      __pyx_t_3 = 0;
    }
    __pyx_L4:;

    /* "validator.pyx":4590
 *             estimator_name = _check_estimator_name(estimator)
 *         raise ValueError(
 *             f"{estimator_name} requires y to be passed, but the target y is None"             # <<<<<<<<<<<<<<
 *         )
 * 
 */
    __pyx_t_3 = __Pyx_PyObject_FormatSimple(__pyx_v_estimator_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4590, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyUnicode_Concat(__pyx_t_3, __pyx_kp_u_requires_y_to_be_passed_but_the); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4590, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "validator.pyx":4589
 *         else:
 *             estimator_name = _check_estimator_name(estimator)
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             f"{estimator_name} requires y to be passed, but the target y is None"
 *         )
 */
    __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4589, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 4589, __pyx_L1_error)

    /* "validator.pyx":4584
 *         The converted and validated y.
 *     """
 *     if y is None:             # <<<<<<<<<<<<<<
 *         if estimator is None:
 *             estimator_name = "estimator"
 */
  }

  /* "validator.pyx":4593
 *         )
 * 
 *     X = check_array(             # <<<<<<<<<<<<<<
 *         X,
 *         accept_sparse=accept_sparse,
 */
  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_check_array); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4593, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);

  /* "validator.pyx":4594
 * 
 *     X = check_array(
 *         X,             # <<<<<<<<<<<<<<
 *         accept_sparse=accept_sparse,
 *         accept_large_sparse=accept_large_sparse,
 */
  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4593, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_INCREF(__pyx_v_X);
  __Pyx_GIVEREF(__pyx_v_X);
  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_X);

  /* "validator.pyx":4595
 *     X = check_array(
 *         X,
 *         accept_sparse=accept_sparse,             # <<<<<<<<<<<<<<
 *         accept_large_sparse=accept_large_sparse,
 *         dtype=dtype,
 */
  __pyx_t_5 = __Pyx_PyDict_NewPresized(13); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4595, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_accept_sparse, __pyx_v_accept_sparse) < 0) __PYX_ERR(0, 4595, __pyx_L1_error)

  /* "validator.pyx":4596
 *         X,
 *         accept_sparse=accept_sparse,
 *         accept_large_sparse=accept_large_sparse,             # <<<<<<<<<<<<<<
 *         dtype=dtype,
 *         order=order,
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_accept_large_sparse, __pyx_v_accept_large_sparse) < 0) __PYX_ERR(0, 4595, __pyx_L1_error)

  /* "validator.pyx":4597
 *         accept_sparse=accept_sparse,
 *         accept_large_sparse=accept_large_sparse,
 *         dtype=dtype,             # <<<<<<<<<<<<<<
 *         order=order,
 *         copy=copy,
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_dtype, __pyx_v_dtype) < 0) __PYX_ERR(0, 4595, __pyx_L1_error)

  /* "validator.pyx":4598
 *         accept_large_sparse=accept_large_sparse,
 *         dtype=dtype,
 *         order=order,             # <<<<<<<<<<<<<<
 *         copy=copy,
 *         force_all_finite=force_all_finite,
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_order, __pyx_v_order) < 0) __PYX_ERR(0, 4595, __pyx_L1_error)

  /* "validator.pyx":4599
 *         dtype=dtype,
 *         order=order,
 *         copy=copy,             # <<<<<<<<<<<<<<
 *         force_all_finite=force_all_finite,
 *         ensure_2d=ensure_2d,
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_copy, __pyx_v_copy) < 0) __PYX_ERR(0, 4595, __pyx_L1_error)

  /* "validator.pyx":4600
 *         order=order,
 *         copy=copy,
 *         force_all_finite=force_all_finite,             # <<<<<<<<<<<<<<
 *         ensure_2d=ensure_2d,
 *         allow_nd=allow_nd,
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_force_all_finite, __pyx_v_force_all_finite) < 0) __PYX_ERR(0, 4595, __pyx_L1_error)

  /* "validator.pyx":4601
 *         copy=copy,
 *         force_all_finite=force_all_finite,
 *         ensure_2d=ensure_2d,             # <<<<<<<<<<<<<<
 *         allow_nd=allow_nd,
 *         ensure_min_samples=ensure_min_samples,
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_ensure_2d, __pyx_v_ensure_2d) < 0) __PYX_ERR(0, 4595, __pyx_L1_error)

  /* "validator.pyx":4602
 *         force_all_finite=force_all_finite,
 *         ensure_2d=ensure_2d,
 *         allow_nd=allow_nd,             # <<<<<<<<<<<<<<
 *         ensure_min_samples=ensure_min_samples,
 *         ensure_min_features=ensure_min_features,
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_allow_nd, __pyx_v_allow_nd) < 0) __PYX_ERR(0, 4595, __pyx_L1_error)

  /* "validator.pyx":4603
 *         ensure_2d=ensure_2d,
 *         allow_nd=allow_nd,
 *         ensure_min_samples=ensure_min_samples,             # <<<<<<<<<<<<<<
 *         ensure_min_features=ensure_min_features,
 *         estimator=estimator,
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_ensure_min_samples, __pyx_v_ensure_min_samples) < 0) __PYX_ERR(0, 4595, __pyx_L1_error)

  /* "validator.pyx":4604
 *         allow_nd=allow_nd,
 *         ensure_min_samples=ensure_min_samples,
 *         ensure_min_features=ensure_min_features,             # <<<<<<<<<<<<<<
 *         estimator=estimator,
 *         input_name="X",
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_ensure_min_features, __pyx_v_ensure_min_features) < 0) __PYX_ERR(0, 4595, __pyx_L1_error)

  /* "validator.pyx":4605
 *         ensure_min_samples=ensure_min_samples,
 *         ensure_min_features=ensure_min_features,
 *         estimator=estimator,             # <<<<<<<<<<<<<<
 *         input_name="X",
 *         to_frame=to_frame
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_estimator, __pyx_v_estimator) < 0) __PYX_ERR(0, 4595, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_input_name, __pyx_n_u_X) < 0) __PYX_ERR(0, 4595, __pyx_L1_error)

  /* "validator.pyx":4607
 *         estimator=estimator,
 *         input_name="X",
 *         to_frame=to_frame             # <<<<<<<<<<<<<<
 *     )
 * 
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_to_frame, __pyx_v_to_frame) < 0) __PYX_ERR(0, 4595, __pyx_L1_error)

  /* "validator.pyx":4593
 *         )
 * 
 *     X = check_array(             # <<<<<<<<<<<<<<
 *         X,
 *         accept_sparse=accept_sparse,
 */
  __pyx_t_6 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4593, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_6);
  __pyx_t_6 = 0;

  /* "validator.pyx":4610
 *     )
 * 
 *     y = check_y(             # <<<<<<<<<<<<<<
 *         y,
 *         multi_output=multi_output,
 */
  __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_check_y); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4610, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);

  /* "validator.pyx":4611
 * 
 *     y = check_y(
 *         y,             # <<<<<<<<<<<<<<
 *         multi_output=multi_output,
 *         y_numeric=y_numeric,
 */
  __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4610, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_INCREF(__pyx_v_y);
  __Pyx_GIVEREF(__pyx_v_y);
  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_y);

  /* "validator.pyx":4612
 *     y = check_y(
 *         y,
 *         multi_output=multi_output,             # <<<<<<<<<<<<<<
 *         y_numeric=y_numeric,
 *         estimator=estimator
 */
  __pyx_t_4 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4612, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_multi_output, __pyx_v_multi_output) < 0) __PYX_ERR(0, 4612, __pyx_L1_error)

  /* "validator.pyx":4613
 *         y,
 *         multi_output=multi_output,
 *         y_numeric=y_numeric,             # <<<<<<<<<<<<<<
 *         estimator=estimator
 *         )
 */
  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_y_numeric, __pyx_v_y_numeric) < 0) __PYX_ERR(0, 4612, __pyx_L1_error)

  /* "validator.pyx":4614
 *         multi_output=multi_output,
 *         y_numeric=y_numeric,
 *         estimator=estimator             # <<<<<<<<<<<<<<
 *         )
 * 
 */
  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_estimator, __pyx_v_estimator) < 0) __PYX_ERR(0, 4612, __pyx_L1_error)

  /* "validator.pyx":4610
 *     )
 * 
 *     y = check_y(             # <<<<<<<<<<<<<<
 *         y,
 *         multi_output=multi_output,
 */
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_6, __pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4610, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF_SET(__pyx_v_y, __pyx_t_3);
  __pyx_t_3 = 0;

  /* "validator.pyx":4617
 *         )
 * 
 *     check_consistent_length(X, y)             # <<<<<<<<<<<<<<
 * 
 *     return X, y
 */
  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_check_consistent_length); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4617, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = NULL;
  __pyx_t_7 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
      __pyx_t_7 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_4)) {
    PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_X, __pyx_v_y};
    __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4617, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_GOTREF(__pyx_t_3);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
    PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_X, __pyx_v_y};
    __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_7, 2+__pyx_t_7); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4617, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_GOTREF(__pyx_t_3);
  } else
  #endif
  {
    __pyx_t_6 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 4617, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    if (__pyx_t_5) {
      __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5); __pyx_t_5 = NULL;
    }
    __Pyx_INCREF(__pyx_v_X);
    __Pyx_GIVEREF(__pyx_v_X);
    PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_7, __pyx_v_X);
    __Pyx_INCREF(__pyx_v_y);
    __Pyx_GIVEREF(__pyx_v_y);
    PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_7, __pyx_v_y);
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_6, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4617, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  }
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "validator.pyx":4619
 *     check_consistent_length(X, y)
 * 
 *     return X, y             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4619, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_v_X);
  __Pyx_GIVEREF(__pyx_v_X);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_X);
  __Pyx_INCREF(__pyx_v_y);
  __Pyx_GIVEREF(__pyx_v_y);
  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_y);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "validator.pyx":4489
 *     return array
 * 
 * def check_X_y(             # <<<<<<<<<<<<<<
 *     X,
 *     y,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("validator.check_X_y", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_estimator_name);
  __Pyx_XDECREF(__pyx_v_X);
  __Pyx_XDECREF(__pyx_v_y);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":4622
 * 
 * 
 * def check_y(y,             # <<<<<<<<<<<<<<
 *     multi_output=False,
 *     y_numeric=False,
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_151check_y(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_150check_y[] = "\n    Validates the target array `y`, ensuring it is suitable for classification \n    or regression tasks based on its content and the specified strategy.\n    \n    Parameters \n    -----------\n    multi_output : bool, default=False\n        Whether to allow 2D y (array or sparse matrix). If false, y will be\n        validated as a vector. y cannot have np.nan or np.inf values if\n        multi_output=True.\n    y_numeric : bool, default=False\n        Whether to ensure that y has a numeric type. If dtype of y is object,\n        it is converted to float64. Should only be used for regression\n        algorithms.\n    input_name : str, default=\"y\"\n       The data name used to construct the error message. In particular\n       if `input_name` is \"y\".    \n    estimator : str or estimator instance, default=None\n        If passed, include the name of the estimator in warning messages.\n    allow_nan : bool, default=False\n       If True, do not throw error when `y` contains NaN.\n    to_frame:bool, default=False, \n        reconvert array to its initial type if it is given as pd.Series or\n        pd.DataFrame. \n    Returns\n    --------\n    y: array-like, \n    y_converted : object\n        The converted and validated y.\n        \n    ";
static PyMethodDef __pyx_mdef_9validator_151check_y = {"check_y", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_151check_y, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_150check_y};
static PyObject *__pyx_pw_9validator_151check_y(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_y = 0;
  PyObject *__pyx_v_multi_output = 0;
  PyObject *__pyx_v_y_numeric = 0;
  PyObject *__pyx_v_input_name = 0;
  PyObject *__pyx_v_estimator = 0;
  PyObject *__pyx_v_to_frame = 0;
  PyObject *__pyx_v_allow_nan = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("check_y (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_y,&__pyx_n_s_multi_output,&__pyx_n_s_y_numeric,&__pyx_n_s_input_name,&__pyx_n_s_estimator,&__pyx_n_s_to_frame,&__pyx_n_s_allow_nan_2,0};
    PyObject* values[7] = {0,0,0,0,0,0,0};

    /* "validator.pyx":4623
 * 
 * def check_y(y,
 *     multi_output=False,             # <<<<<<<<<<<<<<
 *     y_numeric=False,
 *     input_name ="y",
 */
    values[1] = ((PyObject *)Py_False);

    /* "validator.pyx":4624
 * def check_y(y,
 *     multi_output=False,
 *     y_numeric=False,             # <<<<<<<<<<<<<<
 *     input_name ="y",
 *     estimator=None,
 */
    values[2] = ((PyObject *)Py_False);
    values[3] = ((PyObject *)__pyx_n_u_y);

    /* "validator.pyx":4626
 *     y_numeric=False,
 *     input_name ="y",
 *     estimator=None,             # <<<<<<<<<<<<<<
 *     to_frame=False,
 *     allow_nan= False,
 */
    values[4] = ((PyObject *)Py_None);

    /* "validator.pyx":4627
 *     input_name ="y",
 *     estimator=None,
 *     to_frame=False,             # <<<<<<<<<<<<<<
 *     allow_nan= False,
 *     ):
 */
    values[5] = ((PyObject *)Py_False);

    /* "validator.pyx":4628
 *     estimator=None,
 *     to_frame=False,
 *     allow_nan= False,             # <<<<<<<<<<<<<<
 *     ):
 *     """
 */
    values[6] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_multi_output);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y_numeric);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_input_name);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_estimator);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_to_frame);
          if (value) { values[5] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  6:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_allow_nan_2);
          if (value) { values[6] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "check_y") < 0)) __PYX_ERR(0, 4622, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_y = values[0];
    __pyx_v_multi_output = values[1];
    __pyx_v_y_numeric = values[2];
    __pyx_v_input_name = values[3];
    __pyx_v_estimator = values[4];
    __pyx_v_to_frame = values[5];
    __pyx_v_allow_nan = values[6];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("check_y", 0, 1, 7, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4622, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.check_y", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_150check_y(__pyx_self, __pyx_v_y, __pyx_v_multi_output, __pyx_v_y_numeric, __pyx_v_input_name, __pyx_v_estimator, __pyx_v_to_frame, __pyx_v_allow_nan);

  /* "validator.pyx":4622
 * 
 * 
 * def check_y(y,             # <<<<<<<<<<<<<<
 *     multi_output=False,
 *     y_numeric=False,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_150check_y(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y, PyObject *__pyx_v_multi_output, PyObject *__pyx_v_y_numeric, PyObject *__pyx_v_input_name, PyObject *__pyx_v_estimator, PyObject *__pyx_v_to_frame, PyObject *__pyx_v_allow_nan) {
  PyObject *__pyx_v_column_orig = NULL;
  PyObject *__pyx_v_estimator_name = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *(*__pyx_t_5)(PyObject *);
  int __pyx_t_6;
  int __pyx_t_7;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("check_y", 0);
  __Pyx_INCREF(__pyx_v_y);

  /* "validator.pyx":4661
 * 
 *     """
 *     y, column_orig = convert_array_to_pandas(y, input_name= input_name )             # <<<<<<<<<<<<<<
 *     if multi_output:
 *         y = check_array(
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_convert_array_to_pandas); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4661, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4661, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_y);
  __Pyx_GIVEREF(__pyx_v_y);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_y);
  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4661, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_input_name, __pyx_v_input_name) < 0) __PYX_ERR(0, 4661, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4661, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if ((likely(PyTuple_CheckExact(__pyx_t_4))) || (PyList_CheckExact(__pyx_t_4))) {
    PyObject* sequence = __pyx_t_4;
    Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
    if (unlikely(size != 2)) {
      if (size > 2) __Pyx_RaiseTooManyValuesError(2);
      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
      __PYX_ERR(0, 4661, __pyx_L1_error)
    }
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    if (likely(PyTuple_CheckExact(sequence))) {
      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 0); 
      __pyx_t_2 = PyTuple_GET_ITEM(sequence, 1); 
    } else {
      __pyx_t_3 = PyList_GET_ITEM(sequence, 0); 
      __pyx_t_2 = PyList_GET_ITEM(sequence, 1); 
    }
    __Pyx_INCREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_t_2);
    #else
    __pyx_t_3 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4661, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_2 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4661, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    #endif
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  } else {
    Py_ssize_t index = -1;
    __pyx_t_1 = PyObject_GetIter(__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4661, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_5 = Py_TYPE(__pyx_t_1)->tp_iternext;
    index = 0; __pyx_t_3 = __pyx_t_5(__pyx_t_1); if (unlikely(!__pyx_t_3)) goto __pyx_L3_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_3);
    index = 1; __pyx_t_2 = __pyx_t_5(__pyx_t_1); if (unlikely(!__pyx_t_2)) goto __pyx_L3_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_2);
    if (__Pyx_IternextUnpackEndCheck(__pyx_t_5(__pyx_t_1), 2) < 0) __PYX_ERR(0, 4661, __pyx_L1_error)
    __pyx_t_5 = NULL;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    goto __pyx_L4_unpacking_done;
    __pyx_L3_unpacking_failed:;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_5 = NULL;
    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
    __PYX_ERR(0, 4661, __pyx_L1_error)
    __pyx_L4_unpacking_done:;
  }
  __Pyx_DECREF_SET(__pyx_v_y, __pyx_t_3);
  __pyx_t_3 = 0;
  __pyx_v_column_orig = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "validator.pyx":4662
 *     """
 *     y, column_orig = convert_array_to_pandas(y, input_name= input_name )
 *     if multi_output:             # <<<<<<<<<<<<<<
 *         y = check_array(
 *             y,
 */
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_multi_output); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 4662, __pyx_L1_error)
  if (__pyx_t_6) {

    /* "validator.pyx":4663
 *     y, column_orig = convert_array_to_pandas(y, input_name= input_name )
 *     if multi_output:
 *         y = check_array(             # <<<<<<<<<<<<<<
 *             y,
 *             accept_sparse="csr",
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_check_array); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4663, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);

    /* "validator.pyx":4664
 *     if multi_output:
 *         y = check_array(
 *             y,             # <<<<<<<<<<<<<<
 *             accept_sparse="csr",
 *             force_all_finite= True if not allow_nan else "allow-nan",
 */
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4663, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_v_y);
    __Pyx_GIVEREF(__pyx_v_y);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_y);

    /* "validator.pyx":4665
 *         y = check_array(
 *             y,
 *             accept_sparse="csr",             # <<<<<<<<<<<<<<
 *             force_all_finite= True if not allow_nan else "allow-nan",
 *             ensure_2d=False,
 */
    __pyx_t_3 = __Pyx_PyDict_NewPresized(6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4665, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_accept_sparse, __pyx_n_u_csr) < 0) __PYX_ERR(0, 4665, __pyx_L1_error)

    /* "validator.pyx":4666
 *             y,
 *             accept_sparse="csr",
 *             force_all_finite= True if not allow_nan else "allow-nan",             # <<<<<<<<<<<<<<
 *             ensure_2d=False,
 *             dtype=None,
 */
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_allow_nan); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 4666, __pyx_L1_error)
    if (((!__pyx_t_6) != 0)) {
      __Pyx_INCREF(Py_True);
      __pyx_t_1 = Py_True;
    } else {
      __Pyx_INCREF(__pyx_kp_u_allow_nan);
      __pyx_t_1 = __pyx_kp_u_allow_nan;
    }
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_force_all_finite, __pyx_t_1) < 0) __PYX_ERR(0, 4665, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "validator.pyx":4667
 *             accept_sparse="csr",
 *             force_all_finite= True if not allow_nan else "allow-nan",
 *             ensure_2d=False,             # <<<<<<<<<<<<<<
 *             dtype=None,
 *             input_name=input_name,
 */
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_ensure_2d, Py_False) < 0) __PYX_ERR(0, 4665, __pyx_L1_error)

    /* "validator.pyx":4668
 *             force_all_finite= True if not allow_nan else "allow-nan",
 *             ensure_2d=False,
 *             dtype=None,             # <<<<<<<<<<<<<<
 *             input_name=input_name,
 *             estimator=estimator,
 */
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_dtype, Py_None) < 0) __PYX_ERR(0, 4665, __pyx_L1_error)

    /* "validator.pyx":4669
 *             ensure_2d=False,
 *             dtype=None,
 *             input_name=input_name,             # <<<<<<<<<<<<<<
 *             estimator=estimator,
 *         )
 */
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_input_name, __pyx_v_input_name) < 0) __PYX_ERR(0, 4665, __pyx_L1_error)

    /* "validator.pyx":4670
 *             dtype=None,
 *             input_name=input_name,
 *             estimator=estimator,             # <<<<<<<<<<<<<<
 *         )
 *     else:
 */
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_estimator, __pyx_v_estimator) < 0) __PYX_ERR(0, 4665, __pyx_L1_error)

    /* "validator.pyx":4663
 *     y, column_orig = convert_array_to_pandas(y, input_name= input_name )
 *     if multi_output:
 *         y = check_array(             # <<<<<<<<<<<<<<
 *             y,
 *             accept_sparse="csr",
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4663, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF_SET(__pyx_v_y, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "validator.pyx":4662
 *     """
 *     y, column_orig = convert_array_to_pandas(y, input_name= input_name )
 *     if multi_output:             # <<<<<<<<<<<<<<
 *         y = check_array(
 *             y,
 */
    goto __pyx_L5;
  }

  /* "validator.pyx":4673
 *         )
 *     else:
 *         estimator_name = _check_estimator_name(estimator)             # <<<<<<<<<<<<<<
 *         y = _check_y_1d(y, warn=True, input_name=input_name)
 *         _assert_all_finite(y, input_name=input_name,
 */
  /*else*/ {
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_check_estimator_name); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4673, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_2 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_2)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_2);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_v_estimator) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_estimator);
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4673, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_v_estimator_name = __pyx_t_1;
    __pyx_t_1 = 0;

    /* "validator.pyx":4674
 *     else:
 *         estimator_name = _check_estimator_name(estimator)
 *         y = _check_y_1d(y, warn=True, input_name=input_name)             # <<<<<<<<<<<<<<
 *         _assert_all_finite(y, input_name=input_name,
 *                            estimator_name=estimator_name,
 */
    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_check_y_1d); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4674, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4674, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_v_y);
    __Pyx_GIVEREF(__pyx_v_y);
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_y);
    __pyx_t_2 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4674, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_warn, Py_True) < 0) __PYX_ERR(0, 4674, __pyx_L1_error)
    if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_input_name, __pyx_v_input_name) < 0) __PYX_ERR(0, 4674, __pyx_L1_error)
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4674, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF_SET(__pyx_v_y, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "validator.pyx":4675
 *         estimator_name = _check_estimator_name(estimator)
 *         y = _check_y_1d(y, warn=True, input_name=input_name)
 *         _assert_all_finite(y, input_name=input_name,             # <<<<<<<<<<<<<<
 *                            estimator_name=estimator_name,
 *                            allow_nan=allow_nan ,
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_assert_all_finite); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4675, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4675, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_v_y);
    __Pyx_GIVEREF(__pyx_v_y);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_y);
    __pyx_t_3 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4675, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_input_name, __pyx_v_input_name) < 0) __PYX_ERR(0, 4675, __pyx_L1_error)

    /* "validator.pyx":4676
 *         y = _check_y_1d(y, warn=True, input_name=input_name)
 *         _assert_all_finite(y, input_name=input_name,
 *                            estimator_name=estimator_name,             # <<<<<<<<<<<<<<
 *                            allow_nan=allow_nan ,
 *                            )
 */
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_estimator_name, __pyx_v_estimator_name) < 0) __PYX_ERR(0, 4675, __pyx_L1_error)

    /* "validator.pyx":4677
 *         _assert_all_finite(y, input_name=input_name,
 *                            estimator_name=estimator_name,
 *                            allow_nan=allow_nan ,             # <<<<<<<<<<<<<<
 *                            )
 *         _ensure_no_complex_data(y)
 */
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_allow_nan_2, __pyx_v_allow_nan) < 0) __PYX_ERR(0, 4675, __pyx_L1_error)

    /* "validator.pyx":4675
 *         estimator_name = _check_estimator_name(estimator)
 *         y = _check_y_1d(y, warn=True, input_name=input_name)
 *         _assert_all_finite(y, input_name=input_name,             # <<<<<<<<<<<<<<
 *                            estimator_name=estimator_name,
 *                            allow_nan=allow_nan ,
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4675, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "validator.pyx":4679
 *                            allow_nan=allow_nan ,
 *                            )
 *         _ensure_no_complex_data(y)             # <<<<<<<<<<<<<<
 *     if y_numeric and y.dtype.kind == "O":
 *         y = y.astype(np.float64)
 */
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_ensure_no_complex_data); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4679, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_2 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_2)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_2);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_v_y) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_y);
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4679, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }
  __pyx_L5:;

  /* "validator.pyx":4680
 *                            )
 *         _ensure_no_complex_data(y)
 *     if y_numeric and y.dtype.kind == "O":             # <<<<<<<<<<<<<<
 *         y = y.astype(np.float64)
 * 
 */
  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_y_numeric); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 4680, __pyx_L1_error)
  if (__pyx_t_7) {
  } else {
    __pyx_t_6 = __pyx_t_7;
    goto __pyx_L7_bool_binop_done;
  }
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_y, __pyx_n_s_dtype); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4680, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_kind); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4680, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_7 = (__Pyx_PyUnicode_Equals(__pyx_t_3, __pyx_n_u_O, Py_EQ)); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 4680, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_6 = __pyx_t_7;
  __pyx_L7_bool_binop_done:;
  if (__pyx_t_6) {

    /* "validator.pyx":4681
 *         _ensure_no_complex_data(y)
 *     if y_numeric and y.dtype.kind == "O":
 *         y = y.astype(np.float64)             # <<<<<<<<<<<<<<
 * 
 *     if to_frame:
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_y, __pyx_n_s_astype); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4681, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_np); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4681, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_float64); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4681, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_2)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_2);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    __pyx_t_3 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_2, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_4);
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4681, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF_SET(__pyx_v_y, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "validator.pyx":4680
 *                            )
 *         _ensure_no_complex_data(y)
 *     if y_numeric and y.dtype.kind == "O":             # <<<<<<<<<<<<<<
 *         y = y.astype(np.float64)
 * 
 */
  }

  /* "validator.pyx":4683
 *         y = y.astype(np.float64)
 * 
 *     if to_frame:             # <<<<<<<<<<<<<<
 *         y = array_to_frame (
 *             y, to_frame =to_frame ,
 */
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_to_frame); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 4683, __pyx_L1_error)
  if (__pyx_t_6) {

    /* "validator.pyx":4684
 * 
 *     if to_frame:
 *         y = array_to_frame (             # <<<<<<<<<<<<<<
 *             y, to_frame =to_frame ,
 *             columns = column_orig,
 */
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_array_to_frame); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4684, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);

    /* "validator.pyx":4685
 *     if to_frame:
 *         y = array_to_frame (
 *             y, to_frame =to_frame ,             # <<<<<<<<<<<<<<
 *             columns = column_orig,
 *             input_name=input_name,
 */
    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4684, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_INCREF(__pyx_v_y);
    __Pyx_GIVEREF(__pyx_v_y);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_y);
    __pyx_t_4 = __Pyx_PyDict_NewPresized(4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4685, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_to_frame, __pyx_v_to_frame) < 0) __PYX_ERR(0, 4685, __pyx_L1_error)

    /* "validator.pyx":4686
 *         y = array_to_frame (
 *             y, to_frame =to_frame ,
 *             columns = column_orig,             # <<<<<<<<<<<<<<
 *             input_name=input_name,
 *             raise_warning="mute",
 */
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_columns, __pyx_v_column_orig) < 0) __PYX_ERR(0, 4685, __pyx_L1_error)

    /* "validator.pyx":4687
 *             y, to_frame =to_frame ,
 *             columns = column_orig,
 *             input_name=input_name,             # <<<<<<<<<<<<<<
 *             raise_warning="mute",
 *             )
 */
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_input_name, __pyx_v_input_name) < 0) __PYX_ERR(0, 4685, __pyx_L1_error)
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_raise_warning, __pyx_n_u_mute) < 0) __PYX_ERR(0, 4685, __pyx_L1_error)

    /* "validator.pyx":4684
 * 
 *     if to_frame:
 *         y = array_to_frame (             # <<<<<<<<<<<<<<
 *             y, to_frame =to_frame ,
 *             columns = column_orig,
 */
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_1, __pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4684, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF_SET(__pyx_v_y, __pyx_t_2);
    __pyx_t_2 = 0;

    /* "validator.pyx":4683
 *         y = y.astype(np.float64)
 * 
 *     if to_frame:             # <<<<<<<<<<<<<<
 *         y = array_to_frame (
 *             y, to_frame =to_frame ,
 */
  }

  /* "validator.pyx":4691
 *             )
 * 
 *     return y             # <<<<<<<<<<<<<<
 * 
 * def validate_dtype_selector(dtype_selector: str) -> str:
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_y);
  __pyx_r = __pyx_v_y;
  goto __pyx_L0;

  /* "validator.pyx":4622
 * 
 * 
 * def check_y(y,             # <<<<<<<<<<<<<<
 *     multi_output=False,
 *     y_numeric=False,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("validator.check_y", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_column_orig);
  __Pyx_XDECREF(__pyx_v_estimator_name);
  __Pyx_XDECREF(__pyx_v_y);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":4693
 *     return y
 * 
 * def validate_dtype_selector(dtype_selector: str) -> str:             # <<<<<<<<<<<<<<
 *     """
 *     Validates and categorizes the dtype_selector using regex, including handling
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_153validate_dtype_selector(PyObject *__pyx_self, PyObject *__pyx_v_dtype_selector); /*proto*/
static char __pyx_doc_9validator_152validate_dtype_selector[] = "\n    Validates and categorizes the dtype_selector using regex, including handling \n    cases where 'only' is specifically included.\n    \n    Parameters:\n    - dtype_selector (str): The input dtype selector string.\n\n    Returns:\n    - str: A categorized dtype_selector based on predefined patterns. \n          If 'only' is included,\n           the returned category will reflect this to enable specific data \n           type handling.\n\n    Raises:\n    - ValueError: If the input dtype_selector does not match any predefined\n      category.\n    ";
static PyMethodDef __pyx_mdef_9validator_153validate_dtype_selector = {"validate_dtype_selector", (PyCFunction)__pyx_pw_9validator_153validate_dtype_selector, METH_O, __pyx_doc_9validator_152validate_dtype_selector};
static PyObject *__pyx_pw_9validator_153validate_dtype_selector(PyObject *__pyx_self, PyObject *__pyx_v_dtype_selector) {
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("validate_dtype_selector (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_dtype_selector), (&PyUnicode_Type), 1, "dtype_selector", 1))) __PYX_ERR(0, 4693, __pyx_L1_error)
  __pyx_r = __pyx_pf_9validator_152validate_dtype_selector(__pyx_self, ((PyObject*)__pyx_v_dtype_selector));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_152validate_dtype_selector(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_dtype_selector) {
  PyObject *__pyx_v_types = NULL;
  PyObject *__pyx_v_numeric_pattern = NULL;
  PyObject *__pyx_v_categoric_pattern = NULL;
  PyObject *__pyx_v_datetime_pattern = NULL;
  PyObject *__pyx_v_biselect_pattern = NULL;
  PyObject *__pyx_v_suffix = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("validate_dtype_selector", 0);

  /* "validator.pyx":4711
 *       category.
 *     """
 *     types = [             # <<<<<<<<<<<<<<
 *         "numeric", "numeric_only", "categoric", "categoric_only",
 *         "biselect","biselector", "datetime"]
 */
  __pyx_t_1 = PyList_New(7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4711, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_u_numeric);
  __Pyx_GIVEREF(__pyx_n_u_numeric);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_u_numeric);
  __Pyx_INCREF(__pyx_n_u_numeric_only);
  __Pyx_GIVEREF(__pyx_n_u_numeric_only);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_u_numeric_only);
  __Pyx_INCREF(__pyx_n_u_categoric);
  __Pyx_GIVEREF(__pyx_n_u_categoric);
  PyList_SET_ITEM(__pyx_t_1, 2, __pyx_n_u_categoric);
  __Pyx_INCREF(__pyx_n_u_categoric_only);
  __Pyx_GIVEREF(__pyx_n_u_categoric_only);
  PyList_SET_ITEM(__pyx_t_1, 3, __pyx_n_u_categoric_only);
  __Pyx_INCREF(__pyx_n_u_biselect);
  __Pyx_GIVEREF(__pyx_n_u_biselect);
  PyList_SET_ITEM(__pyx_t_1, 4, __pyx_n_u_biselect);
  __Pyx_INCREF(__pyx_n_u_biselector);
  __Pyx_GIVEREF(__pyx_n_u_biselector);
  PyList_SET_ITEM(__pyx_t_1, 5, __pyx_n_u_biselector);
  __Pyx_INCREF(__pyx_n_u_datetime);
  __Pyx_GIVEREF(__pyx_n_u_datetime);
  PyList_SET_ITEM(__pyx_t_1, 6, __pyx_n_u_datetime);
  __pyx_v_types = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":4715
 *         "biselect","biselector", "datetime"]
 *     # Regex patterns for matching dtype_selector categories with an optional 'only'
 *     numeric_pattern = r"numeric(_only)?"             # <<<<<<<<<<<<<<
 *     categoric_pattern = r"categoric(al|_only)?|categorical"
 *     datetime_pattern = r"dt|datetime"
 */
  __Pyx_INCREF(__pyx_kp_u_numeric__only);
  __pyx_v_numeric_pattern = __pyx_kp_u_numeric__only;

  /* "validator.pyx":4716
 *     # Regex patterns for matching dtype_selector categories with an optional 'only'
 *     numeric_pattern = r"numeric(_only)?"
 *     categoric_pattern = r"categoric(al|_only)?|categorical"             # <<<<<<<<<<<<<<
 *     datetime_pattern = r"dt|datetime"
 *     biselect_pattern = r"bi[-_]?selector|biselect|biselector"
 */
  __Pyx_INCREF(__pyx_kp_u_categoric_al__only_categorical);
  __pyx_v_categoric_pattern = __pyx_kp_u_categoric_al__only_categorical;

  /* "validator.pyx":4717
 *     numeric_pattern = r"numeric(_only)?"
 *     categoric_pattern = r"categoric(al|_only)?|categorical"
 *     datetime_pattern = r"dt|datetime"             # <<<<<<<<<<<<<<
 *     biselect_pattern = r"bi[-_]?selector|biselect|biselector"
 * 
 */
  __Pyx_INCREF(__pyx_kp_u_dt_datetime);
  __pyx_v_datetime_pattern = __pyx_kp_u_dt_datetime;

  /* "validator.pyx":4718
 *     categoric_pattern = r"categoric(al|_only)?|categorical"
 *     datetime_pattern = r"dt|datetime"
 *     biselect_pattern = r"bi[-_]?selector|biselect|biselector"             # <<<<<<<<<<<<<<
 * 
 *     # Check if 'only' is included and modify the category accordingly
 */
  __Pyx_INCREF(__pyx_kp_u_bi___selector_biselect_biselecto);
  __pyx_v_biselect_pattern = __pyx_kp_u_bi___selector_biselect_biselecto;

  /* "validator.pyx":4721
 * 
 *     # Check if 'only' is included and modify the category accordingly
 *     suffix = "_only" if "only" in str(dtype_selector).lower() else ""             # <<<<<<<<<<<<<<
 * 
 *     if re.match(numeric_pattern, dtype_selector, re.IGNORECASE):
 */
  __pyx_t_3 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyUnicode_Type)), __pyx_v_dtype_selector); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4721, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_lower); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4721, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4721, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_5 = (__Pyx_PySequence_ContainsTF(__pyx_n_u_only, __pyx_t_2, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 4721, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if ((__pyx_t_5 != 0)) {
    __Pyx_INCREF(__pyx_n_u_only_2);
    __pyx_t_1 = __pyx_n_u_only_2;
  } else {
    __Pyx_INCREF(__pyx_kp_u__7);
    __pyx_t_1 = __pyx_kp_u__7;
  }
  __pyx_v_suffix = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":4723
 *     suffix = "_only" if "only" in str(dtype_selector).lower() else ""
 * 
 *     if re.match(numeric_pattern, dtype_selector, re.IGNORECASE):             # <<<<<<<<<<<<<<
 *         return f"numeric{suffix}"
 *     elif re.match(categoric_pattern, dtype_selector, re.IGNORECASE):
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_re); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4723, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_match); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4723, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_re); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4723, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_IGNORECASE); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4723, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  __pyx_t_6 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
      __pyx_t_6 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_4)) {
    PyObject *__pyx_temp[4] = {__pyx_t_2, __pyx_v_numeric_pattern, __pyx_v_dtype_selector, __pyx_t_3};
    __pyx_t_1 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4723, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
    PyObject *__pyx_temp[4] = {__pyx_t_2, __pyx_v_numeric_pattern, __pyx_v_dtype_selector, __pyx_t_3};
    __pyx_t_1 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4723, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else
  #endif
  {
    __pyx_t_7 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4723, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    if (__pyx_t_2) {
      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_2); __pyx_t_2 = NULL;
    }
    __Pyx_INCREF(__pyx_v_numeric_pattern);
    __Pyx_GIVEREF(__pyx_v_numeric_pattern);
    PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_v_numeric_pattern);
    __Pyx_INCREF(__pyx_v_dtype_selector);
    __Pyx_GIVEREF(__pyx_v_dtype_selector);
    PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_v_dtype_selector);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_7, 2+__pyx_t_6, __pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4723, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  }
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 4723, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_5) {

    /* "validator.pyx":4724
 * 
 *     if re.match(numeric_pattern, dtype_selector, re.IGNORECASE):
 *         return f"numeric{suffix}"             # <<<<<<<<<<<<<<
 *     elif re.match(categoric_pattern, dtype_selector, re.IGNORECASE):
 *         return f"categoric{suffix}"
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_1 = __Pyx_PyUnicode_Unicode(__pyx_v_suffix); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4724, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = __Pyx_PyUnicode_Concat(__pyx_n_u_numeric, __pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4724, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_r = ((PyObject*)__pyx_t_4);
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "validator.pyx":4723
 *     suffix = "_only" if "only" in str(dtype_selector).lower() else ""
 * 
 *     if re.match(numeric_pattern, dtype_selector, re.IGNORECASE):             # <<<<<<<<<<<<<<
 *         return f"numeric{suffix}"
 *     elif re.match(categoric_pattern, dtype_selector, re.IGNORECASE):
 */
  }

  /* "validator.pyx":4725
 *     if re.match(numeric_pattern, dtype_selector, re.IGNORECASE):
 *         return f"numeric{suffix}"
 *     elif re.match(categoric_pattern, dtype_selector, re.IGNORECASE):             # <<<<<<<<<<<<<<
 *         return f"categoric{suffix}"
 *     elif re.match(datetime_pattern, dtype_selector, re.IGNORECASE):
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_re); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4725, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_match); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4725, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_re); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4725, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_IGNORECASE); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4725, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = NULL;
  __pyx_t_6 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_7))) {
    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_7);
    if (likely(__pyx_t_1)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
      __Pyx_INCREF(__pyx_t_1);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_7, function);
      __pyx_t_6 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_7)) {
    PyObject *__pyx_temp[4] = {__pyx_t_1, __pyx_v_categoric_pattern, __pyx_v_dtype_selector, __pyx_t_3};
    __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4725, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_7)) {
    PyObject *__pyx_temp[4] = {__pyx_t_1, __pyx_v_categoric_pattern, __pyx_v_dtype_selector, __pyx_t_3};
    __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_7, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4725, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else
  #endif
  {
    __pyx_t_2 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4725, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    if (__pyx_t_1) {
      __Pyx_GIVEREF(__pyx_t_1); PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1); __pyx_t_1 = NULL;
    }
    __Pyx_INCREF(__pyx_v_categoric_pattern);
    __Pyx_GIVEREF(__pyx_v_categoric_pattern);
    PyTuple_SET_ITEM(__pyx_t_2, 0+__pyx_t_6, __pyx_v_categoric_pattern);
    __Pyx_INCREF(__pyx_v_dtype_selector);
    __Pyx_GIVEREF(__pyx_v_dtype_selector);
    PyTuple_SET_ITEM(__pyx_t_2, 1+__pyx_t_6, __pyx_v_dtype_selector);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_2, 2+__pyx_t_6, __pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_2, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4725, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  }
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 4725, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (__pyx_t_5) {

    /* "validator.pyx":4726
 *         return f"numeric{suffix}"
 *     elif re.match(categoric_pattern, dtype_selector, re.IGNORECASE):
 *         return f"categoric{suffix}"             # <<<<<<<<<<<<<<
 *     elif re.match(datetime_pattern, dtype_selector, re.IGNORECASE):
 *         return "datetime"
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_4 = __Pyx_PyUnicode_Unicode(__pyx_v_suffix); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4726, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_7 = __Pyx_PyUnicode_Concat(__pyx_n_u_categoric, __pyx_t_4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4726, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_r = ((PyObject*)__pyx_t_7);
    __pyx_t_7 = 0;
    goto __pyx_L0;

    /* "validator.pyx":4725
 *     if re.match(numeric_pattern, dtype_selector, re.IGNORECASE):
 *         return f"numeric{suffix}"
 *     elif re.match(categoric_pattern, dtype_selector, re.IGNORECASE):             # <<<<<<<<<<<<<<
 *         return f"categoric{suffix}"
 *     elif re.match(datetime_pattern, dtype_selector, re.IGNORECASE):
 */
  }

  /* "validator.pyx":4727
 *     elif re.match(categoric_pattern, dtype_selector, re.IGNORECASE):
 *         return f"categoric{suffix}"
 *     elif re.match(datetime_pattern, dtype_selector, re.IGNORECASE):             # <<<<<<<<<<<<<<
 *         return "datetime"
 *     elif re.match(biselect_pattern, dtype_selector, re.IGNORECASE):
 */
  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_re); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4727, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_match); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4727, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_re); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4727, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_IGNORECASE); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4727, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = NULL;
  __pyx_t_6 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_6 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_v_datetime_pattern, __pyx_v_dtype_selector, __pyx_t_3};
    __pyx_t_7 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4727, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
    PyObject *__pyx_temp[4] = {__pyx_t_4, __pyx_v_datetime_pattern, __pyx_v_dtype_selector, __pyx_t_3};
    __pyx_t_7 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4727, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else
  #endif
  {
    __pyx_t_1 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4727, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (__pyx_t_4) {
      __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_4); __pyx_t_4 = NULL;
    }
    __Pyx_INCREF(__pyx_v_datetime_pattern);
    __Pyx_GIVEREF(__pyx_v_datetime_pattern);
    PyTuple_SET_ITEM(__pyx_t_1, 0+__pyx_t_6, __pyx_v_datetime_pattern);
    __Pyx_INCREF(__pyx_v_dtype_selector);
    __Pyx_GIVEREF(__pyx_v_dtype_selector);
    PyTuple_SET_ITEM(__pyx_t_1, 1+__pyx_t_6, __pyx_v_dtype_selector);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_1, 2+__pyx_t_6, __pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_1, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4727, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_7); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 4727, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  if (__pyx_t_5) {

    /* "validator.pyx":4728
 *         return f"categoric{suffix}"
 *     elif re.match(datetime_pattern, dtype_selector, re.IGNORECASE):
 *         return "datetime"             # <<<<<<<<<<<<<<
 *     elif re.match(biselect_pattern, dtype_selector, re.IGNORECASE):
 *         return "biselect"
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_n_u_datetime);
    __pyx_r = __pyx_n_u_datetime;
    goto __pyx_L0;

    /* "validator.pyx":4727
 *     elif re.match(categoric_pattern, dtype_selector, re.IGNORECASE):
 *         return f"categoric{suffix}"
 *     elif re.match(datetime_pattern, dtype_selector, re.IGNORECASE):             # <<<<<<<<<<<<<<
 *         return "datetime"
 *     elif re.match(biselect_pattern, dtype_selector, re.IGNORECASE):
 */
  }

  /* "validator.pyx":4729
 *     elif re.match(datetime_pattern, dtype_selector, re.IGNORECASE):
 *         return "datetime"
 *     elif re.match(biselect_pattern, dtype_selector, re.IGNORECASE):             # <<<<<<<<<<<<<<
 *         return "biselect"
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_re); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4729, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_match); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4729, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_re); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4729, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_IGNORECASE); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4729, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  __pyx_t_6 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
      __pyx_t_6 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_1)) {
    PyObject *__pyx_temp[4] = {__pyx_t_2, __pyx_v_biselect_pattern, __pyx_v_dtype_selector, __pyx_t_3};
    __pyx_t_7 = __Pyx_PyFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4729, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_1)) {
    PyObject *__pyx_temp[4] = {__pyx_t_2, __pyx_v_biselect_pattern, __pyx_v_dtype_selector, __pyx_t_3};
    __pyx_t_7 = __Pyx_PyCFunction_FastCall(__pyx_t_1, __pyx_temp+1-__pyx_t_6, 3+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4729, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else
  #endif
  {
    __pyx_t_4 = PyTuple_New(3+__pyx_t_6); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4729, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    if (__pyx_t_2) {
      __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_2); __pyx_t_2 = NULL;
    }
    __Pyx_INCREF(__pyx_v_biselect_pattern);
    __Pyx_GIVEREF(__pyx_v_biselect_pattern);
    PyTuple_SET_ITEM(__pyx_t_4, 0+__pyx_t_6, __pyx_v_biselect_pattern);
    __Pyx_INCREF(__pyx_v_dtype_selector);
    __Pyx_GIVEREF(__pyx_v_dtype_selector);
    PyTuple_SET_ITEM(__pyx_t_4, 1+__pyx_t_6, __pyx_v_dtype_selector);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_4, 2+__pyx_t_6, __pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_4, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4729, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_7); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 4729, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  if (__pyx_t_5) {

    /* "validator.pyx":4730
 *         return "datetime"
 *     elif re.match(biselect_pattern, dtype_selector, re.IGNORECASE):
 *         return "biselect"             # <<<<<<<<<<<<<<
 * 
 *     raise ValueError(
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_n_u_biselect);
    __pyx_r = __pyx_n_u_biselect;
    goto __pyx_L0;

    /* "validator.pyx":4729
 *     elif re.match(datetime_pattern, dtype_selector, re.IGNORECASE):
 *         return "datetime"
 *     elif re.match(biselect_pattern, dtype_selector, re.IGNORECASE):             # <<<<<<<<<<<<<<
 *         return "biselect"
 * 
 */
  }

  /* "validator.pyx":4733
 * 
 *     raise ValueError(
 *         f"Invalid dtype_selector provided. Valid options are :{types}")             # <<<<<<<<<<<<<<
 * 
 * def build_data_if(
 */
  __pyx_t_7 = __Pyx_PyObject_FormatSimple(__pyx_v_types, __pyx_empty_unicode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4733, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __pyx_t_1 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Invalid_dtype_selector_provided, __pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4733, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

  /* "validator.pyx":4732
 *         return "biselect"
 * 
 *     raise ValueError(             # <<<<<<<<<<<<<<
 *         f"Invalid dtype_selector provided. Valid options are :{types}")
 * 
 */
  __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4732, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_Raise(__pyx_t_7, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __PYX_ERR(0, 4732, __pyx_L1_error)

  /* "validator.pyx":4693
 *     return y
 * 
 * def validate_dtype_selector(dtype_selector: str) -> str:             # <<<<<<<<<<<<<<
 *     """
 *     Validates and categorizes the dtype_selector using regex, including handling
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("validator.validate_dtype_selector", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_types);
  __Pyx_XDECREF(__pyx_v_numeric_pattern);
  __Pyx_XDECREF(__pyx_v_categoric_pattern);
  __Pyx_XDECREF(__pyx_v_datetime_pattern);
  __Pyx_XDECREF(__pyx_v_biselect_pattern);
  __Pyx_XDECREF(__pyx_v_suffix);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":4735
 *         f"Invalid dtype_selector provided. Valid options are :{types}")
 * 
 * def build_data_if(             # <<<<<<<<<<<<<<
 *     data,
 *     columns=None,
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_155build_data_if(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_154build_data_if[] = "\n    Converts input data into a pandas DataFrame if necessary and requested,\n    applying specified columns names or generating them if the `force` parameter\n    is set.\n\n    Parameters\n    ----------\n    data : dict, list, tuple, np.ndarray, pd.DataFrame\n        The data to potentially convert to a DataFrame. Can be a dictionary,\n        list, tuple, NumPy array, or already a pandas DataFrame.\n    columns : str or list of str, optional\n        The names for the resulting DataFrame columns or the Series name.\n    to_frame : bool, default=True\n        If True, converts `data` to a DataFrame if it isn't already one.\n    input_name : str, default='data'\n        The name of the input variable, used for constructing error messages.\n    force : bool, default=False\n        Forces the conversion of `data` to a DataFrame by generating column names\n        based on `input_name` if `columns` are not provided.\n    raise_warning : bool, default=True\n        If True, raises a warning when conversion requirements are not met.\n    raise_exception : bool, default=False\n        If True, raises an exception instead of a warning when conversion\n        requirements are not met.\n    coerce_datetime : bool, default=False\n        If True, tries to convert object columns to datetime data types.\n    Returns\n    -------\n    pd.DataFrame\n        The converted DataFrame.\n\n    Raises\n    ------\n    TypeError\n        If `data` cannot be converted to a DataFrame based on the provided\n        parameters and conditions.\n    ";
static PyMethodDef __pyx_mdef_9validator_155build_data_if = {"build_data_if", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_155build_data_if, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_154build_data_if};
static PyObject *__pyx_pw_9validator_155build_data_if(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_data = 0;
  PyObject *__pyx_v_columns = 0;
  PyObject *__pyx_v_to_frame = 0;
  PyObject *__pyx_v_input_name = 0;
  PyObject *__pyx_v_force = 0;
  PyObject *__pyx_v_raise_warning = 0;
  PyObject *__pyx_v_raise_exception = 0;
  PyObject *__pyx_v_coerce_datetime = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("build_data_if (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_data,&__pyx_n_s_columns,&__pyx_n_s_to_frame,&__pyx_n_s_input_name,&__pyx_n_s_force,&__pyx_n_s_raise_warning,&__pyx_n_s_raise_exception,&__pyx_n_s_coerce_datetime,0};
    PyObject* values[8] = {0,0,0,0,0,0,0,0};

    /* "validator.pyx":4737
 * def build_data_if(
 *     data,
 *     columns=None,             # <<<<<<<<<<<<<<
 *     to_frame=True,
 *     input_name='data',
 */
    values[1] = ((PyObject *)Py_None);

    /* "validator.pyx":4738
 *     data,
 *     columns=None,
 *     to_frame=True,             # <<<<<<<<<<<<<<
 *     input_name='data',
 *     force=False,
 */
    values[2] = ((PyObject *)Py_True);
    values[3] = ((PyObject *)__pyx_n_u_data);

    /* "validator.pyx":4740
 *     to_frame=True,
 *     input_name='data',
 *     force=False,             # <<<<<<<<<<<<<<
 *     raise_warning=True,
 *     raise_exception=False,
 */
    values[4] = ((PyObject *)Py_False);

    /* "validator.pyx":4741
 *     input_name='data',
 *     force=False,
 *     raise_warning=True,             # <<<<<<<<<<<<<<
 *     raise_exception=False,
 *     coerce_datetime=False,
 */
    values[5] = ((PyObject *)Py_True);

    /* "validator.pyx":4742
 *     force=False,
 *     raise_warning=True,
 *     raise_exception=False,             # <<<<<<<<<<<<<<
 *     coerce_datetime=False,
 * ):
 */
    values[6] = ((PyObject *)Py_False);

    /* "validator.pyx":4743
 *     raise_warning=True,
 *     raise_exception=False,
 *     coerce_datetime=False,             # <<<<<<<<<<<<<<
 * ):
 *     """
 */
    values[7] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_columns);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_to_frame);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_input_name);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_force);
          if (value) { values[4] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_raise_warning);
          if (value) { values[5] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  6:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_raise_exception);
          if (value) { values[6] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  7:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_coerce_datetime);
          if (value) { values[7] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "build_data_if") < 0)) __PYX_ERR(0, 4735, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_data = values[0];
    __pyx_v_columns = values[1];
    __pyx_v_to_frame = values[2];
    __pyx_v_input_name = values[3];
    __pyx_v_force = values[4];
    __pyx_v_raise_warning = values[5];
    __pyx_v_raise_exception = values[6];
    __pyx_v_coerce_datetime = values[7];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("build_data_if", 0, 1, 8, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4735, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.build_data_if", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_154build_data_if(__pyx_self, __pyx_v_data, __pyx_v_columns, __pyx_v_to_frame, __pyx_v_input_name, __pyx_v_force, __pyx_v_raise_warning, __pyx_v_raise_exception, __pyx_v_coerce_datetime);

  /* "validator.pyx":4735
 *         f"Invalid dtype_selector provided. Valid options are :{types}")
 * 
 * def build_data_if(             # <<<<<<<<<<<<<<
 *     data,
 *     columns=None,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_154build_data_if(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_columns, PyObject *__pyx_v_to_frame, PyObject *__pyx_v_input_name, PyObject *__pyx_v_force, PyObject *__pyx_v_raise_warning, PyObject *__pyx_v_raise_exception, PyObject *__pyx_v_coerce_datetime) {
  PyObject *__pyx_v_msg = NULL;
  PyObject *__pyx_9genexpr29__pyx_v_i = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  Py_ssize_t __pyx_t_7;
  Py_UCS4 __pyx_t_8;
  int __pyx_t_9;
  PyObject *__pyx_t_10 = NULL;
  PyObject *(*__pyx_t_11)(PyObject *);
  Py_ssize_t __pyx_t_12;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("build_data_if", 0);
  __Pyx_INCREF(__pyx_v_data);
  __Pyx_INCREF(__pyx_v_columns);

  /* "validator.pyx":4782
 *         parameters and conditions.
 *     """
 *     if isinstance(data, dict):             # <<<<<<<<<<<<<<
 *         data = pd.DataFrame(data)
 *         columns = list(data.columns)
 */
  __pyx_t_1 = PyDict_Check(__pyx_v_data); 
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "validator.pyx":4783
 *     """
 *     if isinstance(data, dict):
 *         data = pd.DataFrame(data)             # <<<<<<<<<<<<<<
 *         columns = list(data.columns)
 *     elif isinstance(data, (list, tuple)):
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_pd); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4783, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_DataFrame); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4783, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_v_data) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_data);
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4783, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "validator.pyx":4784
 *     if isinstance(data, dict):
 *         data = pd.DataFrame(data)
 *         columns = list(data.columns)             # <<<<<<<<<<<<<<
 *     elif isinstance(data, (list, tuple)):
 *         data = np.array(data)
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_columns); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4784, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = PySequence_List(__pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4784, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF_SET(__pyx_v_columns, __pyx_t_5);
    __pyx_t_5 = 0;

    /* "validator.pyx":4782
 *         parameters and conditions.
 *     """
 *     if isinstance(data, dict):             # <<<<<<<<<<<<<<
 *         data = pd.DataFrame(data)
 *         columns = list(data.columns)
 */
    goto __pyx_L3;
  }

  /* "validator.pyx":4785
 *         data = pd.DataFrame(data)
 *         columns = list(data.columns)
 *     elif isinstance(data, (list, tuple)):             # <<<<<<<<<<<<<<
 *         data = np.array(data)
 *     elif isinstance ( data, pd.Series):
 */
  __pyx_t_1 = PyList_Check(__pyx_v_data); 
  __pyx_t_6 = (__pyx_t_1 != 0);
  if (!__pyx_t_6) {
  } else {
    __pyx_t_2 = __pyx_t_6;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_6 = PyTuple_Check(__pyx_v_data); 
  __pyx_t_1 = (__pyx_t_6 != 0);
  __pyx_t_2 = __pyx_t_1;
  __pyx_L4_bool_binop_done:;
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "validator.pyx":4786
 *         columns = list(data.columns)
 *     elif isinstance(data, (list, tuple)):
 *         data = np.array(data)             # <<<<<<<<<<<<<<
 *     elif isinstance ( data, pd.Series):
 *         data =data.to_frame ()
 */
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4786, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_array); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4786, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_5 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_3, __pyx_v_data) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_data);
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4786, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_5);
    __pyx_t_5 = 0;

    /* "validator.pyx":4785
 *         data = pd.DataFrame(data)
 *         columns = list(data.columns)
 *     elif isinstance(data, (list, tuple)):             # <<<<<<<<<<<<<<
 *         data = np.array(data)
 *     elif isinstance ( data, pd.Series):
 */
    goto __pyx_L3;
  }

  /* "validator.pyx":4787
 *     elif isinstance(data, (list, tuple)):
 *         data = np.array(data)
 *     elif isinstance ( data, pd.Series):             # <<<<<<<<<<<<<<
 *         data =data.to_frame ()
 * 
 */
  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_pd); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4787, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_Series); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4787, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_1 = PyObject_IsInstance(__pyx_v_data, __pyx_t_4); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 4787, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "validator.pyx":4788
 *         data = np.array(data)
 *     elif isinstance ( data, pd.Series):
 *         data =data.to_frame ()             # <<<<<<<<<<<<<<
 * 
 *     # Ensure data is two dimensional
 */
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_to_frame); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4788, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_3 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    __pyx_t_4 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_5);
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4788, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "validator.pyx":4787
 *     elif isinstance(data, (list, tuple)):
 *         data = np.array(data)
 *     elif isinstance ( data, pd.Series):             # <<<<<<<<<<<<<<
 *         data =data.to_frame ()
 * 
 */
  }
  __pyx_L3:;

  /* "validator.pyx":4791
 * 
 *     # Ensure data is two dimensional
 *     data = ensure_2d(data)             # <<<<<<<<<<<<<<
 *     # Check if data needs to be converted to a DataFrame
 *     if to_frame and not isinstance(data, pd.DataFrame):
 */
  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_ensure_2d); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4791, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
    }
  }
  __pyx_t_4 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_3, __pyx_v_data) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_data);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4791, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_4);
  __pyx_t_4 = 0;

  /* "validator.pyx":4793
 *     data = ensure_2d(data)
 *     # Check if data needs to be converted to a DataFrame
 *     if to_frame and not isinstance(data, pd.DataFrame):             # <<<<<<<<<<<<<<
 *         if columns is None and not force:
 *             msg = (f"Conversion of {input_name} to DataFrame requires column names. "
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_to_frame); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 4793, __pyx_L1_error)
  if (__pyx_t_1) {
  } else {
    __pyx_t_2 = __pyx_t_1;
    goto __pyx_L7_bool_binop_done;
  }
  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_pd); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4793, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_DataFrame); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4793, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_1 = PyObject_IsInstance(__pyx_v_data, __pyx_t_5); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 4793, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_6 = ((!(__pyx_t_1 != 0)) != 0);
  __pyx_t_2 = __pyx_t_6;
  __pyx_L7_bool_binop_done:;
  if (__pyx_t_2) {

    /* "validator.pyx":4794
 *     # Check if data needs to be converted to a DataFrame
 *     if to_frame and not isinstance(data, pd.DataFrame):
 *         if columns is None and not force:             # <<<<<<<<<<<<<<
 *             msg = (f"Conversion of {input_name} to DataFrame requires column names. "
 *                    "Provide `columns` or set `force=True` to generate them automatically.")
 */
    __pyx_t_6 = (__pyx_v_columns == Py_None);
    __pyx_t_1 = (__pyx_t_6 != 0);
    if (__pyx_t_1) {
    } else {
      __pyx_t_2 = __pyx_t_1;
      goto __pyx_L10_bool_binop_done;
    }
    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_force); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 4794, __pyx_L1_error)
    __pyx_t_6 = ((!__pyx_t_1) != 0);
    __pyx_t_2 = __pyx_t_6;
    __pyx_L10_bool_binop_done:;
    if (__pyx_t_2) {

      /* "validator.pyx":4795
 *     if to_frame and not isinstance(data, pd.DataFrame):
 *         if columns is None and not force:
 *             msg = (f"Conversion of {input_name} to DataFrame requires column names. "             # <<<<<<<<<<<<<<
 *                    "Provide `columns` or set `force=True` to generate them automatically.")
 *             if raise_exception:
 */
      __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4795, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_7 = 0;
      __pyx_t_8 = 127;
      __Pyx_INCREF(__pyx_kp_u_Conversion_of);
      __pyx_t_7 += 14;
      __Pyx_GIVEREF(__pyx_kp_u_Conversion_of);
      PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_kp_u_Conversion_of);
      __pyx_t_4 = __Pyx_PyObject_FormatSimple(__pyx_v_input_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4795, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_8 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) > __pyx_t_8) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) : __pyx_t_8;
      __pyx_t_7 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
      __Pyx_GIVEREF(__pyx_t_4);
      PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_4);
      __pyx_t_4 = 0;
      __Pyx_INCREF(__pyx_kp_u_to_DataFrame_requires_column_na);
      __pyx_t_7 += 106;
      __Pyx_GIVEREF(__pyx_kp_u_to_DataFrame_requires_column_na);
      PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_kp_u_to_DataFrame_requires_column_na);
      __pyx_t_4 = __Pyx_PyUnicode_Join(__pyx_t_5, 3, __pyx_t_7, __pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4795, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_v_msg = ((PyObject*)__pyx_t_4);
      __pyx_t_4 = 0;

      /* "validator.pyx":4797
 *             msg = (f"Conversion of {input_name} to DataFrame requires column names. "
 *                    "Provide `columns` or set `force=True` to generate them automatically.")
 *             if raise_exception:             # <<<<<<<<<<<<<<
 *                 raise TypeError(msg)
 *             if raise_warning:
 */
      __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_raise_exception); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4797, __pyx_L1_error)
      if (unlikely(__pyx_t_2)) {

        /* "validator.pyx":4798
 *                    "Provide `columns` or set `force=True` to generate them automatically.")
 *             if raise_exception:
 *                 raise TypeError(msg)             # <<<<<<<<<<<<<<
 *             if raise_warning:
 *                 warnings.warn(msg, UserWarning)
 */
        __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_v_msg); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4798, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_Raise(__pyx_t_4, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __PYX_ERR(0, 4798, __pyx_L1_error)

        /* "validator.pyx":4797
 *             msg = (f"Conversion of {input_name} to DataFrame requires column names. "
 *                    "Provide `columns` or set `force=True` to generate them automatically.")
 *             if raise_exception:             # <<<<<<<<<<<<<<
 *                 raise TypeError(msg)
 *             if raise_warning:
 */
      }

      /* "validator.pyx":4799
 *             if raise_exception:
 *                 raise TypeError(msg)
 *             if raise_warning:             # <<<<<<<<<<<<<<
 *                 warnings.warn(msg, UserWarning)
 *         # Generate column names if forced and not provided
 */
      __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_raise_warning); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4799, __pyx_L1_error)
      if (__pyx_t_2) {

        /* "validator.pyx":4800
 *                 raise TypeError(msg)
 *             if raise_warning:
 *                 warnings.warn(msg, UserWarning)             # <<<<<<<<<<<<<<
 *         # Generate column names if forced and not provided
 *         if force and columns is None:
 */
        __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_warnings); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4800, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_warn); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4800, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_t_5 = NULL;
        __pyx_t_9 = 0;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_3))) {
          __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
          if (likely(__pyx_t_5)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
            __Pyx_INCREF(__pyx_t_5);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_3, function);
            __pyx_t_9 = 1;
          }
        }
        #if CYTHON_FAST_PYCALL
        if (PyFunction_Check(__pyx_t_3)) {
          PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_msg, __pyx_builtin_UserWarning};
          __pyx_t_4 = __Pyx_PyFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_9, 2+__pyx_t_9); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4800, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_GOTREF(__pyx_t_4);
        } else
        #endif
        #if CYTHON_FAST_PYCCALL
        if (__Pyx_PyFastCFunction_Check(__pyx_t_3)) {
          PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_msg, __pyx_builtin_UserWarning};
          __pyx_t_4 = __Pyx_PyCFunction_FastCall(__pyx_t_3, __pyx_temp+1-__pyx_t_9, 2+__pyx_t_9); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4800, __pyx_L1_error)
          __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_GOTREF(__pyx_t_4);
        } else
        #endif
        {
          __pyx_t_10 = PyTuple_New(2+__pyx_t_9); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 4800, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_10);
          if (__pyx_t_5) {
            __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_5); __pyx_t_5 = NULL;
          }
          __Pyx_INCREF(__pyx_v_msg);
          __Pyx_GIVEREF(__pyx_v_msg);
          PyTuple_SET_ITEM(__pyx_t_10, 0+__pyx_t_9, __pyx_v_msg);
          __Pyx_INCREF(__pyx_builtin_UserWarning);
          __Pyx_GIVEREF(__pyx_builtin_UserWarning);
          PyTuple_SET_ITEM(__pyx_t_10, 1+__pyx_t_9, __pyx_builtin_UserWarning);
          __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_10, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4800, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
        }
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

        /* "validator.pyx":4799
 *             if raise_exception:
 *                 raise TypeError(msg)
 *             if raise_warning:             # <<<<<<<<<<<<<<
 *                 warnings.warn(msg, UserWarning)
 *         # Generate column names if forced and not provided
 */
      }

      /* "validator.pyx":4794
 *     # Check if data needs to be converted to a DataFrame
 *     if to_frame and not isinstance(data, pd.DataFrame):
 *         if columns is None and not force:             # <<<<<<<<<<<<<<
 *             msg = (f"Conversion of {input_name} to DataFrame requires column names. "
 *                    "Provide `columns` or set `force=True` to generate them automatically.")
 */
    }

    /* "validator.pyx":4802
 *                 warnings.warn(msg, UserWarning)
 *         # Generate column names if forced and not provided
 *         if force and columns is None:             # <<<<<<<<<<<<<<
 *             columns = [f"{input_name}_{i}" for i in range(data.shape[1])]
 * 
 */
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_force); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 4802, __pyx_L1_error)
    if (__pyx_t_6) {
    } else {
      __pyx_t_2 = __pyx_t_6;
      goto __pyx_L15_bool_binop_done;
    }
    __pyx_t_6 = (__pyx_v_columns == Py_None);
    __pyx_t_1 = (__pyx_t_6 != 0);
    __pyx_t_2 = __pyx_t_1;
    __pyx_L15_bool_binop_done:;
    if (__pyx_t_2) {

      /* "validator.pyx":4803
 *         # Generate column names if forced and not provided
 *         if force and columns is None:
 *             columns = [f"{input_name}_{i}" for i in range(data.shape[1])]             # <<<<<<<<<<<<<<
 * 
 *         data = pd.DataFrame(data, columns=columns)
 */
      { /* enter inner scope */
        __pyx_t_4 = PyList_New(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4803, __pyx_L19_error)
        __Pyx_GOTREF(__pyx_t_4);
        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_shape); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4803, __pyx_L19_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_10 = __Pyx_GetItemInt(__pyx_t_3, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 4803, __pyx_L19_error)
        __Pyx_GOTREF(__pyx_t_10);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_range, __pyx_t_10); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4803, __pyx_L19_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
        if (likely(PyList_CheckExact(__pyx_t_3)) || PyTuple_CheckExact(__pyx_t_3)) {
          __pyx_t_10 = __pyx_t_3; __Pyx_INCREF(__pyx_t_10); __pyx_t_7 = 0;
          __pyx_t_11 = NULL;
        } else {
          __pyx_t_7 = -1; __pyx_t_10 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 4803, __pyx_L19_error)
          __Pyx_GOTREF(__pyx_t_10);
          __pyx_t_11 = Py_TYPE(__pyx_t_10)->tp_iternext; if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 4803, __pyx_L19_error)
        }
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        for (;;) {
          if (likely(!__pyx_t_11)) {
            if (likely(PyList_CheckExact(__pyx_t_10))) {
              if (__pyx_t_7 >= PyList_GET_SIZE(__pyx_t_10)) break;
              #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
              __pyx_t_3 = PyList_GET_ITEM(__pyx_t_10, __pyx_t_7); __Pyx_INCREF(__pyx_t_3); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 4803, __pyx_L19_error)
              #else
              __pyx_t_3 = PySequence_ITEM(__pyx_t_10, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4803, __pyx_L19_error)
              __Pyx_GOTREF(__pyx_t_3);
              #endif
            } else {
              if (__pyx_t_7 >= PyTuple_GET_SIZE(__pyx_t_10)) break;
              #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
              __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_10, __pyx_t_7); __Pyx_INCREF(__pyx_t_3); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 4803, __pyx_L19_error)
              #else
              __pyx_t_3 = PySequence_ITEM(__pyx_t_10, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4803, __pyx_L19_error)
              __Pyx_GOTREF(__pyx_t_3);
              #endif
            }
          } else {
            __pyx_t_3 = __pyx_t_11(__pyx_t_10);
            if (unlikely(!__pyx_t_3)) {
              PyObject* exc_type = PyErr_Occurred();
              if (exc_type) {
                if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
                else __PYX_ERR(0, 4803, __pyx_L19_error)
              }
              break;
            }
            __Pyx_GOTREF(__pyx_t_3);
          }
          __Pyx_XDECREF_SET(__pyx_9genexpr29__pyx_v_i, __pyx_t_3);
          __pyx_t_3 = 0;
          __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4803, __pyx_L19_error)
          __Pyx_GOTREF(__pyx_t_3);
          __pyx_t_12 = 0;
          __pyx_t_8 = 127;
          __pyx_t_5 = __Pyx_PyObject_FormatSimple(__pyx_v_input_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4803, __pyx_L19_error)
          __Pyx_GOTREF(__pyx_t_5);
          __pyx_t_8 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) > __pyx_t_8) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) : __pyx_t_8;
          __pyx_t_12 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_5);
          __Pyx_GIVEREF(__pyx_t_5);
          PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_5);
          __pyx_t_5 = 0;
          __Pyx_INCREF(__pyx_n_u__102);
          __pyx_t_12 += 1;
          __Pyx_GIVEREF(__pyx_n_u__102);
          PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_n_u__102);
          __pyx_t_5 = __Pyx_PyObject_FormatSimple(__pyx_9genexpr29__pyx_v_i, __pyx_empty_unicode); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4803, __pyx_L19_error)
          __Pyx_GOTREF(__pyx_t_5);
          __pyx_t_8 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) > __pyx_t_8) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_5) : __pyx_t_8;
          __pyx_t_12 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_5);
          __Pyx_GIVEREF(__pyx_t_5);
          PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_5);
          __pyx_t_5 = 0;
          __pyx_t_5 = __Pyx_PyUnicode_Join(__pyx_t_3, 3, __pyx_t_12, __pyx_t_8); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4803, __pyx_L19_error)
          __Pyx_GOTREF(__pyx_t_5);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          if (unlikely(__Pyx_ListComp_Append(__pyx_t_4, (PyObject*)__pyx_t_5))) __PYX_ERR(0, 4803, __pyx_L19_error)
          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        }
        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
        __Pyx_XDECREF(__pyx_9genexpr29__pyx_v_i); __pyx_9genexpr29__pyx_v_i = 0;
        goto __pyx_L22_exit_scope;
        __pyx_L19_error:;
        __Pyx_XDECREF(__pyx_9genexpr29__pyx_v_i); __pyx_9genexpr29__pyx_v_i = 0;
        goto __pyx_L1_error;
        __pyx_L22_exit_scope:;
      } /* exit inner scope */
      __Pyx_DECREF_SET(__pyx_v_columns, __pyx_t_4);
      __pyx_t_4 = 0;

      /* "validator.pyx":4802
 *                 warnings.warn(msg, UserWarning)
 *         # Generate column names if forced and not provided
 *         if force and columns is None:             # <<<<<<<<<<<<<<
 *             columns = [f"{input_name}_{i}" for i in range(data.shape[1])]
 * 
 */
    }

    /* "validator.pyx":4805
 *             columns = [f"{input_name}_{i}" for i in range(data.shape[1])]
 * 
 *         data = pd.DataFrame(data, columns=columns)             # <<<<<<<<<<<<<<
 * 
 *     data =array_to_frame(
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_pd); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4805, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_DataFrame); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 4805, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4805, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_INCREF(__pyx_v_data);
    __Pyx_GIVEREF(__pyx_v_data);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_data);
    __pyx_t_5 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4805, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_columns, __pyx_v_columns) < 0) __PYX_ERR(0, 4805, __pyx_L1_error)
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_10, __pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4805, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "validator.pyx":4793
 *     data = ensure_2d(data)
 *     # Check if data needs to be converted to a DataFrame
 *     if to_frame and not isinstance(data, pd.DataFrame):             # <<<<<<<<<<<<<<
 *         if columns is None and not force:
 *             msg = (f"Conversion of {input_name} to DataFrame requires column names. "
 */
  }

  /* "validator.pyx":4807
 *         data = pd.DataFrame(data, columns=columns)
 * 
 *     data =array_to_frame(             # <<<<<<<<<<<<<<
 *         data, columns = columns,
 *         to_frame =to_frame,
 */
  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_array_to_frame); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4807, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);

  /* "validator.pyx":4808
 * 
 *     data =array_to_frame(
 *         data, columns = columns,             # <<<<<<<<<<<<<<
 *         to_frame =to_frame,
 *         input_name=input_name,
 */
  __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4807, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_INCREF(__pyx_v_data);
  __Pyx_GIVEREF(__pyx_v_data);
  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_data);
  __pyx_t_4 = __Pyx_PyDict_NewPresized(4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4808, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_columns, __pyx_v_columns) < 0) __PYX_ERR(0, 4808, __pyx_L1_error)

  /* "validator.pyx":4809
 *     data =array_to_frame(
 *         data, columns = columns,
 *         to_frame =to_frame,             # <<<<<<<<<<<<<<
 *         input_name=input_name,
 *         force =force,
 */
  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_to_frame, __pyx_v_to_frame) < 0) __PYX_ERR(0, 4808, __pyx_L1_error)

  /* "validator.pyx":4810
 *         data, columns = columns,
 *         to_frame =to_frame,
 *         input_name=input_name,             # <<<<<<<<<<<<<<
 *         force =force,
 *         )
 */
  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_input_name, __pyx_v_input_name) < 0) __PYX_ERR(0, 4808, __pyx_L1_error)

  /* "validator.pyx":4811
 *         to_frame =to_frame,
 *         input_name=input_name,
 *         force =force,             # <<<<<<<<<<<<<<
 *         )
 *     if isinstance (data, pd.DataFrame):
 */
  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_force, __pyx_v_force) < 0) __PYX_ERR(0, 4808, __pyx_L1_error)

  /* "validator.pyx":4807
 *         data = pd.DataFrame(data, columns=columns)
 * 
 *     data =array_to_frame(             # <<<<<<<<<<<<<<
 *         data, columns = columns,
 *         to_frame =to_frame,
 */
  __pyx_t_10 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 4807, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_10);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_10);
  __pyx_t_10 = 0;

  /* "validator.pyx":4813
 *         force =force,
 *         )
 *     if isinstance (data, pd.DataFrame):             # <<<<<<<<<<<<<<
 *         # re_check data_types
 *         data = recheck_data_types(
 */
  __Pyx_GetModuleGlobalName(__pyx_t_10, __pyx_n_s_pd); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 4813, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_10);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_10, __pyx_n_s_DataFrame); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4813, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
  __pyx_t_2 = PyObject_IsInstance(__pyx_v_data, __pyx_t_4); if (unlikely(__pyx_t_2 == ((int)-1))) __PYX_ERR(0, 4813, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "validator.pyx":4815
 *     if isinstance (data, pd.DataFrame):
 *         # re_check data_types
 *         data = recheck_data_types(             # <<<<<<<<<<<<<<
 *             data, coerce_datetime=coerce_datetime,
 *             coerce_numeric=True, return_as_numpy=False
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_recheck_data_types); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4815, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);

    /* "validator.pyx":4816
 *         # re_check data_types
 *         data = recheck_data_types(
 *             data, coerce_datetime=coerce_datetime,             # <<<<<<<<<<<<<<
 *             coerce_numeric=True, return_as_numpy=False
 *             )
 */
    __pyx_t_10 = PyTuple_New(1); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 4815, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    __Pyx_INCREF(__pyx_v_data);
    __Pyx_GIVEREF(__pyx_v_data);
    PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_v_data);
    __pyx_t_5 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4816, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_coerce_datetime, __pyx_v_coerce_datetime) < 0) __PYX_ERR(0, 4816, __pyx_L1_error)

    /* "validator.pyx":4817
 *         data = recheck_data_types(
 *             data, coerce_datetime=coerce_datetime,
 *             coerce_numeric=True, return_as_numpy=False             # <<<<<<<<<<<<<<
 *             )
 *     return data  # Return original data if conditions are not met
 */
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_coerce_numeric, Py_True) < 0) __PYX_ERR(0, 4816, __pyx_L1_error)
    if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_return_as_numpy, Py_False) < 0) __PYX_ERR(0, 4816, __pyx_L1_error)

    /* "validator.pyx":4815
 *     if isinstance (data, pd.DataFrame):
 *         # re_check data_types
 *         data = recheck_data_types(             # <<<<<<<<<<<<<<
 *             data, coerce_datetime=coerce_datetime,
 *             coerce_numeric=True, return_as_numpy=False
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_10, __pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4815, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "validator.pyx":4813
 *         force =force,
 *         )
 *     if isinstance (data, pd.DataFrame):             # <<<<<<<<<<<<<<
 *         # re_check data_types
 *         data = recheck_data_types(
 */
  }

  /* "validator.pyx":4819
 *             coerce_numeric=True, return_as_numpy=False
 *             )
 *     return data  # Return original data if conditions are not met             # <<<<<<<<<<<<<<
 * 
 * def build_data_if2(
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_data);
  __pyx_r = __pyx_v_data;
  goto __pyx_L0;

  /* "validator.pyx":4735
 *         f"Invalid dtype_selector provided. Valid options are :{types}")
 * 
 * def build_data_if(             # <<<<<<<<<<<<<<
 *     data,
 *     columns=None,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_AddTraceback("validator.build_data_if", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_msg);
  __Pyx_XDECREF(__pyx_9genexpr29__pyx_v_i);
  __Pyx_XDECREF(__pyx_v_data);
  __Pyx_XDECREF(__pyx_v_columns);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":4821
 *     return data  # Return original data if conditions are not met
 * 
 * def build_data_if2(             # <<<<<<<<<<<<<<
 *     data: Union[dict, np.ndarray, pd.DataFrame],
 *     columns=None,
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_157build_data_if2(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_156build_data_if2[] = " Contruct data from dict or array if necessary informations are given.\n    \n    Paramaters \n    -------------\n    data: dict, Array-like \n        Array to convert to frame. \n    columns: str or list of str \n        Series name or columns names for pandas.Series and DataFrame. \n        \n    to_frame: str, default=False\n        If ``True`` , reconvert the array to frame using the a naive columns\n        name built from the `input_name` ortherwise no-action is performed \n        and return the same array.\n        \n    input_name : str, default=\"Data\"\n        The data name used to construct the error message. \n        \n    raise_warning : bool, default=True\n        If True then raise a warning if conversion is required.\n        If ``ignore``, silence mode is triggered.\n        \n    raise_exception : bool, default=False\n        If True then raise an exception if array is not symmetric.\n        \n    force:bool, default=False\n        Force conversion array to a frame is columns is not supplied.\n        Use the combinaison, `input_name` and `X.shape[1]` range.\n\n    Return \n    --------\n    dataframe constructed. \n    \n    ";
static PyMethodDef __pyx_mdef_9validator_157build_data_if2 = {"build_data_if2", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_157build_data_if2, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_156build_data_if2};
static PyObject *__pyx_pw_9validator_157build_data_if2(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_data = 0;
  PyObject *__pyx_v_columns = 0;
  PyObject *__pyx_v_to_frame = 0;
  PyObject *__pyx_v_input_name = 0;
  PyObject *__pyx_v_force = 0;
  PyObject *__pyx_v_kws = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("build_data_if2 (wrapper)", 0);
  __pyx_v_kws = PyDict_New(); if (unlikely(!__pyx_v_kws)) return NULL;
  __Pyx_GOTREF(__pyx_v_kws);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_data,&__pyx_n_s_columns,&__pyx_n_s_to_frame,&__pyx_n_s_input_name,&__pyx_n_s_force,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "validator.pyx":4823
 * def build_data_if2(
 *     data: Union[dict, np.ndarray, pd.DataFrame],
 *     columns=None,             # <<<<<<<<<<<<<<
 *     to_frame=True,
 *     input_name='data',
 */
    values[1] = ((PyObject *)Py_None);

    /* "validator.pyx":4824
 *     data: Union[dict, np.ndarray, pd.DataFrame],
 *     columns=None,
 *     to_frame=True,             # <<<<<<<<<<<<<<
 *     input_name='data',
 *     force=False,
 */
    values[2] = ((PyObject *)Py_True);
    values[3] = ((PyObject *)__pyx_n_u_data);

    /* "validator.pyx":4826
 *     to_frame=True,
 *     input_name='data',
 *     force=False,             # <<<<<<<<<<<<<<
 *     **kws
 *     ):
 */
    values[4] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_columns);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_to_frame);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_input_name);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_force);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kws, values, pos_args, "build_data_if2") < 0)) __PYX_ERR(0, 4821, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_data = values[0];
    __pyx_v_columns = values[1];
    __pyx_v_to_frame = values[2];
    __pyx_v_input_name = values[3];
    __pyx_v_force = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("build_data_if2", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4821, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_DECREF(__pyx_v_kws); __pyx_v_kws = 0;
  __Pyx_AddTraceback("validator.build_data_if2", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_156build_data_if2(__pyx_self, __pyx_v_data, __pyx_v_columns, __pyx_v_to_frame, __pyx_v_input_name, __pyx_v_force, __pyx_v_kws);

  /* "validator.pyx":4821
 *     return data  # Return original data if conditions are not met
 * 
 * def build_data_if2(             # <<<<<<<<<<<<<<
 *     data: Union[dict, np.ndarray, pd.DataFrame],
 *     columns=None,
 */

  /* function exit code */
  __Pyx_XDECREF(__pyx_v_kws);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_156build_data_if2(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_data, PyObject *__pyx_v_columns, PyObject *__pyx_v_to_frame, PyObject *__pyx_v_input_name, PyObject *__pyx_v_force, PyObject *__pyx_v_kws) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  Py_ssize_t __pyx_t_8;
  Py_UCS4 __pyx_t_9;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("build_data_if2", 0);
  __Pyx_INCREF(__pyx_v_data);
  __Pyx_INCREF(__pyx_v_columns);

  /* "validator.pyx":4862
 * 
 *     """
 *     if isinstance ( data, dict ) :             # <<<<<<<<<<<<<<
 *         data = pd.DataFrame ( data)
 *         columns = list( data.columns)
 */
  __pyx_t_1 = PyDict_Check(__pyx_v_data); 
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "validator.pyx":4863
 *     """
 *     if isinstance ( data, dict ) :
 *         data = pd.DataFrame ( data)             # <<<<<<<<<<<<<<
 *         columns = list( data.columns)
 *     elif isinstance ( data, ( list, tuple)):
 */
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_pd); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4863, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_DataFrame); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4863, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_v_data) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_data);
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4863, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "validator.pyx":4864
 *     if isinstance ( data, dict ) :
 *         data = pd.DataFrame ( data)
 *         columns = list( data.columns)             # <<<<<<<<<<<<<<
 *     elif isinstance ( data, ( list, tuple)):
 *         data = np.array(data )
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_data, __pyx_n_s_columns); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4864, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = PySequence_List(__pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4864, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF_SET(__pyx_v_columns, __pyx_t_5);
    __pyx_t_5 = 0;

    /* "validator.pyx":4862
 * 
 *     """
 *     if isinstance ( data, dict ) :             # <<<<<<<<<<<<<<
 *         data = pd.DataFrame ( data)
 *         columns = list( data.columns)
 */
    goto __pyx_L3;
  }

  /* "validator.pyx":4865
 *         data = pd.DataFrame ( data)
 *         columns = list( data.columns)
 *     elif isinstance ( data, ( list, tuple)):             # <<<<<<<<<<<<<<
 *         data = np.array(data )
 * 
 */
  __pyx_t_1 = PyList_Check(__pyx_v_data); 
  __pyx_t_6 = (__pyx_t_1 != 0);
  if (!__pyx_t_6) {
  } else {
    __pyx_t_2 = __pyx_t_6;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_6 = PyTuple_Check(__pyx_v_data); 
  __pyx_t_1 = (__pyx_t_6 != 0);
  __pyx_t_2 = __pyx_t_1;
  __pyx_L4_bool_binop_done:;
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "validator.pyx":4866
 *         columns = list( data.columns)
 *     elif isinstance ( data, ( list, tuple)):
 *         data = np.array(data )             # <<<<<<<<<<<<<<
 * 
 *     if not is_frame ( data, df_only=True ):
 */
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4866, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_array); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4866, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_5 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_3, __pyx_v_data) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_data);
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4866, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF_SET(__pyx_v_data, __pyx_t_5);
    __pyx_t_5 = 0;

    /* "validator.pyx":4865
 *         data = pd.DataFrame ( data)
 *         columns = list( data.columns)
 *     elif isinstance ( data, ( list, tuple)):             # <<<<<<<<<<<<<<
 *         data = np.array(data )
 * 
 */
  }
  __pyx_L3:;

  /* "validator.pyx":4868
 *         data = np.array(data )
 * 
 *     if not is_frame ( data, df_only=True ):             # <<<<<<<<<<<<<<
 *         if not to_frame:
 *             raise TypeError("Expect a dataframe while columns is missing.")
 */
  __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_is_frame); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4868, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4868, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_INCREF(__pyx_v_data);
  __Pyx_GIVEREF(__pyx_v_data);
  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_data);
  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4868, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_df_only, Py_True) < 0) __PYX_ERR(0, 4868, __pyx_L1_error)
  __pyx_t_7 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_4, __pyx_t_3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4868, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_7); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 4868, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __pyx_t_2 = ((!__pyx_t_1) != 0);
  if (__pyx_t_2) {

    /* "validator.pyx":4869
 * 
 *     if not is_frame ( data, df_only=True ):
 *         if not to_frame:             # <<<<<<<<<<<<<<
 *             raise TypeError("Expect a dataframe while columns is missing.")
 *         if to_frame and not force:
 */
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_to_frame); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4869, __pyx_L1_error)
    __pyx_t_1 = ((!__pyx_t_2) != 0);
    if (unlikely(__pyx_t_1)) {

      /* "validator.pyx":4870
 *     if not is_frame ( data, df_only=True ):
 *         if not to_frame:
 *             raise TypeError("Expect a dataframe while columns is missing.")             # <<<<<<<<<<<<<<
 *         if to_frame and not force:
 *             raise TypeError(
 */
      __pyx_t_7 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__114, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4870, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_Raise(__pyx_t_7, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __PYX_ERR(0, 4870, __pyx_L1_error)

      /* "validator.pyx":4869
 * 
 *     if not is_frame ( data, df_only=True ):
 *         if not to_frame:             # <<<<<<<<<<<<<<
 *             raise TypeError("Expect a dataframe while columns is missing.")
 *         if to_frame and not force:
 */
    }

    /* "validator.pyx":4871
 *         if not to_frame:
 *             raise TypeError("Expect a dataframe while columns is missing.")
 *         if to_frame and not force:             # <<<<<<<<<<<<<<
 *             raise TypeError(
 *                 "Expect columns to build the data frame or set"
 */
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_to_frame); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4871, __pyx_L1_error)
    if (__pyx_t_2) {
    } else {
      __pyx_t_1 = __pyx_t_2;
      goto __pyx_L9_bool_binop_done;
    }
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_force); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4871, __pyx_L1_error)
    __pyx_t_6 = ((!__pyx_t_2) != 0);
    __pyx_t_1 = __pyx_t_6;
    __pyx_L9_bool_binop_done:;
    if (unlikely(__pyx_t_1)) {

      /* "validator.pyx":4873
 *         if to_frame and not force:
 *             raise TypeError(
 *                 "Expect columns to build the data frame or set"             # <<<<<<<<<<<<<<
 *                 " `force` to ``True`` to create a temporary frame:"
 *                f" Got {type(data).__name__!r}.")
 */
      __pyx_t_7 = PyTuple_New(3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4873, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_8 = 0;
      __pyx_t_9 = 127;
      __Pyx_INCREF(__pyx_kp_u_Expect_columns_to_build_the_data);
      __pyx_t_8 += 99;
      __Pyx_GIVEREF(__pyx_kp_u_Expect_columns_to_build_the_data);
      PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_kp_u_Expect_columns_to_build_the_data);

      /* "validator.pyx":4875
 *                 "Expect columns to build the data frame or set"
 *                 " `force` to ``True`` to create a temporary frame:"
 *                f" Got {type(data).__name__!r}.")             # <<<<<<<<<<<<<<
 * 
 *     return array_to_frame(
 */
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)Py_TYPE(__pyx_v_data)), __pyx_n_s_name); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4875, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_t_3), __pyx_empty_unicode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4875, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_9 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) > __pyx_t_9) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_4) : __pyx_t_9;
      __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_4);
      __Pyx_GIVEREF(__pyx_t_4);
      PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_t_4);
      __pyx_t_4 = 0;
      __Pyx_INCREF(__pyx_kp_u__16);
      __pyx_t_8 += 1;
      __Pyx_GIVEREF(__pyx_kp_u__16);
      PyTuple_SET_ITEM(__pyx_t_7, 2, __pyx_kp_u__16);

      /* "validator.pyx":4873
 *         if to_frame and not force:
 *             raise TypeError(
 *                 "Expect columns to build the data frame or set"             # <<<<<<<<<<<<<<
 *                 " `force` to ``True`` to create a temporary frame:"
 *                f" Got {type(data).__name__!r}.")
 */
      __pyx_t_4 = __Pyx_PyUnicode_Join(__pyx_t_7, 3, __pyx_t_8, __pyx_t_9); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4873, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

      /* "validator.pyx":4872
 *             raise TypeError("Expect a dataframe while columns is missing.")
 *         if to_frame and not force:
 *             raise TypeError(             # <<<<<<<<<<<<<<
 *                 "Expect columns to build the data frame or set"
 *                 " `force` to ``True`` to create a temporary frame:"
 */
      __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_builtin_TypeError, __pyx_t_4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4872, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_Raise(__pyx_t_7, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __PYX_ERR(0, 4872, __pyx_L1_error)

      /* "validator.pyx":4871
 *         if not to_frame:
 *             raise TypeError("Expect a dataframe while columns is missing.")
 *         if to_frame and not force:             # <<<<<<<<<<<<<<
 *             raise TypeError(
 *                 "Expect columns to build the data frame or set"
 */
    }

    /* "validator.pyx":4868
 *         data = np.array(data )
 * 
 *     if not is_frame ( data, df_only=True ):             # <<<<<<<<<<<<<<
 *         if not to_frame:
 *             raise TypeError("Expect a dataframe while columns is missing.")
 */
  }

  /* "validator.pyx":4877
 *                f" Got {type(data).__name__!r}.")
 * 
 *     return array_to_frame(             # <<<<<<<<<<<<<<
 *         data, columns = columns,
 *         to_frame =to_frame,
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_array_to_frame); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 4877, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);

  /* "validator.pyx":4878
 * 
 *     return array_to_frame(
 *         data, columns = columns,             # <<<<<<<<<<<<<<
 *         to_frame =to_frame,
 *         input_name=input_name,
 */
  __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4877, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_INCREF(__pyx_v_data);
  __Pyx_GIVEREF(__pyx_v_data);
  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_v_data);

  /* "validator.pyx":4877
 *                f" Got {type(data).__name__!r}.")
 * 
 *     return array_to_frame(             # <<<<<<<<<<<<<<
 *         data, columns = columns,
 *         to_frame =to_frame,
 */
  __pyx_t_5 = __Pyx_PyDict_NewPresized(4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4878, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);

  /* "validator.pyx":4878
 * 
 *     return array_to_frame(
 *         data, columns = columns,             # <<<<<<<<<<<<<<
 *         to_frame =to_frame,
 *         input_name=input_name,
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_columns, __pyx_v_columns) < 0) __PYX_ERR(0, 4878, __pyx_L1_error)

  /* "validator.pyx":4879
 *     return array_to_frame(
 *         data, columns = columns,
 *         to_frame =to_frame,             # <<<<<<<<<<<<<<
 *         input_name=input_name,
 *         force =force,
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_to_frame, __pyx_v_to_frame) < 0) __PYX_ERR(0, 4878, __pyx_L1_error)

  /* "validator.pyx":4880
 *         data, columns = columns,
 *         to_frame =to_frame,
 *         input_name=input_name,             # <<<<<<<<<<<<<<
 *         force =force,
 *         **kws
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_input_name, __pyx_v_input_name) < 0) __PYX_ERR(0, 4878, __pyx_L1_error)

  /* "validator.pyx":4881
 *         to_frame =to_frame,
 *         input_name=input_name,
 *         force =force,             # <<<<<<<<<<<<<<
 *         **kws
 *         )
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_force, __pyx_v_force) < 0) __PYX_ERR(0, 4878, __pyx_L1_error)
  __pyx_t_3 = __pyx_t_5;
  __pyx_t_5 = 0;

  /* "validator.pyx":4882
 *         input_name=input_name,
 *         force =force,
 *         **kws             # <<<<<<<<<<<<<<
 *         )
 * 
 */
  if (__Pyx_MergeKeywords(__pyx_t_3, __pyx_v_kws) < 0) __PYX_ERR(0, 4882, __pyx_L1_error)

  /* "validator.pyx":4877
 *                f" Got {type(data).__name__!r}.")
 * 
 *     return array_to_frame(             # <<<<<<<<<<<<<<
 *         data, columns = columns,
 *         to_frame =to_frame,
 */
  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_4, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4877, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_5;
  __pyx_t_5 = 0;
  goto __pyx_L0;

  /* "validator.pyx":4821
 *     return data  # Return original data if conditions are not met
 * 
 * def build_data_if2(             # <<<<<<<<<<<<<<
 *     data: Union[dict, np.ndarray, pd.DataFrame],
 *     columns=None,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("validator.build_data_if2", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_data);
  __Pyx_XDECREF(__pyx_v_columns);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":4885
 *         )
 * 
 * def array_to_frame(             # <<<<<<<<<<<<<<
 *     X,
 *     *,
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_159array_to_frame(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_158array_to_frame[] = "\n    Validates and optionally converts an array-like object to a pandas DataFrame,\n    applying specified column names if provided or generating them if the `force`\n    parameter is set.\n\n    Parameters\n    ----------\n    X : array-like\n        The array to potentially convert to a DataFrame.\n    columns : str or list of str, optional\n        The names for the resulting DataFrame columns or the Series name.\n    to_frame : bool, default=False\n        If True, converts `X` to a DataFrame if it isn't already one.\n    input_name : str, default=''\n        The name of the input variable, used for error and warning messages.\n    raise_warning : bool, default=True\n        If True and `to_frame` is True but `columns` are not provided,\n        a warning is issued unless `force` is True.\n    raise_exception : bool, default=False\n        If True, raises an exception when `to_frame` is True but columns\n        are not provided and `force` is False.\n    force : bool, default=False\n        Forces the conversion of `X` to a DataFrame by generating column names\n        based on `input_name` if `columns` are not provided.\n\n    Returns\n    -------\n    pd.DataFrame or pd.Series\n        The potentially converted DataFrame or Series, or `X` unchanged.\n\n    Examples\n    --------\n    >>> from gofast.tools.validator import array_to_frame\n    >>> from sklearn.datasets import load_iris\n    >>> data = load_iris()\n    >>> X = data.data\n    >>> array_to_frame(X, to_frame=True, columns=['sepal_length', 'sepal_width',\n                                                  'petal_length', 'petal_width'])\n    ";
static PyMethodDef __pyx_mdef_9validator_159array_to_frame = {"array_to_frame", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_159array_to_frame, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_158array_to_frame};
static PyObject *__pyx_pw_9validator_159array_to_frame(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_X = 0;
  PyObject *__pyx_v_to_frame = 0;
  PyObject *__pyx_v_columns = 0;
  PyObject *__pyx_v_raise_exception = 0;
  PyObject *__pyx_v_raise_warning = 0;
  PyObject *__pyx_v_input_name = 0;
  PyObject *__pyx_v_force = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array_to_frame (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_X,&__pyx_n_s_to_frame,&__pyx_n_s_columns,&__pyx_n_s_raise_exception,&__pyx_n_s_raise_warning,&__pyx_n_s_input_name,&__pyx_n_s_force,0};
    PyObject* values[7] = {0,0,0,0,0,0,0};

    /* "validator.pyx":4888
 *     X,
 *     *,
 *     to_frame=False,             # <<<<<<<<<<<<<<
 *     columns=None,
 *     raise_exception=False,
 */
    values[1] = ((PyObject *)Py_False);

    /* "validator.pyx":4889
 *     *,
 *     to_frame=False,
 *     columns=None,             # <<<<<<<<<<<<<<
 *     raise_exception=False,
 *     raise_warning=True,
 */
    values[2] = ((PyObject *)Py_None);

    /* "validator.pyx":4890
 *     to_frame=False,
 *     columns=None,
 *     raise_exception=False,             # <<<<<<<<<<<<<<
 *     raise_warning=True,
 *     input_name='',
 */
    values[3] = ((PyObject *)Py_False);

    /* "validator.pyx":4891
 *     columns=None,
 *     raise_exception=False,
 *     raise_warning=True,             # <<<<<<<<<<<<<<
 *     input_name='',
 *     force=False
 */
    values[4] = ((PyObject *)Py_True);
    values[5] = ((PyObject *)__pyx_kp_u__7);

    /* "validator.pyx":4893
 *     raise_warning=True,
 *     input_name='',
 *     force=False             # <<<<<<<<<<<<<<
 * ):
 *     """
 */
    values[6] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_X)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (kw_args > 0 && likely(kw_args <= 6)) {
        Py_ssize_t index;
        for (index = 1; index < 7 && kw_args > 0; index++) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
          if (value) { values[index] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "array_to_frame") < 0)) __PYX_ERR(0, 4885, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_X = values[0];
    __pyx_v_to_frame = values[1];
    __pyx_v_columns = values[2];
    __pyx_v_raise_exception = values[3];
    __pyx_v_raise_warning = values[4];
    __pyx_v_input_name = values[5];
    __pyx_v_force = values[6];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("array_to_frame", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4885, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.array_to_frame", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_158array_to_frame(__pyx_self, __pyx_v_X, __pyx_v_to_frame, __pyx_v_columns, __pyx_v_raise_exception, __pyx_v_raise_warning, __pyx_v_input_name, __pyx_v_force);

  /* "validator.pyx":4885
 *         )
 * 
 * def array_to_frame(             # <<<<<<<<<<<<<<
 *     X,
 *     *,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_158array_to_frame(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X, PyObject *__pyx_v_to_frame, PyObject *__pyx_v_columns, PyObject *__pyx_v_raise_exception, PyObject *__pyx_v_raise_warning, PyObject *__pyx_v_input_name, PyObject *__pyx_v_force) {
  PyObject *__pyx_v_msg = NULL;
  CYTHON_UNUSED PyObject *__pyx_v__ = NULL;
  PyObject *__pyx_9genexpr30__pyx_v_i = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_t_7;
  Py_ssize_t __pyx_t_8;
  PyObject *(*__pyx_t_9)(PyObject *);
  Py_ssize_t __pyx_t_10;
  Py_UCS4 __pyx_t_11;
  PyObject *__pyx_t_12 = NULL;
  PyObject *(*__pyx_t_13)(PyObject *);
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("array_to_frame", 0);
  __Pyx_INCREF(__pyx_v_X);
  __Pyx_INCREF(__pyx_v_columns);

  /* "validator.pyx":4935
 *     """
 *     # Determine if conversion to frame is needed
 *     if to_frame and not isinstance(X, (pd.DataFrame, pd.Series)):             # <<<<<<<<<<<<<<
 *         # Handle force conversion without provided column names
 *         if columns is None and force:
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_to_frame); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4935, __pyx_L1_error)
  if (__pyx_t_2) {
  } else {
    __pyx_t_1 = __pyx_t_2;
    goto __pyx_L4_bool_binop_done;
  }
  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_pd); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4935, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_DataFrame); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4935, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_pd); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4935, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_Series); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4935, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_6 = PyObject_IsInstance(__pyx_v_X, __pyx_t_4); 
  __pyx_t_7 = (__pyx_t_6 != 0);
  if (!__pyx_t_7) {
  } else {
    __pyx_t_2 = __pyx_t_7;
    goto __pyx_L6_bool_binop_done;
  }
  __pyx_t_7 = PyObject_IsInstance(__pyx_v_X, __pyx_t_5); 
  __pyx_t_6 = (__pyx_t_7 != 0);
  __pyx_t_2 = __pyx_t_6;
  __pyx_L6_bool_binop_done:;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_6 = ((!(__pyx_t_2 != 0)) != 0);
  __pyx_t_1 = __pyx_t_6;
  __pyx_L4_bool_binop_done:;
  if (__pyx_t_1) {

    /* "validator.pyx":4937
 *     if to_frame and not isinstance(X, (pd.DataFrame, pd.Series)):
 *         # Handle force conversion without provided column names
 *         if columns is None and force:             # <<<<<<<<<<<<<<
 *             columns = [f"{input_name}_{i}" for i in range(X.shape[1])]
 *         elif columns is None:
 */
    __pyx_t_6 = (__pyx_v_columns == Py_None);
    __pyx_t_2 = (__pyx_t_6 != 0);
    if (__pyx_t_2) {
    } else {
      __pyx_t_1 = __pyx_t_2;
      goto __pyx_L9_bool_binop_done;
    }
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_force); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4937, __pyx_L1_error)
    __pyx_t_1 = __pyx_t_2;
    __pyx_L9_bool_binop_done:;
    if (__pyx_t_1) {

      /* "validator.pyx":4938
 *         # Handle force conversion without provided column names
 *         if columns is None and force:
 *             columns = [f"{input_name}_{i}" for i in range(X.shape[1])]             # <<<<<<<<<<<<<<
 *         elif columns is None:
 *             msg = (
 */
      { /* enter inner scope */
        __pyx_t_4 = PyList_New(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4938, __pyx_L13_error)
        __Pyx_GOTREF(__pyx_t_4);
        __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4938, __pyx_L13_error)
        __Pyx_GOTREF(__pyx_t_5);
        __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_5, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4938, __pyx_L13_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_builtin_range, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4938, __pyx_L13_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        if (likely(PyList_CheckExact(__pyx_t_5)) || PyTuple_CheckExact(__pyx_t_5)) {
          __pyx_t_3 = __pyx_t_5; __Pyx_INCREF(__pyx_t_3); __pyx_t_8 = 0;
          __pyx_t_9 = NULL;
        } else {
          __pyx_t_8 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4938, __pyx_L13_error)
          __Pyx_GOTREF(__pyx_t_3);
          __pyx_t_9 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 4938, __pyx_L13_error)
        }
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        for (;;) {
          if (likely(!__pyx_t_9)) {
            if (likely(PyList_CheckExact(__pyx_t_3))) {
              if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_3)) break;
              #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
              __pyx_t_5 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_8); __Pyx_INCREF(__pyx_t_5); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 4938, __pyx_L13_error)
              #else
              __pyx_t_5 = PySequence_ITEM(__pyx_t_3, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4938, __pyx_L13_error)
              __Pyx_GOTREF(__pyx_t_5);
              #endif
            } else {
              if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
              #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
              __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_8); __Pyx_INCREF(__pyx_t_5); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 4938, __pyx_L13_error)
              #else
              __pyx_t_5 = PySequence_ITEM(__pyx_t_3, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4938, __pyx_L13_error)
              __Pyx_GOTREF(__pyx_t_5);
              #endif
            }
          } else {
            __pyx_t_5 = __pyx_t_9(__pyx_t_3);
            if (unlikely(!__pyx_t_5)) {
              PyObject* exc_type = PyErr_Occurred();
              if (exc_type) {
                if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
                else __PYX_ERR(0, 4938, __pyx_L13_error)
              }
              break;
            }
            __Pyx_GOTREF(__pyx_t_5);
          }
          __Pyx_XDECREF_SET(__pyx_9genexpr30__pyx_v_i, __pyx_t_5);
          __pyx_t_5 = 0;
          __pyx_t_5 = PyTuple_New(3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4938, __pyx_L13_error)
          __Pyx_GOTREF(__pyx_t_5);
          __pyx_t_10 = 0;
          __pyx_t_11 = 127;
          __pyx_t_12 = __Pyx_PyObject_FormatSimple(__pyx_v_input_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 4938, __pyx_L13_error)
          __Pyx_GOTREF(__pyx_t_12);
          __pyx_t_11 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_12) > __pyx_t_11) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_12) : __pyx_t_11;
          __pyx_t_10 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_12);
          __Pyx_GIVEREF(__pyx_t_12);
          PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_12);
          __pyx_t_12 = 0;
          __Pyx_INCREF(__pyx_n_u__102);
          __pyx_t_10 += 1;
          __Pyx_GIVEREF(__pyx_n_u__102);
          PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_n_u__102);
          __pyx_t_12 = __Pyx_PyObject_FormatSimple(__pyx_9genexpr30__pyx_v_i, __pyx_empty_unicode); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 4938, __pyx_L13_error)
          __Pyx_GOTREF(__pyx_t_12);
          __pyx_t_11 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_12) > __pyx_t_11) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_12) : __pyx_t_11;
          __pyx_t_10 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_12);
          __Pyx_GIVEREF(__pyx_t_12);
          PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_t_12);
          __pyx_t_12 = 0;
          __pyx_t_12 = __Pyx_PyUnicode_Join(__pyx_t_5, 3, __pyx_t_10, __pyx_t_11); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 4938, __pyx_L13_error)
          __Pyx_GOTREF(__pyx_t_12);
          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
          if (unlikely(__Pyx_ListComp_Append(__pyx_t_4, (PyObject*)__pyx_t_12))) __PYX_ERR(0, 4938, __pyx_L13_error)
          __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
        }
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_XDECREF(__pyx_9genexpr30__pyx_v_i); __pyx_9genexpr30__pyx_v_i = 0;
        goto __pyx_L16_exit_scope;
        __pyx_L13_error:;
        __Pyx_XDECREF(__pyx_9genexpr30__pyx_v_i); __pyx_9genexpr30__pyx_v_i = 0;
        goto __pyx_L1_error;
        __pyx_L16_exit_scope:;
      } /* exit inner scope */
      __Pyx_DECREF_SET(__pyx_v_columns, __pyx_t_4);
      __pyx_t_4 = 0;

      /* "validator.pyx":4937
 *     if to_frame and not isinstance(X, (pd.DataFrame, pd.Series)):
 *         # Handle force conversion without provided column names
 *         if columns is None and force:             # <<<<<<<<<<<<<<
 *             columns = [f"{input_name}_{i}" for i in range(X.shape[1])]
 *         elif columns is None:
 */
      goto __pyx_L8;
    }

    /* "validator.pyx":4939
 *         if columns is None and force:
 *             columns = [f"{input_name}_{i}" for i in range(X.shape[1])]
 *         elif columns is None:             # <<<<<<<<<<<<<<
 *             msg = (
 *                 f"Array '{input_name}' requires column names for conversion to a DataFrame. "
 */
    __pyx_t_1 = (__pyx_v_columns == Py_None);
    __pyx_t_2 = (__pyx_t_1 != 0);
    if (__pyx_t_2) {

      /* "validator.pyx":4941
 *         elif columns is None:
 *             msg = (
 *                 f"Array '{input_name}' requires column names for conversion to a DataFrame. "             # <<<<<<<<<<<<<<
 *                  "Provide `columns` or set `force=True` to auto-generate column names."
 *             )
 */
      __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4941, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_8 = 0;
      __pyx_t_11 = 127;
      __Pyx_INCREF(__pyx_kp_u_Array);
      __pyx_t_8 += 7;
      __Pyx_GIVEREF(__pyx_kp_u_Array);
      PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_kp_u_Array);
      __pyx_t_3 = __Pyx_PyObject_FormatSimple(__pyx_v_input_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4941, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_11 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) > __pyx_t_11) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) : __pyx_t_11;
      __pyx_t_8 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_3);
      __Pyx_GIVEREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_3);
      __pyx_t_3 = 0;
      __Pyx_INCREF(__pyx_kp_u_requires_column_names_for_conve);
      __pyx_t_8 += 123;
      __Pyx_GIVEREF(__pyx_kp_u_requires_column_names_for_conve);
      PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_kp_u_requires_column_names_for_conve);
      __pyx_t_3 = __Pyx_PyUnicode_Join(__pyx_t_4, 3, __pyx_t_8, __pyx_t_11); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4941, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_v_msg = ((PyObject*)__pyx_t_3);
      __pyx_t_3 = 0;

      /* "validator.pyx":4944
 *                  "Provide `columns` or set `force=True` to auto-generate column names."
 *             )
 *             if raise_exception:             # <<<<<<<<<<<<<<
 *                 raise ValueError(msg)
 *             if raise_warning and raise_warning not in ("silence", "ignore", "mute"):
 */
      __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_raise_exception); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 4944, __pyx_L1_error)
      if (unlikely(__pyx_t_2)) {

        /* "validator.pyx":4945
 *             )
 *             if raise_exception:
 *                 raise ValueError(msg)             # <<<<<<<<<<<<<<
 *             if raise_warning and raise_warning not in ("silence", "ignore", "mute"):
 *                 warnings.warn(msg)
 */
        __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_v_msg); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4945, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_Raise(__pyx_t_3, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __PYX_ERR(0, 4945, __pyx_L1_error)

        /* "validator.pyx":4944
 *                  "Provide `columns` or set `force=True` to auto-generate column names."
 *             )
 *             if raise_exception:             # <<<<<<<<<<<<<<
 *                 raise ValueError(msg)
 *             if raise_warning and raise_warning not in ("silence", "ignore", "mute"):
 */
      }

      /* "validator.pyx":4946
 *             if raise_exception:
 *                 raise ValueError(msg)
 *             if raise_warning and raise_warning not in ("silence", "ignore", "mute"):             # <<<<<<<<<<<<<<
 *                 warnings.warn(msg)
 *             return X  # Early return if no columns and not forcing
 */
      __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_raise_warning); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 4946, __pyx_L1_error)
      if (__pyx_t_1) {
      } else {
        __pyx_t_2 = __pyx_t_1;
        goto __pyx_L19_bool_binop_done;
      }
      __Pyx_INCREF(__pyx_v_raise_warning);
      __pyx_t_3 = __pyx_v_raise_warning;
      __pyx_t_6 = (__Pyx_PyUnicode_Equals(__pyx_t_3, __pyx_n_u_silence, Py_NE)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 4946, __pyx_L1_error)
      if (__pyx_t_6) {
      } else {
        __pyx_t_1 = __pyx_t_6;
        goto __pyx_L21_bool_binop_done;
      }
      __pyx_t_6 = (__Pyx_PyUnicode_Equals(__pyx_t_3, __pyx_n_u_ignore, Py_NE)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 4946, __pyx_L1_error)
      if (__pyx_t_6) {
      } else {
        __pyx_t_1 = __pyx_t_6;
        goto __pyx_L21_bool_binop_done;
      }
      __pyx_t_6 = (__Pyx_PyUnicode_Equals(__pyx_t_3, __pyx_n_u_mute, Py_NE)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 4946, __pyx_L1_error)
      __pyx_t_1 = __pyx_t_6;
      __pyx_L21_bool_binop_done:;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = (__pyx_t_1 != 0);
      __pyx_t_2 = __pyx_t_6;
      __pyx_L19_bool_binop_done:;
      if (__pyx_t_2) {

        /* "validator.pyx":4947
 *                 raise ValueError(msg)
 *             if raise_warning and raise_warning not in ("silence", "ignore", "mute"):
 *                 warnings.warn(msg)             # <<<<<<<<<<<<<<
 *             return X  # Early return if no columns and not forcing
 * 
 */
        __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_warnings); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4947, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __pyx_t_12 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_warn); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 4947, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_12);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_t_4 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_12))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_12);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_12);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_12, function);
          }
        }
        __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_12, __pyx_t_4, __pyx_v_msg) : __Pyx_PyObject_CallOneArg(__pyx_t_12, __pyx_v_msg);
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4947, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

        /* "validator.pyx":4946
 *             if raise_exception:
 *                 raise ValueError(msg)
 *             if raise_warning and raise_warning not in ("silence", "ignore", "mute"):             # <<<<<<<<<<<<<<
 *                 warnings.warn(msg)
 *             return X  # Early return if no columns and not forcing
 */
      }

      /* "validator.pyx":4948
 *             if raise_warning and raise_warning not in ("silence", "ignore", "mute"):
 *                 warnings.warn(msg)
 *             return X  # Early return if no columns and not forcing             # <<<<<<<<<<<<<<
 * 
 *         # Proceed with conversion using the provided or generated column names
 */
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_v_X);
      __pyx_r = __pyx_v_X;
      goto __pyx_L0;

      /* "validator.pyx":4939
 *         if columns is None and force:
 *             columns = [f"{input_name}_{i}" for i in range(X.shape[1])]
 *         elif columns is None:             # <<<<<<<<<<<<<<
 *             msg = (
 *                 f"Array '{input_name}' requires column names for conversion to a DataFrame. "
 */
    }
    __pyx_L8:;

    /* "validator.pyx":4951
 * 
 *         # Proceed with conversion using the provided or generated column names
 *         X,_ = convert_array_to_pandas(X, to_frame=True, columns=columns,             # <<<<<<<<<<<<<<
 *                                       input_name=input_name)
 * 
 */
    __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_convert_array_to_pandas); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4951, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_12 = PyTuple_New(1); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 4951, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_12);
    __Pyx_INCREF(__pyx_v_X);
    __Pyx_GIVEREF(__pyx_v_X);
    PyTuple_SET_ITEM(__pyx_t_12, 0, __pyx_v_X);
    __pyx_t_4 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4951, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_to_frame, Py_True) < 0) __PYX_ERR(0, 4951, __pyx_L1_error)
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_columns, __pyx_v_columns) < 0) __PYX_ERR(0, 4951, __pyx_L1_error)

    /* "validator.pyx":4952
 *         # Proceed with conversion using the provided or generated column names
 *         X,_ = convert_array_to_pandas(X, to_frame=True, columns=columns,
 *                                       input_name=input_name)             # <<<<<<<<<<<<<<
 * 
 *     return X
 */
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_input_name, __pyx_v_input_name) < 0) __PYX_ERR(0, 4951, __pyx_L1_error)

    /* "validator.pyx":4951
 * 
 *         # Proceed with conversion using the provided or generated column names
 *         X,_ = convert_array_to_pandas(X, to_frame=True, columns=columns,             # <<<<<<<<<<<<<<
 *                                       input_name=input_name)
 * 
 */
    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_12, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 4951, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if ((likely(PyTuple_CheckExact(__pyx_t_5))) || (PyList_CheckExact(__pyx_t_5))) {
      PyObject* sequence = __pyx_t_5;
      Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
      if (unlikely(size != 2)) {
        if (size > 2) __Pyx_RaiseTooManyValuesError(2);
        else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
        __PYX_ERR(0, 4951, __pyx_L1_error)
      }
      #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
      if (likely(PyTuple_CheckExact(sequence))) {
        __pyx_t_4 = PyTuple_GET_ITEM(sequence, 0); 
        __pyx_t_12 = PyTuple_GET_ITEM(sequence, 1); 
      } else {
        __pyx_t_4 = PyList_GET_ITEM(sequence, 0); 
        __pyx_t_12 = PyList_GET_ITEM(sequence, 1); 
      }
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_12);
      #else
      __pyx_t_4 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 4951, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_12 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 4951, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_12);
      #endif
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    } else {
      Py_ssize_t index = -1;
      __pyx_t_3 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4951, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_13 = Py_TYPE(__pyx_t_3)->tp_iternext;
      index = 0; __pyx_t_4 = __pyx_t_13(__pyx_t_3); if (unlikely(!__pyx_t_4)) goto __pyx_L24_unpacking_failed;
      __Pyx_GOTREF(__pyx_t_4);
      index = 1; __pyx_t_12 = __pyx_t_13(__pyx_t_3); if (unlikely(!__pyx_t_12)) goto __pyx_L24_unpacking_failed;
      __Pyx_GOTREF(__pyx_t_12);
      if (__Pyx_IternextUnpackEndCheck(__pyx_t_13(__pyx_t_3), 2) < 0) __PYX_ERR(0, 4951, __pyx_L1_error)
      __pyx_t_13 = NULL;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      goto __pyx_L25_unpacking_done;
      __pyx_L24_unpacking_failed:;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_13 = NULL;
      if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
      __PYX_ERR(0, 4951, __pyx_L1_error)
      __pyx_L25_unpacking_done:;
    }
    __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_v__ = __pyx_t_12;
    __pyx_t_12 = 0;

    /* "validator.pyx":4935
 *     """
 *     # Determine if conversion to frame is needed
 *     if to_frame and not isinstance(X, (pd.DataFrame, pd.Series)):             # <<<<<<<<<<<<<<
 *         # Handle force conversion without provided column names
 *         if columns is None and force:
 */
  }

  /* "validator.pyx":4954
 *                                       input_name=input_name)
 * 
 *     return X             # <<<<<<<<<<<<<<
 * 
 * def array_to_frame2(
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_X);
  __pyx_r = __pyx_v_X;
  goto __pyx_L0;

  /* "validator.pyx":4885
 *         )
 * 
 * def array_to_frame(             # <<<<<<<<<<<<<<
 *     X,
 *     *,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_12);
  __Pyx_AddTraceback("validator.array_to_frame", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_msg);
  __Pyx_XDECREF(__pyx_v__);
  __Pyx_XDECREF(__pyx_9genexpr30__pyx_v_i);
  __Pyx_XDECREF(__pyx_v_X);
  __Pyx_XDECREF(__pyx_v_columns);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":4956
 *     return X
 * 
 * def array_to_frame2(             # <<<<<<<<<<<<<<
 *     X,
 *     *,
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_161array_to_frame2(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_160array_to_frame2[] = "Added part of `is_frame` dedicated to X and y frame reconversion \n    validation.\n    \n    Parameters \n    ------------\n    X: Array-like \n        Array to convert to frame. \n    columns: str or list of str \n        Series name or columns names for pandas.Series and DataFrame. \n        \n    to_frame: str, default=False\n        If ``True`` , reconvert the array to frame using the columns orthewise \n        no-action is performed and return the same array.\n    input_name : str, default=\"\"\n        The data name used to construct the error message. \n        \n    raise_warning : bool, default=True\n        If True then raise a warning if conversion is required.\n        If ``ignore``, warnings silence mode is triggered.\n    raise_exception : bool, default=False\n        If True then raise an exception if array is not symmetric.\n        \n    force:bool, default=False\n        Force conversion array to a frame is columns is not supplied.\n        Use the combinaison, `input_name` and `X.shape[1]` range.\n        \n    Returns\n    --------\n    X: converted array \n    \n    Example\n    ---------\n    >>> from gofast.datasets import fetch_data  \n    >>> from gofast.tools.validator import array_to_frame \n    >>> data = fetch_data ('hlogs').frame \n    >>> array_to_frame (data.k.values , \n                        to_frame= True, columns =None, input_name= 'y',\n                        raise_warning=\"silence\"\n                                ) \n    ... array([nan, nan, nan, ..., nan, nan, nan]) # mute \n    \n    ";
static PyMethodDef __pyx_mdef_9validator_161array_to_frame2 = {"array_to_frame2", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_161array_to_frame2, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_160array_to_frame2};
static PyObject *__pyx_pw_9validator_161array_to_frame2(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_X = 0;
  PyObject *__pyx_v_to_frame = 0;
  PyObject *__pyx_v_columns = 0;
  PyObject *__pyx_v_raise_exception = 0;
  PyObject *__pyx_v_raise_warning = 0;
  PyObject *__pyx_v_input_name = 0;
  PyObject *__pyx_v_force = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("array_to_frame2 (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_X,&__pyx_n_s_to_frame,&__pyx_n_s_columns,&__pyx_n_s_raise_exception,&__pyx_n_s_raise_warning,&__pyx_n_s_input_name,&__pyx_n_s_force,0};
    PyObject* values[7] = {0,0,0,0,0,0,0};

    /* "validator.pyx":4959
 *     X,
 *     *,
 *     to_frame = False,             # <<<<<<<<<<<<<<
 *     columns = None,
 *     raise_exception =False,
 */
    values[1] = ((PyObject *)Py_False);

    /* "validator.pyx":4960
 *     *,
 *     to_frame = False,
 *     columns = None,             # <<<<<<<<<<<<<<
 *     raise_exception =False,
 *     raise_warning =True,
 */
    values[2] = ((PyObject *)Py_None);

    /* "validator.pyx":4961
 *     to_frame = False,
 *     columns = None,
 *     raise_exception =False,             # <<<<<<<<<<<<<<
 *     raise_warning =True,
 *     input_name ='',
 */
    values[3] = ((PyObject *)Py_False);

    /* "validator.pyx":4962
 *     columns = None,
 *     raise_exception =False,
 *     raise_warning =True,             # <<<<<<<<<<<<<<
 *     input_name ='',
 *     force:bool=False,
 */
    values[4] = ((PyObject *)Py_True);
    values[5] = ((PyObject *)__pyx_kp_u__7);

    /* "validator.pyx":4964
 *     raise_warning =True,
 *     input_name ='',
 *     force:bool=False,             # <<<<<<<<<<<<<<
 *   ):
 *     """Added part of `is_frame` dedicated to X and y frame reconversion
 */
    values[6] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_X)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (kw_args > 0 && likely(kw_args <= 6)) {
        Py_ssize_t index;
        for (index = 1; index < 7 && kw_args > 0; index++) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
          if (value) { values[index] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "array_to_frame2") < 0)) __PYX_ERR(0, 4956, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_X = values[0];
    __pyx_v_to_frame = values[1];
    __pyx_v_columns = values[2];
    __pyx_v_raise_exception = values[3];
    __pyx_v_raise_warning = values[4];
    __pyx_v_input_name = values[5];
    __pyx_v_force = values[6];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("array_to_frame2", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4956, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.array_to_frame2", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_160array_to_frame2(__pyx_self, __pyx_v_X, __pyx_v_to_frame, __pyx_v_columns, __pyx_v_raise_exception, __pyx_v_raise_warning, __pyx_v_input_name, __pyx_v_force);

  /* "validator.pyx":4956
 *     return X
 * 
 * def array_to_frame2(             # <<<<<<<<<<<<<<
 *     X,
 *     *,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_160array_to_frame2(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X, PyObject *__pyx_v_to_frame, PyObject *__pyx_v_columns, PyObject *__pyx_v_raise_exception, PyObject *__pyx_v_raise_warning, PyObject *__pyx_v_input_name, PyObject *__pyx_v_force) {
  PyObject *__pyx_v_isf = NULL;
  PyObject *__pyx_v_msg = NULL;
  CYTHON_UNUSED PyObject *__pyx_v__ = NULL;
  PyObject *__pyx_9genexpr31__pyx_v_i = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_t_6;
  Py_ssize_t __pyx_t_7;
  PyObject *(*__pyx_t_8)(PyObject *);
  PyObject *__pyx_t_9 = NULL;
  Py_UCS4 __pyx_t_10;
  PyObject *(*__pyx_t_11)(PyObject *);
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("array_to_frame2", 0);
  __Pyx_INCREF(__pyx_v_X);
  __Pyx_INCREF(__pyx_v_columns);

  /* "validator.pyx":5009
 *     """
 * 
 *     isf = to_frame ; isf = is_frame( X)             # <<<<<<<<<<<<<<
 * 
 *     if ( to_frame
 */
  __Pyx_INCREF(__pyx_v_to_frame);
  __pyx_v_isf = __pyx_v_to_frame;
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_is_frame); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5009, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_X) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_X);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5009, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF_SET(__pyx_v_isf, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":5011
 *     isf = to_frame ; isf = is_frame( X)
 * 
 *     if ( to_frame             # <<<<<<<<<<<<<<
 *         and not isf
 *         and columns is None
 */
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_v_to_frame); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 5011, __pyx_L1_error)
  if (__pyx_t_5) {
  } else {
    __pyx_t_4 = __pyx_t_5;
    goto __pyx_L4_bool_binop_done;
  }

  /* "validator.pyx":5012
 * 
 *     if ( to_frame
 *         and not isf             # <<<<<<<<<<<<<<
 *         and columns is None
 *         ):
 */
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_v_isf); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 5012, __pyx_L1_error)
  __pyx_t_6 = ((!__pyx_t_5) != 0);
  if (__pyx_t_6) {
  } else {
    __pyx_t_4 = __pyx_t_6;
    goto __pyx_L4_bool_binop_done;
  }

  /* "validator.pyx":5013
 *     if ( to_frame
 *         and not isf
 *         and columns is None             # <<<<<<<<<<<<<<
 *         ):
 *         if force:
 */
  __pyx_t_6 = (__pyx_v_columns == Py_None);
  __pyx_t_5 = (__pyx_t_6 != 0);
  __pyx_t_4 = __pyx_t_5;
  __pyx_L4_bool_binop_done:;

  /* "validator.pyx":5011
 *     isf = to_frame ; isf = is_frame( X)
 * 
 *     if ( to_frame             # <<<<<<<<<<<<<<
 *         and not isf
 *         and columns is None
 */
  if (__pyx_t_4) {

    /* "validator.pyx":5015
 *         and columns is None
 *         ):
 *         if force:             # <<<<<<<<<<<<<<
 *             columns =[f"{input_name + str(i)}" for i in range(X.shape[1])]
 *             isf =True
 */
    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_force); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 5015, __pyx_L1_error)
    if (__pyx_t_4) {

      /* "validator.pyx":5016
 *         ):
 *         if force:
 *             columns =[f"{input_name + str(i)}" for i in range(X.shape[1])]             # <<<<<<<<<<<<<<
 *             isf =True
 *         else:
 */
      { /* enter inner scope */
        __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5016, __pyx_L10_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_shape); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5016, __pyx_L10_error)
        __Pyx_GOTREF(__pyx_t_2);
        __pyx_t_3 = __Pyx_GetItemInt(__pyx_t_2, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5016, __pyx_L10_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_range, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5016, __pyx_L10_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        if (likely(PyList_CheckExact(__pyx_t_2)) || PyTuple_CheckExact(__pyx_t_2)) {
          __pyx_t_3 = __pyx_t_2; __Pyx_INCREF(__pyx_t_3); __pyx_t_7 = 0;
          __pyx_t_8 = NULL;
        } else {
          __pyx_t_7 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5016, __pyx_L10_error)
          __Pyx_GOTREF(__pyx_t_3);
          __pyx_t_8 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 5016, __pyx_L10_error)
        }
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        for (;;) {
          if (likely(!__pyx_t_8)) {
            if (likely(PyList_CheckExact(__pyx_t_3))) {
              if (__pyx_t_7 >= PyList_GET_SIZE(__pyx_t_3)) break;
              #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
              __pyx_t_2 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_2); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 5016, __pyx_L10_error)
              #else
              __pyx_t_2 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5016, __pyx_L10_error)
              __Pyx_GOTREF(__pyx_t_2);
              #endif
            } else {
              if (__pyx_t_7 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
              #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
              __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_7); __Pyx_INCREF(__pyx_t_2); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 5016, __pyx_L10_error)
              #else
              __pyx_t_2 = PySequence_ITEM(__pyx_t_3, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5016, __pyx_L10_error)
              __Pyx_GOTREF(__pyx_t_2);
              #endif
            }
          } else {
            __pyx_t_2 = __pyx_t_8(__pyx_t_3);
            if (unlikely(!__pyx_t_2)) {
              PyObject* exc_type = PyErr_Occurred();
              if (exc_type) {
                if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
                else __PYX_ERR(0, 5016, __pyx_L10_error)
              }
              break;
            }
            __Pyx_GOTREF(__pyx_t_2);
          }
          __Pyx_XDECREF_SET(__pyx_9genexpr31__pyx_v_i, __pyx_t_2);
          __pyx_t_2 = 0;
          __pyx_t_2 = __Pyx_PyObject_CallOneArg(((PyObject *)(&PyUnicode_Type)), __pyx_9genexpr31__pyx_v_i); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5016, __pyx_L10_error)
          __Pyx_GOTREF(__pyx_t_2);
          __pyx_t_9 = PyNumber_Add(__pyx_v_input_name, __pyx_t_2); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 5016, __pyx_L10_error)
          __Pyx_GOTREF(__pyx_t_9);
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
          __pyx_t_2 = __Pyx_PyObject_FormatSimple(__pyx_t_9, __pyx_empty_unicode); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5016, __pyx_L10_error)
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
          if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_2))) __PYX_ERR(0, 5016, __pyx_L10_error)
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        }
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_XDECREF(__pyx_9genexpr31__pyx_v_i); __pyx_9genexpr31__pyx_v_i = 0;
        goto __pyx_L13_exit_scope;
        __pyx_L10_error:;
        __Pyx_XDECREF(__pyx_9genexpr31__pyx_v_i); __pyx_9genexpr31__pyx_v_i = 0;
        goto __pyx_L1_error;
        __pyx_L13_exit_scope:;
      } /* exit inner scope */
      __Pyx_DECREF_SET(__pyx_v_columns, __pyx_t_1);
      __pyx_t_1 = 0;

      /* "validator.pyx":5017
 *         if force:
 *             columns =[f"{input_name + str(i)}" for i in range(X.shape[1])]
 *             isf =True             # <<<<<<<<<<<<<<
 *         else:
 *             msg = (f"Array {input_name} is originally not a frame. Frame "
 */
      __Pyx_INCREF(Py_True);
      __Pyx_DECREF_SET(__pyx_v_isf, Py_True);

      /* "validator.pyx":5015
 *         and columns is None
 *         ):
 *         if force:             # <<<<<<<<<<<<<<
 *             columns =[f"{input_name + str(i)}" for i in range(X.shape[1])]
 *             isf =True
 */
      goto __pyx_L7;
    }

    /* "validator.pyx":5019
 *             isf =True
 *         else:
 *             msg = (f"Array {input_name} is originally not a frame. Frame "             # <<<<<<<<<<<<<<
 *                    "conversion cannot be performed with no column names."
 *                    )
 */
    /*else*/ {
      __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5019, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_7 = 0;
      __pyx_t_10 = 127;
      __Pyx_INCREF(__pyx_kp_u_Array_2);
      __pyx_t_7 += 6;
      __Pyx_GIVEREF(__pyx_kp_u_Array_2);
      PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_Array_2);
      __pyx_t_3 = __Pyx_PyObject_FormatSimple(__pyx_v_input_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5019, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_10 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) > __pyx_t_10) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) : __pyx_t_10;
      __pyx_t_7 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_3);
      __Pyx_GIVEREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_3);
      __pyx_t_3 = 0;
      __Pyx_INCREF(__pyx_kp_u_is_originally_not_a_frame_Frame);
      __pyx_t_7 += 86;
      __Pyx_GIVEREF(__pyx_kp_u_is_originally_not_a_frame_Frame);
      PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_is_originally_not_a_frame_Frame);
      __pyx_t_3 = __Pyx_PyUnicode_Join(__pyx_t_1, 3, __pyx_t_7, __pyx_t_10); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5019, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_v_msg = ((PyObject*)__pyx_t_3);
      __pyx_t_3 = 0;

      /* "validator.pyx":5022
 *                    "conversion cannot be performed with no column names."
 *                    )
 *             if raise_exception:             # <<<<<<<<<<<<<<
 *                 raise ValueError (msg)
 *             if  ( raise_warning
 */
      __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_raise_exception); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 5022, __pyx_L1_error)
      if (unlikely(__pyx_t_4)) {

        /* "validator.pyx":5023
 *                    )
 *             if raise_exception:
 *                 raise ValueError (msg)             # <<<<<<<<<<<<<<
 *             if  ( raise_warning
 *                  and raise_warning not in ("silence","ignore", "mute")
 */
        __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_v_msg); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5023, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_Raise(__pyx_t_3, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __PYX_ERR(0, 5023, __pyx_L1_error)

        /* "validator.pyx":5022
 *                    "conversion cannot be performed with no column names."
 *                    )
 *             if raise_exception:             # <<<<<<<<<<<<<<
 *                 raise ValueError (msg)
 *             if  ( raise_warning
 */
      }

      /* "validator.pyx":5024
 *             if raise_exception:
 *                 raise ValueError (msg)
 *             if  ( raise_warning             # <<<<<<<<<<<<<<
 *                  and raise_warning not in ("silence","ignore", "mute")
 *                  ):
 */
      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_v_raise_warning); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 5024, __pyx_L1_error)
      if (__pyx_t_5) {
      } else {
        __pyx_t_4 = __pyx_t_5;
        goto __pyx_L16_bool_binop_done;
      }

      /* "validator.pyx":5025
 *                 raise ValueError (msg)
 *             if  ( raise_warning
 *                  and raise_warning not in ("silence","ignore", "mute")             # <<<<<<<<<<<<<<
 *                  ):
 *                 warnings.warn(msg )
 */
      __Pyx_INCREF(__pyx_v_raise_warning);
      __pyx_t_3 = __pyx_v_raise_warning;
      __pyx_t_6 = (__Pyx_PyUnicode_Equals(__pyx_t_3, __pyx_n_u_silence, Py_NE)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 5025, __pyx_L1_error)
      if (__pyx_t_6) {
      } else {
        __pyx_t_5 = __pyx_t_6;
        goto __pyx_L18_bool_binop_done;
      }
      __pyx_t_6 = (__Pyx_PyUnicode_Equals(__pyx_t_3, __pyx_n_u_ignore, Py_NE)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 5025, __pyx_L1_error)
      if (__pyx_t_6) {
      } else {
        __pyx_t_5 = __pyx_t_6;
        goto __pyx_L18_bool_binop_done;
      }
      __pyx_t_6 = (__Pyx_PyUnicode_Equals(__pyx_t_3, __pyx_n_u_mute, Py_NE)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 5025, __pyx_L1_error)
      __pyx_t_5 = __pyx_t_6;
      __pyx_L18_bool_binop_done:;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = (__pyx_t_5 != 0);
      __pyx_t_4 = __pyx_t_6;
      __pyx_L16_bool_binop_done:;

      /* "validator.pyx":5024
 *             if raise_exception:
 *                 raise ValueError (msg)
 *             if  ( raise_warning             # <<<<<<<<<<<<<<
 *                  and raise_warning not in ("silence","ignore", "mute")
 *                  ):
 */
      if (__pyx_t_4) {

        /* "validator.pyx":5027
 *                  and raise_warning not in ("silence","ignore", "mute")
 *                  ):
 *                 warnings.warn(msg )             # <<<<<<<<<<<<<<
 * 
 *             isf=False
 */
        __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_warnings); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5027, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_warn); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5027, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __pyx_t_1 = NULL;
        if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
          __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
          if (likely(__pyx_t_1)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
            __Pyx_INCREF(__pyx_t_1);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_2, function);
          }
        }
        __pyx_t_3 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_1, __pyx_v_msg) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_msg);
        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
        if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5027, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

        /* "validator.pyx":5024
 *             if raise_exception:
 *                 raise ValueError (msg)
 *             if  ( raise_warning             # <<<<<<<<<<<<<<
 *                  and raise_warning not in ("silence","ignore", "mute")
 *                  ):
 */
      }

      /* "validator.pyx":5029
 *                 warnings.warn(msg )
 * 
 *             isf=False             # <<<<<<<<<<<<<<
 * 
 *     elif ( to_frame
 */
      __Pyx_INCREF(Py_False);
      __Pyx_DECREF_SET(__pyx_v_isf, Py_False);
    }
    __pyx_L7:;

    /* "validator.pyx":5011
 *     isf = to_frame ; isf = is_frame( X)
 * 
 *     if ( to_frame             # <<<<<<<<<<<<<<
 *         and not isf
 *         and columns is None
 */
    goto __pyx_L3;
  }

  /* "validator.pyx":5031
 *             isf=False
 * 
 *     elif ( to_frame             # <<<<<<<<<<<<<<
 *           and columns is not None
 *           ):
 */
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_to_frame); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 5031, __pyx_L1_error)
  if (__pyx_t_6) {
  } else {
    __pyx_t_4 = __pyx_t_6;
    goto __pyx_L21_bool_binop_done;
  }

  /* "validator.pyx":5032
 * 
 *     elif ( to_frame
 *           and columns is not None             # <<<<<<<<<<<<<<
 *           ):
 *         isf =True
 */
  __pyx_t_6 = (__pyx_v_columns != Py_None);
  __pyx_t_5 = (__pyx_t_6 != 0);
  __pyx_t_4 = __pyx_t_5;
  __pyx_L21_bool_binop_done:;

  /* "validator.pyx":5031
 *             isf=False
 * 
 *     elif ( to_frame             # <<<<<<<<<<<<<<
 *           and columns is not None
 *           ):
 */
  if (__pyx_t_4) {

    /* "validator.pyx":5034
 *           and columns is not None
 *           ):
 *         isf =True             # <<<<<<<<<<<<<<
 * 
 *     X, _= convert_array_to_pandas(
 */
    __Pyx_INCREF(Py_True);
    __Pyx_DECREF_SET(__pyx_v_isf, Py_True);

    /* "validator.pyx":5031
 *             isf=False
 * 
 *     elif ( to_frame             # <<<<<<<<<<<<<<
 *           and columns is not None
 *           ):
 */
  }
  __pyx_L3:;

  /* "validator.pyx":5036
 *         isf =True
 * 
 *     X, _= convert_array_to_pandas(             # <<<<<<<<<<<<<<
 *         X,
 *         to_frame=isf,
 */
  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_convert_array_to_pandas); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5036, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);

  /* "validator.pyx":5037
 * 
 *     X, _= convert_array_to_pandas(
 *         X,             # <<<<<<<<<<<<<<
 *         to_frame=isf,
 *         columns =columns,
 */
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5036, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_X);
  __Pyx_GIVEREF(__pyx_v_X);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_X);

  /* "validator.pyx":5038
 *     X, _= convert_array_to_pandas(
 *         X,
 *         to_frame=isf,             # <<<<<<<<<<<<<<
 *         columns =columns,
 *         input_name=input_name
 */
  __pyx_t_1 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5038, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_to_frame, __pyx_v_isf) < 0) __PYX_ERR(0, 5038, __pyx_L1_error)

  /* "validator.pyx":5039
 *         X,
 *         to_frame=isf,
 *         columns =columns,             # <<<<<<<<<<<<<<
 *         input_name=input_name
 *         )
 */
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_columns, __pyx_v_columns) < 0) __PYX_ERR(0, 5038, __pyx_L1_error)

  /* "validator.pyx":5040
 *         to_frame=isf,
 *         columns =columns,
 *         input_name=input_name             # <<<<<<<<<<<<<<
 *         )
 * 
 */
  if (PyDict_SetItem(__pyx_t_1, __pyx_n_s_input_name, __pyx_v_input_name) < 0) __PYX_ERR(0, 5038, __pyx_L1_error)

  /* "validator.pyx":5036
 *         isf =True
 * 
 *     X, _= convert_array_to_pandas(             # <<<<<<<<<<<<<<
 *         X,
 *         to_frame=isf,
 */
  __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_2, __pyx_t_1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 5036, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_9);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if ((likely(PyTuple_CheckExact(__pyx_t_9))) || (PyList_CheckExact(__pyx_t_9))) {
    PyObject* sequence = __pyx_t_9;
    Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
    if (unlikely(size != 2)) {
      if (size > 2) __Pyx_RaiseTooManyValuesError(2);
      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
      __PYX_ERR(0, 5036, __pyx_L1_error)
    }
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    if (likely(PyTuple_CheckExact(sequence))) {
      __pyx_t_1 = PyTuple_GET_ITEM(sequence, 0); 
      __pyx_t_2 = PyTuple_GET_ITEM(sequence, 1); 
    } else {
      __pyx_t_1 = PyList_GET_ITEM(sequence, 0); 
      __pyx_t_2 = PyList_GET_ITEM(sequence, 1); 
    }
    __Pyx_INCREF(__pyx_t_1);
    __Pyx_INCREF(__pyx_t_2);
    #else
    __pyx_t_1 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5036, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5036, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    #endif
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
  } else {
    Py_ssize_t index = -1;
    __pyx_t_3 = PyObject_GetIter(__pyx_t_9); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5036, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_t_11 = Py_TYPE(__pyx_t_3)->tp_iternext;
    index = 0; __pyx_t_1 = __pyx_t_11(__pyx_t_3); if (unlikely(!__pyx_t_1)) goto __pyx_L23_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_1);
    index = 1; __pyx_t_2 = __pyx_t_11(__pyx_t_3); if (unlikely(!__pyx_t_2)) goto __pyx_L23_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_2);
    if (__Pyx_IternextUnpackEndCheck(__pyx_t_11(__pyx_t_3), 2) < 0) __PYX_ERR(0, 5036, __pyx_L1_error)
    __pyx_t_11 = NULL;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    goto __pyx_L24_unpacking_done;
    __pyx_L23_unpacking_failed:;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_11 = NULL;
    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
    __PYX_ERR(0, 5036, __pyx_L1_error)
    __pyx_L24_unpacking_done:;
  }
  __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_v__ = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "validator.pyx":5043
 *         )
 * 
 *     return X             # <<<<<<<<<<<<<<
 * 
 * def _check_y_1d(y, *, warn=False, input_name ='y'):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_X);
  __pyx_r = __pyx_v_X;
  goto __pyx_L0;

  /* "validator.pyx":4956
 *     return X
 * 
 * def array_to_frame2(             # <<<<<<<<<<<<<<
 *     X,
 *     *,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("validator.array_to_frame2", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_isf);
  __Pyx_XDECREF(__pyx_v_msg);
  __Pyx_XDECREF(__pyx_v__);
  __Pyx_XDECREF(__pyx_9genexpr31__pyx_v_i);
  __Pyx_XDECREF(__pyx_v_X);
  __Pyx_XDECREF(__pyx_v_columns);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":5045
 *     return X
 * 
 * def _check_y_1d(y, *, warn=False, input_name ='y'):             # <<<<<<<<<<<<<<
 *     """Ravel column or 1d numpy array, else raises an error.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_163_check_y_1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_162_check_y_1d[] = "Ravel column or 1d numpy array, else raises an error.\n    \n    and Isolated part of check_X_y dedicated to y validation.\n    \n    Parameters\n    ----------\n    y : array-like\n       Input data.\n    warn : bool, default=False\n       To control display of warnings.\n    Returns\n    -------\n    y : ndarray\n       Output data.\n    Raises\n    ------\n    ValueError\n        If `y` is not a 1D array or a 2D array with a single row or column.\n    ";
static PyMethodDef __pyx_mdef_9validator_163_check_y_1d = {"_check_y_1d", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_163_check_y_1d, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_162_check_y_1d};
static PyObject *__pyx_pw_9validator_163_check_y_1d(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_y = 0;
  PyObject *__pyx_v_warn = 0;
  PyObject *__pyx_v_input_name = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_check_y_1d (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_y,&__pyx_n_s_warn,&__pyx_n_s_input_name,0};
    PyObject* values[3] = {0,0,0};
    values[1] = ((PyObject *)Py_False);
    values[2] = ((PyObject *)__pyx_n_u_y);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_y)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (kw_args > 0 && likely(kw_args <= 2)) {
        Py_ssize_t index;
        for (index = 1; index < 3 && kw_args > 0; index++) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
          if (value) { values[index] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_check_y_1d") < 0)) __PYX_ERR(0, 5045, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_y = values[0];
    __pyx_v_warn = values[1];
    __pyx_v_input_name = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_check_y_1d", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 5045, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator._check_y_1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_162_check_y_1d(__pyx_self, __pyx_v_y, __pyx_v_warn, __pyx_v_input_name);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_162_check_y_1d(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_y, PyObject *__pyx_v_warn, PyObject *__pyx_v_input_name) {
  PyObject *__pyx_v_xp = NULL;
  CYTHON_UNUSED PyObject *__pyx_v__ = NULL;
  PyObject *__pyx_v_shape = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *(*__pyx_t_5)(PyObject *);
  Py_ssize_t __pyx_t_6;
  int __pyx_t_7;
  int __pyx_t_8;
  PyObject *__pyx_t_9 = NULL;
  int __pyx_t_10;
  Py_UCS4 __pyx_t_11;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_check_y_1d", 0);
  __Pyx_INCREF(__pyx_v_y);

  /* "validator.pyx":5065
 *         If `y` is not a 1D array or a 2D array with a single row or column.
 *     """
 *     xp, _ = get_namespace(y)             # <<<<<<<<<<<<<<
 *     y = xp.asarray(y)
 *     shape = y.shape
 */
  __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_get_namespace); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5065, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_3, __pyx_v_y) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_y);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5065, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
    PyObject* sequence = __pyx_t_1;
    Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
    if (unlikely(size != 2)) {
      if (size > 2) __Pyx_RaiseTooManyValuesError(2);
      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
      __PYX_ERR(0, 5065, __pyx_L1_error)
    }
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    if (likely(PyTuple_CheckExact(sequence))) {
      __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 1); 
    } else {
      __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
      __pyx_t_3 = PyList_GET_ITEM(sequence, 1); 
    }
    __Pyx_INCREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_t_3);
    #else
    __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5065, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5065, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    #endif
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  } else {
    Py_ssize_t index = -1;
    __pyx_t_4 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5065, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_5 = Py_TYPE(__pyx_t_4)->tp_iternext;
    index = 0; __pyx_t_2 = __pyx_t_5(__pyx_t_4); if (unlikely(!__pyx_t_2)) goto __pyx_L3_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_2);
    index = 1; __pyx_t_3 = __pyx_t_5(__pyx_t_4); if (unlikely(!__pyx_t_3)) goto __pyx_L3_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_3);
    if (__Pyx_IternextUnpackEndCheck(__pyx_t_5(__pyx_t_4), 2) < 0) __PYX_ERR(0, 5065, __pyx_L1_error)
    __pyx_t_5 = NULL;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    goto __pyx_L4_unpacking_done;
    __pyx_L3_unpacking_failed:;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_5 = NULL;
    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
    __PYX_ERR(0, 5065, __pyx_L1_error)
    __pyx_L4_unpacking_done:;
  }
  __pyx_v_xp = __pyx_t_2;
  __pyx_t_2 = 0;
  __pyx_v__ = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "validator.pyx":5066
 *     """
 *     xp, _ = get_namespace(y)
 *     y = xp.asarray(y)             # <<<<<<<<<<<<<<
 *     shape = y.shape
 *     if len(shape) == 1:
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_xp, __pyx_n_s_asarray); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5066, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_1 = (__pyx_t_2) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_2, __pyx_v_y) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_y);
  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5066, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF_SET(__pyx_v_y, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "validator.pyx":5067
 *     xp, _ = get_namespace(y)
 *     y = xp.asarray(y)
 *     shape = y.shape             # <<<<<<<<<<<<<<
 *     if len(shape) == 1:
 *         return _asarray_with_order(xp.reshape(y, -1), order="C", xp=xp)
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_y, __pyx_n_s_shape); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5067, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_shape = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "validator.pyx":5068
 *     y = xp.asarray(y)
 *     shape = y.shape
 *     if len(shape) == 1:             # <<<<<<<<<<<<<<
 *         return _asarray_with_order(xp.reshape(y, -1), order="C", xp=xp)
 *     if len(shape) == 2 and shape[1] == 1:
 */
  __pyx_t_6 = PyObject_Length(__pyx_v_shape); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 5068, __pyx_L1_error)
  __pyx_t_7 = ((__pyx_t_6 == 1) != 0);
  if (__pyx_t_7) {

    /* "validator.pyx":5069
 *     shape = y.shape
 *     if len(shape) == 1:
 *         return _asarray_with_order(xp.reshape(y, -1), order="C", xp=xp)             # <<<<<<<<<<<<<<
 *     if len(shape) == 2 and shape[1] == 1:
 *         if warn:
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_asarray_with_order); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5069, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_xp, __pyx_n_s_reshape); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5069, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = NULL;
    __pyx_t_8 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
        __pyx_t_8 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_y, __pyx_int_neg_1};
      __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5069, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_3);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[3] = {__pyx_t_4, __pyx_v_y, __pyx_int_neg_1};
      __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5069, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_3);
    } else
    #endif
    {
      __pyx_t_9 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 5069, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      if (__pyx_t_4) {
        __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_4); __pyx_t_4 = NULL;
      }
      __Pyx_INCREF(__pyx_v_y);
      __Pyx_GIVEREF(__pyx_v_y);
      PyTuple_SET_ITEM(__pyx_t_9, 0+__pyx_t_8, __pyx_v_y);
      __Pyx_INCREF(__pyx_int_neg_1);
      __Pyx_GIVEREF(__pyx_int_neg_1);
      PyTuple_SET_ITEM(__pyx_t_9, 1+__pyx_t_8, __pyx_int_neg_1);
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_9, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5069, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5069, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5069, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_order, __pyx_n_u_C) < 0) __PYX_ERR(0, 5069, __pyx_L1_error)
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_xp, __pyx_v_xp) < 0) __PYX_ERR(0, 5069, __pyx_L1_error)
    __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 5069, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_r = __pyx_t_9;
    __pyx_t_9 = 0;
    goto __pyx_L0;

    /* "validator.pyx":5068
 *     y = xp.asarray(y)
 *     shape = y.shape
 *     if len(shape) == 1:             # <<<<<<<<<<<<<<
 *         return _asarray_with_order(xp.reshape(y, -1), order="C", xp=xp)
 *     if len(shape) == 2 and shape[1] == 1:
 */
  }

  /* "validator.pyx":5070
 *     if len(shape) == 1:
 *         return _asarray_with_order(xp.reshape(y, -1), order="C", xp=xp)
 *     if len(shape) == 2 and shape[1] == 1:             # <<<<<<<<<<<<<<
 *         if warn:
 *             warnings.warn(
 */
  __pyx_t_6 = PyObject_Length(__pyx_v_shape); if (unlikely(__pyx_t_6 == ((Py_ssize_t)-1))) __PYX_ERR(0, 5070, __pyx_L1_error)
  __pyx_t_10 = ((__pyx_t_6 == 2) != 0);
  if (__pyx_t_10) {
  } else {
    __pyx_t_7 = __pyx_t_10;
    goto __pyx_L7_bool_binop_done;
  }
  __pyx_t_9 = __Pyx_GetItemInt(__pyx_v_shape, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 5070, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_9);
  __pyx_t_3 = __Pyx_PyInt_EqObjC(__pyx_t_9, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5070, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
  __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 5070, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_7 = __pyx_t_10;
  __pyx_L7_bool_binop_done:;
  if (__pyx_t_7) {

    /* "validator.pyx":5071
 *         return _asarray_with_order(xp.reshape(y, -1), order="C", xp=xp)
 *     if len(shape) == 2 and shape[1] == 1:
 *         if warn:             # <<<<<<<<<<<<<<
 *             warnings.warn(
 *                 "A column-vector y was passed when a 1d array was"
 */
    __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_warn); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 5071, __pyx_L1_error)
    if (__pyx_t_7) {

      /* "validator.pyx":5072
 *     if len(shape) == 2 and shape[1] == 1:
 *         if warn:
 *             warnings.warn(             # <<<<<<<<<<<<<<
 *                 "A column-vector y was passed when a 1d array was"
 *                 " expected. Please change the shape of y to "
 */
      __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_warnings); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5072, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_warn); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 5072, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

      /* "validator.pyx":5076
 *                 " expected. Please change the shape of y to "
 *                 "(n_samples, ), for example using ravel().",
 *                 DataConversionWarning,             # <<<<<<<<<<<<<<
 *                 stacklevel=2,
 *             )
 */
      __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_DataConversionWarning); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5076, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);

      /* "validator.pyx":5072
 *     if len(shape) == 2 and shape[1] == 1:
 *         if warn:
 *             warnings.warn(             # <<<<<<<<<<<<<<
 *                 "A column-vector y was passed when a 1d array was"
 *                 " expected. Please change the shape of y to "
 */
      __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5072, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_INCREF(__pyx_kp_u_A_column_vector_y_was_passed_whe);
      __Pyx_GIVEREF(__pyx_kp_u_A_column_vector_y_was_passed_whe);
      PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_kp_u_A_column_vector_y_was_passed_whe);
      __Pyx_GIVEREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_3);
      __pyx_t_3 = 0;

      /* "validator.pyx":5077
 *                 "(n_samples, ), for example using ravel().",
 *                 DataConversionWarning,
 *                 stacklevel=2,             # <<<<<<<<<<<<<<
 *             )
 *         return _asarray_with_order(xp.reshape(y, -1), order="C", xp=xp)
 */
      __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5077, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_stacklevel, __pyx_int_2) < 0) __PYX_ERR(0, 5077, __pyx_L1_error)

      /* "validator.pyx":5072
 *     if len(shape) == 2 and shape[1] == 1:
 *         if warn:
 *             warnings.warn(             # <<<<<<<<<<<<<<
 *                 "A column-vector y was passed when a 1d array was"
 *                 " expected. Please change the shape of y to "
 */
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_9, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5072, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "validator.pyx":5071
 *         return _asarray_with_order(xp.reshape(y, -1), order="C", xp=xp)
 *     if len(shape) == 2 and shape[1] == 1:
 *         if warn:             # <<<<<<<<<<<<<<
 *             warnings.warn(
 *                 "A column-vector y was passed when a 1d array was"
 */
    }

    /* "validator.pyx":5079
 *                 stacklevel=2,
 *             )
 *         return _asarray_with_order(xp.reshape(y, -1), order="C", xp=xp)             # <<<<<<<<<<<<<<
 * 
 *     raise ValueError(f"{input_name} should be a 1d array, got"
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_asarray_with_order); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5079, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_xp, __pyx_n_s_reshape); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5079, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_9 = NULL;
    __pyx_t_8 = 0;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_9)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_9);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
        __pyx_t_8 = 1;
      }
    }
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[3] = {__pyx_t_9, __pyx_v_y, __pyx_int_neg_1};
      __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5079, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_GOTREF(__pyx_t_3);
    } else
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(__pyx_t_2)) {
      PyObject *__pyx_temp[3] = {__pyx_t_9, __pyx_v_y, __pyx_int_neg_1};
      __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_2, __pyx_temp+1-__pyx_t_8, 2+__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5079, __pyx_L1_error)
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;
      __Pyx_GOTREF(__pyx_t_3);
    } else
    #endif
    {
      __pyx_t_4 = PyTuple_New(2+__pyx_t_8); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5079, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      if (__pyx_t_9) {
        __Pyx_GIVEREF(__pyx_t_9); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_9); __pyx_t_9 = NULL;
      }
      __Pyx_INCREF(__pyx_v_y);
      __Pyx_GIVEREF(__pyx_v_y);
      PyTuple_SET_ITEM(__pyx_t_4, 0+__pyx_t_8, __pyx_v_y);
      __Pyx_INCREF(__pyx_int_neg_1);
      __Pyx_GIVEREF(__pyx_int_neg_1);
      PyTuple_SET_ITEM(__pyx_t_4, 1+__pyx_t_8, __pyx_int_neg_1);
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5079, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5079, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyDict_NewPresized(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5079, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_order, __pyx_n_u_C) < 0) __PYX_ERR(0, 5079, __pyx_L1_error)
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_xp, __pyx_v_xp) < 0) __PYX_ERR(0, 5079, __pyx_L1_error)
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5079, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;

    /* "validator.pyx":5070
 *     if len(shape) == 1:
 *         return _asarray_with_order(xp.reshape(y, -1), order="C", xp=xp)
 *     if len(shape) == 2 and shape[1] == 1:             # <<<<<<<<<<<<<<
 *         if warn:
 *             warnings.warn(
 */
  }

  /* "validator.pyx":5081
 *         return _asarray_with_order(xp.reshape(y, -1), order="C", xp=xp)
 * 
 *     raise ValueError(f"{input_name} should be a 1d array, got"             # <<<<<<<<<<<<<<
 *                      f" an array of shape {shape} instead.")
 * 
 */
  __pyx_t_4 = PyTuple_New(4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5081, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_6 = 0;
  __pyx_t_11 = 127;
  __pyx_t_3 = __Pyx_PyObject_FormatSimple(__pyx_v_input_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5081, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_11 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) > __pyx_t_11) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) : __pyx_t_11;
  __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
  __pyx_t_3 = 0;
  __Pyx_INCREF(__pyx_kp_u_should_be_a_1d_array_got_an_arr);
  __pyx_t_6 += 45;
  __Pyx_GIVEREF(__pyx_kp_u_should_be_a_1d_array_got_an_arr);
  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_kp_u_should_be_a_1d_array_got_an_arr);

  /* "validator.pyx":5082
 * 
 *     raise ValueError(f"{input_name} should be a 1d array, got"
 *                      f" an array of shape {shape} instead.")             # <<<<<<<<<<<<<<
 * 
 * def _check_large_sparse(X, accept_large_sparse=False):
 */
  __pyx_t_3 = __Pyx_PyObject_FormatSimple(__pyx_v_shape, __pyx_empty_unicode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5082, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_11 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) > __pyx_t_11) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_3) : __pyx_t_11;
  __pyx_t_6 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_3);
  __pyx_t_3 = 0;
  __Pyx_INCREF(__pyx_kp_u_instead);
  __pyx_t_6 += 9;
  __Pyx_GIVEREF(__pyx_kp_u_instead);
  PyTuple_SET_ITEM(__pyx_t_4, 3, __pyx_kp_u_instead);

  /* "validator.pyx":5081
 *         return _asarray_with_order(xp.reshape(y, -1), order="C", xp=xp)
 * 
 *     raise ValueError(f"{input_name} should be a 1d array, got"             # <<<<<<<<<<<<<<
 *                      f" an array of shape {shape} instead.")
 * 
 */
  __pyx_t_3 = __Pyx_PyUnicode_Join(__pyx_t_4, 4, __pyx_t_6, __pyx_t_11); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5081, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5081, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_Raise(__pyx_t_4, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __PYX_ERR(0, 5081, __pyx_L1_error)

  /* "validator.pyx":5045
 *     return X
 * 
 * def _check_y_1d(y, *, warn=False, input_name ='y'):             # <<<<<<<<<<<<<<
 *     """Ravel column or 1d numpy array, else raises an error.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("validator._check_y_1d", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_xp);
  __Pyx_XDECREF(__pyx_v__);
  __Pyx_XDECREF(__pyx_v_shape);
  __Pyx_XDECREF(__pyx_v_y);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":5084
 *                      f" an array of shape {shape} instead.")
 * 
 * def _check_large_sparse(X, accept_large_sparse=False):             # <<<<<<<<<<<<<<
 *     """Raise a ValueError if X has 64bit indices and accept_large_sparse=False"""
 *     if not accept_large_sparse:
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_165_check_large_sparse(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_164_check_large_sparse[] = "Raise a ValueError if X has 64bit indices and accept_large_sparse=False";
static PyMethodDef __pyx_mdef_9validator_165_check_large_sparse = {"_check_large_sparse", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_165_check_large_sparse, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_164_check_large_sparse};
static PyObject *__pyx_pw_9validator_165_check_large_sparse(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_X = 0;
  PyObject *__pyx_v_accept_large_sparse = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_check_large_sparse (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_X,&__pyx_n_s_accept_large_sparse,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_X)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_accept_large_sparse);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_check_large_sparse") < 0)) __PYX_ERR(0, 5084, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_X = values[0];
    __pyx_v_accept_large_sparse = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_check_large_sparse", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 5084, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator._check_large_sparse", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_164_check_large_sparse(__pyx_self, __pyx_v_X, __pyx_v_accept_large_sparse);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_164_check_large_sparse(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X, PyObject *__pyx_v_accept_large_sparse) {
  PyObject *__pyx_v_supported_indices = NULL;
  PyObject *__pyx_v_index_keys = NULL;
  PyObject *__pyx_v_key = NULL;
  PyObject *__pyx_v_indices_datatype = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  Py_ssize_t __pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_check_large_sparse", 0);

  /* "validator.pyx":5086
 * def _check_large_sparse(X, accept_large_sparse=False):
 *     """Raise a ValueError if X has 64bit indices and accept_large_sparse=False"""
 *     if not accept_large_sparse:             # <<<<<<<<<<<<<<
 *         supported_indices = ["int32"]
 *         if X.getformat() == "coo":
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_accept_large_sparse); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 5086, __pyx_L1_error)
  __pyx_t_2 = ((!__pyx_t_1) != 0);
  if (__pyx_t_2) {

    /* "validator.pyx":5087
 *     """Raise a ValueError if X has 64bit indices and accept_large_sparse=False"""
 *     if not accept_large_sparse:
 *         supported_indices = ["int32"]             # <<<<<<<<<<<<<<
 *         if X.getformat() == "coo":
 *             index_keys = ["col", "row"]
 */
    __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5087, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_n_u_int32);
    __Pyx_GIVEREF(__pyx_n_u_int32);
    PyList_SET_ITEM(__pyx_t_3, 0, __pyx_n_u_int32);
    __pyx_v_supported_indices = ((PyObject*)__pyx_t_3);
    __pyx_t_3 = 0;

    /* "validator.pyx":5088
 *     if not accept_large_sparse:
 *         supported_indices = ["int32"]
 *         if X.getformat() == "coo":             # <<<<<<<<<<<<<<
 *             index_keys = ["col", "row"]
 *         elif X.getformat() in ["csr", "csc", "bsr"]:
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_getformat); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5088, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5088, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_2 = (__Pyx_PyUnicode_Equals(__pyx_t_3, __pyx_n_u_coo, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 5088, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (__pyx_t_2) {

      /* "validator.pyx":5089
 *         supported_indices = ["int32"]
 *         if X.getformat() == "coo":
 *             index_keys = ["col", "row"]             # <<<<<<<<<<<<<<
 *         elif X.getformat() in ["csr", "csc", "bsr"]:
 *             index_keys = ["indices", "indptr"]
 */
      __pyx_t_3 = PyList_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5089, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_INCREF(__pyx_n_u_col);
      __Pyx_GIVEREF(__pyx_n_u_col);
      PyList_SET_ITEM(__pyx_t_3, 0, __pyx_n_u_col);
      __Pyx_INCREF(__pyx_n_u_row);
      __Pyx_GIVEREF(__pyx_n_u_row);
      PyList_SET_ITEM(__pyx_t_3, 1, __pyx_n_u_row);
      __pyx_v_index_keys = ((PyObject*)__pyx_t_3);
      __pyx_t_3 = 0;

      /* "validator.pyx":5088
 *     if not accept_large_sparse:
 *         supported_indices = ["int32"]
 *         if X.getformat() == "coo":             # <<<<<<<<<<<<<<
 *             index_keys = ["col", "row"]
 *         elif X.getformat() in ["csr", "csc", "bsr"]:
 */
      goto __pyx_L4;
    }

    /* "validator.pyx":5090
 *         if X.getformat() == "coo":
 *             index_keys = ["col", "row"]
 *         elif X.getformat() in ["csr", "csc", "bsr"]:             # <<<<<<<<<<<<<<
 *             index_keys = ["indices", "indptr"]
 *         else:
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_getformat); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5090, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5090, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_t_3, __pyx_n_u_csr, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 5090, __pyx_L1_error)
    if (!__pyx_t_1) {
    } else {
      __pyx_t_2 = __pyx_t_1;
      goto __pyx_L5_bool_binop_done;
    }
    __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_t_3, __pyx_n_u_csc, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 5090, __pyx_L1_error)
    if (!__pyx_t_1) {
    } else {
      __pyx_t_2 = __pyx_t_1;
      goto __pyx_L5_bool_binop_done;
    }
    __pyx_t_1 = (__Pyx_PyUnicode_Equals(__pyx_t_3, __pyx_n_u_bsr, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 5090, __pyx_L1_error)
    __pyx_t_2 = __pyx_t_1;
    __pyx_L5_bool_binop_done:;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_1 = (__pyx_t_2 != 0);
    if (__pyx_t_1) {

      /* "validator.pyx":5091
 *             index_keys = ["col", "row"]
 *         elif X.getformat() in ["csr", "csc", "bsr"]:
 *             index_keys = ["indices", "indptr"]             # <<<<<<<<<<<<<<
 *         else:
 *             return
 */
      __pyx_t_3 = PyList_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5091, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_INCREF(__pyx_n_u_indices);
      __Pyx_GIVEREF(__pyx_n_u_indices);
      PyList_SET_ITEM(__pyx_t_3, 0, __pyx_n_u_indices);
      __Pyx_INCREF(__pyx_n_u_indptr);
      __Pyx_GIVEREF(__pyx_n_u_indptr);
      PyList_SET_ITEM(__pyx_t_3, 1, __pyx_n_u_indptr);
      __pyx_v_index_keys = ((PyObject*)__pyx_t_3);
      __pyx_t_3 = 0;

      /* "validator.pyx":5090
 *         if X.getformat() == "coo":
 *             index_keys = ["col", "row"]
 *         elif X.getformat() in ["csr", "csc", "bsr"]:             # <<<<<<<<<<<<<<
 *             index_keys = ["indices", "indptr"]
 *         else:
 */
      goto __pyx_L4;
    }

    /* "validator.pyx":5093
 *             index_keys = ["indices", "indptr"]
 *         else:
 *             return             # <<<<<<<<<<<<<<
 *         for key in index_keys:
 *             indices_datatype = getattr(X, key).dtype
 */
    /*else*/ {
      __Pyx_XDECREF(__pyx_r);
      __pyx_r = Py_None; __Pyx_INCREF(Py_None);
      goto __pyx_L0;
    }
    __pyx_L4:;

    /* "validator.pyx":5094
 *         else:
 *             return
 *         for key in index_keys:             # <<<<<<<<<<<<<<
 *             indices_datatype = getattr(X, key).dtype
 *             if indices_datatype not in supported_indices:
 */
    __pyx_t_3 = __pyx_v_index_keys; __Pyx_INCREF(__pyx_t_3); __pyx_t_6 = 0;
    for (;;) {
      if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_3)) break;
      #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
      __pyx_t_4 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_6); __Pyx_INCREF(__pyx_t_4); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 5094, __pyx_L1_error)
      #else
      __pyx_t_4 = PySequence_ITEM(__pyx_t_3, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5094, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      #endif
      __Pyx_XDECREF_SET(__pyx_v_key, __pyx_t_4);
      __pyx_t_4 = 0;

      /* "validator.pyx":5095
 *             return
 *         for key in index_keys:
 *             indices_datatype = getattr(X, key).dtype             # <<<<<<<<<<<<<<
 *             if indices_datatype not in supported_indices:
 *                 raise ValueError(
 */
      __pyx_t_4 = __Pyx_GetAttr(__pyx_v_X, __pyx_v_key); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5095, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_dtype); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 5095, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF_SET(__pyx_v_indices_datatype, __pyx_t_5);
      __pyx_t_5 = 0;

      /* "validator.pyx":5096
 *         for key in index_keys:
 *             indices_datatype = getattr(X, key).dtype
 *             if indices_datatype not in supported_indices:             # <<<<<<<<<<<<<<
 *                 raise ValueError(
 *                     "Only sparse matrices with 32-bit integer"
 */
      __pyx_t_1 = (__Pyx_PySequence_ContainsTF(__pyx_v_indices_datatype, __pyx_v_supported_indices, Py_NE)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 5096, __pyx_L1_error)
      __pyx_t_2 = (__pyx_t_1 != 0);
      if (unlikely(__pyx_t_2)) {

        /* "validator.pyx":5099
 *                 raise ValueError(
 *                     "Only sparse matrices with 32-bit integer"
 *                     " indices are accepted. Got %s indices." % indices_datatype             # <<<<<<<<<<<<<<
 *                 )
 * def _ensure_sparse_format(
 */
        __pyx_t_5 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_Only_sparse_matrices_with_32_bit, __pyx_v_indices_datatype); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 5099, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);

        /* "validator.pyx":5097
 *             indices_datatype = getattr(X, key).dtype
 *             if indices_datatype not in supported_indices:
 *                 raise ValueError(             # <<<<<<<<<<<<<<
 *                     "Only sparse matrices with 32-bit integer"
 *                     " indices are accepted. Got %s indices." % indices_datatype
 */
        __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5097, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __Pyx_Raise(__pyx_t_4, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __PYX_ERR(0, 5097, __pyx_L1_error)

        /* "validator.pyx":5096
 *         for key in index_keys:
 *             indices_datatype = getattr(X, key).dtype
 *             if indices_datatype not in supported_indices:             # <<<<<<<<<<<<<<
 *                 raise ValueError(
 *                     "Only sparse matrices with 32-bit integer"
 */
      }

      /* "validator.pyx":5094
 *         else:
 *             return
 *         for key in index_keys:             # <<<<<<<<<<<<<<
 *             indices_datatype = getattr(X, key).dtype
 *             if indices_datatype not in supported_indices:
 */
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "validator.pyx":5086
 * def _check_large_sparse(X, accept_large_sparse=False):
 *     """Raise a ValueError if X has 64bit indices and accept_large_sparse=False"""
 *     if not accept_large_sparse:             # <<<<<<<<<<<<<<
 *         supported_indices = ["int32"]
 *         if X.getformat() == "coo":
 */
  }

  /* "validator.pyx":5084
 *                      f" an array of shape {shape} instead.")
 * 
 * def _check_large_sparse(X, accept_large_sparse=False):             # <<<<<<<<<<<<<<
 *     """Raise a ValueError if X has 64bit indices and accept_large_sparse=False"""
 *     if not accept_large_sparse:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("validator._check_large_sparse", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_supported_indices);
  __Pyx_XDECREF(__pyx_v_index_keys);
  __Pyx_XDECREF(__pyx_v_key);
  __Pyx_XDECREF(__pyx_v_indices_datatype);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":5101
 *                     " indices are accepted. Got %s indices." % indices_datatype
 *                 )
 * def _ensure_sparse_format(             # <<<<<<<<<<<<<<
 *     spmatrix,
 *     accept_sparse,
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_167_ensure_sparse_format(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_166_ensure_sparse_format[] = "Convert a sparse matrix to a given format.\n    Checks the sparse format of spmatrix and converts if necessary.\n    Parameters\n    ----------\n    spmatrix : sparse matrix\n        Input to validate and convert.\n    accept_sparse : str, bool or list/tuple of str\n        String[s] representing allowed sparse matrix formats ('csc',\n        'csr', 'coo', 'dok', 'bsr', 'lil', 'dia'). If the input is sparse but\n        not in the allowed format, it will be converted to the first listed\n        format. True allows the input to be any format. False means\n        that a sparse matrix input will raise an error.\n    dtype : str, type or None\n        Data type of result. If None, the dtype of the input is preserved.\n    copy : bool\n        Whether a forced copy will be triggered. If copy=False, a copy might\n        be triggered by a conversion.\n    force_all_finite : bool or 'allow-nan'\n        Whether to raise an error on np.inf, np.nan, pd.NA in X. The\n        possibilities are:\n        - True: Force all values of X to be finite.\n        - False: accepts np.inf, np.nan, pd.NA in X.\n        - 'allow-nan': accepts only np.nan and pd.NA values in X. Values cannot\n          be infinite.\n        .. versionadded:: 0.20\n           ``force_all_finite`` accepts the string ``'allow-nan'``.\n        .. versionchanged:: 0.23\n           Accepts `pd.NA` and converts it into `np.nan`\n    estimator_name : str, default=None\n        The estimator name, used to construct the error message.\n    input_name : str, default=\"\"\n        The data name used to construct the error message. In particular\n        if `input_name` is \"X\" and the data has NaN values and\n        allow_nan is False, the error message will link to the imputer\n        documentation.\n    Returns\n    -------\n    spmatrix_converted : sparse matrix.\n        Matrix that is ensured to have an allowed type.\n    ";
static PyMethodDef __pyx_mdef_9validator_167_ensure_sparse_format = {"_ensure_sparse_format", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_167_ensure_sparse_format, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_166_ensure_sparse_format};
static PyObject *__pyx_pw_9validator_167_ensure_sparse_format(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_spmatrix = 0;
  PyObject *__pyx_v_accept_sparse = 0;
  PyObject *__pyx_v_dtype = 0;
  PyObject *__pyx_v_copy = 0;
  PyObject *__pyx_v_force_all_finite = 0;
  PyObject *__pyx_v_accept_large_sparse = 0;
  PyObject *__pyx_v_estimator_name = 0;
  PyObject *__pyx_v_input_name = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_ensure_sparse_format (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_spmatrix,&__pyx_n_s_accept_sparse,&__pyx_n_s_dtype,&__pyx_n_s_copy,&__pyx_n_s_force_all_finite,&__pyx_n_s_accept_large_sparse,&__pyx_n_s_estimator_name,&__pyx_n_s_input_name,0};
    PyObject* values[8] = {0,0,0,0,0,0,0,0};

    /* "validator.pyx":5108
 *     force_all_finite,
 *     accept_large_sparse,
 *     estimator_name=None,             # <<<<<<<<<<<<<<
 *     input_name="",
 * ):
 */
    values[6] = ((PyObject *)Py_None);
    values[7] = ((PyObject *)__pyx_kp_u__7);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        CYTHON_FALLTHROUGH;
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_spmatrix)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_accept_sparse)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_ensure_sparse_format", 0, 6, 8, 1); __PYX_ERR(0, 5101, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_dtype)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_ensure_sparse_format", 0, 6, 8, 2); __PYX_ERR(0, 5101, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_copy)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_ensure_sparse_format", 0, 6, 8, 3); __PYX_ERR(0, 5101, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (likely((values[4] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_force_all_finite)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_ensure_sparse_format", 0, 6, 8, 4); __PYX_ERR(0, 5101, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  5:
        if (likely((values[5] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_accept_large_sparse)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_ensure_sparse_format", 0, 6, 8, 5); __PYX_ERR(0, 5101, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  6:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_estimator_name);
          if (value) { values[6] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  7:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_input_name);
          if (value) { values[7] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_ensure_sparse_format") < 0)) __PYX_ERR(0, 5101, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        CYTHON_FALLTHROUGH;
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        CYTHON_FALLTHROUGH;
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_spmatrix = values[0];
    __pyx_v_accept_sparse = values[1];
    __pyx_v_dtype = values[2];
    __pyx_v_copy = values[3];
    __pyx_v_force_all_finite = values[4];
    __pyx_v_accept_large_sparse = values[5];
    __pyx_v_estimator_name = values[6];
    __pyx_v_input_name = values[7];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_ensure_sparse_format", 0, 6, 8, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 5101, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator._ensure_sparse_format", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_166_ensure_sparse_format(__pyx_self, __pyx_v_spmatrix, __pyx_v_accept_sparse, __pyx_v_dtype, __pyx_v_copy, __pyx_v_force_all_finite, __pyx_v_accept_large_sparse, __pyx_v_estimator_name, __pyx_v_input_name);

  /* "validator.pyx":5101
 *                     " indices are accepted. Got %s indices." % indices_datatype
 *                 )
 * def _ensure_sparse_format(             # <<<<<<<<<<<<<<
 *     spmatrix,
 *     accept_sparse,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_166_ensure_sparse_format(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_spmatrix, PyObject *__pyx_v_accept_sparse, PyObject *__pyx_v_dtype, PyObject *__pyx_v_copy, PyObject *__pyx_v_force_all_finite, PyObject *__pyx_v_accept_large_sparse, PyObject *__pyx_v_estimator_name, PyObject *__pyx_v_input_name) {
  int __pyx_v_changed_format;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_t_8;
  Py_ssize_t __pyx_t_9;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_ensure_sparse_format", 0);
  __Pyx_INCREF(__pyx_v_spmatrix);
  __Pyx_INCREF(__pyx_v_accept_sparse);
  __Pyx_INCREF(__pyx_v_dtype);

  /* "validator.pyx":5151
 *         Matrix that is ensured to have an allowed type.
 *     """
 *     if dtype is None:             # <<<<<<<<<<<<<<
 *         dtype = spmatrix.dtype
 * 
 */
  __pyx_t_1 = (__pyx_v_dtype == Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "validator.pyx":5152
 *     """
 *     if dtype is None:
 *         dtype = spmatrix.dtype             # <<<<<<<<<<<<<<
 * 
 *     changed_format = False
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_spmatrix, __pyx_n_s_dtype); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5152, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF_SET(__pyx_v_dtype, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "validator.pyx":5151
 *         Matrix that is ensured to have an allowed type.
 *     """
 *     if dtype is None:             # <<<<<<<<<<<<<<
 *         dtype = spmatrix.dtype
 * 
 */
  }

  /* "validator.pyx":5154
 *         dtype = spmatrix.dtype
 * 
 *     changed_format = False             # <<<<<<<<<<<<<<
 * 
 *     if isinstance(accept_sparse, str):
 */
  __pyx_v_changed_format = 0;

  /* "validator.pyx":5156
 *     changed_format = False
 * 
 *     if isinstance(accept_sparse, str):             # <<<<<<<<<<<<<<
 *         accept_sparse = [accept_sparse]
 * 
 */
  __pyx_t_2 = PyUnicode_Check(__pyx_v_accept_sparse); 
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "validator.pyx":5157
 * 
 *     if isinstance(accept_sparse, str):
 *         accept_sparse = [accept_sparse]             # <<<<<<<<<<<<<<
 * 
 *     # Indices dtype validation
 */
    __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5157, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_v_accept_sparse);
    __Pyx_GIVEREF(__pyx_v_accept_sparse);
    PyList_SET_ITEM(__pyx_t_3, 0, __pyx_v_accept_sparse);
    __Pyx_DECREF_SET(__pyx_v_accept_sparse, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "validator.pyx":5156
 *     changed_format = False
 * 
 *     if isinstance(accept_sparse, str):             # <<<<<<<<<<<<<<
 *         accept_sparse = [accept_sparse]
 * 
 */
  }

  /* "validator.pyx":5160
 * 
 *     # Indices dtype validation
 *     _check_large_sparse(spmatrix, accept_large_sparse)             # <<<<<<<<<<<<<<
 * 
 *     if accept_sparse is False:
 */
  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_check_large_sparse); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5160, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = NULL;
  __pyx_t_6 = 0;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
      __pyx_t_6 = 1;
    }
  }
  #if CYTHON_FAST_PYCALL
  if (PyFunction_Check(__pyx_t_4)) {
    PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_spmatrix, __pyx_v_accept_large_sparse};
    __pyx_t_3 = __Pyx_PyFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5160, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_GOTREF(__pyx_t_3);
  } else
  #endif
  #if CYTHON_FAST_PYCCALL
  if (__Pyx_PyFastCFunction_Check(__pyx_t_4)) {
    PyObject *__pyx_temp[3] = {__pyx_t_5, __pyx_v_spmatrix, __pyx_v_accept_large_sparse};
    __pyx_t_3 = __Pyx_PyCFunction_FastCall(__pyx_t_4, __pyx_temp+1-__pyx_t_6, 2+__pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5160, __pyx_L1_error)
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_GOTREF(__pyx_t_3);
  } else
  #endif
  {
    __pyx_t_7 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 5160, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    if (__pyx_t_5) {
      __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_5); __pyx_t_5 = NULL;
    }
    __Pyx_INCREF(__pyx_v_spmatrix);
    __Pyx_GIVEREF(__pyx_v_spmatrix);
    PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_v_spmatrix);
    __Pyx_INCREF(__pyx_v_accept_large_sparse);
    __Pyx_GIVEREF(__pyx_v_accept_large_sparse);
    PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_v_accept_large_sparse);
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_7, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5160, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  }
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "validator.pyx":5162
 *     _check_large_sparse(spmatrix, accept_large_sparse)
 * 
 *     if accept_sparse is False:             # <<<<<<<<<<<<<<
 *         raise TypeError(
 *             "A sparse matrix was passed, but dense "
 */
  __pyx_t_1 = (__pyx_v_accept_sparse == Py_False);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (unlikely(__pyx_t_2)) {

    /* "validator.pyx":5163
 * 
 *     if accept_sparse is False:
 *         raise TypeError(             # <<<<<<<<<<<<<<
 *             "A sparse matrix was passed, but dense "
 *             "data is required. Use X.toarray() to "
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_TypeError, __pyx_tuple__115, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5163, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 5163, __pyx_L1_error)

    /* "validator.pyx":5162
 *     _check_large_sparse(spmatrix, accept_large_sparse)
 * 
 *     if accept_sparse is False:             # <<<<<<<<<<<<<<
 *         raise TypeError(
 *             "A sparse matrix was passed, but dense "
 */
  }

  /* "validator.pyx":5168
 *             "convert to a dense numpy array."
 *         )
 *     elif isinstance(accept_sparse, (list, tuple)):             # <<<<<<<<<<<<<<
 *         if len(accept_sparse) == 0:
 *             raise ValueError(
 */
  __pyx_t_1 = PyList_Check(__pyx_v_accept_sparse); 
  __pyx_t_8 = (__pyx_t_1 != 0);
  if (!__pyx_t_8) {
  } else {
    __pyx_t_2 = __pyx_t_8;
    goto __pyx_L6_bool_binop_done;
  }
  __pyx_t_8 = PyTuple_Check(__pyx_v_accept_sparse); 
  __pyx_t_1 = (__pyx_t_8 != 0);
  __pyx_t_2 = __pyx_t_1;
  __pyx_L6_bool_binop_done:;
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "validator.pyx":5169
 *         )
 *     elif isinstance(accept_sparse, (list, tuple)):
 *         if len(accept_sparse) == 0:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 "When providing 'accept_sparse' "
 */
    __pyx_t_9 = PyObject_Length(__pyx_v_accept_sparse); if (unlikely(__pyx_t_9 == ((Py_ssize_t)-1))) __PYX_ERR(0, 5169, __pyx_L1_error)
    __pyx_t_1 = ((__pyx_t_9 == 0) != 0);
    if (unlikely(__pyx_t_1)) {

      /* "validator.pyx":5170
 *     elif isinstance(accept_sparse, (list, tuple)):
 *         if len(accept_sparse) == 0:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "When providing 'accept_sparse' "
 *                 "as a tuple or list, it must contain at "
 */
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__116, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5170, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __PYX_ERR(0, 5170, __pyx_L1_error)

      /* "validator.pyx":5169
 *         )
 *     elif isinstance(accept_sparse, (list, tuple)):
 *         if len(accept_sparse) == 0:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 "When providing 'accept_sparse' "
 */
    }

    /* "validator.pyx":5176
 *             )
 *         # ensure correct sparse format
 *         if spmatrix.format not in accept_sparse:             # <<<<<<<<<<<<<<
 *             # create new with correct sparse
 *             spmatrix = spmatrix.asformat(accept_sparse[0])
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_spmatrix, __pyx_n_s_format); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5176, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_1 = (__Pyx_PySequence_ContainsTF(__pyx_t_3, __pyx_v_accept_sparse, Py_NE)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 5176, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_2 = (__pyx_t_1 != 0);
    if (__pyx_t_2) {

      /* "validator.pyx":5178
 *         if spmatrix.format not in accept_sparse:
 *             # create new with correct sparse
 *             spmatrix = spmatrix.asformat(accept_sparse[0])             # <<<<<<<<<<<<<<
 *             changed_format = True
 *     elif accept_sparse is not True:
 */
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_spmatrix, __pyx_n_s_asformat); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5178, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_7 = __Pyx_GetItemInt(__pyx_v_accept_sparse, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 5178, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_5 = NULL;
      if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
        __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
        if (likely(__pyx_t_5)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
          __Pyx_INCREF(__pyx_t_5);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_4, function);
        }
      }
      __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_7);
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5178, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_DECREF_SET(__pyx_v_spmatrix, __pyx_t_3);
      __pyx_t_3 = 0;

      /* "validator.pyx":5179
 *             # create new with correct sparse
 *             spmatrix = spmatrix.asformat(accept_sparse[0])
 *             changed_format = True             # <<<<<<<<<<<<<<
 *     elif accept_sparse is not True:
 *         # any other type
 */
      __pyx_v_changed_format = 1;

      /* "validator.pyx":5176
 *             )
 *         # ensure correct sparse format
 *         if spmatrix.format not in accept_sparse:             # <<<<<<<<<<<<<<
 *             # create new with correct sparse
 *             spmatrix = spmatrix.asformat(accept_sparse[0])
 */
    }

    /* "validator.pyx":5168
 *             "convert to a dense numpy array."
 *         )
 *     elif isinstance(accept_sparse, (list, tuple)):             # <<<<<<<<<<<<<<
 *         if len(accept_sparse) == 0:
 *             raise ValueError(
 */
    goto __pyx_L5;
  }

  /* "validator.pyx":5180
 *             spmatrix = spmatrix.asformat(accept_sparse[0])
 *             changed_format = True
 *     elif accept_sparse is not True:             # <<<<<<<<<<<<<<
 *         # any other type
 *         raise ValueError(
 */
  __pyx_t_2 = (__pyx_v_accept_sparse != Py_True);
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (unlikely(__pyx_t_1)) {

    /* "validator.pyx":5185
 *             "Parameter 'accept_sparse' should be a string, "
 *             "boolean or list of strings. You provided "
 *             "'accept_sparse={}'.".format(accept_sparse)             # <<<<<<<<<<<<<<
 *         )
 * 
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_kp_u_Parameter_accept_sparse_should_b, __pyx_n_s_format); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5185, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_3 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_7, __pyx_v_accept_sparse) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_accept_sparse);
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5185, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "validator.pyx":5182
 *     elif accept_sparse is not True:
 *         # any other type
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             "Parameter 'accept_sparse' should be a string, "
 *             "boolean or list of strings. You provided "
 */
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5182, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 5182, __pyx_L1_error)

    /* "validator.pyx":5180
 *             spmatrix = spmatrix.asformat(accept_sparse[0])
 *             changed_format = True
 *     elif accept_sparse is not True:             # <<<<<<<<<<<<<<
 *         # any other type
 *         raise ValueError(
 */
  }
  __pyx_L5:;

  /* "validator.pyx":5188
 *         )
 * 
 *     if dtype != spmatrix.dtype:             # <<<<<<<<<<<<<<
 *         # convert dtype
 *         spmatrix = spmatrix.astype(dtype)
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_spmatrix, __pyx_n_s_dtype); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5188, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = PyObject_RichCompare(__pyx_v_dtype, __pyx_t_4, Py_NE); __Pyx_XGOTREF(__pyx_t_3); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5188, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 5188, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_1) {

    /* "validator.pyx":5190
 *     if dtype != spmatrix.dtype:
 *         # convert dtype
 *         spmatrix = spmatrix.astype(dtype)             # <<<<<<<<<<<<<<
 *     elif copy and not changed_format:
 *         # force copy
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_spmatrix, __pyx_n_s_astype); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5190, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_3 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_7, __pyx_v_dtype) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_dtype);
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5190, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF_SET(__pyx_v_spmatrix, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "validator.pyx":5188
 *         )
 * 
 *     if dtype != spmatrix.dtype:             # <<<<<<<<<<<<<<
 *         # convert dtype
 *         spmatrix = spmatrix.astype(dtype)
 */
    goto __pyx_L10;
  }

  /* "validator.pyx":5191
 *         # convert dtype
 *         spmatrix = spmatrix.astype(dtype)
 *     elif copy and not changed_format:             # <<<<<<<<<<<<<<
 *         # force copy
 *         spmatrix = spmatrix.copy()
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_copy); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 5191, __pyx_L1_error)
  if (__pyx_t_2) {
  } else {
    __pyx_t_1 = __pyx_t_2;
    goto __pyx_L11_bool_binop_done;
  }
  __pyx_t_2 = ((!(__pyx_v_changed_format != 0)) != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L11_bool_binop_done:;
  if (__pyx_t_1) {

    /* "validator.pyx":5193
 *     elif copy and not changed_format:
 *         # force copy
 *         spmatrix = spmatrix.copy()             # <<<<<<<<<<<<<<
 * 
 *     if force_all_finite:
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_spmatrix, __pyx_n_s_copy); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5193, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_7 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_7)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_7);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    __pyx_t_3 = (__pyx_t_7) ? __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_7) : __Pyx_PyObject_CallNoArg(__pyx_t_4);
    __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5193, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF_SET(__pyx_v_spmatrix, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "validator.pyx":5191
 *         # convert dtype
 *         spmatrix = spmatrix.astype(dtype)
 *     elif copy and not changed_format:             # <<<<<<<<<<<<<<
 *         # force copy
 *         spmatrix = spmatrix.copy()
 */
  }
  __pyx_L10:;

  /* "validator.pyx":5195
 *         spmatrix = spmatrix.copy()
 * 
 *     if force_all_finite:             # <<<<<<<<<<<<<<
 *         if not hasattr(spmatrix, "data"):
 *             warnings.warn(
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_force_all_finite); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 5195, __pyx_L1_error)
  if (__pyx_t_1) {

    /* "validator.pyx":5196
 * 
 *     if force_all_finite:
 *         if not hasattr(spmatrix, "data"):             # <<<<<<<<<<<<<<
 *             warnings.warn(
 *                 "Can't check %s sparse matrix for nan or inf." % spmatrix.format,
 */
    __pyx_t_1 = __Pyx_HasAttr(__pyx_v_spmatrix, __pyx_n_u_data); if (unlikely(__pyx_t_1 == ((int)-1))) __PYX_ERR(0, 5196, __pyx_L1_error)
    __pyx_t_2 = ((!(__pyx_t_1 != 0)) != 0);
    if (__pyx_t_2) {

      /* "validator.pyx":5197
 *     if force_all_finite:
 *         if not hasattr(spmatrix, "data"):
 *             warnings.warn(             # <<<<<<<<<<<<<<
 *                 "Can't check %s sparse matrix for nan or inf." % spmatrix.format,
 *                 stacklevel=2,
 */
      __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_warnings); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5197, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_warn); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5197, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

      /* "validator.pyx":5198
 *         if not hasattr(spmatrix, "data"):
 *             warnings.warn(
 *                 "Can't check %s sparse matrix for nan or inf." % spmatrix.format,             # <<<<<<<<<<<<<<
 *                 stacklevel=2,
 *             )
 */
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_spmatrix, __pyx_n_s_format); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5198, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_7 = __Pyx_PyUnicode_FormatSafe(__pyx_kp_u_Can_t_check_s_sparse_matrix_for, __pyx_t_3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 5198, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

      /* "validator.pyx":5197
 *     if force_all_finite:
 *         if not hasattr(spmatrix, "data"):
 *             warnings.warn(             # <<<<<<<<<<<<<<
 *                 "Can't check %s sparse matrix for nan or inf." % spmatrix.format,
 *                 stacklevel=2,
 */
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5197, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_GIVEREF(__pyx_t_7);
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_7);
      __pyx_t_7 = 0;

      /* "validator.pyx":5199
 *             warnings.warn(
 *                 "Can't check %s sparse matrix for nan or inf." % spmatrix.format,
 *                 stacklevel=2,             # <<<<<<<<<<<<<<
 *             )
 *         else:
 */
      __pyx_t_7 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 5199, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_stacklevel, __pyx_int_2) < 0) __PYX_ERR(0, 5199, __pyx_L1_error)

      /* "validator.pyx":5197
 *     if force_all_finite:
 *         if not hasattr(spmatrix, "data"):
 *             warnings.warn(             # <<<<<<<<<<<<<<
 *                 "Can't check %s sparse matrix for nan or inf." % spmatrix.format,
 *                 stacklevel=2,
 */
      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_3, __pyx_t_7); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 5197, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

      /* "validator.pyx":5196
 * 
 *     if force_all_finite:
 *         if not hasattr(spmatrix, "data"):             # <<<<<<<<<<<<<<
 *             warnings.warn(
 *                 "Can't check %s sparse matrix for nan or inf." % spmatrix.format,
 */
      goto __pyx_L14;
    }

    /* "validator.pyx":5202
 *             )
 *         else:
 *             _assert_all_finite(             # <<<<<<<<<<<<<<
 *                 spmatrix.data,
 *                 allow_nan=force_all_finite == "allow-nan",
 */
    /*else*/ {
      __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_assert_all_finite); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 5202, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);

      /* "validator.pyx":5203
 *         else:
 *             _assert_all_finite(
 *                 spmatrix.data,             # <<<<<<<<<<<<<<
 *                 allow_nan=force_all_finite == "allow-nan",
 *                 estimator_name=estimator_name,
 */
      __pyx_t_7 = __Pyx_PyObject_GetAttrStr(__pyx_v_spmatrix, __pyx_n_s_data); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 5203, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);

      /* "validator.pyx":5202
 *             )
 *         else:
 *             _assert_all_finite(             # <<<<<<<<<<<<<<
 *                 spmatrix.data,
 *                 allow_nan=force_all_finite == "allow-nan",
 */
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5202, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_GIVEREF(__pyx_t_7);
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_7);
      __pyx_t_7 = 0;

      /* "validator.pyx":5204
 *             _assert_all_finite(
 *                 spmatrix.data,
 *                 allow_nan=force_all_finite == "allow-nan",             # <<<<<<<<<<<<<<
 *                 estimator_name=estimator_name,
 *                 input_name=input_name,
 */
      __pyx_t_7 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 5204, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_4 = PyObject_RichCompare(__pyx_v_force_all_finite, __pyx_kp_u_allow_nan, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5204, __pyx_L1_error)
      if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_allow_nan_2, __pyx_t_4) < 0) __PYX_ERR(0, 5204, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

      /* "validator.pyx":5205
 *                 spmatrix.data,
 *                 allow_nan=force_all_finite == "allow-nan",
 *                 estimator_name=estimator_name,             # <<<<<<<<<<<<<<
 *                 input_name=input_name,
 *             )
 */
      if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_estimator_name, __pyx_v_estimator_name) < 0) __PYX_ERR(0, 5204, __pyx_L1_error)

      /* "validator.pyx":5206
 *                 allow_nan=force_all_finite == "allow-nan",
 *                 estimator_name=estimator_name,
 *                 input_name=input_name,             # <<<<<<<<<<<<<<
 *             )
 * 
 */
      if (PyDict_SetItem(__pyx_t_7, __pyx_n_s_input_name, __pyx_v_input_name) < 0) __PYX_ERR(0, 5204, __pyx_L1_error)

      /* "validator.pyx":5202
 *             )
 *         else:
 *             _assert_all_finite(             # <<<<<<<<<<<<<<
 *                 spmatrix.data,
 *                 allow_nan=force_all_finite == "allow-nan",
 */
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_3, __pyx_t_7); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5202, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    }
    __pyx_L14:;

    /* "validator.pyx":5195
 *         spmatrix = spmatrix.copy()
 * 
 *     if force_all_finite:             # <<<<<<<<<<<<<<
 *         if not hasattr(spmatrix, "data"):
 *             warnings.warn(
 */
  }

  /* "validator.pyx":5209
 *             )
 * 
 *     return spmatrix             # <<<<<<<<<<<<<<
 * 
 * def _object_dtype_isnan(X):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_spmatrix);
  __pyx_r = __pyx_v_spmatrix;
  goto __pyx_L0;

  /* "validator.pyx":5101
 *                     " indices are accepted. Got %s indices." % indices_datatype
 *                 )
 * def _ensure_sparse_format(             # <<<<<<<<<<<<<<
 *     spmatrix,
 *     accept_sparse,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("validator._ensure_sparse_format", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_spmatrix);
  __Pyx_XDECREF(__pyx_v_accept_sparse);
  __Pyx_XDECREF(__pyx_v_dtype);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":5211
 *     return spmatrix
 * 
 * def _object_dtype_isnan(X):             # <<<<<<<<<<<<<<
 *     return X != X
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_169_object_dtype_isnan(PyObject *__pyx_self, PyObject *__pyx_v_X); /*proto*/
static PyMethodDef __pyx_mdef_9validator_169_object_dtype_isnan = {"_object_dtype_isnan", (PyCFunction)__pyx_pw_9validator_169_object_dtype_isnan, METH_O, 0};
static PyObject *__pyx_pw_9validator_169_object_dtype_isnan(PyObject *__pyx_self, PyObject *__pyx_v_X) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_object_dtype_isnan (wrapper)", 0);
  __pyx_r = __pyx_pf_9validator_168_object_dtype_isnan(__pyx_self, ((PyObject *)__pyx_v_X));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_168_object_dtype_isnan(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_object_dtype_isnan", 0);

  /* "validator.pyx":5212
 * 
 * def _object_dtype_isnan(X):
 *     return X != X             # <<<<<<<<<<<<<<
 * 
 * def _assert_all_finite(
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyObject_RichCompare(__pyx_v_X, __pyx_v_X, Py_NE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5212, __pyx_L1_error)
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "validator.pyx":5211
 *     return spmatrix
 * 
 * def _object_dtype_isnan(X):             # <<<<<<<<<<<<<<
 *     return X != X
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("validator._object_dtype_isnan", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":5214
 *     return X != X
 * 
 * def _assert_all_finite(             # <<<<<<<<<<<<<<
 *     X, allow_nan=False, msg_dtype=None, estimator_name=None, input_name=""
 * ):
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_171_assert_all_finite(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_170_assert_all_finite[] = "Like assert_all_finite, but only for ndarray.";
static PyMethodDef __pyx_mdef_9validator_171_assert_all_finite = {"_assert_all_finite", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_171_assert_all_finite, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_170_assert_all_finite};
static PyObject *__pyx_pw_9validator_171_assert_all_finite(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_X = 0;
  PyObject *__pyx_v_allow_nan = 0;
  PyObject *__pyx_v_msg_dtype = 0;
  PyObject *__pyx_v_estimator_name = 0;
  PyObject *__pyx_v_input_name = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_assert_all_finite (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_X,&__pyx_n_s_allow_nan_2,&__pyx_n_s_msg_dtype,&__pyx_n_s_estimator_name,&__pyx_n_s_input_name,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "validator.pyx":5215
 * 
 * def _assert_all_finite(
 *     X, allow_nan=False, msg_dtype=None, estimator_name=None, input_name=""             # <<<<<<<<<<<<<<
 * ):
 *     """Like assert_all_finite, but only for ndarray."""
 */
    values[1] = ((PyObject *)Py_False);
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)__pyx_kp_u__7);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_X)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_allow_nan_2);
          if (value) { values[1] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_msg_dtype);
          if (value) { values[2] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  3:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_estimator_name);
          if (value) { values[3] = value; kw_args--; }
        }
        CYTHON_FALLTHROUGH;
        case  4:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_input_name);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_assert_all_finite") < 0)) __PYX_ERR(0, 5214, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        CYTHON_FALLTHROUGH;
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        CYTHON_FALLTHROUGH;
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_X = values[0];
    __pyx_v_allow_nan = values[1];
    __pyx_v_msg_dtype = values[2];
    __pyx_v_estimator_name = values[3];
    __pyx_v_input_name = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_assert_all_finite", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 5214, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator._assert_all_finite", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_170_assert_all_finite(__pyx_self, __pyx_v_X, __pyx_v_allow_nan, __pyx_v_msg_dtype, __pyx_v_estimator_name, __pyx_v_input_name);

  /* "validator.pyx":5214
 *     return X != X
 * 
 * def _assert_all_finite(             # <<<<<<<<<<<<<<
 *     X, allow_nan=False, msg_dtype=None, estimator_name=None, input_name=""
 * ):
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_170_assert_all_finite(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X, PyObject *__pyx_v_allow_nan, PyObject *__pyx_v_msg_dtype, PyObject *__pyx_v_estimator_name, PyObject *__pyx_v_input_name) {
  PyObject *__pyx_v_err_msg = NULL;
  PyObject *__pyx_v_xp = NULL;
  CYTHON_UNUSED PyObject *__pyx_v__ = NULL;
  PyObject *__pyx_v_first_pass_isfinite = NULL;
  PyObject *__pyx_v_has_inf = NULL;
  PyObject *__pyx_v_has_nan_error = NULL;
  PyObject *__pyx_v_type_err = NULL;
  PyObject *__pyx_v_padded_input_name = NULL;
  PyObject *__pyx_v_msg_err = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *(*__pyx_t_5)(PyObject *);
  int __pyx_t_6;
  int __pyx_t_7;
  int __pyx_t_8;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  Py_ssize_t __pyx_t_15;
  Py_UCS4 __pyx_t_16;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_assert_all_finite", 0);
  __Pyx_INCREF(__pyx_v_X);
  __Pyx_INCREF(__pyx_v_msg_dtype);

  /* "validator.pyx":5220
 * 
 *     err_msg=(
 *         f"{input_name} does not accept missing values encoded as NaN"             # <<<<<<<<<<<<<<
 *         " natively. Alternatively, it is possible to preprocess the data,"
 *         " for instance by using the imputer transformer like the ufunc"
 */
  __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_input_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5220, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyUnicode_Concat(__pyx_t_1, __pyx_kp_u_does_not_accept_missing_values); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5220, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_err_msg = ((PyObject*)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "validator.pyx":5226
 *         )
 * 
 *     xp, _ = get_namespace(X)             # <<<<<<<<<<<<<<
 * 
 *     # if _get_config()["assume_finite"]:
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_get_namespace); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5226, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  __pyx_t_2 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_3, __pyx_v_X) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_X);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5226, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if ((likely(PyTuple_CheckExact(__pyx_t_2))) || (PyList_CheckExact(__pyx_t_2))) {
    PyObject* sequence = __pyx_t_2;
    Py_ssize_t size = __Pyx_PySequence_SIZE(sequence);
    if (unlikely(size != 2)) {
      if (size > 2) __Pyx_RaiseTooManyValuesError(2);
      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
      __PYX_ERR(0, 5226, __pyx_L1_error)
    }
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    if (likely(PyTuple_CheckExact(sequence))) {
      __pyx_t_1 = PyTuple_GET_ITEM(sequence, 0); 
      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 1); 
    } else {
      __pyx_t_1 = PyList_GET_ITEM(sequence, 0); 
      __pyx_t_3 = PyList_GET_ITEM(sequence, 1); 
    }
    __Pyx_INCREF(__pyx_t_1);
    __Pyx_INCREF(__pyx_t_3);
    #else
    __pyx_t_1 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5226, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_3 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5226, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    #endif
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  } else {
    Py_ssize_t index = -1;
    __pyx_t_4 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5226, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_5 = Py_TYPE(__pyx_t_4)->tp_iternext;
    index = 0; __pyx_t_1 = __pyx_t_5(__pyx_t_4); if (unlikely(!__pyx_t_1)) goto __pyx_L3_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_1);
    index = 1; __pyx_t_3 = __pyx_t_5(__pyx_t_4); if (unlikely(!__pyx_t_3)) goto __pyx_L3_unpacking_failed;
    __Pyx_GOTREF(__pyx_t_3);
    if (__Pyx_IternextUnpackEndCheck(__pyx_t_5(__pyx_t_4), 2) < 0) __PYX_ERR(0, 5226, __pyx_L1_error)
    __pyx_t_5 = NULL;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    goto __pyx_L4_unpacking_done;
    __pyx_L3_unpacking_failed:;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_5 = NULL;
    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
    __PYX_ERR(0, 5226, __pyx_L1_error)
    __pyx_L4_unpacking_done:;
  }
  __pyx_v_xp = __pyx_t_1;
  __pyx_t_1 = 0;
  __pyx_v__ = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "validator.pyx":5230
 *     # if _get_config()["assume_finite"]:
 *     #     return
 *     X = xp.asarray(X)             # <<<<<<<<<<<<<<
 * 
 *     # for object dtype data, we only check for NaNs (GH-13254)
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_xp, __pyx_n_s_asarray); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5230, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_1 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_1)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_1);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_2 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_1, __pyx_v_X) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_X);
  __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5230, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF_SET(__pyx_v_X, __pyx_t_2);
  __pyx_t_2 = 0;

  /* "validator.pyx":5233
 * 
 *     # for object dtype data, we only check for NaNs (GH-13254)
 *     if X.dtype == np.dtype("object") and not allow_nan:             # <<<<<<<<<<<<<<
 *         if _object_dtype_isnan(X).any():
 *             raise ValueError("Input contains NaN. " + err_msg)
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_dtype); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5233, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5233, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_dtype); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5233, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_1)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_1);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  __pyx_t_3 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_1, __pyx_n_u_object) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_n_u_object);
  __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5233, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = PyObject_RichCompare(__pyx_t_2, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5233, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 5233, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (__pyx_t_7) {
  } else {
    __pyx_t_6 = __pyx_t_7;
    goto __pyx_L6_bool_binop_done;
  }
  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_allow_nan); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 5233, __pyx_L1_error)
  __pyx_t_8 = ((!__pyx_t_7) != 0);
  __pyx_t_6 = __pyx_t_8;
  __pyx_L6_bool_binop_done:;
  if (__pyx_t_6) {

    /* "validator.pyx":5234
 *     # for object dtype data, we only check for NaNs (GH-13254)
 *     if X.dtype == np.dtype("object") and not allow_nan:
 *         if _object_dtype_isnan(X).any():             # <<<<<<<<<<<<<<
 *             raise ValueError("Input contains NaN. " + err_msg)
 * 
 */
    __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_object_dtype_isnan); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5234, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = NULL;
    if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_1)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    __pyx_t_3 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_1, __pyx_v_X) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_X);
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5234, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_any); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5234, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    __pyx_t_4 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5234, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 5234, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(__pyx_t_6)) {

      /* "validator.pyx":5235
 *     if X.dtype == np.dtype("object") and not allow_nan:
 *         if _object_dtype_isnan(X).any():
 *             raise ValueError("Input contains NaN. " + err_msg)             # <<<<<<<<<<<<<<
 * 
 *     # We need only consider float arrays, hence can early return for all else.
 */
      __pyx_t_4 = __Pyx_PyUnicode_Concat(__pyx_kp_u_Input_contains_NaN, __pyx_v_err_msg); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5235, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5235, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_Raise(__pyx_t_2, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __PYX_ERR(0, 5235, __pyx_L1_error)

      /* "validator.pyx":5234
 *     # for object dtype data, we only check for NaNs (GH-13254)
 *     if X.dtype == np.dtype("object") and not allow_nan:
 *         if _object_dtype_isnan(X).any():             # <<<<<<<<<<<<<<
 *             raise ValueError("Input contains NaN. " + err_msg)
 * 
 */
    }

    /* "validator.pyx":5233
 * 
 *     # for object dtype data, we only check for NaNs (GH-13254)
 *     if X.dtype == np.dtype("object") and not allow_nan:             # <<<<<<<<<<<<<<
 *         if _object_dtype_isnan(X).any():
 *             raise ValueError("Input contains NaN. " + err_msg)
 */
  }

  /* "validator.pyx":5238
 * 
 *     # We need only consider float arrays, hence can early return for all else.
 *     if X.dtype.kind not in "fc":             # <<<<<<<<<<<<<<
 *         return
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_dtype); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5238, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_kind); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5238, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_6 = (__Pyx_PyUnicode_ContainsTF(__pyx_t_4, __pyx_n_u_fc, Py_NE)); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 5238, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_8 = (__pyx_t_6 != 0);
  if (__pyx_t_8) {

    /* "validator.pyx":5239
 *     # We need only consider float arrays, hence can early return for all else.
 *     if X.dtype.kind not in "fc":
 *         return             # <<<<<<<<<<<<<<
 * 
 *     # First try an O(n) time, O(1) space solution for the common case that
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_r = Py_None; __Pyx_INCREF(Py_None);
    goto __pyx_L0;

    /* "validator.pyx":5238
 * 
 *     # We need only consider float arrays, hence can early return for all else.
 *     if X.dtype.kind not in "fc":             # <<<<<<<<<<<<<<
 *         return
 * 
 */
  }

  /* "validator.pyx":5245
 *     # Cython implementation to prevent false positives and provide a detailed
 *     # error message.
 *     with np.errstate(over="ignore"):             # <<<<<<<<<<<<<<
 *         first_pass_isfinite = xp.isfinite(xp.sum(X))
 *     if first_pass_isfinite:
 */
  /*with:*/ {
    __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5245, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_errstate); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5245, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5245, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_over, __pyx_n_u_ignore) < 0) __PYX_ERR(0, 5245, __pyx_L1_error)
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5245, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_9 = __Pyx_PyObject_LookupSpecial(__pyx_t_3, __pyx_n_s_exit); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 5245, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __pyx_t_2 = __Pyx_PyObject_LookupSpecial(__pyx_t_3, __pyx_n_s_enter); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5245, __pyx_L10_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {
      __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_2);
      if (likely(__pyx_t_1)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_2, function);
      }
    }
    __pyx_t_4 = (__pyx_t_1) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_1) : __Pyx_PyObject_CallNoArg(__pyx_t_2);
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5245, __pyx_L10_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    /*try:*/ {
      {
        __Pyx_PyThreadState_declare
        __Pyx_PyThreadState_assign
        __Pyx_ExceptionSave(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12);
        __Pyx_XGOTREF(__pyx_t_10);
        __Pyx_XGOTREF(__pyx_t_11);
        __Pyx_XGOTREF(__pyx_t_12);
        /*try:*/ {

          /* "validator.pyx":5246
 *     # error message.
 *     with np.errstate(over="ignore"):
 *         first_pass_isfinite = xp.isfinite(xp.sum(X))             # <<<<<<<<<<<<<<
 *     if first_pass_isfinite:
 *         return
 */
          __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_xp, __pyx_n_s_isfinite); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5246, __pyx_L14_error)
          __Pyx_GOTREF(__pyx_t_4);
          __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_xp, __pyx_n_s_sum); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5246, __pyx_L14_error)
          __Pyx_GOTREF(__pyx_t_1);
          __pyx_t_13 = NULL;
          if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
            __pyx_t_13 = PyMethod_GET_SELF(__pyx_t_1);
            if (likely(__pyx_t_13)) {
              PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
              __Pyx_INCREF(__pyx_t_13);
              __Pyx_INCREF(function);
              __Pyx_DECREF_SET(__pyx_t_1, function);
            }
          }
          __pyx_t_2 = (__pyx_t_13) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_13, __pyx_v_X) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_X);
          __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
          if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5246, __pyx_L14_error)
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
          __pyx_t_1 = NULL;
          if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_4))) {
            __pyx_t_1 = PyMethod_GET_SELF(__pyx_t_4);
            if (likely(__pyx_t_1)) {
              PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
              __Pyx_INCREF(__pyx_t_1);
              __Pyx_INCREF(function);
              __Pyx_DECREF_SET(__pyx_t_4, function);
            }
          }
          __pyx_t_3 = (__pyx_t_1) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_1, __pyx_t_2) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_2);
          __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
          if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5246, __pyx_L14_error)
          __Pyx_GOTREF(__pyx_t_3);
          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
          __pyx_v_first_pass_isfinite = __pyx_t_3;
          __pyx_t_3 = 0;

          /* "validator.pyx":5245
 *     # Cython implementation to prevent false positives and provide a detailed
 *     # error message.
 *     with np.errstate(over="ignore"):             # <<<<<<<<<<<<<<
 *         first_pass_isfinite = xp.isfinite(xp.sum(X))
 *     if first_pass_isfinite:
 */
        }
        __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
        __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
        __Pyx_XDECREF(__pyx_t_12); __pyx_t_12 = 0;
        goto __pyx_L19_try_end;
        __pyx_L14_error:;
        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
        /*except:*/ {
          __Pyx_AddTraceback("validator._assert_all_finite", __pyx_clineno, __pyx_lineno, __pyx_filename);
          if (__Pyx_GetException(&__pyx_t_3, &__pyx_t_4, &__pyx_t_2) < 0) __PYX_ERR(0, 5245, __pyx_L16_except_error)
          __Pyx_GOTREF(__pyx_t_3);
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_GOTREF(__pyx_t_2);
          __pyx_t_1 = PyTuple_Pack(3, __pyx_t_3, __pyx_t_4, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5245, __pyx_L16_except_error)
          __Pyx_GOTREF(__pyx_t_1);
          __pyx_t_14 = __Pyx_PyObject_Call(__pyx_t_9, __pyx_t_1, NULL);
          __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
          if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 5245, __pyx_L16_except_error)
          __Pyx_GOTREF(__pyx_t_14);
          __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_14);
          __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
          if (__pyx_t_8 < 0) __PYX_ERR(0, 5245, __pyx_L16_except_error)
          __pyx_t_6 = ((!(__pyx_t_8 != 0)) != 0);
          if (__pyx_t_6) {
            __Pyx_GIVEREF(__pyx_t_3);
            __Pyx_GIVEREF(__pyx_t_4);
            __Pyx_XGIVEREF(__pyx_t_2);
            __Pyx_ErrRestoreWithState(__pyx_t_3, __pyx_t_4, __pyx_t_2);
            __pyx_t_3 = 0; __pyx_t_4 = 0; __pyx_t_2 = 0; 
            __PYX_ERR(0, 5245, __pyx_L16_except_error)
          }
          __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
          __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
          __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
          goto __pyx_L15_exception_handled;
        }
        __pyx_L16_except_error:;
        __Pyx_XGIVEREF(__pyx_t_10);
        __Pyx_XGIVEREF(__pyx_t_11);
        __Pyx_XGIVEREF(__pyx_t_12);
        __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_11, __pyx_t_12);
        goto __pyx_L1_error;
        __pyx_L15_exception_handled:;
        __Pyx_XGIVEREF(__pyx_t_10);
        __Pyx_XGIVEREF(__pyx_t_11);
        __Pyx_XGIVEREF(__pyx_t_12);
        __Pyx_ExceptionReset(__pyx_t_10, __pyx_t_11, __pyx_t_12);
        __pyx_L19_try_end:;
      }
    }
    /*finally:*/ {
      /*normal exit:*/{
        if (__pyx_t_9) {
          __pyx_t_12 = __Pyx_PyObject_Call(__pyx_t_9, __pyx_tuple__109, NULL);
          __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
          if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 5245, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_12);
          __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
        }
        goto __pyx_L13;
      }
      __pyx_L13:;
    }
    goto __pyx_L23;
    __pyx_L10_error:;
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    goto __pyx_L1_error;
    __pyx_L23:;
  }

  /* "validator.pyx":5247
 *     with np.errstate(over="ignore"):
 *         first_pass_isfinite = xp.isfinite(xp.sum(X))
 *     if first_pass_isfinite:             # <<<<<<<<<<<<<<
 *         return
 *     # Cython implementation doesn't support FP16 or complex numbers
 */
  if (unlikely(!__pyx_v_first_pass_isfinite)) { __Pyx_RaiseUnboundLocalError("first_pass_isfinite"); __PYX_ERR(0, 5247, __pyx_L1_error) }
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_first_pass_isfinite); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 5247, __pyx_L1_error)
  if (__pyx_t_6) {

    /* "validator.pyx":5248
 *         first_pass_isfinite = xp.isfinite(xp.sum(X))
 *     if first_pass_isfinite:
 *         return             # <<<<<<<<<<<<<<
 *     # Cython implementation doesn't support FP16 or complex numbers
 *     # use_cython = (
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_r = Py_None; __Pyx_INCREF(Py_None);
    goto __pyx_L0;

    /* "validator.pyx":5247
 *     with np.errstate(over="ignore"):
 *         first_pass_isfinite = xp.isfinite(xp.sum(X))
 *     if first_pass_isfinite:             # <<<<<<<<<<<<<<
 *         return
 *     # Cython implementation doesn't support FP16 or complex numbers
 */
  }

  /* "validator.pyx":5258
 *     #     has_inf = out == FiniteStatus.has_infinite
 *     # else:
 *     has_inf = np.isinf(X).any()             # <<<<<<<<<<<<<<
 *     has_nan_error = False if allow_nan else xp.isnan(X).any()
 *     if has_inf or has_nan_error:
 */
  __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_np); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5258, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_isinf); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5258, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  __pyx_t_4 = (__pyx_t_3) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_3, __pyx_v_X) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_X);
  __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5258, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_any); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5258, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5258, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_has_inf = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "validator.pyx":5259
 *     # else:
 *     has_inf = np.isinf(X).any()
 *     has_nan_error = False if allow_nan else xp.isnan(X).any()             # <<<<<<<<<<<<<<
 *     if has_inf or has_nan_error:
 *         if has_nan_error:
 */
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_allow_nan); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 5259, __pyx_L1_error)
  if (__pyx_t_6) {
    __Pyx_INCREF(Py_False);
    __pyx_t_2 = Py_False;
  } else {
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_xp, __pyx_n_s_isnan); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5259, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_13 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_13 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_13)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_13);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    __pyx_t_4 = (__pyx_t_13) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_13, __pyx_v_X) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_X);
    __Pyx_XDECREF(__pyx_t_13); __pyx_t_13 = 0;
    if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5259, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_any); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5259, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = NULL;
    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5259, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_2 = __pyx_t_1;
    __pyx_t_1 = 0;
  }
  __pyx_v_has_nan_error = __pyx_t_2;
  __pyx_t_2 = 0;

  /* "validator.pyx":5260
 *     has_inf = np.isinf(X).any()
 *     has_nan_error = False if allow_nan else xp.isnan(X).any()
 *     if has_inf or has_nan_error:             # <<<<<<<<<<<<<<
 *         if has_nan_error:
 *             type_err = "NaN"
 */
  __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_v_has_inf); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 5260, __pyx_L1_error)
  if (!__pyx_t_8) {
  } else {
    __pyx_t_6 = __pyx_t_8;
    goto __pyx_L26_bool_binop_done;
  }
  __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_v_has_nan_error); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 5260, __pyx_L1_error)
  __pyx_t_6 = __pyx_t_8;
  __pyx_L26_bool_binop_done:;
  if (__pyx_t_6) {

    /* "validator.pyx":5261
 *     has_nan_error = False if allow_nan else xp.isnan(X).any()
 *     if has_inf or has_nan_error:
 *         if has_nan_error:             # <<<<<<<<<<<<<<
 *             type_err = "NaN"
 *         else:
 */
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_has_nan_error); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 5261, __pyx_L1_error)
    if (__pyx_t_6) {

      /* "validator.pyx":5262
 *     if has_inf or has_nan_error:
 *         if has_nan_error:
 *             type_err = "NaN"             # <<<<<<<<<<<<<<
 *         else:
 *             msg_dtype = msg_dtype if msg_dtype is not None else X.dtype
 */
      __Pyx_INCREF(__pyx_n_u_NaN);
      __pyx_v_type_err = __pyx_n_u_NaN;

      /* "validator.pyx":5261
 *     has_nan_error = False if allow_nan else xp.isnan(X).any()
 *     if has_inf or has_nan_error:
 *         if has_nan_error:             # <<<<<<<<<<<<<<
 *             type_err = "NaN"
 *         else:
 */
      goto __pyx_L28;
    }

    /* "validator.pyx":5264
 *             type_err = "NaN"
 *         else:
 *             msg_dtype = msg_dtype if msg_dtype is not None else X.dtype             # <<<<<<<<<<<<<<
 *             type_err = f"infinity or a value too large for {msg_dtype!r}"
 *         padded_input_name = input_name + " " if input_name else ""
 */
    /*else*/ {
      __pyx_t_6 = (__pyx_v_msg_dtype != Py_None);
      if ((__pyx_t_6 != 0)) {
        __Pyx_INCREF(__pyx_v_msg_dtype);
        __pyx_t_2 = __pyx_v_msg_dtype;
      } else {
        __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_dtype); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5264, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_2 = __pyx_t_1;
        __pyx_t_1 = 0;
      }
      __Pyx_DECREF_SET(__pyx_v_msg_dtype, __pyx_t_2);
      __pyx_t_2 = 0;

      /* "validator.pyx":5265
 *         else:
 *             msg_dtype = msg_dtype if msg_dtype is not None else X.dtype
 *             type_err = f"infinity or a value too large for {msg_dtype!r}"             # <<<<<<<<<<<<<<
 *         padded_input_name = input_name + " " if input_name else ""
 *         msg_err = f"Input {padded_input_name}contains {type_err}."
 */
      __pyx_t_2 = __Pyx_PyObject_FormatSimpleAndDecref(PyObject_Repr(__pyx_v_msg_dtype), __pyx_empty_unicode); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5265, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_1 = __Pyx_PyUnicode_Concat(__pyx_kp_u_infinity_or_a_value_too_large_fo, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5265, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_v_type_err = ((PyObject*)__pyx_t_1);
      __pyx_t_1 = 0;
    }
    __pyx_L28:;

    /* "validator.pyx":5266
 *             msg_dtype = msg_dtype if msg_dtype is not None else X.dtype
 *             type_err = f"infinity or a value too large for {msg_dtype!r}"
 *         padded_input_name = input_name + " " if input_name else ""             # <<<<<<<<<<<<<<
 *         msg_err = f"Input {padded_input_name}contains {type_err}."
 *         if estimator_name and input_name == "X" and has_nan_error:
 */
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_v_input_name); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 5266, __pyx_L1_error)
    if (__pyx_t_6) {
      __pyx_t_2 = PyNumber_Add(__pyx_v_input_name, __pyx_kp_u__81); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5266, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_1 = __pyx_t_2;
      __pyx_t_2 = 0;
    } else {
      __Pyx_INCREF(__pyx_kp_u__7);
      __pyx_t_1 = __pyx_kp_u__7;
    }
    __pyx_v_padded_input_name = __pyx_t_1;
    __pyx_t_1 = 0;

    /* "validator.pyx":5267
 *             type_err = f"infinity or a value too large for {msg_dtype!r}"
 *         padded_input_name = input_name + " " if input_name else ""
 *         msg_err = f"Input {padded_input_name}contains {type_err}."             # <<<<<<<<<<<<<<
 *         if estimator_name and input_name == "X" and has_nan_error:
 *             # Improve the error message on how to handle missing values in
 */
    __pyx_t_1 = PyTuple_New(5); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5267, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_15 = 0;
    __pyx_t_16 = 127;
    __Pyx_INCREF(__pyx_kp_u_Input);
    __pyx_t_15 += 6;
    __Pyx_GIVEREF(__pyx_kp_u_Input);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_u_Input);
    __pyx_t_2 = __Pyx_PyObject_FormatSimple(__pyx_v_padded_input_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5267, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_16 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) > __pyx_t_16) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_2) : __pyx_t_16;
    __pyx_t_15 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_2);
    __Pyx_GIVEREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_2);
    __pyx_t_2 = 0;
    __Pyx_INCREF(__pyx_kp_u_contains_2);
    __pyx_t_15 += 9;
    __Pyx_GIVEREF(__pyx_kp_u_contains_2);
    PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_kp_u_contains_2);
    __Pyx_INCREF(__pyx_v_type_err);
    __pyx_t_16 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_v_type_err) > __pyx_t_16) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_v_type_err) : __pyx_t_16;
    __pyx_t_15 += __Pyx_PyUnicode_GET_LENGTH(__pyx_v_type_err);
    __Pyx_GIVEREF(__pyx_v_type_err);
    PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_v_type_err);
    __Pyx_INCREF(__pyx_kp_u__16);
    __pyx_t_15 += 1;
    __Pyx_GIVEREF(__pyx_kp_u__16);
    PyTuple_SET_ITEM(__pyx_t_1, 4, __pyx_kp_u__16);
    __pyx_t_2 = __Pyx_PyUnicode_Join(__pyx_t_1, 5, __pyx_t_15, __pyx_t_16); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5267, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_v_msg_err = ((PyObject*)__pyx_t_2);
    __pyx_t_2 = 0;

    /* "validator.pyx":5268
 *         padded_input_name = input_name + " " if input_name else ""
 *         msg_err = f"Input {padded_input_name}contains {type_err}."
 *         if estimator_name and input_name == "X" and has_nan_error:             # <<<<<<<<<<<<<<
 *             # Improve the error message on how to handle missing values in
 *             # scikit-learn.
 */
    __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_v_estimator_name); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 5268, __pyx_L1_error)
    if (__pyx_t_8) {
    } else {
      __pyx_t_6 = __pyx_t_8;
      goto __pyx_L30_bool_binop_done;
    }
    __pyx_t_8 = (__Pyx_PyUnicode_Equals(__pyx_v_input_name, __pyx_n_u_X, Py_EQ)); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 5268, __pyx_L1_error)
    if (__pyx_t_8) {
    } else {
      __pyx_t_6 = __pyx_t_8;
      goto __pyx_L30_bool_binop_done;
    }
    __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_v_has_nan_error); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 5268, __pyx_L1_error)
    __pyx_t_6 = __pyx_t_8;
    __pyx_L30_bool_binop_done:;
    if (__pyx_t_6) {

      /* "validator.pyx":5272
 *             # scikit-learn.
 *             msg_err += (
 *                 f"\n{estimator_name} does not accept missing values"             # <<<<<<<<<<<<<<
 *                 " encoded as NaN natively. For supervised learning, you might want"
 *                 " to consider sklearn.ensemble.HistGradientBoostingClassifier and"
 */
      __pyx_t_2 = PyTuple_New(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5272, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_15 = 0;
      __pyx_t_16 = 127;
      __Pyx_INCREF(__pyx_kp_u__117);
      __pyx_t_15 += 1;
      __Pyx_GIVEREF(__pyx_kp_u__117);
      PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_kp_u__117);
      __pyx_t_1 = __Pyx_PyObject_FormatSimple(__pyx_v_estimator_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5272, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_16 = (__Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) > __pyx_t_16) ? __Pyx_PyUnicode_MAX_CHAR_VALUE(__pyx_t_1) : __pyx_t_16;
      __pyx_t_15 += __Pyx_PyUnicode_GET_LENGTH(__pyx_t_1);
      __Pyx_GIVEREF(__pyx_t_1);
      PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_1);
      __pyx_t_1 = 0;
      __Pyx_INCREF(__pyx_kp_u_does_not_accept_missing_values_2);
      __pyx_t_15 += 600;
      __Pyx_GIVEREF(__pyx_kp_u_does_not_accept_missing_values_2);
      PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_kp_u_does_not_accept_missing_values_2);
      __pyx_t_1 = __Pyx_PyUnicode_Join(__pyx_t_2, 3, __pyx_t_15, __pyx_t_16); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5272, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

      /* "validator.pyx":5271
 *             # Improve the error message on how to handle missing values in
 *             # scikit-learn.
 *             msg_err += (             # <<<<<<<<<<<<<<
 *                 f"\n{estimator_name} does not accept missing values"
 *                 " encoded as NaN natively. For supervised learning, you might want"
 */
      __pyx_t_2 = __Pyx_PyUnicode_Concat(__pyx_v_msg_err, __pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5271, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_DECREF_SET(__pyx_v_msg_err, ((PyObject*)__pyx_t_2));
      __pyx_t_2 = 0;

      /* "validator.pyx":5268
 *         padded_input_name = input_name + " " if input_name else ""
 *         msg_err = f"Input {padded_input_name}contains {type_err}."
 *         if estimator_name and input_name == "X" and has_nan_error:             # <<<<<<<<<<<<<<
 *             # Improve the error message on how to handle missing values in
 *             # scikit-learn.
 */
      goto __pyx_L29;
    }

    /* "validator.pyx":5285
 *                 "#estimators-that-handle-nan-values"
 *             )
 *         elif estimator_name is None and has_nan_error:             # <<<<<<<<<<<<<<
 *             msg_err += f"\n{err_msg}"
 * 
 */
    __pyx_t_8 = (__pyx_v_estimator_name == Py_None);
    __pyx_t_7 = (__pyx_t_8 != 0);
    if (__pyx_t_7) {
    } else {
      __pyx_t_6 = __pyx_t_7;
      goto __pyx_L33_bool_binop_done;
    }
    __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_v_has_nan_error); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 5285, __pyx_L1_error)
    __pyx_t_6 = __pyx_t_7;
    __pyx_L33_bool_binop_done:;
    if (__pyx_t_6) {

      /* "validator.pyx":5286
 *             )
 *         elif estimator_name is None and has_nan_error:
 *             msg_err += f"\n{err_msg}"             # <<<<<<<<<<<<<<
 * 
 *         raise ValueError(msg_err)
 */
      __pyx_t_2 = __Pyx_PyUnicode_Concat(__pyx_kp_u__117, __pyx_v_err_msg); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5286, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_1 = __Pyx_PyUnicode_Concat(__pyx_v_msg_err, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5286, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF_SET(__pyx_v_msg_err, ((PyObject*)__pyx_t_1));
      __pyx_t_1 = 0;

      /* "validator.pyx":5285
 *                 "#estimators-that-handle-nan-values"
 *             )
 *         elif estimator_name is None and has_nan_error:             # <<<<<<<<<<<<<<
 *             msg_err += f"\n{err_msg}"
 * 
 */
    }
    __pyx_L29:;

    /* "validator.pyx":5288
 *             msg_err += f"\n{err_msg}"
 * 
 *         raise ValueError(msg_err)             # <<<<<<<<<<<<<<
 * 
 * def assert_all_finite(
 */
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_builtin_ValueError, __pyx_v_msg_err); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5288, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 5288, __pyx_L1_error)

    /* "validator.pyx":5260
 *     has_inf = np.isinf(X).any()
 *     has_nan_error = False if allow_nan else xp.isnan(X).any()
 *     if has_inf or has_nan_error:             # <<<<<<<<<<<<<<
 *         if has_nan_error:
 *             type_err = "NaN"
 */
  }

  /* "validator.pyx":5214
 *     return X != X
 * 
 * def _assert_all_finite(             # <<<<<<<<<<<<<<
 *     X, allow_nan=False, msg_dtype=None, estimator_name=None, input_name=""
 * ):
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_13);
  __Pyx_AddTraceback("validator._assert_all_finite", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_err_msg);
  __Pyx_XDECREF(__pyx_v_xp);
  __Pyx_XDECREF(__pyx_v__);
  __Pyx_XDECREF(__pyx_v_first_pass_isfinite);
  __Pyx_XDECREF(__pyx_v_has_inf);
  __Pyx_XDECREF(__pyx_v_has_nan_error);
  __Pyx_XDECREF(__pyx_v_type_err);
  __Pyx_XDECREF(__pyx_v_padded_input_name);
  __Pyx_XDECREF(__pyx_v_msg_err);
  __Pyx_XDECREF(__pyx_v_X);
  __Pyx_XDECREF(__pyx_v_msg_dtype);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":5290
 *         raise ValueError(msg_err)
 * 
 * def assert_all_finite(             # <<<<<<<<<<<<<<
 *     X,
 *     *,
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_173assert_all_finite(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_172assert_all_finite[] = "Throw a ValueError if X contains NaN or infinity.\n    Parameters\n    ----------\n    X : {ndarray, sparse matrix}\n        The input data.\n    allow_nan : bool, default=False\n        If True, do not throw error when `X` contains NaN.\n    estimator_name : str, default=None\n        The estimator name, used to construct the error message.\n    input_name : str, default=\"\"\n        The data name used to construct the error message. In particular\n        if `input_name` is \"X\" and the data has NaN values and\n        allow_nan is False, the error message will link to the imputer\n        documentation.\n    ";
static PyMethodDef __pyx_mdef_9validator_173assert_all_finite = {"assert_all_finite", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_173assert_all_finite, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_172assert_all_finite};
static PyObject *__pyx_pw_9validator_173assert_all_finite(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_X = 0;
  PyObject *__pyx_v_allow_nan = 0;
  PyObject *__pyx_v_estimator_name = 0;
  PyObject *__pyx_v_input_name = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("assert_all_finite (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_X,&__pyx_n_s_allow_nan_2,&__pyx_n_s_estimator_name,&__pyx_n_s_input_name,0};
    PyObject* values[4] = {0,0,0,0};

    /* "validator.pyx":5293
 *     X,
 *     *,
 *     allow_nan=False,             # <<<<<<<<<<<<<<
 *     estimator_name=None,
 *     input_name="",
 */
    values[1] = ((PyObject *)Py_False);

    /* "validator.pyx":5294
 *     *,
 *     allow_nan=False,
 *     estimator_name=None,             # <<<<<<<<<<<<<<
 *     input_name="",
 * ):
 */
    values[2] = ((PyObject *)Py_None);
    values[3] = ((PyObject *)__pyx_kp_u__7);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_X)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (kw_args > 0 && likely(kw_args <= 3)) {
        Py_ssize_t index;
        for (index = 1; index < 4 && kw_args > 0; index++) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, *__pyx_pyargnames[index]);
          if (value) { values[index] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "assert_all_finite") < 0)) __PYX_ERR(0, 5290, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_X = values[0];
    __pyx_v_allow_nan = values[1];
    __pyx_v_estimator_name = values[2];
    __pyx_v_input_name = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("assert_all_finite", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 5290, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator.assert_all_finite", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_172assert_all_finite(__pyx_self, __pyx_v_X, __pyx_v_allow_nan, __pyx_v_estimator_name, __pyx_v_input_name);

  /* "validator.pyx":5290
 *         raise ValueError(msg_err)
 * 
 * def assert_all_finite(             # <<<<<<<<<<<<<<
 *     X,
 *     *,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_172assert_all_finite(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_X, PyObject *__pyx_v_allow_nan, PyObject *__pyx_v_estimator_name, PyObject *__pyx_v_input_name) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("assert_all_finite", 0);

  /* "validator.pyx":5312
 *         documentation.
 *     """
 *     _assert_all_finite(             # <<<<<<<<<<<<<<
 *         X.data if sp.issparse(X) else X,
 *         allow_nan=allow_nan,
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_assert_all_finite); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5312, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);

  /* "validator.pyx":5313
 *     """
 *     _assert_all_finite(
 *         X.data if sp.issparse(X) else X,             # <<<<<<<<<<<<<<
 *         allow_nan=allow_nan,
 *         estimator_name=estimator_name,
 */
  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_sp); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5313, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_issparse); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 5313, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = NULL;
  if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
    }
  }
  __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_4, __pyx_v_X) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_X);
  __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5313, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 5313, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_6) {
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_X, __pyx_n_s_data); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5313, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_2 = __pyx_t_3;
    __pyx_t_3 = 0;
  } else {
    __Pyx_INCREF(__pyx_v_X);
    __pyx_t_2 = __pyx_v_X;
  }

  /* "validator.pyx":5312
 *         documentation.
 *     """
 *     _assert_all_finite(             # <<<<<<<<<<<<<<
 *         X.data if sp.issparse(X) else X,
 *         allow_nan=allow_nan,
 */
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5312, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
  __pyx_t_2 = 0;

  /* "validator.pyx":5314
 *     _assert_all_finite(
 *         X.data if sp.issparse(X) else X,
 *         allow_nan=allow_nan,             # <<<<<<<<<<<<<<
 *         estimator_name=estimator_name,
 *         input_name=input_name,
 */
  __pyx_t_2 = __Pyx_PyDict_NewPresized(3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5314, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_allow_nan_2, __pyx_v_allow_nan) < 0) __PYX_ERR(0, 5314, __pyx_L1_error)

  /* "validator.pyx":5315
 *         X.data if sp.issparse(X) else X,
 *         allow_nan=allow_nan,
 *         estimator_name=estimator_name,             # <<<<<<<<<<<<<<
 *         input_name=input_name,
 *     )
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_estimator_name, __pyx_v_estimator_name) < 0) __PYX_ERR(0, 5314, __pyx_L1_error)

  /* "validator.pyx":5316
 *         allow_nan=allow_nan,
 *         estimator_name=estimator_name,
 *         input_name=input_name,             # <<<<<<<<<<<<<<
 *     )
 * 
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_input_name, __pyx_v_input_name) < 0) __PYX_ERR(0, 5314, __pyx_L1_error)

  /* "validator.pyx":5312
 *         documentation.
 *     """
 *     _assert_all_finite(             # <<<<<<<<<<<<<<
 *         X.data if sp.issparse(X) else X,
 *         allow_nan=allow_nan,
 */
  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 5312, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

  /* "validator.pyx":5290
 *         raise ValueError(msg_err)
 * 
 * def assert_all_finite(             # <<<<<<<<<<<<<<
 *     X,
 *     *,
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("validator.assert_all_finite", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "validator.pyx":5319
 *     )
 * 
 * def _generate_get_feature_names_out(estimator, n_features_out, input_features=None):             # <<<<<<<<<<<<<<
 *     """Generate feature names out for estimator using the estimator name as the prefix.
 *     The input_feature names are validated but not used. This function is useful
 */

/* Python wrapper */
static PyObject *__pyx_pw_9validator_175_generate_get_feature_names_out(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_9validator_174_generate_get_feature_names_out[] = "Generate feature names out for estimator using the estimator name as the prefix.\n    The input_feature names are validated but not used. This function is useful\n    for estimators that generate their own names based on `n_features_out`, i.e. PCA.\n    Parameters\n    ----------\n    estimator : estimator instance\n        Estimator producing output feature names.\n    n_feature_out : int\n        Number of feature names out.\n    input_features : array-like of str or None, default=None\n        Only used to validate feature names with `estimator.feature_names_in_`.\n    Returns\n    -------\n    feature_names_in : ndarray of str or `None`\n        Feature names in.\n    ";
static PyMethodDef __pyx_mdef_9validator_175_generate_get_feature_names_out = {"_generate_get_feature_names_out", (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_9validator_175_generate_get_feature_names_out, METH_VARARGS|METH_KEYWORDS, __pyx_doc_9validator_174_generate_get_feature_names_out};
static PyObject *__pyx_pw_9validator_175_generate_get_feature_names_out(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_estimator = 0;
  PyObject *__pyx_v_n_features_out = 0;
  PyObject *__pyx_v_input_features = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_generate_get_feature_names_out (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_estimator,&__pyx_n_s_n_features_out,&__pyx_n_s_input_features,0};
    PyObject* values[3] = {0,0,0};
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        CYTHON_FALLTHROUGH;
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        CYTHON_FALLTHROUGH;
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_estimator)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        CYTHON_FALLTHROUGH;
        case  1:
        if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_n_features_out)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("_generate_get_feature_names_out", 0, 2, 3, 1); __PYX_ERR(0, 5319, __pyx_L3_error)
        }
        CYTHON_FALLTHROUGH;
        case  2:
        if (kw_args > 0) {
          PyObject* value = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_input_features);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_generate_get_feature_names_out") < 0)) __PYX_ERR(0, 5319, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        CYTHON_FALLTHROUGH;
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_estimator = values[0];
    __pyx_v_n_features_out = values[1];
    __pyx_v_input_features = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_generate_get_feature_names_out", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 5319, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("validator._generate_get_feature_names_out", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_9validator_174_generate_get_feature_names_out(__pyx_self, __pyx_v_estimator, __pyx_v_n_features_out, __pyx_v_input_features);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_9validator_174_generate_get_feature_names_out(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_estimator, PyObject *__pyx_v_n_features_out, PyObject *__pyx_v_input_features) {
  PyObject *__pyx_v_estimator_name = NULL;
  PyObject *__pyx_9genexpr32__pyx_v_i = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  Py_ssize_t __pyx_t_5;
  PyObject *(*__pyx_t_6)(PyObject *);
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("_generate_get_feature_names_out", 0);

  /* "validator.pyx":5336
 *         Feature names in.
 *     """
 *     _check_feature_names_in(estimator, input_features, generate_names=False)             # <<<<<<<<<<<<<<
 *     estimator_name = estimator.__class__.__name__.lower()
 *     return np.asarray(
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_check_feature_names_in); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5336, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5336, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_estimator);
  __Pyx_GIVEREF(__pyx_v_estimator);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_estimator);
  __Pyx_INCREF(__pyx_v_input_features);
  __Pyx_GIVEREF(__pyx_v_input_features);
  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_v_input_features);
  __pyx_t_3 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5336, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_generate_names, Py_False) < 0) __PYX_ERR(0, 5336, __pyx_L1_error)
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5336, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "validator.pyx":5337
 *     """
 *     _check_feature_names_in(estimator, input_features, generate_names=False)
 *     estimator_name = estimator.__class__.__name__.lower()             # <<<<<<<<<<<<<<
 *     return np.asarray(
 *         [f"{estimator_name}{i}" for i in range(n_features_out)], dtype=object
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_estimator, __pyx_n_s_class); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5337, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5337, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_lower); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5337, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  __pyx_t_4 = (__pyx_t_2) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2) : __Pyx_PyObject_CallNoArg(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5337, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_estimator_name = __pyx_t_4;
  __pyx_t_4 = 0;

  /* "validator.pyx":5338
 *     _check_feature_names_in(estimator, input_features, generate_names=False)
 *     estimator_name = estimator.__class__.__name__.lower()
 *     return np.asarray(             # <<<<<<<<<<<<<<
 *         [f"{estimator_name}{i}" for i in range(n_features_out)], dtype=object
 *     )
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_np); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5338, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_asarray); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5338, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  { /* enter inner scope */

    /* "validator.pyx":5339
 *     estimator_name = estimator.__class__.__name__.lower()
 *     return np.asarray(
 *         [f"{estimator_name}{i}" for i in range(n_features_out)], dtype=object             # <<<<<<<<<<<<<<
 *     )
 * 
 */
    __pyx_t_4 = PyList_New(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5339, __pyx_L5_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_builtin_range, __pyx_v_n_features_out); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5339, __pyx_L5_error)
    __Pyx_GOTREF(__pyx_t_2);
    if (likely(PyList_CheckExact(__pyx_t_2)) || PyTuple_CheckExact(__pyx_t_2)) {
      __pyx_t_1 = __pyx_t_2; __Pyx_INCREF(__pyx_t_1); __pyx_t_5 = 0;
      __pyx_t_6 = NULL;
    } else {
      __pyx_t_5 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5339, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_6 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 5339, __pyx_L5_error)
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    for (;;) {
      if (likely(!__pyx_t_6)) {
        if (likely(PyList_CheckExact(__pyx_t_1))) {
          if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_1)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_2 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_5); __Pyx_INCREF(__pyx_t_2); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 5339, __pyx_L5_error)
          #else
          __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5339, __pyx_L5_error)
          __Pyx_GOTREF(__pyx_t_2);
          #endif
        } else {
          if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
          #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
          __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_5); __Pyx_INCREF(__pyx_t_2); __pyx_t_5++; if (unlikely(0 < 0)) __PYX_ERR(0, 5339, __pyx_L5_error)
          #else
          __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_5); __pyx_t_5++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5339, __pyx_L5_error)
          __Pyx_GOTREF(__pyx_t_2);
          #endif
        }
      } else {
        __pyx_t_2 = __pyx_t_6(__pyx_t_1);
        if (unlikely(!__pyx_t_2)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else __PYX_ERR(0, 5339, __pyx_L5_error)
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_2);
      }
      __Pyx_XDECREF_SET(__pyx_9genexpr32__pyx_v_i, __pyx_t_2);
      __pyx_t_2 = 0;
      __pyx_t_2 = __Pyx_PyObject_FormatSimple(__pyx_v_estimator_name, __pyx_empty_unicode); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5339, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_7 = __Pyx_PyObject_FormatSimple(__pyx_9genexpr32__pyx_v_i, __pyx_empty_unicode); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 5339, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_8 = __Pyx_PyUnicode_Concat(__pyx_t_2, __pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 5339, __pyx_L5_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_4, (PyObject*)__pyx_t_8))) __PYX_ERR(0, 5339, __pyx_L5_error)
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_XDECREF(__pyx_9genexpr32__pyx_v_i); __pyx_9genexpr32__pyx_v_i = 0;
    goto __pyx_L8_exit_scope;
    __pyx_L5_error:;
    __Pyx_XDECREF(__pyx_9genexpr32__pyx_v_i); __pyx_9genexpr32__pyx_v_i = 0;
    goto __pyx_L1_error;
    __pyx_L8_exit_scope:;
  } /* exit inner scope */

  /* "validator.pyx":5338
 *     _check_feature_names_in(estimator, input_features, generate_names=False)
 *     estimator_name = estimator.__class__.__name__.lower()
 *     return np.asarray(             # <<<<<<<<<<<<<<
 *         [f"{estimator_name}{i}" for i in range(n_features_out)], dtype=object
 *     )
 */
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5338, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_4);
  __pyx_t_4 = 0;

  /* "validator.pyx":5339
 *     estimator_name = estimator.__class__.__name__.lower()
 *     return np.asarray(
 *         [f"{estimator_name}{i}" for i in range(n_features_out)], dtype=object             # <<<<<<<<<<<<<<
 *     )
 * 
 */
  __pyx_t_4 = __Pyx_PyDict_NewPresized(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5339, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_t_4, __pyx_n_s_dtype, __pyx_builtin_object) < 0) __PYX_ERR(0, 5339, __pyx_L1_error)

  /* "validator.pyx":5338
 *     _check_feature_names_in(estimator, input_features, generate_names=False)
 *     estimator_name = estimator.__class__.__name__.lower()
 *     return np.asarray(             # <<<<<<<<<<<<<<
 *         [f"{estimator_name}{i}" for i in range(n_features_out)], dtype=object
 *     )
 */
  __pyx_t_8 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_1, __pyx_t_4); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 5338, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_r = __pyx_t_8;
  __pyx_t_8 = 0;
  goto __pyx_L0;

  /* "validator.pyx":5319
 *     )
 * 
 * def _generate_get_feature_names_out(estimator, n_features_out, input_features=None):             # <<<<<<<<<<<<<<
 *     """Generate feature names out for estimator using the estimator name as the prefix.
 *     The input_feature names are validated but not used. This function is useful
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("validator._generate_get_feature_names_out", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_estimator_name);
  __Pyx_XDECREF(__pyx_9genexpr32__pyx_v_i);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static struct __pyx_obj_9validator___pyx_scope_struct__validate_scores *__pyx_freelist_9validator___pyx_scope_struct__validate_scores[8];
static int __pyx_freecount_9validator___pyx_scope_struct__validate_scores = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct__validate_scores(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct__validate_scores > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct__validate_scores)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct__validate_scores[--__pyx_freecount_9validator___pyx_scope_struct__validate_scores];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct__validate_scores));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct__validate_scores(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct__validate_scores *p = (struct __pyx_obj_9validator___pyx_scope_struct__validate_scores *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_mode);
  Py_CLEAR(p->__pyx_v_scores);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct__validate_scores < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct__validate_scores)))) {
    __pyx_freelist_9validator___pyx_scope_struct__validate_scores[__pyx_freecount_9validator___pyx_scope_struct__validate_scores++] = ((struct __pyx_obj_9validator___pyx_scope_struct__validate_scores *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct__validate_scores(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct__validate_scores *p = (struct __pyx_obj_9validator___pyx_scope_struct__validate_scores *)o;
  if (p->__pyx_v_mode) {
    e = (*v)(p->__pyx_v_mode, a); if (e) return e;
  }
  if (p->__pyx_v_scores) {
    e = (*v)(p->__pyx_v_scores, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9validator___pyx_scope_struct__validate_scores(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9validator___pyx_scope_struct__validate_scores *p = (struct __pyx_obj_9validator___pyx_scope_struct__validate_scores *)o;
  tmp = ((PyObject*)p->__pyx_v_mode);
  p->__pyx_v_mode = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_scores);
  p->__pyx_v_scores = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct__validate_scores = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct__validate_scores", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct__validate_scores), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct__validate_scores, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct__validate_scores, /*tp_traverse*/
  __pyx_tp_clear_9validator___pyx_scope_struct__validate_scores, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct__validate_scores, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_1_genexpr *__pyx_freelist_9validator___pyx_scope_struct_1_genexpr[8];
static int __pyx_freecount_9validator___pyx_scope_struct_1_genexpr = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_1_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_1_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_1_genexpr)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_1_genexpr[--__pyx_freecount_9validator___pyx_scope_struct_1_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_1_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_1_genexpr(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_1_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_1_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_score);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_1_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_1_genexpr)))) {
    __pyx_freelist_9validator___pyx_scope_struct_1_genexpr[__pyx_freecount_9validator___pyx_scope_struct_1_genexpr++] = ((struct __pyx_obj_9validator___pyx_scope_struct_1_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_1_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_1_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_1_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_score) {
    e = (*v)(p->__pyx_v_score, a); if (e) return e;
  }
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_1_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_1_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_1_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_1_genexpr, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_1_genexpr, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_1_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types *__pyx_freelist_9validator___pyx_scope_struct_2_validate_data_types[8];
static int __pyx_freecount_9validator___pyx_scope_struct_2_validate_data_types = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_2_validate_data_types(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_2_validate_data_types > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_2_validate_data_types[--__pyx_freecount_9validator___pyx_scope_struct_2_validate_data_types];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_2_validate_data_types(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types *p = (struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_error);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_2_validate_data_types < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types)))) {
    __pyx_freelist_9validator___pyx_scope_struct_2_validate_data_types[__pyx_freecount_9validator___pyx_scope_struct_2_validate_data_types++] = ((struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_2_validate_data_types(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types *p = (struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types *)o;
  if (p->__pyx_v_error) {
    e = (*v)(p->__pyx_v_error, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9validator___pyx_scope_struct_2_validate_data_types(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types *p = (struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types *)o;
  tmp = ((PyObject*)p->__pyx_v_error);
  p->__pyx_v_error = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_2_validate_data_types = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_2_validate_data_types", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_2_validate_data_types), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_2_validate_data_types, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_2_validate_data_types, /*tp_traverse*/
  __pyx_tp_clear_9validator___pyx_scope_struct_2_validate_data_types, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_2_validate_data_types, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator *__pyx_freelist_9validator___pyx_scope_struct_3_parameter_validator[8];
static int __pyx_freecount_9validator___pyx_scope_struct_3_parameter_validator = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_3_parameter_validator(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_3_parameter_validator > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_3_parameter_validator[--__pyx_freecount_9validator___pyx_scope_struct_3_parameter_validator];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_3_parameter_validator(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator *p = (struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_kws);
  Py_CLEAR(p->__pyx_v_match_method);
  Py_CLEAR(p->__pyx_v_normalize_string);
  Py_CLEAR(p->__pyx_v_raise_exception);
  Py_CLEAR(p->__pyx_v_target_strs);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_3_parameter_validator < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator)))) {
    __pyx_freelist_9validator___pyx_scope_struct_3_parameter_validator[__pyx_freecount_9validator___pyx_scope_struct_3_parameter_validator++] = ((struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_3_parameter_validator(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator *p = (struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator *)o;
  if (p->__pyx_v_kws) {
    e = (*v)(p->__pyx_v_kws, a); if (e) return e;
  }
  if (p->__pyx_v_match_method) {
    e = (*v)(p->__pyx_v_match_method, a); if (e) return e;
  }
  if (p->__pyx_v_normalize_string) {
    e = (*v)(p->__pyx_v_normalize_string, a); if (e) return e;
  }
  if (p->__pyx_v_raise_exception) {
    e = (*v)(p->__pyx_v_raise_exception, a); if (e) return e;
  }
  if (p->__pyx_v_target_strs) {
    e = (*v)(p->__pyx_v_target_strs, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9validator___pyx_scope_struct_3_parameter_validator(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator *p = (struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator *)o;
  tmp = ((PyObject*)p->__pyx_v_kws);
  p->__pyx_v_kws = ((PyObject*)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_match_method);
  p->__pyx_v_match_method = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_normalize_string);
  p->__pyx_v_normalize_string = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_raise_exception);
  p->__pyx_v_raise_exception = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_target_strs);
  p->__pyx_v_target_strs = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_3_parameter_validator = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_3_parameter_validator", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_3_parameter_validator), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_3_parameter_validator, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_3_parameter_validator, /*tp_traverse*/
  __pyx_tp_clear_9validator___pyx_scope_struct_3_parameter_validator, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_3_parameter_validator, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_4_validate_length_range *__pyx_freelist_9validator___pyx_scope_struct_4_validate_length_range[8];
static int __pyx_freecount_9validator___pyx_scope_struct_4_validate_length_range = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_4_validate_length_range(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_4_validate_length_range > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_4_validate_length_range)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_4_validate_length_range[--__pyx_freecount_9validator___pyx_scope_struct_4_validate_length_range];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_4_validate_length_range));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_4_validate_length_range(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_4_validate_length_range *p = (struct __pyx_obj_9validator___pyx_scope_struct_4_validate_length_range *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_length_range);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_4_validate_length_range < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_4_validate_length_range)))) {
    __pyx_freelist_9validator___pyx_scope_struct_4_validate_length_range[__pyx_freecount_9validator___pyx_scope_struct_4_validate_length_range++] = ((struct __pyx_obj_9validator___pyx_scope_struct_4_validate_length_range *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_4_validate_length_range(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_4_validate_length_range *p = (struct __pyx_obj_9validator___pyx_scope_struct_4_validate_length_range *)o;
  if (p->__pyx_v_length_range) {
    e = (*v)(p->__pyx_v_length_range, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9validator___pyx_scope_struct_4_validate_length_range(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9validator___pyx_scope_struct_4_validate_length_range *p = (struct __pyx_obj_9validator___pyx_scope_struct_4_validate_length_range *)o;
  tmp = ((PyObject*)p->__pyx_v_length_range);
  p->__pyx_v_length_range = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_4_validate_length_range = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_4_validate_length_range", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_4_validate_length_range), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_4_validate_length_range, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_4_validate_length_range, /*tp_traverse*/
  __pyx_tp_clear_9validator___pyx_scope_struct_4_validate_length_range, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_4_validate_length_range, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_5_genexpr *__pyx_freelist_9validator___pyx_scope_struct_5_genexpr[8];
static int __pyx_freecount_9validator___pyx_scope_struct_5_genexpr = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_5_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_5_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_5_genexpr)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_5_genexpr[--__pyx_freecount_9validator___pyx_scope_struct_5_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_5_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_5_genexpr(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_5_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_5_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_x);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_5_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_5_genexpr)))) {
    __pyx_freelist_9validator___pyx_scope_struct_5_genexpr[__pyx_freecount_9validator___pyx_scope_struct_5_genexpr++] = ((struct __pyx_obj_9validator___pyx_scope_struct_5_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_5_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_5_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_5_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_x) {
    e = (*v)(p->__pyx_v_x, a); if (e) return e;
  }
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_5_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_5_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_5_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_5_genexpr, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_5_genexpr, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_5_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects *__pyx_freelist_9validator___pyx_scope_struct_6_contains_nested_objects[8];
static int __pyx_freecount_9validator___pyx_scope_struct_6_contains_nested_objects = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_6_contains_nested_objects(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_6_contains_nested_objects > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_6_contains_nested_objects[--__pyx_freecount_9validator___pyx_scope_struct_6_contains_nested_objects];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_6_contains_nested_objects(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects *p = (struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_allowed_types);
  Py_CLEAR(p->__pyx_v_is_nested);
  Py_CLEAR(p->__pyx_v_lst);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_6_contains_nested_objects < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects)))) {
    __pyx_freelist_9validator___pyx_scope_struct_6_contains_nested_objects[__pyx_freecount_9validator___pyx_scope_struct_6_contains_nested_objects++] = ((struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_6_contains_nested_objects(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects *p = (struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects *)o;
  if (p->__pyx_v_allowed_types) {
    e = (*v)(p->__pyx_v_allowed_types, a); if (e) return e;
  }
  if (p->__pyx_v_is_nested) {
    e = (*v)(p->__pyx_v_is_nested, a); if (e) return e;
  }
  if (p->__pyx_v_lst) {
    e = (*v)(p->__pyx_v_lst, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9validator___pyx_scope_struct_6_contains_nested_objects(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects *p = (struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects *)o;
  tmp = ((PyObject*)p->__pyx_v_allowed_types);
  p->__pyx_v_allowed_types = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_is_nested);
  p->__pyx_v_is_nested = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_lst);
  p->__pyx_v_lst = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_6_contains_nested_objects = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_6_contains_nested_objects", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_6_contains_nested_objects), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_6_contains_nested_objects, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_6_contains_nested_objects, /*tp_traverse*/
  __pyx_tp_clear_9validator___pyx_scope_struct_6_contains_nested_objects, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_6_contains_nested_objects, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_7_genexpr *__pyx_freelist_9validator___pyx_scope_struct_7_genexpr[8];
static int __pyx_freecount_9validator___pyx_scope_struct_7_genexpr = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_7_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_7_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_7_genexpr)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_7_genexpr[--__pyx_freecount_9validator___pyx_scope_struct_7_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_7_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_7_genexpr(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_7_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_7_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_item);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_7_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_7_genexpr)))) {
    __pyx_freelist_9validator___pyx_scope_struct_7_genexpr[__pyx_freecount_9validator___pyx_scope_struct_7_genexpr++] = ((struct __pyx_obj_9validator___pyx_scope_struct_7_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_7_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_7_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_7_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_item) {
    e = (*v)(p->__pyx_v_item, a); if (e) return e;
  }
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_7_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_7_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_7_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_7_genexpr, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_7_genexpr, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_7_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_8_genexpr *__pyx_freelist_9validator___pyx_scope_struct_8_genexpr[8];
static int __pyx_freecount_9validator___pyx_scope_struct_8_genexpr = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_8_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_8_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_8_genexpr)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_8_genexpr[--__pyx_freecount_9validator___pyx_scope_struct_8_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_8_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_8_genexpr(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_8_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_8_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_item);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_8_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_8_genexpr)))) {
    __pyx_freelist_9validator___pyx_scope_struct_8_genexpr[__pyx_freecount_9validator___pyx_scope_struct_8_genexpr++] = ((struct __pyx_obj_9validator___pyx_scope_struct_8_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_8_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_8_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_8_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_item) {
    e = (*v)(p->__pyx_v_item, a); if (e) return e;
  }
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_8_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_8_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_8_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_8_genexpr, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_8_genexpr, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_8_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy *__pyx_freelist_9validator___pyx_scope_struct_9_validate_nan_policy[8];
static int __pyx_freecount_9validator___pyx_scope_struct_9_validate_nan_policy = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_9_validate_nan_policy(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_9_validate_nan_policy > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_9_validate_nan_policy[--__pyx_freecount_9validator___pyx_scope_struct_9_validate_nan_policy];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_9_validate_nan_policy(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy *p = (struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_arrays);
  Py_CLEAR(p->__pyx_v_not_nan_mask);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_9_validate_nan_policy < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy)))) {
    __pyx_freelist_9validator___pyx_scope_struct_9_validate_nan_policy[__pyx_freecount_9validator___pyx_scope_struct_9_validate_nan_policy++] = ((struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_9_validate_nan_policy(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy *p = (struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy *)o;
  if (p->__pyx_v_arrays) {
    e = (*v)(p->__pyx_v_arrays, a); if (e) return e;
  }
  if (p->__pyx_v_not_nan_mask) {
    e = (*v)(p->__pyx_v_not_nan_mask, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9validator___pyx_scope_struct_9_validate_nan_policy(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy *p = (struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy *)o;
  tmp = ((PyObject*)p->__pyx_v_arrays);
  p->__pyx_v_arrays = ((PyObject*)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_not_nan_mask);
  p->__pyx_v_not_nan_mask = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_9_validate_nan_policy = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_9_validate_nan_policy", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_9_validate_nan_policy), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_9_validate_nan_policy, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_9_validate_nan_policy, /*tp_traverse*/
  __pyx_tp_clear_9validator___pyx_scope_struct_9_validate_nan_policy, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_9_validate_nan_policy, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_10_genexpr *__pyx_freelist_9validator___pyx_scope_struct_10_genexpr[8];
static int __pyx_freecount_9validator___pyx_scope_struct_10_genexpr = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_10_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_10_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_10_genexpr)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_10_genexpr[--__pyx_freecount_9validator___pyx_scope_struct_10_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_10_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_10_genexpr(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_10_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_10_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_array);
  Py_CLEAR(p->__pyx_t_0);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_10_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_10_genexpr)))) {
    __pyx_freelist_9validator___pyx_scope_struct_10_genexpr[__pyx_freecount_9validator___pyx_scope_struct_10_genexpr++] = ((struct __pyx_obj_9validator___pyx_scope_struct_10_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_10_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_10_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_10_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_array) {
    e = (*v)(p->__pyx_v_array, a); if (e) return e;
  }
  if (p->__pyx_t_0) {
    e = (*v)(p->__pyx_t_0, a); if (e) return e;
  }
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_10_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_10_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_10_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_10_genexpr, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_10_genexpr, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_10_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_11_genexpr *__pyx_freelist_9validator___pyx_scope_struct_11_genexpr[8];
static int __pyx_freecount_9validator___pyx_scope_struct_11_genexpr = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_11_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_11_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_11_genexpr)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_11_genexpr[--__pyx_freecount_9validator___pyx_scope_struct_11_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_11_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_11_genexpr(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_11_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_11_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_array);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_11_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_11_genexpr)))) {
    __pyx_freelist_9validator___pyx_scope_struct_11_genexpr[__pyx_freecount_9validator___pyx_scope_struct_11_genexpr++] = ((struct __pyx_obj_9validator___pyx_scope_struct_11_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_11_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_11_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_11_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_array) {
    e = (*v)(p->__pyx_v_array, a); if (e) return e;
  }
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_11_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_11_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_11_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_11_genexpr, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_11_genexpr, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_11_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_12_check_classification_targets *__pyx_freelist_9validator___pyx_scope_struct_12_check_classification_targets[8];
static int __pyx_freecount_9validator___pyx_scope_struct_12_check_classification_targets = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_12_check_classification_targets(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_12_check_classification_targets > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_12_check_classification_targets)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_12_check_classification_targets[--__pyx_freecount_9validator___pyx_scope_struct_12_check_classification_targets];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_12_check_classification_targets));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_12_check_classification_targets(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_12_check_classification_targets *p = (struct __pyx_obj_9validator___pyx_scope_struct_12_check_classification_targets *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_target);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_12_check_classification_targets < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_12_check_classification_targets)))) {
    __pyx_freelist_9validator___pyx_scope_struct_12_check_classification_targets[__pyx_freecount_9validator___pyx_scope_struct_12_check_classification_targets++] = ((struct __pyx_obj_9validator___pyx_scope_struct_12_check_classification_targets *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_12_check_classification_targets(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_12_check_classification_targets *p = (struct __pyx_obj_9validator___pyx_scope_struct_12_check_classification_targets *)o;
  if (p->__pyx_v_target) {
    e = (*v)(p->__pyx_v_target, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9validator___pyx_scope_struct_12_check_classification_targets(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9validator___pyx_scope_struct_12_check_classification_targets *p = (struct __pyx_obj_9validator___pyx_scope_struct_12_check_classification_targets *)o;
  tmp = ((PyObject*)p->__pyx_v_target);
  p->__pyx_v_target = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_12_check_classification_targets = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_12_check_classification_targets", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_12_check_classification_targets), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_12_check_classification_targets, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_12_check_classification_targets, /*tp_traverse*/
  __pyx_tp_clear_9validator___pyx_scope_struct_12_check_classification_targets, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_12_check_classification_targets, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_13_genexpr *__pyx_freelist_9validator___pyx_scope_struct_13_genexpr[8];
static int __pyx_freecount_9validator___pyx_scope_struct_13_genexpr = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_13_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_13_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_13_genexpr)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_13_genexpr[--__pyx_freecount_9validator___pyx_scope_struct_13_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_13_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_13_genexpr(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_13_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_13_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_item);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_13_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_13_genexpr)))) {
    __pyx_freelist_9validator___pyx_scope_struct_13_genexpr[__pyx_freecount_9validator___pyx_scope_struct_13_genexpr++] = ((struct __pyx_obj_9validator___pyx_scope_struct_13_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_13_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_13_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_13_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_item) {
    e = (*v)(p->__pyx_v_item, a); if (e) return e;
  }
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_13_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_13_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_13_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_13_genexpr, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_13_genexpr, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_13_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_14__check_y *__pyx_freelist_9validator___pyx_scope_struct_14__check_y[8];
static int __pyx_freecount_9validator___pyx_scope_struct_14__check_y = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_14__check_y(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_14__check_y > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_14__check_y)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_14__check_y[--__pyx_freecount_9validator___pyx_scope_struct_14__check_y];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_14__check_y));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_14__check_y(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_14__check_y *p = (struct __pyx_obj_9validator___pyx_scope_struct_14__check_y *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_unique_values);
  Py_CLEAR(p->__pyx_v_y);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_14__check_y < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_14__check_y)))) {
    __pyx_freelist_9validator___pyx_scope_struct_14__check_y[__pyx_freecount_9validator___pyx_scope_struct_14__check_y++] = ((struct __pyx_obj_9validator___pyx_scope_struct_14__check_y *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_14__check_y(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_14__check_y *p = (struct __pyx_obj_9validator___pyx_scope_struct_14__check_y *)o;
  if (p->__pyx_v_unique_values) {
    e = (*v)(p->__pyx_v_unique_values, a); if (e) return e;
  }
  if (p->__pyx_v_y) {
    e = (*v)(p->__pyx_v_y, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9validator___pyx_scope_struct_14__check_y(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9validator___pyx_scope_struct_14__check_y *p = (struct __pyx_obj_9validator___pyx_scope_struct_14__check_y *)o;
  tmp = ((PyObject*)p->__pyx_v_unique_values);
  p->__pyx_v_unique_values = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_y);
  p->__pyx_v_y = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_14__check_y = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_14__check_y", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_14__check_y), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_14__check_y, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_14__check_y, /*tp_traverse*/
  __pyx_tp_clear_9validator___pyx_scope_struct_14__check_y, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_14__check_y, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_15_genexpr *__pyx_freelist_9validator___pyx_scope_struct_15_genexpr[8];
static int __pyx_freecount_9validator___pyx_scope_struct_15_genexpr = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_15_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_15_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_15_genexpr)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_15_genexpr[--__pyx_freecount_9validator___pyx_scope_struct_15_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_15_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_15_genexpr(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_15_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_15_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_el);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_15_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_15_genexpr)))) {
    __pyx_freelist_9validator___pyx_scope_struct_15_genexpr[__pyx_freecount_9validator___pyx_scope_struct_15_genexpr++] = ((struct __pyx_obj_9validator___pyx_scope_struct_15_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_15_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_15_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_15_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_el) {
    e = (*v)(p->__pyx_v_el, a); if (e) return e;
  }
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_15_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_15_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_15_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_15_genexpr, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_15_genexpr, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_15_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_16_genexpr *__pyx_freelist_9validator___pyx_scope_struct_16_genexpr[8];
static int __pyx_freecount_9validator___pyx_scope_struct_16_genexpr = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_16_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_16_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_16_genexpr)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_16_genexpr[--__pyx_freecount_9validator___pyx_scope_struct_16_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_16_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_16_genexpr(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_16_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_16_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_val);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_16_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_16_genexpr)))) {
    __pyx_freelist_9validator___pyx_scope_struct_16_genexpr[__pyx_freecount_9validator___pyx_scope_struct_16_genexpr++] = ((struct __pyx_obj_9validator___pyx_scope_struct_16_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_16_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_16_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_16_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_val) {
    e = (*v)(p->__pyx_v_val, a); if (e) return e;
  }
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_16_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_16_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_16_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_16_genexpr, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_16_genexpr, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_16_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_17_has_required_attributes *__pyx_freelist_9validator___pyx_scope_struct_17_has_required_attributes[8];
static int __pyx_freecount_9validator___pyx_scope_struct_17_has_required_attributes = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_17_has_required_attributes(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_17_has_required_attributes > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_17_has_required_attributes)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_17_has_required_attributes[--__pyx_freecount_9validator___pyx_scope_struct_17_has_required_attributes];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_17_has_required_attributes));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_17_has_required_attributes(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_17_has_required_attributes *p = (struct __pyx_obj_9validator___pyx_scope_struct_17_has_required_attributes *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_attributes);
  Py_CLEAR(p->__pyx_v_model);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_17_has_required_attributes < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_17_has_required_attributes)))) {
    __pyx_freelist_9validator___pyx_scope_struct_17_has_required_attributes[__pyx_freecount_9validator___pyx_scope_struct_17_has_required_attributes++] = ((struct __pyx_obj_9validator___pyx_scope_struct_17_has_required_attributes *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_17_has_required_attributes(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_17_has_required_attributes *p = (struct __pyx_obj_9validator___pyx_scope_struct_17_has_required_attributes *)o;
  if (p->__pyx_v_attributes) {
    e = (*v)(p->__pyx_v_attributes, a); if (e) return e;
  }
  if (p->__pyx_v_model) {
    e = (*v)(p->__pyx_v_model, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9validator___pyx_scope_struct_17_has_required_attributes(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9validator___pyx_scope_struct_17_has_required_attributes *p = (struct __pyx_obj_9validator___pyx_scope_struct_17_has_required_attributes *)o;
  tmp = ((PyObject*)p->__pyx_v_attributes);
  p->__pyx_v_attributes = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_model);
  p->__pyx_v_model = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_17_has_required_attributes = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_17_has_required_attributes", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_17_has_required_attributes), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_17_has_required_attributes, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_17_has_required_attributes, /*tp_traverse*/
  __pyx_tp_clear_9validator___pyx_scope_struct_17_has_required_attributes, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_17_has_required_attributes, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_18_genexpr *__pyx_freelist_9validator___pyx_scope_struct_18_genexpr[8];
static int __pyx_freecount_9validator___pyx_scope_struct_18_genexpr = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_18_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_18_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_18_genexpr)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_18_genexpr[--__pyx_freecount_9validator___pyx_scope_struct_18_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_18_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_18_genexpr(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_18_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_18_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_attr);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_18_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_18_genexpr)))) {
    __pyx_freelist_9validator___pyx_scope_struct_18_genexpr[__pyx_freecount_9validator___pyx_scope_struct_18_genexpr++] = ((struct __pyx_obj_9validator___pyx_scope_struct_18_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_18_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_18_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_18_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_attr) {
    e = (*v)(p->__pyx_v_attr, a); if (e) return e;
  }
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_18_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_18_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_18_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_18_genexpr, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_18_genexpr, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_18_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates *__pyx_freelist_9validator___pyx_scope_struct_19_validate_dates[8];
static int __pyx_freecount_9validator___pyx_scope_struct_19_validate_dates = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_19_validate_dates(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_19_validate_dates > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_19_validate_dates[--__pyx_freecount_9validator___pyx_scope_struct_19_validate_dates];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_19_validate_dates(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates *p = (struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_date_format);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_19_validate_dates < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates)))) {
    __pyx_freelist_9validator___pyx_scope_struct_19_validate_dates[__pyx_freecount_9validator___pyx_scope_struct_19_validate_dates++] = ((struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_19_validate_dates(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates *p = (struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates *)o;
  if (p->__pyx_v_date_format) {
    e = (*v)(p->__pyx_v_date_format, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9validator___pyx_scope_struct_19_validate_dates(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates *p = (struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates *)o;
  tmp = ((PyObject*)p->__pyx_v_date_format);
  p->__pyx_v_date_format = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_19_validate_dates = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_19_validate_dates", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_19_validate_dates), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_19_validate_dates, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_19_validate_dates, /*tp_traverse*/
  __pyx_tp_clear_9validator___pyx_scope_struct_19_validate_dates, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_19_validate_dates, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_20_validate_and_adjust_ranges *__pyx_freelist_9validator___pyx_scope_struct_20_validate_and_adjust_ranges[8];
static int __pyx_freecount_9validator___pyx_scope_struct_20_validate_and_adjust_ranges = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_20_validate_and_adjust_ranges(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_20_validate_and_adjust_ranges > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_20_validate_and_adjust_ranges)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_20_validate_and_adjust_ranges[--__pyx_freecount_9validator___pyx_scope_struct_20_validate_and_adjust_ranges];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_20_validate_and_adjust_ranges));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_20_validate_and_adjust_ranges(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_20_validate_and_adjust_ranges *p = (struct __pyx_obj_9validator___pyx_scope_struct_20_validate_and_adjust_ranges *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_range_tuple);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_20_validate_and_adjust_ranges < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_20_validate_and_adjust_ranges)))) {
    __pyx_freelist_9validator___pyx_scope_struct_20_validate_and_adjust_ranges[__pyx_freecount_9validator___pyx_scope_struct_20_validate_and_adjust_ranges++] = ((struct __pyx_obj_9validator___pyx_scope_struct_20_validate_and_adjust_ranges *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_20_validate_and_adjust_ranges(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_20_validate_and_adjust_ranges *p = (struct __pyx_obj_9validator___pyx_scope_struct_20_validate_and_adjust_ranges *)o;
  if (p->__pyx_v_range_tuple) {
    e = (*v)(p->__pyx_v_range_tuple, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9validator___pyx_scope_struct_20_validate_and_adjust_ranges(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9validator___pyx_scope_struct_20_validate_and_adjust_ranges *p = (struct __pyx_obj_9validator___pyx_scope_struct_20_validate_and_adjust_ranges *)o;
  tmp = ((PyObject*)p->__pyx_v_range_tuple);
  p->__pyx_v_range_tuple = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_20_validate_and_adjust_ranges = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_20_validate_and_adjust_ranges", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_20_validate_and_adjust_ranges), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_20_validate_and_adjust_ranges, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_20_validate_and_adjust_ranges, /*tp_traverse*/
  __pyx_tp_clear_9validator___pyx_scope_struct_20_validate_and_adjust_ranges, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_20_validate_and_adjust_ranges, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_21_genexpr *__pyx_freelist_9validator___pyx_scope_struct_21_genexpr[8];
static int __pyx_freecount_9validator___pyx_scope_struct_21_genexpr = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_21_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_21_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_21_genexpr)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_21_genexpr[--__pyx_freecount_9validator___pyx_scope_struct_21_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_21_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_21_genexpr(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_21_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_21_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_value);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_21_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_21_genexpr)))) {
    __pyx_freelist_9validator___pyx_scope_struct_21_genexpr[__pyx_freecount_9validator___pyx_scope_struct_21_genexpr++] = ((struct __pyx_obj_9validator___pyx_scope_struct_21_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_21_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_21_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_21_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_value) {
    e = (*v)(p->__pyx_v_value, a); if (e) return e;
  }
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_21_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_21_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_21_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_21_genexpr, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_21_genexpr, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_21_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *__pyx_freelist_9validator___pyx_scope_struct_22__validate_input[8];
static int __pyx_freecount_9validator___pyx_scope_struct_22__validate_input = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_22__validate_input(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_22__validate_input > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_22__validate_input[--__pyx_freecount_9validator___pyx_scope_struct_22__validate_input];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_22__validate_input(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *p = (struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v__is_arraylike_1d);
  Py_CLEAR(p->__pyx_v_x);
  Py_CLEAR(p->__pyx_v_y);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_22__validate_input < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input)))) {
    __pyx_freelist_9validator___pyx_scope_struct_22__validate_input[__pyx_freecount_9validator___pyx_scope_struct_22__validate_input++] = ((struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_22__validate_input(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *p = (struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *)o;
  if (p->__pyx_v__is_arraylike_1d) {
    e = (*v)(p->__pyx_v__is_arraylike_1d, a); if (e) return e;
  }
  if (p->__pyx_v_x) {
    e = (*v)(p->__pyx_v_x, a); if (e) return e;
  }
  if (p->__pyx_v_y) {
    e = (*v)(p->__pyx_v_y, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9validator___pyx_scope_struct_22__validate_input(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *p = (struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input *)o;
  tmp = ((PyObject*)p->__pyx_v__is_arraylike_1d);
  p->__pyx_v__is_arraylike_1d = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_x);
  p->__pyx_v_x = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_y);
  p->__pyx_v_y = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_22__validate_input = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_22__validate_input", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_22__validate_input), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_22__validate_input, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_22__validate_input, /*tp_traverse*/
  __pyx_tp_clear_9validator___pyx_scope_struct_22__validate_input, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_22__validate_input, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args *__pyx_freelist_9validator___pyx_scope_struct_23__deprecate_positional_args[8];
static int __pyx_freecount_9validator___pyx_scope_struct_23__deprecate_positional_args = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_23__deprecate_positional_args(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_23__deprecate_positional_args > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_23__deprecate_positional_args[--__pyx_freecount_9validator___pyx_scope_struct_23__deprecate_positional_args];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_23__deprecate_positional_args(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args *p = (struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_version);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_23__deprecate_positional_args < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args)))) {
    __pyx_freelist_9validator___pyx_scope_struct_23__deprecate_positional_args[__pyx_freecount_9validator___pyx_scope_struct_23__deprecate_positional_args++] = ((struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_23__deprecate_positional_args(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args *p = (struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args *)o;
  if (p->__pyx_v_version) {
    e = (*v)(p->__pyx_v_version, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9validator___pyx_scope_struct_23__deprecate_positional_args(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args *p = (struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args *)o;
  tmp = ((PyObject*)p->__pyx_v_version);
  p->__pyx_v_version = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_23__deprecate_positional_args = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_23__deprecate_positional_args", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_23__deprecate_positional_args, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_23__deprecate_positional_args, /*tp_traverse*/
  __pyx_tp_clear_9validator___pyx_scope_struct_23__deprecate_positional_args, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_23__deprecate_positional_args, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args *__pyx_freelist_9validator___pyx_scope_struct_24__inner_deprecate_positional_args[8];
static int __pyx_freecount_9validator___pyx_scope_struct_24__inner_deprecate_positional_args = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_24__inner_deprecate_positional_args(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_24__inner_deprecate_positional_args > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_24__inner_deprecate_positional_args[--__pyx_freecount_9validator___pyx_scope_struct_24__inner_deprecate_positional_args];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_24__inner_deprecate_positional_args(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args *p = (struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_all_args);
  Py_CLEAR(p->__pyx_v_f);
  Py_CLEAR(p->__pyx_v_kwonly_args);
  Py_CLEAR(p->__pyx_v_name);
  Py_CLEAR(p->__pyx_v_sig);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_24__inner_deprecate_positional_args < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args)))) {
    __pyx_freelist_9validator___pyx_scope_struct_24__inner_deprecate_positional_args[__pyx_freecount_9validator___pyx_scope_struct_24__inner_deprecate_positional_args++] = ((struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_24__inner_deprecate_positional_args(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args *p = (struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_all_args) {
    e = (*v)(p->__pyx_v_all_args, a); if (e) return e;
  }
  if (p->__pyx_v_f) {
    e = (*v)(p->__pyx_v_f, a); if (e) return e;
  }
  if (p->__pyx_v_kwonly_args) {
    e = (*v)(p->__pyx_v_kwonly_args, a); if (e) return e;
  }
  if (p->__pyx_v_name) {
    e = (*v)(p->__pyx_v_name, a); if (e) return e;
  }
  if (p->__pyx_v_sig) {
    e = (*v)(p->__pyx_v_sig, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9validator___pyx_scope_struct_24__inner_deprecate_positional_args(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args *p = (struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args *)o;
  tmp = ((PyObject*)p->__pyx_outer_scope);
  p->__pyx_outer_scope = ((struct __pyx_obj_9validator___pyx_scope_struct_23__deprecate_positional_args *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_all_args);
  p->__pyx_v_all_args = ((PyObject*)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_f);
  p->__pyx_v_f = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_kwonly_args);
  p->__pyx_v_kwonly_args = ((PyObject*)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_name);
  p->__pyx_v_name = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_sig);
  p->__pyx_v_sig = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_24__inner_deprecate_positional_args = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_24__inner_deprecate_positional_args", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_24__inner_deprecate_positional_args), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_24__inner_deprecate_positional_args, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_24__inner_deprecate_positional_args, /*tp_traverse*/
  __pyx_tp_clear_9validator___pyx_scope_struct_24__inner_deprecate_positional_args, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_24__inner_deprecate_positional_args, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_25_check_scalar *__pyx_freelist_9validator___pyx_scope_struct_25_check_scalar[8];
static int __pyx_freecount_9validator___pyx_scope_struct_25_check_scalar = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_25_check_scalar(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_25_check_scalar > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_25_check_scalar)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_25_check_scalar[--__pyx_freecount_9validator___pyx_scope_struct_25_check_scalar];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_25_check_scalar));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_25_check_scalar(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_25_check_scalar *p = (struct __pyx_obj_9validator___pyx_scope_struct_25_check_scalar *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_target_type);
  Py_CLEAR(p->__pyx_v_type_name);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_25_check_scalar < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_25_check_scalar)))) {
    __pyx_freelist_9validator___pyx_scope_struct_25_check_scalar[__pyx_freecount_9validator___pyx_scope_struct_25_check_scalar++] = ((struct __pyx_obj_9validator___pyx_scope_struct_25_check_scalar *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_25_check_scalar(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_25_check_scalar *p = (struct __pyx_obj_9validator___pyx_scope_struct_25_check_scalar *)o;
  if (p->__pyx_v_target_type) {
    e = (*v)(p->__pyx_v_target_type, a); if (e) return e;
  }
  if (p->__pyx_v_type_name) {
    e = (*v)(p->__pyx_v_type_name, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9validator___pyx_scope_struct_25_check_scalar(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9validator___pyx_scope_struct_25_check_scalar *p = (struct __pyx_obj_9validator___pyx_scope_struct_25_check_scalar *)o;
  tmp = ((PyObject*)p->__pyx_v_target_type);
  p->__pyx_v_target_type = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->__pyx_v_type_name);
  p->__pyx_v_type_name = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_25_check_scalar = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_25_check_scalar", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_25_check_scalar), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_25_check_scalar, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_25_check_scalar, /*tp_traverse*/
  __pyx_tp_clear_9validator___pyx_scope_struct_25_check_scalar, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_25_check_scalar, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_26_genexpr *__pyx_freelist_9validator___pyx_scope_struct_26_genexpr[8];
static int __pyx_freecount_9validator___pyx_scope_struct_26_genexpr = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_26_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_26_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_26_genexpr)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_26_genexpr[--__pyx_freecount_9validator___pyx_scope_struct_26_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_26_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_26_genexpr(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_26_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_26_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_t);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_26_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_26_genexpr)))) {
    __pyx_freelist_9validator___pyx_scope_struct_26_genexpr[__pyx_freecount_9validator___pyx_scope_struct_26_genexpr++] = ((struct __pyx_obj_9validator___pyx_scope_struct_26_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_26_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_26_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_26_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_t) {
    e = (*v)(p->__pyx_v_t, a); if (e) return e;
  }
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_26_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_26_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_26_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_26_genexpr, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_26_genexpr, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_26_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_27__get_feature_names *__pyx_freelist_9validator___pyx_scope_struct_27__get_feature_names[8];
static int __pyx_freecount_9validator___pyx_scope_struct_27__get_feature_names = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_27__get_feature_names(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_27__get_feature_names > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_27__get_feature_names)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_27__get_feature_names[--__pyx_freecount_9validator___pyx_scope_struct_27__get_feature_names];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_27__get_feature_names));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_27__get_feature_names(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_27__get_feature_names *p = (struct __pyx_obj_9validator___pyx_scope_struct_27__get_feature_names *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_feature_names);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_27__get_feature_names < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_27__get_feature_names)))) {
    __pyx_freelist_9validator___pyx_scope_struct_27__get_feature_names[__pyx_freecount_9validator___pyx_scope_struct_27__get_feature_names++] = ((struct __pyx_obj_9validator___pyx_scope_struct_27__get_feature_names *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_27__get_feature_names(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_27__get_feature_names *p = (struct __pyx_obj_9validator___pyx_scope_struct_27__get_feature_names *)o;
  if (p->__pyx_v_feature_names) {
    e = (*v)(p->__pyx_v_feature_names, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9validator___pyx_scope_struct_27__get_feature_names(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9validator___pyx_scope_struct_27__get_feature_names *p = (struct __pyx_obj_9validator___pyx_scope_struct_27__get_feature_names *)o;
  tmp = ((PyObject*)p->__pyx_v_feature_names);
  p->__pyx_v_feature_names = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_27__get_feature_names = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_27__get_feature_names", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_27__get_feature_names), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_27__get_feature_names, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_27__get_feature_names, /*tp_traverse*/
  __pyx_tp_clear_9validator___pyx_scope_struct_27__get_feature_names, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_27__get_feature_names, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_28_genexpr *__pyx_freelist_9validator___pyx_scope_struct_28_genexpr[8];
static int __pyx_freecount_9validator___pyx_scope_struct_28_genexpr = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_28_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_28_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_28_genexpr)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_28_genexpr[--__pyx_freecount_9validator___pyx_scope_struct_28_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_28_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_28_genexpr(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_28_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_28_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_genexpr);
  Py_CLEAR(p->__pyx_v_t);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_28_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_28_genexpr)))) {
    __pyx_freelist_9validator___pyx_scope_struct_28_genexpr[__pyx_freecount_9validator___pyx_scope_struct_28_genexpr++] = ((struct __pyx_obj_9validator___pyx_scope_struct_28_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_28_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_28_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_28_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_genexpr) {
    e = (*v)(p->__pyx_v_genexpr, a); if (e) return e;
  }
  if (p->__pyx_v_t) {
    e = (*v)(p->__pyx_v_t, a); if (e) return e;
  }
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_28_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_28_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_28_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_28_genexpr, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_28_genexpr, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_28_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_29_genexpr *__pyx_freelist_9validator___pyx_scope_struct_29_genexpr[8];
static int __pyx_freecount_9validator___pyx_scope_struct_29_genexpr = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_29_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_29_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_29_genexpr)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_29_genexpr[--__pyx_freecount_9validator___pyx_scope_struct_29_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_29_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_29_genexpr(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_29_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_29_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_v);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_29_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_29_genexpr)))) {
    __pyx_freelist_9validator___pyx_scope_struct_29_genexpr[__pyx_freecount_9validator___pyx_scope_struct_29_genexpr++] = ((struct __pyx_obj_9validator___pyx_scope_struct_29_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_29_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_29_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_29_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_v) {
    e = (*v)(p->__pyx_v_v, a); if (e) return e;
  }
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_29_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_29_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_29_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_29_genexpr, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_29_genexpr, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_29_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_30_check_array *__pyx_freelist_9validator___pyx_scope_struct_30_check_array[8];
static int __pyx_freecount_9validator___pyx_scope_struct_30_check_array = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_30_check_array(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_30_check_array > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_30_check_array)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_30_check_array[--__pyx_freecount_9validator___pyx_scope_struct_30_check_array];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_30_check_array));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_30_check_array(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_30_check_array *p = (struct __pyx_obj_9validator___pyx_scope_struct_30_check_array *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_dtypes_orig);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_30_check_array < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_30_check_array)))) {
    __pyx_freelist_9validator___pyx_scope_struct_30_check_array[__pyx_freecount_9validator___pyx_scope_struct_30_check_array++] = ((struct __pyx_obj_9validator___pyx_scope_struct_30_check_array *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_30_check_array(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_30_check_array *p = (struct __pyx_obj_9validator___pyx_scope_struct_30_check_array *)o;
  if (p->__pyx_v_dtypes_orig) {
    e = (*v)(p->__pyx_v_dtypes_orig, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_9validator___pyx_scope_struct_30_check_array(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_9validator___pyx_scope_struct_30_check_array *p = (struct __pyx_obj_9validator___pyx_scope_struct_30_check_array *)o;
  tmp = ((PyObject*)p->__pyx_v_dtypes_orig);
  p->__pyx_v_dtypes_orig = ((PyObject*)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_30_check_array = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_30_check_array", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_30_check_array), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_30_check_array, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_30_check_array, /*tp_traverse*/
  __pyx_tp_clear_9validator___pyx_scope_struct_30_check_array, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_30_check_array, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_31_genexpr *__pyx_freelist_9validator___pyx_scope_struct_31_genexpr[8];
static int __pyx_freecount_9validator___pyx_scope_struct_31_genexpr = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_31_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_31_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_31_genexpr)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_31_genexpr[--__pyx_freecount_9validator___pyx_scope_struct_31_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_31_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_31_genexpr(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_31_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_31_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_i);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_31_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_31_genexpr)))) {
    __pyx_freelist_9validator___pyx_scope_struct_31_genexpr[__pyx_freecount_9validator___pyx_scope_struct_31_genexpr++] = ((struct __pyx_obj_9validator___pyx_scope_struct_31_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_31_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_31_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_31_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_i) {
    e = (*v)(p->__pyx_v_i, a); if (e) return e;
  }
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_31_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_31_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_31_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_31_genexpr, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_31_genexpr, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_31_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static struct __pyx_obj_9validator___pyx_scope_struct_32_genexpr *__pyx_freelist_9validator___pyx_scope_struct_32_genexpr[8];
static int __pyx_freecount_9validator___pyx_scope_struct_32_genexpr = 0;

static PyObject *__pyx_tp_new_9validator___pyx_scope_struct_32_genexpr(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_9validator___pyx_scope_struct_32_genexpr > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_32_genexpr)))) {
    o = (PyObject*)__pyx_freelist_9validator___pyx_scope_struct_32_genexpr[--__pyx_freecount_9validator___pyx_scope_struct_32_genexpr];
    memset(o, 0, sizeof(struct __pyx_obj_9validator___pyx_scope_struct_32_genexpr));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_9validator___pyx_scope_struct_32_genexpr(PyObject *o) {
  struct __pyx_obj_9validator___pyx_scope_struct_32_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_32_genexpr *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_outer_scope);
  Py_CLEAR(p->__pyx_v_dtype_iter);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_9validator___pyx_scope_struct_32_genexpr < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_9validator___pyx_scope_struct_32_genexpr)))) {
    __pyx_freelist_9validator___pyx_scope_struct_32_genexpr[__pyx_freecount_9validator___pyx_scope_struct_32_genexpr++] = ((struct __pyx_obj_9validator___pyx_scope_struct_32_genexpr *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_9validator___pyx_scope_struct_32_genexpr(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_9validator___pyx_scope_struct_32_genexpr *p = (struct __pyx_obj_9validator___pyx_scope_struct_32_genexpr *)o;
  if (p->__pyx_outer_scope) {
    e = (*v)(((PyObject *)p->__pyx_outer_scope), a); if (e) return e;
  }
  if (p->__pyx_v_dtype_iter) {
    e = (*v)(p->__pyx_v_dtype_iter, a); if (e) return e;
  }
  return 0;
}

static PyTypeObject __pyx_type_9validator___pyx_scope_struct_32_genexpr = {
  PyVarObject_HEAD_INIT(0, 0)
  "validator.__pyx_scope_struct_32_genexpr", /*tp_name*/
  sizeof(struct __pyx_obj_9validator___pyx_scope_struct_32_genexpr), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_9validator___pyx_scope_struct_32_genexpr, /*tp_dealloc*/
  #if PY_VERSION_HEX < 0x030800b4
  0, /*tp_print*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4
  0, /*tp_vectorcall_offset*/
  #endif
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_9validator___pyx_scope_struct_32_genexpr, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_9validator___pyx_scope_struct_32_genexpr, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
  0, /*tp_vectorcall*/
  #endif
  #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
  0, /*tp_print*/
  #endif
  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
  0, /*tp_pypy_flags*/
  #endif
};

static PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
#if CYTHON_PEP489_MULTI_PHASE_INIT
static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
static int __pyx_pymod_exec_validator(PyObject* module); /*proto*/
static PyModuleDef_Slot __pyx_moduledef_slots[] = {
  {Py_mod_create, (void*)__pyx_pymod_create},
  {Py_mod_exec, (void*)__pyx_pymod_exec_validator},
  {0, NULL}
};
#endif

static struct PyModuleDef __pyx_moduledef = {
    PyModuleDef_HEAD_INIT,
    "validator",
    __pyx_k_validator_module_provides_a_com, /* m_doc */
  #if CYTHON_PEP489_MULTI_PHASE_INIT
    0, /* m_size */
  #else
    -1, /* m_size */
  #endif
    __pyx_methods /* m_methods */,
  #if CYTHON_PEP489_MULTI_PHASE_INIT
    __pyx_moduledef_slots, /* m_slots */
  #else
    NULL, /* m_reload */
  #endif
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif
#ifndef CYTHON_SMALL_CODE
#if defined(__clang__)
    #define CYTHON_SMALL_CODE
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))
    #define CYTHON_SMALL_CODE __attribute__((cold))
#else
    #define CYTHON_SMALL_CODE
#endif
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_kp_u_01, __pyx_k_01, sizeof(__pyx_k_01), 0, 1, 0, 0},
  {&__pyx_kp_u_1_3, __pyx_k_1_3, sizeof(__pyx_k_1_3), 0, 1, 0, 0},
  {&__pyx_kp_u_A_column_vector_y_was_passed_whe, __pyx_k_A_column_vector_y_was_passed_whe, sizeof(__pyx_k_A_column_vector_y_was_passed_whe), 0, 1, 0, 0},
  {&__pyx_kp_u_A_singleton_array_r_cannot_be_co, __pyx_k_A_singleton_array_r_cannot_be_co, sizeof(__pyx_k_A_singleton_array_r_cannot_be_co), 0, 1, 0, 0},
  {&__pyx_kp_u_A_sparse_matrix_was_passed_but_d, __pyx_k_A_sparse_matrix_was_passed_but_d, sizeof(__pyx_k_A_sparse_matrix_was_passed_but_d), 0, 1, 0, 0},
  {&__pyx_kp_u_Added_part_of_is_frame_dedicated, __pyx_k_Added_part_of_is_frame_dedicated, sizeof(__pyx_k_Added_part_of_is_frame_dedicated), 0, 1, 0, 0},
  {&__pyx_kp_u_All_distribution_values_must_be, __pyx_k_All_distribution_values_must_be, sizeof(__pyx_k_All_distribution_values_must_be), 0, 1, 0, 0},
  {&__pyx_kp_u_All_elements_in_the_target_array, __pyx_k_All_elements_in_the_target_array, sizeof(__pyx_k_All_elements_in_the_target_array), 0, 1, 0, 0},
  {&__pyx_n_s_Any, __pyx_k_Any, sizeof(__pyx_k_Any), 0, 0, 1, 1},
  {&__pyx_kp_u_Array, __pyx_k_Array, sizeof(__pyx_k_Array), 0, 1, 0, 0},
  {&__pyx_kp_u_Array_2, __pyx_k_Array_2, sizeof(__pyx_k_Array_2), 0, 1, 0, 0},
  {&__pyx_kp_u_Array_at_index, __pyx_k_Array_at_index, sizeof(__pyx_k_Array_at_index), 0, 1, 0, 0},
  {&__pyx_kp_u_Array_is_not_symmetric_and_will, __pyx_k_Array_is_not_symmetric_and_will, sizeof(__pyx_k_Array_is_not_symmetric_and_will), 0, 1, 0, 0},
  {&__pyx_kp_u_Array_must_be_symmetric, __pyx_k_Array_must_be_symmetric, sizeof(__pyx_k_Array_must_be_symmetric), 0, 1, 0, 0},
  {&__pyx_kp_u_Array_sizes_must_be_consistent_a, __pyx_k_Array_sizes_must_be_consistent_a, sizeof(__pyx_k_Array_sizes_must_be_consistent_a), 0, 1, 0, 0},
  {&__pyx_kp_u_Assert_the_name_of_x_and_y_in_t, __pyx_k_Assert_the_name_of_x_and_y_in_t, sizeof(__pyx_k_Assert_the_name_of_x_and_y_in_t), 0, 1, 0, 0},
  {&__pyx_n_s_AttributeError, __pyx_k_AttributeError, sizeof(__pyx_k_AttributeError), 0, 0, 1, 1},
  {&__pyx_kp_u_Automatic_alignment_failed_Index, __pyx_k_Automatic_alignment_failed_Index, sizeof(__pyx_k_Automatic_alignment_failed_Index), 0, 1, 0, 0},
  {&__pyx_kp_u_Automatic_strategy_detected_too, __pyx_k_Automatic_strategy_detected_too, sizeof(__pyx_k_Automatic_strategy_detected_too), 0, 1, 0, 0},
  {&__pyx_kp_u_Both_elements_in, __pyx_k_Both_elements_in, sizeof(__pyx_k_Both_elements_in), 0, 1, 0, 0},
  {&__pyx_kp_u_Both_y_true_and_y_pred_must_be_o, __pyx_k_Both_y_true_and_y_pred_must_be_o, sizeof(__pyx_k_Both_y_true_and_y_pred_must_be_o), 0, 1, 0, 0},
  {&__pyx_n_s_BuiltinFunctionType, __pyx_k_BuiltinFunctionType, sizeof(__pyx_k_BuiltinFunctionType), 0, 0, 1, 1},
  {&__pyx_n_u_C, __pyx_k_C, sizeof(__pyx_k_C), 0, 1, 0, 1},
  {&__pyx_n_s_Callable, __pyx_k_Callable, sizeof(__pyx_k_Callable), 0, 0, 1, 1},
  {&__pyx_kp_u_Can_t_check_s_sparse_matrix_for, __pyx_k_Can_t_check_s_sparse_matrix_for, sizeof(__pyx_k_Can_t_check_s_sparse_matrix_for), 0, 1, 0, 0},
  {&__pyx_kp_u_Cannot_normalize_weights_because, __pyx_k_Cannot_normalize_weights_because, sizeof(__pyx_k_Cannot_normalize_weights_because), 0, 1, 0, 0},
  {&__pyx_n_s_CategoricalDtype, __pyx_k_CategoricalDtype, sizeof(__pyx_k_CategoricalDtype), 0, 0, 1, 1},
  {&__pyx_kp_u_Check_if_the_provided_DataFrame, __pyx_k_Check_if_the_provided_DataFrame, sizeof(__pyx_k_Check_if_the_provided_DataFrame), 0, 1, 0, 0},
  {&__pyx_kp_u_Check_whether_the_estimator_s_fi, __pyx_k_Check_whether_the_estimator_s_fi, sizeof(__pyx_k_Check_whether_the_estimator_s_fi), 0, 1, 0, 0},
  {&__pyx_kp_u_Check_whether_the_target_array, __pyx_k_Check_whether_the_target_array, sizeof(__pyx_k_Check_whether_the_target_array), 0, 1, 0, 0},
  {&__pyx_kp_u_Check_your_date_data_For_datetim, __pyx_k_Check_your_date_data_For_datetim, sizeof(__pyx_k_Check_your_date_data_For_datetim), 0, 1, 0, 0},
  {&__pyx_kp_u_Checks_for_mixed_data_types_in, __pyx_k_Checks_for_mixed_data_types_in, sizeof(__pyx_k_Checks_for_mixed_data_types_in), 0, 1, 0, 0},
  {&__pyx_kp_u_Checks_if_TensorFlow_is_install, __pyx_k_Checks_if_TensorFlow_is_install, sizeof(__pyx_k_Checks_if_TensorFlow_is_install), 0, 1, 0, 0},
  {&__pyx_kp_u_Checks_if_a_specified_column_in, __pyx_k_Checks_if_a_specified_column_in, sizeof(__pyx_k_Checks_if_a_specified_column_in), 0, 1, 0, 0},
  {&__pyx_kp_u_Checks_if_an_array_is_normalize, __pyx_k_Checks_if_an_array_is_normalize, sizeof(__pyx_k_Checks_if_an_array_is_normalize), 0, 1, 0, 0},
  {&__pyx_kp_u_Checks_if_the_given_data_DataFr, __pyx_k_Checks_if_the_given_data_DataFr, sizeof(__pyx_k_Checks_if_the_given_data_DataFr), 0, 1, 0, 0},
  {&__pyx_kp_u_Checks_if_the_provided_array_is, __pyx_k_Checks_if_the_provided_array_is, sizeof(__pyx_k_Checks_if_the_provided_array_is), 0, 1, 0, 0},
  {&__pyx_kp_u_Checks_if_y_is_a_probability_di, __pyx_k_Checks_if_y_is_a_probability_di, sizeof(__pyx_k_Checks_if_y_is_a_probability_di), 0, 1, 0, 0},
  {&__pyx_kp_u_Choose_ceil_floor_or_None, __pyx_k_Choose_ceil_floor_or_None, sizeof(__pyx_k_Choose_ceil_floor_or_None), 0, 1, 0, 0},
  {&__pyx_kp_u_Choose_from, __pyx_k_Choose_from, sizeof(__pyx_k_Choose_from), 0, 1, 0, 0},
  {&__pyx_kp_u_Column, __pyx_k_Column, sizeof(__pyx_k_Column), 0, 1, 0, 0},
  {&__pyx_kp_u_Columns_for, __pyx_k_Columns_for, sizeof(__pyx_k_Columns_for), 0, 1, 0, 0},
  {&__pyx_kp_u_Columns_for_input_name_r_expect, __pyx_k_Columns_for_input_name_r_expect, sizeof(__pyx_k_Columns_for_input_name_r_expect), 0, 1, 0, 0},
  {&__pyx_kp_u_Columns_indices_imply, __pyx_k_Columns_indices_imply, sizeof(__pyx_k_Columns_indices_imply), 0, 1, 0, 0},
  {&__pyx_kp_u_Columns_must_be_provided_for_Dat, __pyx_k_Columns_must_be_provided_for_Dat, sizeof(__pyx_k_Columns_must_be_provided_for_Dat), 0, 1, 0, 0},
  {&__pyx_n_s_ComplexWarning, __pyx_k_ComplexWarning, sizeof(__pyx_k_ComplexWarning), 0, 0, 1, 1},
  {&__pyx_kp_u_Complex_data_not_supported, __pyx_k_Complex_data_not_supported, sizeof(__pyx_k_Complex_data_not_supported), 0, 1, 0, 0},
  {&__pyx_kp_u_Continuous_data_not_suitable_for, __pyx_k_Continuous_data_not_suitable_for, sizeof(__pyx_k_Continuous_data_not_suitable_for), 0, 1, 0, 0},
  {&__pyx_kp_u_Conversion_of, __pyx_k_Conversion_of, sizeof(__pyx_k_Conversion_of), 0, 1, 0, 0},
  {&__pyx_kp_u_Creates_a_validator_function_fo, __pyx_k_Creates_a_validator_function_fo, sizeof(__pyx_k_Creates_a_validator_function_fo), 0, 1, 0, 0},
  {&__pyx_kp_u_Custom_check_failed, __pyx_k_Custom_check_failed, sizeof(__pyx_k_Custom_check_failed), 0, 1, 0, 0},
  {&__pyx_n_u_Data, __pyx_k_Data, sizeof(__pyx_k_Data), 0, 1, 0, 1},
  {&__pyx_n_s_DataConversionWarning, __pyx_k_DataConversionWarning, sizeof(__pyx_k_DataConversionWarning), 0, 0, 1, 1},
  {&__pyx_n_u_DataConversionWarning, __pyx_k_DataConversionWarning, sizeof(__pyx_k_DataConversionWarning), 0, 1, 0, 1},
  {&__pyx_n_s_DataFrame, __pyx_k_DataFrame, sizeof(__pyx_k_DataFrame), 0, 0, 1, 1},
  {&__pyx_n_u_DataFrame, __pyx_k_DataFrame, sizeof(__pyx_k_DataFrame), 0, 1, 0, 1},
  {&__pyx_kp_u_DataFrame_must_be_square_equal_n, __pyx_k_DataFrame_must_be_square_equal_n, sizeof(__pyx_k_DataFrame_must_be_square_equal_n), 0, 1, 0, 0},
  {&__pyx_kp_u_Data_cannot_be_None_when_x_and_y, __pyx_k_Data_cannot_be_None_when_x_and_y, sizeof(__pyx_k_Data_cannot_be_None_when_x_and_y), 0, 1, 0, 0},
  {&__pyx_kp_u_Determine_whether_the_input_eit, __pyx_k_Determine_whether_the_input_eit, sizeof(__pyx_k_Determine_whether_the_input_eit), 0, 1, 0, 0},
  {&__pyx_kp_u_Determines_whether_a_list_conta, __pyx_k_Determines_whether_a_list_conta, sizeof(__pyx_k_Determines_whether_a_list_conta), 0, 1, 0, 0},
  {&__pyx_kp_u_Dynamically_determine_or_valida, __pyx_k_Dynamically_determine_or_valida, sizeof(__pyx_k_Dynamically_determine_or_valida), 0, 1, 0, 0},
  {&__pyx_kp_u_Each_set_of_scores_must_be_a_val, __pyx_k_Each_set_of_scores_must_be_a_val, sizeof(__pyx_k_Each_set_of_scores_must_be_a_val), 0, 1, 0, 0},
  {&__pyx_kp_u_Encountered_zero_in_y_true_leadi, __pyx_k_Encountered_zero_in_y_true_leadi, sizeof(__pyx_k_Encountered_zero_in_y_true_leadi), 0, 1, 0, 0},
  {&__pyx_kp_u_Encountered_zero_in_y_true_which, __pyx_k_Encountered_zero_in_y_true_which, sizeof(__pyx_k_Encountered_zero_in_y_true_which), 0, 1, 0, 0},
  {&__pyx_kp_u_Ensure_that_provided_arrays_con, __pyx_k_Ensure_that_provided_arrays_con, sizeof(__pyx_k_Ensure_that_provided_arrays_con), 0, 1, 0, 0},
  {&__pyx_kp_u_Ensure_that_the_input_X_is_conv, __pyx_k_Ensure_that_the_input_X_is_conv, sizeof(__pyx_k_Ensure_that_the_input_X_is_conv), 0, 1, 0, 0},
  {&__pyx_kp_u_Epsilon_must_be_auto_or_converti, __pyx_k_Epsilon_must_be_auto_or_converti, sizeof(__pyx_k_Epsilon_must_be_auto_or_converti), 0, 1, 0, 0},
  {&__pyx_kp_u_Error_converting_target_array_at, __pyx_k_Error_converting_target_array_at, sizeof(__pyx_k_Error_converting_target_array_at), 0, 1, 0, 0},
  {&__pyx_n_u_Expect, __pyx_k_Expect, sizeof(__pyx_k_Expect), 0, 1, 0, 1},
  {&__pyx_kp_u_Expect_a_dataframe_Got, __pyx_k_Expect_a_dataframe_Got, sizeof(__pyx_k_Expect_a_dataframe_Got), 0, 1, 0, 0},
  {&__pyx_kp_u_Expect_a_dataframe_while_columns, __pyx_k_Expect_a_dataframe_while_columns, sizeof(__pyx_k_Expect_a_dataframe_while_columns), 0, 1, 0, 0},
  {&__pyx_kp_u_Expect_columns_to_build_the_data, __pyx_k_Expect_columns_to_build_the_data, sizeof(__pyx_k_Expect_columns_to_build_the_data), 0, 1, 0, 0},
  {&__pyx_kp_u_Expect_type_array_got, __pyx_k_Expect_type_array_got, sizeof(__pyx_k_Expect_type_array_got), 0, 1, 0, 0},
  {&__pyx_kp_u_Expected, __pyx_k_Expected, sizeof(__pyx_k_Expected), 0, 1, 0, 0},
  {&__pyx_kp_u_Expected_2D_array_got_1D_array_i, __pyx_k_Expected_2D_array_got_1D_array_i, sizeof(__pyx_k_Expected_2D_array_got_1D_array_i), 0, 1, 0, 0},
  {&__pyx_kp_u_Expected_2D_array_got_scalar_arr, __pyx_k_Expected_2D_array_got_scalar_arr, sizeof(__pyx_k_Expected_2D_array_got_scalar_arr), 0, 1, 0, 0},
  {&__pyx_kp_u_Expected_both_x_and_y_to_be_one, __pyx_k_Expected_both_x_and_y_to_be_one, sizeof(__pyx_k_Expected_both_x_and_y_to_be_one), 0, 1, 0, 0},
  {&__pyx_kp_u_Expected_categoric_types_but_fou, __pyx_k_Expected_categoric_types_but_fou, sizeof(__pyx_k_Expected_categoric_types_but_fou), 0, 1, 0, 0},
  {&__pyx_kp_u_Expected_format_YYYY_or_YYYY_MM, __pyx_k_Expected_format_YYYY_or_YYYY_MM, sizeof(__pyx_k_Expected_format_YYYY_or_YYYY_MM), 0, 1, 0, 0},
  {&__pyx_kp_u_Expected_int_float_or_str_for_ye, __pyx_k_Expected_int_float_or_str_for_ye, sizeof(__pyx_k_Expected_int_float_or_str_for_ye), 0, 1, 0, 0},
  {&__pyx_kp_u_Expected_multi_output_for_true_l, __pyx_k_Expected_multi_output_for_true_l, sizeof(__pyx_k_Expected_multi_output_for_true_l), 0, 1, 0, 0},
  {&__pyx_kp_u_Expected_numeric_types_but_found, __pyx_k_Expected_numeric_types_but_found, sizeof(__pyx_k_Expected_numeric_types_but_found), 0, 1, 0, 0},
  {&__pyx_kp_u_Expected_sequence_or_array_like, __pyx_k_Expected_sequence_or_array_like, sizeof(__pyx_k_Expected_sequence_or_array_like), 0, 1, 0, 0},
  {&__pyx_kp_u_Expects_a_one_dimensional_array, __pyx_k_Expects_a_one_dimensional_array, sizeof(__pyx_k_Expects_a_one_dimensional_array), 0, 1, 0, 0},
  {&__pyx_kp_u_Expects_an_array_got, __pyx_k_Expects_an_array_got, sizeof(__pyx_k_Expects_an_array_got), 0, 1, 0, 0},
  {&__pyx_n_s_FLOAT_DTYPES, __pyx_k_FLOAT_DTYPES, sizeof(__pyx_k_FLOAT_DTYPES), 0, 0, 1, 1},
  {&__pyx_kp_u_Failed_to_construct_a_DataFrame, __pyx_k_Failed_to_construct_a_DataFrame, sizeof(__pyx_k_Failed_to_construct_a_DataFrame), 0, 1, 0, 0},
  {&__pyx_kp_u_Feature_names_only_support_names, __pyx_k_Feature_names_only_support_names, sizeof(__pyx_k_Feature_names_only_support_names), 0, 1, 0, 0},
  {&__pyx_kp_u_Filter_and_return_only_the_vali, __pyx_k_Filter_and_return_only_the_vali, sizeof(__pyx_k_Filter_and_return_only_the_vali), 0, 1, 0, 0},
  {&__pyx_kp_u_Found_array_with, __pyx_k_Found_array_with, sizeof(__pyx_k_Found_array_with), 0, 1, 0, 0},
  {&__pyx_kp_u_Found_array_with_0_length_while, __pyx_k_Found_array_with_0_length_while, sizeof(__pyx_k_Found_array_with_0_length_while), 0, 1, 0, 0},
  {&__pyx_kp_u_Found_array_with_dim, __pyx_k_Found_array_with_dim, sizeof(__pyx_k_Found_array_with_dim), 0, 1, 0, 0},
  {&__pyx_kp_u_Found_input_variables_with_incon, __pyx_k_Found_input_variables_with_incon, sizeof(__pyx_k_Found_input_variables_with_incon), 0, 1, 0, 0},
  {&__pyx_n_s_FutureWarning, __pyx_k_FutureWarning, sizeof(__pyx_k_FutureWarning), 0, 0, 1, 1},
  {&__pyx_kp_u_Got, __pyx_k_Got, sizeof(__pyx_k_Got), 0, 1, 0, 0},
  {&__pyx_n_s_IGNORECASE, __pyx_k_IGNORECASE, sizeof(__pyx_k_IGNORECASE), 0, 0, 1, 1},
  {&__pyx_n_s_ImportError, __pyx_k_ImportError, sizeof(__pyx_k_ImportError), 0, 0, 1, 1},
  {&__pyx_kp_u_Input, __pyx_k_Input, sizeof(__pyx_k_Input), 0, 1, 0, 0},
  {&__pyx_kp_u_Input_contains_NaN, __pyx_k_Input_contains_NaN, sizeof(__pyx_k_Input_contains_NaN), 0, 1, 0, 0},
  {&__pyx_kp_u_Input_must_be_a_square_matrix, __pyx_k_Input_must_be_a_square_matrix, sizeof(__pyx_k_Input_must_be_a_square_matrix), 0, 1, 0, 0},
  {&__pyx_kp_u_Input_values_contain_NaNs_and_na, __pyx_k_Input_values_contain_NaNs_and_na, sizeof(__pyx_k_Input_values_contain_NaNs_and_na), 0, 1, 0, 0},
  {&__pyx_n_s_Integral, __pyx_k_Integral, sizeof(__pyx_k_Integral), 0, 0, 1, 1},
  {&__pyx_kp_u_Invalid_alignment_option_provide, __pyx_k_Invalid_alignment_option_provide, sizeof(__pyx_k_Invalid_alignment_option_provide), 0, 1, 0, 0},
  {&__pyx_kp_u_Invalid_dtype_selector_provided, __pyx_k_Invalid_dtype_selector_provided, sizeof(__pyx_k_Invalid_dtype_selector_provided), 0, 1, 0, 0},
  {&__pyx_kp_u_Invalid_input, __pyx_k_Invalid_input, sizeof(__pyx_k_Invalid_input), 0, 1, 0, 0},
  {&__pyx_kp_u_Invalid_nan_policy, __pyx_k_Invalid_nan_policy, sizeof(__pyx_k_Invalid_nan_policy), 0, 1, 0, 0},
  {&__pyx_kp_u_Invalid_nan_policy_2, __pyx_k_Invalid_nan_policy_2, sizeof(__pyx_k_Invalid_nan_policy_2), 0, 1, 0, 0},
  {&__pyx_kp_u_Invalid_rounding_method, __pyx_k_Invalid_rounding_method, sizeof(__pyx_k_Invalid_rounding_method), 0, 1, 0, 0},
  {&__pyx_kp_u_Invalid_validation_mode, __pyx_k_Invalid_validation_mode, sizeof(__pyx_k_Invalid_validation_mode), 0, 1, 0, 0},
  {&__pyx_kp_u_Invalid_value_for_multioutput_pa, __pyx_k_Invalid_value_for_multioutput_pa, sizeof(__pyx_k_Invalid_value_for_multioutput_pa), 0, 1, 0, 0},
  {&__pyx_n_s_KEYWORD_ONLY, __pyx_k_KEYWORD_ONLY, sizeof(__pyx_k_KEYWORD_ONLY), 0, 0, 1, 1},
  {&__pyx_kp_u_Length_of_sample_weights_must_ma, __pyx_k_Length_of_sample_weights_must_ma, sizeof(__pyx_k_Length_of_sample_weights_must_ma), 0, 1, 0, 0},
  {&__pyx_n_s_Memory, __pyx_k_Memory, sizeof(__pyx_k_Memory), 0, 0, 1, 1},
  {&__pyx_kp_u_Mismatch_in_the_number_of_output, __pyx_k_Mismatch_in_the_number_of_output, sizeof(__pyx_k_Mismatch_in_the_number_of_output), 0, 1, 0, 0},
  {&__pyx_kp_u_Missing_x_and_y_NoneType_not_sup, __pyx_k_Missing_x_and_y_NoneType_not_sup, sizeof(__pyx_k_Missing_x_and_y_NoneType_not_sup), 0, 1, 0, 0},
  {&__pyx_kp_u_Mixed_data_types_found_Be_cautio, __pyx_k_Mixed_data_types_found_Be_cautio, sizeof(__pyx_k_Mixed_data_types_found_Be_cautio), 0, 1, 0, 0},
  {&__pyx_kp_u_Mixed_types_detected_Please_enco, __pyx_k_Mixed_types_detected_Please_enco, sizeof(__pyx_k_Mixed_types_detected_Please_enco), 0, 1, 0, 0},
  {&__pyx_kp_u_Mixed_types_detected_with_unexpe, __pyx_k_Mixed_types_detected_with_unexpe, sizeof(__pyx_k_Mixed_types_detected_with_unexpe), 0, 1, 0, 0},
  {&__pyx_n_s_Model, __pyx_k_Model, sizeof(__pyx_k_Model), 0, 0, 1, 1},
  {&__pyx_kp_u_Model_does_not_support_essential, __pyx_k_Model_does_not_support_essential, sizeof(__pyx_k_Model_does_not_support_essential), 0, 1, 0, 0},
  {&__pyx_kp_u_Multi_output_scores_provided_but, __pyx_k_Multi_output_scores_provided_but, sizeof(__pyx_k_Multi_output_scores_provided_but), 0, 1, 0, 0},
  {&__pyx_kp_u_Multilabel_indicator_format_dete, __pyx_k_Multilabel_indicator_format_dete, sizeof(__pyx_k_Multilabel_indicator_format_dete), 0, 1, 0, 0},
  {&__pyx_n_s_NUMERIC_KINDS, __pyx_k_NUMERIC_KINDS, sizeof(__pyx_k_NUMERIC_KINDS), 0, 0, 1, 1},
  {&__pyx_n_u_NaN, __pyx_k_NaN, sizeof(__pyx_k_NaN), 0, 1, 0, 1},
  {&__pyx_kp_u_NaN_values_found_in_the_data, __pyx_k_NaN_values_found_in_the_data, sizeof(__pyx_k_NaN_values_found_in_the_data), 0, 1, 0, 0},
  {&__pyx_kp_u_NaN_values_found_in_the_data_but, __pyx_k_NaN_values_found_in_the_data_but, sizeof(__pyx_k_NaN_values_found_in_the_data_but), 0, 1, 0, 0},
  {&__pyx_kp_u_Name_or_columns_must_be_supplied, __pyx_k_Name_or_columns_must_be_supplied, sizeof(__pyx_k_Name_or_columns_must_be_supplied), 0, 1, 0, 0},
  {&__pyx_kp_u_Negative_values_are_not_allowed, __pyx_k_Negative_values_are_not_allowed, sizeof(__pyx_k_Negative_values_are_not_allowed), 0, 1, 0, 0},
  {&__pyx_kp_u_Non_multi_output_scores_with_mul, __pyx_k_Non_multi_output_scores_with_mul, sizeof(__pyx_k_Non_multi_output_scores_with_mul), 0, 1, 0, 0},
  {&__pyx_kp_u_Non_numeric_target_values_contai, __pyx_k_Non_numeric_target_values_contai, sizeof(__pyx_k_Non_numeric_target_values_contai), 0, 1, 0, 0},
  {&__pyx_kp_u_None, __pyx_k_None, sizeof(__pyx_k_None), 0, 1, 0, 0},
  {&__pyx_kp_u_Normalization_by_sum_impossible, __pyx_k_Normalization_by_sum_impossible, sizeof(__pyx_k_Normalization_by_sum_impossible), 0, 1, 0, 0},
  {&__pyx_kp_u_Normalization_impossible_with_ze, __pyx_k_Normalization_impossible_with_ze, sizeof(__pyx_k_Normalization_impossible_with_ze), 0, 1, 0, 0},
  {&__pyx_n_s_NotFittedError, __pyx_k_NotFittedError, sizeof(__pyx_k_NotFittedError), 0, 0, 1, 1},
  {&__pyx_kp_u_Numeric_target_values_contain_Na, __pyx_k_Numeric_target_values_contain_Na, sizeof(__pyx_k_Numeric_target_values_contain_Na), 0, 1, 0, 0},
  {&__pyx_kp_u_Numpy_array_must_contain_exactly, __pyx_k_Numpy_array_must_contain_exactly, sizeof(__pyx_k_Numpy_array_must_contain_exactly), 0, 1, 0, 0},
  {&__pyx_n_u_O, __pyx_k_O, sizeof(__pyx_k_O), 0, 1, 0, 1},
  {&__pyx_kp_u_Only_sparse_matrices_with_32_bit, __pyx_k_Only_sparse_matrices_with_32_bit, sizeof(__pyx_k_Only_sparse_matrices_with_32_bit), 0, 1, 0, 0},
  {&__pyx_n_s_Optional, __pyx_k_Optional, sizeof(__pyx_k_Optional), 0, 0, 1, 1},
  {&__pyx_n_s_POSITIONAL_OR_KEYWORD, __pyx_k_POSITIONAL_OR_KEYWORD, sizeof(__pyx_k_POSITIONAL_OR_KEYWORD), 0, 0, 1, 1},
  {&__pyx_n_s_Parameter, __pyx_k_Parameter, sizeof(__pyx_k_Parameter), 0, 0, 1, 1},
  {&__pyx_kp_u_Parameter_accept_sparse_should_b, __pyx_k_Parameter_accept_sparse_should_b, sizeof(__pyx_k_Parameter_accept_sparse_should_b), 0, 1, 0, 0},
  {&__pyx_kp_u_Pass, __pyx_k_Pass, sizeof(__pyx_k_Pass), 0, 1, 0, 0},
  {&__pyx_kp_u_Perform_is_fitted_validation_fo, __pyx_k_Perform_is_fitted_validation_fo, sizeof(__pyx_k_Perform_is_fitted_validation_fo), 0, 1, 0, 0},
  {&__pyx_kp_u_Performance_data_expects_a_DataF, __pyx_k_Performance_data_expects_a_DataF, sizeof(__pyx_k_Performance_data_expects_a_DataF), 0, 1, 0, 0},
  {&__pyx_n_s_PositiveSpectrumWarning, __pyx_k_PositiveSpectrumWarning, sizeof(__pyx_k_PositiveSpectrumWarning), 0, 0, 1, 1},
  {&__pyx_n_u_PositiveSpectrumWarning, __pyx_k_PositiveSpectrumWarning, sizeof(__pyx_k_PositiveSpectrumWarning), 0, 1, 0, 1},
  {&__pyx_kp_u_Possible_values_are, __pyx_k_Possible_values_are, sizeof(__pyx_k_Possible_values_are), 0, 1, 0, 0},
  {&__pyx_kp_u_Preprocess_input_arrays_to_hand, __pyx_k_Preprocess_input_arrays_to_hand, sizeof(__pyx_k_Preprocess_input_arrays_to_hand), 0, 1, 0, 0},
  {&__pyx_kp_u_Provided_object_is_not_a_Keras_m, __pyx_k_Provided_object_is_not_a_Keras_m, sizeof(__pyx_k_Provided_object_is_not_a_Keras_m), 0, 1, 0, 0},
  {&__pyx_n_s_RandomState, __pyx_k_RandomState, sizeof(__pyx_k_RandomState), 0, 0, 1, 1},
  {&__pyx_n_s_Real, __pyx_k_Real, sizeof(__pyx_k_Real), 0, 0, 1, 1},
  {&__pyx_kp_u_Rechecks_and_coerces_column_dat, __pyx_k_Rechecks_and_coerces_column_dat, sizeof(__pyx_k_Rechecks_and_coerces_column_dat), 0, 1, 0, 0},
  {&__pyx_n_s_RuntimeWarning, __pyx_k_RuntimeWarning, sizeof(__pyx_k_RuntimeWarning), 0, 0, 1, 1},
  {&__pyx_kp_u_Sample_weights_must_be_non_negat, __pyx_k_Sample_weights_must_be_non_negat, sizeof(__pyx_k_Sample_weights_must_be_non_negat), 0, 1, 0, 0},
  {&__pyx_kp_u_Sample_weights_must_be_non_negat_2, __pyx_k_Sample_weights_must_be_non_negat_2, sizeof(__pyx_k_Sample_weights_must_be_non_negat_2), 0, 1, 0, 0},
  {&__pyx_kp_u_Sample_weights_must_be_one_dimen, __pyx_k_Sample_weights_must_be_one_dimen, sizeof(__pyx_k_Sample_weights_must_be_one_dimen), 0, 1, 0, 0},
  {&__pyx_kp_u_Scores_must_be_a_valid_probabili, __pyx_k_Scores_must_be_a_valid_probabili, sizeof(__pyx_k_Scores_must_be_a_valid_probabili), 0, 1, 0, 0},
  {&__pyx_n_s_Sequential, __pyx_k_Sequential, sizeof(__pyx_k_Sequential), 0, 0, 1, 1},
  {&__pyx_n_s_Series, __pyx_k_Series, sizeof(__pyx_k_Series), 0, 0, 1, 1},
  {&__pyx_kp_u_Shape_of_passed_values_for, __pyx_k_Shape_of_passed_values_for, sizeof(__pyx_k_Shape_of_passed_values_for), 0, 1, 0, 0},
  {&__pyx_kp_u_Shape_of_passed_values_is, __pyx_k_Shape_of_passed_values_is, sizeof(__pyx_k_Shape_of_passed_values_is), 0, 1, 0, 0},
  {&__pyx_kp_u_Singleton_array_r_cannot_be_cons, __pyx_k_Singleton_array_r_cannot_be_cons, sizeof(__pyx_k_Singleton_array_r_cannot_be_cons), 0, 1, 0, 0},
  {&__pyx_n_s_SparseDtype, __pyx_k_SparseDtype, sizeof(__pyx_k_SparseDtype), 0, 0, 1, 1},
  {&__pyx_kp_u_Standardization_impossible_with, __pyx_k_Standardization_impossible_with, sizeof(__pyx_k_Standardization_impossible_with), 0, 1, 0, 0},
  {&__pyx_kp_u_Start_and_end_dates_are_within_t, __pyx_k_Start_and_end_dates_are_within_t, sizeof(__pyx_k_Start_and_end_dates_are_within_t), 0, 1, 0, 0},
  {&__pyx_kp_u_Start_date_time_must_be_earlier, __pyx_k_Start_date_time_must_be_earlier, sizeof(__pyx_k_Start_date_time_must_be_earlier), 0, 1, 0, 0},
  {&__pyx_n_s_T, __pyx_k_T, sizeof(__pyx_k_T), 0, 0, 1, 1},
  {&__pyx_kp_u_Target_array_at_index, __pyx_k_Target_array_at_index, sizeof(__pyx_k_Target_array_at_index), 0, 1, 0, 0},
  {&__pyx_kp_u_Target_array_must_be_one_dimensi, __pyx_k_Target_array_must_be_one_dimensi, sizeof(__pyx_k_Target_array_must_be_one_dimensi), 0, 1, 0, 0},
  {&__pyx_kp_u_Target_array_must_contain_at_lea, __pyx_k_Target_array_must_contain_at_lea, sizeof(__pyx_k_Target_array_must_contain_at_lea), 0, 1, 0, 0},
  {&__pyx_kp_u_Target_values_must_be_categorica, __pyx_k_Target_values_must_be_categorica, sizeof(__pyx_k_Target_values_must_be_categorica), 0, 1, 0, 0},
  {&__pyx_kp_u_Targets_are_suitable_for_classif, __pyx_k_Targets_are_suitable_for_classif, sizeof(__pyx_k_Targets_are_suitable_for_classif), 0, 1, 0, 0},
  {&__pyx_kp_u_The_distribution_must_have_exact, __pyx_k_The_distribution_must_have_exact, sizeof(__pyx_k_The_distribution_must_have_exact), 0, 1, 0, 0},
  {&__pyx_kp_u_The_first_element_in, __pyx_k_The_first_element_in, sizeof(__pyx_k_The_first_element_in), 0, 1, 0, 0},
  {&__pyx_kp_u_The_multioutput_parameter_is_not, __pyx_k_The_multioutput_parameter_is_not, sizeof(__pyx_k_The_multioutput_parameter_is_not), 0, 1, 0, 0},
  {&__pyx_kp_u_The_parameter, __pyx_k_The_parameter, sizeof(__pyx_k_The_parameter), 0, 1, 0, 0},
  {&__pyx_kp_u_The_sum_of_the_distribution_valu, __pyx_k_The_sum_of_the_distribution_valu, sizeof(__pyx_k_The_sum_of_the_distribution_valu), 0, 1, 0, 0},
  {&__pyx_kp_u_This_name_s_instance_is_not_fitt, __pyx_k_This_name_s_instance_is_not_fitt, sizeof(__pyx_k_This_name_s_instance_is_not_fitt), 0, 1, 0, 0},
  {&__pyx_kp_u_This_s_instance_is_not_fitted_ye, __pyx_k_This_s_instance_is_not_fitted_ye, sizeof(__pyx_k_This_s_instance_is_not_fitted_ye), 0, 1, 0, 0},
  {&__pyx_kp_u_Time_column, __pyx_k_Time_column, sizeof(__pyx_k_Time_column), 0, 1, 0, 0},
  {&__pyx_kp_u_Time_intervals_are_not_regular, __pyx_k_Time_intervals_are_not_regular, sizeof(__pyx_k_Time_intervals_are_not_regular), 0, 1, 0, 0},
  {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
  {&__pyx_n_u_USV, __pyx_k_USV, sizeof(__pyx_k_USV), 0, 1, 0, 1},
  {&__pyx_kp_u_Unable_to_determine_the_target_t, __pyx_k_Unable_to_determine_the_target_t, sizeof(__pyx_k_Unable_to_determine_the_target_t), 0, 1, 0, 0},
  {&__pyx_kp_u_Unable_to_find_the_name, __pyx_k_Unable_to_find_the_name, sizeof(__pyx_k_Unable_to_find_the_name), 0, 1, 0, 0},
  {&__pyx_kp_u_Unable_to_find_the_number_of_fea, __pyx_k_Unable_to_find_the_number_of_fea, sizeof(__pyx_k_Unable_to_find_the_number_of_fea), 0, 1, 0, 0},
  {&__pyx_kp_u_Unable_to_generate_feature_names, __pyx_k_Unable_to_generate_feature_names, sizeof(__pyx_k_Unable_to_generate_feature_names), 0, 1, 0, 0},
  {&__pyx_n_s_Union, __pyx_k_Union, sizeof(__pyx_k_Union), 0, 0, 1, 1},
  {&__pyx_kp_u_Unknown_value_for_include_bounda, __pyx_k_Unknown_value_for_include_bounda, sizeof(__pyx_k_Unknown_value_for_include_bounda), 0, 1, 0, 0},
  {&__pyx_kp_u_Unsupported_expected_type_provid, __pyx_k_Unsupported_expected_type_provid, sizeof(__pyx_k_Unsupported_expected_type_provid), 0, 1, 0, 0},
  {&__pyx_kp_u_Unsupported_or_mismatched_data_t, __pyx_k_Unsupported_or_mismatched_data_t, sizeof(__pyx_k_Unsupported_or_mismatched_data_t), 0, 1, 0, 0},
  {&__pyx_kp_u_Unsupported_target_type, __pyx_k_Unsupported_target_type, sizeof(__pyx_k_Unsupported_target_type), 0, 1, 0, 0},
  {&__pyx_kp_u_Unsupports_mode, __pyx_k_Unsupports_mode, sizeof(__pyx_k_Unsupports_mode), 0, 1, 0, 0},
  {&__pyx_kp_u_Use_numeric_or_object, __pyx_k_Use_numeric_or_object, sizeof(__pyx_k_Use_numeric_or_object), 0, 1, 0, 0},
  {&__pyx_n_s_UserWarning, __pyx_k_UserWarning, sizeof(__pyx_k_UserWarning), 0, 0, 1, 1},
  {&__pyx_kp_u_Valid_modes_are_strict_soft_or, __pyx_k_Valid_modes_are_strict_soft_or, sizeof(__pyx_k_Valid_modes_are_strict_soft_or), 0, 1, 0, 0},
  {&__pyx_kp_u_Valid_options_are, __pyx_k_Valid_options_are, sizeof(__pyx_k_Valid_options_are), 0, 1, 0, 0},
  {&__pyx_kp_u_Validate_and_compute_sample_wei, __pyx_k_Validate_and_compute_sample_wei, sizeof(__pyx_k_Validate_and_compute_sample_wei), 0, 1, 0, 0},
  {&__pyx_kp_u_Validate_that_the_input_data_fo, __pyx_k_Validate_that_the_input_data_fo, sizeof(__pyx_k_Validate_that_the_input_data_fo), 0, 1, 0, 0},
  {&__pyx_kp_u_Validate_that_the_target_arrays, __pyx_k_Validate_that_the_target_arrays, sizeof(__pyx_k_Validate_that_the_target_arrays), 0, 1, 0, 0},
  {&__pyx_kp_u_Validate_the_multioutput_parame, __pyx_k_Validate_the_multioutput_parame, sizeof(__pyx_k_Validate_the_multioutput_parame), 0, 1, 0, 0},
  {&__pyx_kp_u_Validates_a_DataFrame_to_ensure, __pyx_k_Validates_a_DataFrame_to_ensure, sizeof(__pyx_k_Validates_a_DataFrame_to_ensure), 0, 1, 0, 0},
  {&__pyx_kp_u_Validates_and_adjusts_the_provi, __pyx_k_Validates_and_adjusts_the_provi, sizeof(__pyx_k_Validates_and_adjusts_the_provi), 0, 1, 0, 0},
  {&__pyx_kp_u_Validates_and_applies_a_specifi, __pyx_k_Validates_and_applies_a_specifi, sizeof(__pyx_k_Validates_and_applies_a_specifi), 0, 1, 0, 0},
  {&__pyx_kp_u_Validates_and_optionally_conver, __pyx_k_Validates_and_optionally_conver, sizeof(__pyx_k_Validates_and_optionally_conver), 0, 1, 0, 0},
  {&__pyx_kp_u_Validates_and_optionally_normal, __pyx_k_Validates_and_optionally_normal, sizeof(__pyx_k_Validates_and_optionally_normal), 0, 1, 0, 0},
  {&__pyx_kp_u_Validates_and_parses_start_and, __pyx_k_Validates_and_parses_start_and, sizeof(__pyx_k_Validates_and_parses_start_and), 0, 1, 0, 0},
  {&__pyx_kp_u_Validates_if_a_given_value_is_n, __pyx_k_Validates_if_a_given_value_is_n, sizeof(__pyx_k_Validates_if_a_given_value_is_n), 0, 1, 0, 0},
  {&__pyx_kp_u_Validates_or_generates_distribu, __pyx_k_Validates_or_generates_distribu, sizeof(__pyx_k_Validates_or_generates_distribu), 0, 1, 0, 0},
  {&__pyx_kp_u_Validates_that_the_sample_weigh, __pyx_k_Validates_that_the_sample_weigh, sizeof(__pyx_k_Validates_that_the_sample_weigh), 0, 1, 0, 0},
  {&__pyx_kp_u_Validates_that_the_scores_repre, __pyx_k_Validates_that_the_scores_repre, sizeof(__pyx_k_Validates_that_the_scores_repre), 0, 1, 0, 0},
  {&__pyx_kp_u_Validates_that_the_target_data, __pyx_k_Validates_that_the_target_data, sizeof(__pyx_k_Validates_that_the_target_data), 0, 1, 0, 0},
  {&__pyx_kp_u_Validates_that_the_true_and_pre, __pyx_k_Validates_that_the_true_and_pre, sizeof(__pyx_k_Validates_that_the_true_and_pre), 0, 1, 0, 0},
  {&__pyx_kp_u_Validates_the_nan_policy_or_any, __pyx_k_Validates_the_nan_policy_or_any, sizeof(__pyx_k_Validates_the_nan_policy_or_any), 0, 1, 0, 0},
  {&__pyx_kp_u_Validates_the_review_length_ran, __pyx_k_Validates_the_review_length_ran, sizeof(__pyx_k_Validates_the_review_length_ran), 0, 1, 0, 0},
  {&__pyx_kp_u_Validates_whether_a_given_objec, __pyx_k_Validates_whether_a_given_objec, sizeof(__pyx_k_Validates_whether_a_given_objec), 0, 1, 0, 0},
  {&__pyx_kp_u_Validation_failed_in_strict_mode, __pyx_k_Validation_failed_in_strict_mode, sizeof(__pyx_k_Validation_failed_in_strict_mode), 0, 1, 0, 0},
  {&__pyx_kp_u_Value, __pyx_k_Value, sizeof(__pyx_k_Value), 0, 1, 0, 0},
  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
  {&__pyx_kp_u_Value_2, __pyx_k_Value_2, sizeof(__pyx_k_Value_2), 0, 1, 0, 0},
  {&__pyx_kp_s_Warning_raised_when_the_eigenval, __pyx_k_Warning_raised_when_the_eigenval, sizeof(__pyx_k_Warning_raised_when_the_eigenval), 0, 0, 1, 0},
  {&__pyx_kp_s_Warning_used_to_notify_implicit, __pyx_k_Warning_used_to_notify_implicit, sizeof(__pyx_k_Warning_used_to_notify_implicit), 0, 0, 1, 0},
  {&__pyx_kp_u_Weights_must_be_between, __pyx_k_Weights_must_be_between, sizeof(__pyx_k_Weights_must_be_between), 0, 1, 0, 0},
  {&__pyx_kp_u_Weights_must_be_non_negative_unl, __pyx_k_Weights_must_be_non_negative_unl, sizeof(__pyx_k_Weights_must_be_non_negative_unl), 0, 1, 0, 0},
  {&__pyx_kp_u_Weights_must_be_provided_in_a_fo, __pyx_k_Weights_must_be_provided_in_a_fo, sizeof(__pyx_k_Weights_must_be_provided_in_a_fo), 0, 1, 0, 0},
  {&__pyx_kp_u_Weights_must_have_dimensions_in, __pyx_k_Weights_must_have_dimensions_in, sizeof(__pyx_k_Weights_must_have_dimensions_in), 0, 1, 0, 0},
  {&__pyx_kp_u_When_providing_accept_sparse_as, __pyx_k_When_providing_accept_sparse_as, sizeof(__pyx_k_When_providing_accept_sparse_as), 0, 1, 0, 0},
  {&__pyx_n_s_X, __pyx_k_X, sizeof(__pyx_k_X), 0, 0, 1, 1},
  {&__pyx_n_u_X, __pyx_k_X, sizeof(__pyx_k_X), 0, 1, 0, 1},
  {&__pyx_kp_u_Y_m_d, __pyx_k_Y_m_d, sizeof(__pyx_k_Y_m_d), 0, 1, 0, 0},
  {&__pyx_kp_u_Year, __pyx_k_Year, sizeof(__pyx_k_Year), 0, 1, 0, 0},
  {&__pyx_kp_u__100, __pyx_k__100, sizeof(__pyx_k__100), 0, 1, 0, 0},
  {&__pyx_kp_u__101, __pyx_k__101, sizeof(__pyx_k__101), 0, 1, 0, 0},
  {&__pyx_n_s__102, __pyx_k__102, sizeof(__pyx_k__102), 0, 0, 1, 1},
  {&__pyx_n_u__102, __pyx_k__102, sizeof(__pyx_k__102), 0, 1, 0, 1},
  {&__pyx_n_u__103, __pyx_k__103, sizeof(__pyx_k__103), 0, 1, 0, 1},
  {&__pyx_kp_u__113, __pyx_k__113, sizeof(__pyx_k__113), 0, 1, 0, 0},
  {&__pyx_kp_u__117, __pyx_k__117, sizeof(__pyx_k__117), 0, 1, 0, 0},
  {&__pyx_n_s__118, __pyx_k__118, sizeof(__pyx_k__118), 0, 0, 1, 1},
  {&__pyx_kp_u__16, __pyx_k__16, sizeof(__pyx_k__16), 0, 1, 0, 0},
  {&__pyx_kp_u__18, __pyx_k__18, sizeof(__pyx_k__18), 0, 1, 0, 0},
  {&__pyx_kp_u__52, __pyx_k__52, sizeof(__pyx_k__52), 0, 1, 0, 0},
  {&__pyx_kp_u__53, __pyx_k__53, sizeof(__pyx_k__53), 0, 1, 0, 0},
  {&__pyx_kp_u__54, __pyx_k__54, sizeof(__pyx_k__54), 0, 1, 0, 0},
  {&__pyx_kp_u__63, __pyx_k__63, sizeof(__pyx_k__63), 0, 1, 0, 0},
  {&__pyx_kp_u__64, __pyx_k__64, sizeof(__pyx_k__64), 0, 1, 0, 0},
  {&__pyx_kp_u__7, __pyx_k__7, sizeof(__pyx_k__7), 0, 1, 0, 0},
  {&__pyx_kp_u__81, __pyx_k__81, sizeof(__pyx_k__81), 0, 1, 0, 0},
  {&__pyx_kp_u__82, __pyx_k__82, sizeof(__pyx_k__82), 0, 1, 0, 0},
  {&__pyx_kp_u__83, __pyx_k__83, sizeof(__pyx_k__83), 0, 1, 0, 0},
  {&__pyx_kp_u__92, __pyx_k__92, sizeof(__pyx_k__92), 0, 1, 0, 0},
  {&__pyx_kp_u__93, __pyx_k__93, sizeof(__pyx_k__93), 0, 1, 0, 0},
  {&__pyx_kp_u__97, __pyx_k__97, sizeof(__pyx_k__97), 0, 1, 0, 0},
  {&__pyx_kp_u__98, __pyx_k__98, sizeof(__pyx_k__98), 0, 1, 0, 0},
  {&__pyx_kp_u__99, __pyx_k__99, sizeof(__pyx_k__99), 0, 1, 0, 0},
  {&__pyx_kp_u_a, __pyx_k_a, sizeof(__pyx_k_a), 0, 1, 0, 0},
  {&__pyx_kp_u_a_non_negative_integer, __pyx_k_a_non_negative_integer, sizeof(__pyx_k_a_non_negative_integer), 0, 1, 0, 0},
  {&__pyx_kp_u_a_positive_integer, __pyx_k_a_positive_integer, sizeof(__pyx_k_a_positive_integer), 0, 1, 0, 0},
  {&__pyx_n_s_accept_large_sparse, __pyx_k_accept_large_sparse, sizeof(__pyx_k_accept_large_sparse), 0, 0, 1, 1},
  {&__pyx_n_s_accept_multi_output, __pyx_k_accept_multi_output, sizeof(__pyx_k_accept_multi_output), 0, 0, 1, 1},
  {&__pyx_n_s_accept_multioutput, __pyx_k_accept_multioutput, sizeof(__pyx_k_accept_multioutput), 0, 0, 1, 1},
  {&__pyx_n_s_accept_sparse, __pyx_k_accept_sparse, sizeof(__pyx_k_accept_sparse), 0, 0, 1, 1},
  {&__pyx_n_s_actual_type_y_pred, __pyx_k_actual_type_y_pred, sizeof(__pyx_k_actual_type_y_pred), 0, 0, 1, 1},
  {&__pyx_n_s_actual_type_y_true, __pyx_k_actual_type_y_true, sizeof(__pyx_k_actual_type_y_true), 0, 0, 1, 1},
  {&__pyx_n_s_adjusted_ranges, __pyx_k_adjusted_ranges, sizeof(__pyx_k_adjusted_ranges), 0, 0, 1, 1},
  {&__pyx_n_s_align, __pyx_k_align, sizeof(__pyx_k_align), 0, 0, 1, 1},
  {&__pyx_n_s_align_mode, __pyx_k_align_mode, sizeof(__pyx_k_align_mode), 0, 0, 1, 1},
  {&__pyx_n_s_alignment, __pyx_k_alignment, sizeof(__pyx_k_alignment), 0, 0, 1, 1},
  {&__pyx_n_s_all, __pyx_k_all, sizeof(__pyx_k_all), 0, 0, 1, 1},
  {&__pyx_n_s_all_2, __pyx_k_all_2, sizeof(__pyx_k_all_2), 0, 0, 1, 1},
  {&__pyx_n_s_all_args, __pyx_k_all_args, sizeof(__pyx_k_all_args), 0, 0, 1, 1},
  {&__pyx_n_s_all_or_any, __pyx_k_all_or_any, sizeof(__pyx_k_all_or_any), 0, 0, 1, 1},
  {&__pyx_n_s_allclose, __pyx_k_allclose, sizeof(__pyx_k_allclose), 0, 0, 1, 1},
  {&__pyx_kp_u_allow_nan, __pyx_k_allow_nan, sizeof(__pyx_k_allow_nan), 0, 1, 0, 0},
  {&__pyx_n_s_allow_nan_2, __pyx_k_allow_nan_2, sizeof(__pyx_k_allow_nan_2), 0, 0, 1, 1},
  {&__pyx_n_s_allow_nd, __pyx_k_allow_nd, sizeof(__pyx_k_allow_nd), 0, 0, 1, 1},
  {&__pyx_n_s_allow_negative, __pyx_k_allow_negative, sizeof(__pyx_k_allow_negative), 0, 0, 1, 1},
  {&__pyx_n_s_allowed_dims, __pyx_k_allowed_dims, sizeof(__pyx_k_allowed_dims), 0, 0, 1, 1},
  {&__pyx_n_s_allowed_policies, __pyx_k_allowed_policies, sizeof(__pyx_k_allowed_policies), 0, 0, 1, 1},
  {&__pyx_n_s_allowed_types, __pyx_k_allowed_types, sizeof(__pyx_k_allowed_types), 0, 0, 1, 1},
  {&__pyx_kp_u_and, __pyx_k_and, sizeof(__pyx_k_and), 0, 1, 0, 0},
  {&__pyx_kp_u_and_2, __pyx_k_and_2, sizeof(__pyx_k_and_2), 0, 1, 0, 0},
  {&__pyx_n_s_any, __pyx_k_any, sizeof(__pyx_k_any), 0, 0, 1, 1},
  {&__pyx_n_s_api, __pyx_k_api, sizeof(__pyx_k_api), 0, 0, 1, 1},
  {&__pyx_n_s_apply, __pyx_k_apply, sizeof(__pyx_k_apply), 0, 0, 1, 1},
  {&__pyx_n_s_ar1, __pyx_k_ar1, sizeof(__pyx_k_ar1), 0, 0, 1, 1},
  {&__pyx_n_s_ar2, __pyx_k_ar2, sizeof(__pyx_k_ar2), 0, 0, 1, 1},
  {&__pyx_n_s_arg, __pyx_k_arg, sizeof(__pyx_k_arg), 0, 0, 1, 1},
  {&__pyx_n_s_args, __pyx_k_args, sizeof(__pyx_k_args), 0, 0, 1, 1},
  {&__pyx_n_s_args_msg, __pyx_k_args_msg, sizeof(__pyx_k_args_msg), 0, 0, 1, 1},
  {&__pyx_n_s_arr, __pyx_k_arr, sizeof(__pyx_k_arr), 0, 0, 1, 1},
  {&__pyx_n_s_arr_name, __pyx_k_arr_name, sizeof(__pyx_k_arr_name), 0, 0, 1, 1},
  {&__pyx_n_s_array, __pyx_k_array, sizeof(__pyx_k_array), 0, 0, 1, 1},
  {&__pyx_n_u_array, __pyx_k_array, sizeof(__pyx_k_array), 0, 1, 0, 1},
  {&__pyx_n_u_array_2, __pyx_k_array_2, sizeof(__pyx_k_array_2), 0, 1, 0, 1},
  {&__pyx_n_s_array_api, __pyx_k_array_api, sizeof(__pyx_k_array_api), 0, 0, 1, 1},
  {&__pyx_n_s_array_equal, __pyx_k_array_equal, sizeof(__pyx_k_array_equal), 0, 0, 1, 1},
  {&__pyx_kp_u_array_must_be_2_dimensional_and, __pyx_k_array_must_be_2_dimensional_and, sizeof(__pyx_k_array_must_be_2_dimensional_and), 0, 1, 0, 0},
  {&__pyx_n_s_array_orig, __pyx_k_array_orig, sizeof(__pyx_k_array_orig), 0, 0, 1, 1},
  {&__pyx_n_s_array_to_frame, __pyx_k_array_to_frame, sizeof(__pyx_k_array_to_frame), 0, 0, 1, 1},
  {&__pyx_n_u_array_to_frame, __pyx_k_array_to_frame, sizeof(__pyx_k_array_to_frame), 0, 1, 0, 1},
  {&__pyx_n_s_array_to_frame2, __pyx_k_array_to_frame2, sizeof(__pyx_k_array_to_frame2), 0, 0, 1, 1},
  {&__pyx_n_u_array_to_frame2, __pyx_k_array_to_frame2, sizeof(__pyx_k_array_to_frame2), 0, 1, 0, 1},
  {&__pyx_kp_u_array_to_frame2_line_4956, __pyx_k_array_to_frame2_line_4956, sizeof(__pyx_k_array_to_frame2_line_4956), 0, 1, 0, 0},
  {&__pyx_kp_u_array_to_frame_line_4885, __pyx_k_array_to_frame_line_4885, sizeof(__pyx_k_array_to_frame_line_4885), 0, 1, 0, 0},
  {&__pyx_n_s_arrays, __pyx_k_arrays, sizeof(__pyx_k_arrays), 0, 0, 1, 1},
  {&__pyx_kp_u_as_it_inherently_combines_outpu, __pyx_k_as_it_inherently_combines_outpu, sizeof(__pyx_k_as_it_inherently_combines_outpu), 0, 1, 0, 0},
  {&__pyx_kp_u_as_keyword_args_From_version, __pyx_k_as_keyword_args_From_version, sizeof(__pyx_k_as_keyword_args_From_version), 0, 1, 0, 0},
  {&__pyx_n_s_asarray, __pyx_k_asarray, sizeof(__pyx_k_asarray), 0, 0, 1, 1},
  {&__pyx_n_s_asarray_with_order, __pyx_k_asarray_with_order, sizeof(__pyx_k_asarray_with_order), 0, 0, 1, 1},
  {&__pyx_n_s_asformat, __pyx_k_asformat, sizeof(__pyx_k_asformat), 0, 0, 1, 1},
  {&__pyx_n_s_assert_all_finite, __pyx_k_assert_all_finite, sizeof(__pyx_k_assert_all_finite), 0, 0, 1, 1},
  {&__pyx_n_s_assert_all_finite_2, __pyx_k_assert_all_finite_2, sizeof(__pyx_k_assert_all_finite_2), 0, 0, 1, 1},
  {&__pyx_n_u_assert_all_finite_2, __pyx_k_assert_all_finite_2, sizeof(__pyx_k_assert_all_finite_2), 0, 1, 0, 1},
  {&__pyx_n_s_assert_xy_in, __pyx_k_assert_xy_in, sizeof(__pyx_k_assert_xy_in), 0, 0, 1, 1},
  {&__pyx_n_u_assert_xy_in, __pyx_k_assert_xy_in, sizeof(__pyx_k_assert_xy_in), 0, 1, 0, 1},
  {&__pyx_kp_u_assert_xy_in_line_2884, __pyx_k_assert_xy_in_line_2884, sizeof(__pyx_k_assert_xy_in_line_2884), 0, 1, 0, 0},
  {&__pyx_n_s_astype, __pyx_k_astype, sizeof(__pyx_k_astype), 0, 0, 1, 1},
  {&__pyx_n_s_atol, __pyx_k_atol, sizeof(__pyx_k_atol), 0, 0, 1, 1},
  {&__pyx_n_s_attr, __pyx_k_attr, sizeof(__pyx_k_attr), 0, 0, 1, 1},
  {&__pyx_n_s_attributes, __pyx_k_attributes, sizeof(__pyx_k_attributes), 0, 0, 1, 1},
  {&__pyx_n_u_auto, __pyx_k_auto, sizeof(__pyx_k_auto), 0, 1, 0, 1},
  {&__pyx_n_u_average_uniform, __pyx_k_average_uniform, sizeof(__pyx_k_average_uniform), 0, 1, 0, 1},
  {&__pyx_n_s_axis, __pyx_k_axis, sizeof(__pyx_k_axis), 0, 0, 1, 1},
  {&__pyx_n_s_base_epsilon, __pyx_k_base_epsilon, sizeof(__pyx_k_base_epsilon), 0, 0, 1, 1},
  {&__pyx_n_u_best_estimator, __pyx_k_best_estimator, sizeof(__pyx_k_best_estimator), 0, 1, 0, 1},
  {&__pyx_n_u_best_params, __pyx_k_best_params, sizeof(__pyx_k_best_params), 0, 1, 0, 1},
  {&__pyx_kp_u_bi___selector_biselect_biselecto, __pyx_k_bi___selector_biselect_biselecto, sizeof(__pyx_k_bi___selector_biselect_biselecto), 0, 1, 0, 0},
  {&__pyx_n_u_biselect, __pyx_k_biselect, sizeof(__pyx_k_biselect), 0, 1, 0, 1},
  {&__pyx_n_s_biselect_pattern, __pyx_k_biselect_pattern, sizeof(__pyx_k_biselect_pattern), 0, 0, 1, 1},
  {&__pyx_n_u_biselector, __pyx_k_biselector, sizeof(__pyx_k_biselector), 0, 1, 0, 1},
  {&__pyx_n_u_biufc, __pyx_k_biufc, sizeof(__pyx_k_biufc), 0, 1, 0, 1},
  {&__pyx_n_u_bool, __pyx_k_bool, sizeof(__pyx_k_bool), 0, 1, 0, 1},
  {&__pyx_n_u_both, __pyx_k_both, sizeof(__pyx_k_both), 0, 1, 0, 1},
  {&__pyx_n_u_bsr, __pyx_k_bsr, sizeof(__pyx_k_bsr), 0, 1, 0, 1},
  {&__pyx_n_u_buifc, __pyx_k_buifc, sizeof(__pyx_k_buifc), 0, 1, 0, 1},
  {&__pyx_n_s_build_data_if, __pyx_k_build_data_if, sizeof(__pyx_k_build_data_if), 0, 0, 1, 1},
  {&__pyx_n_u_build_data_if, __pyx_k_build_data_if, sizeof(__pyx_k_build_data_if), 0, 1, 0, 1},
  {&__pyx_n_s_build_data_if2, __pyx_k_build_data_if2, sizeof(__pyx_k_build_data_if2), 0, 0, 1, 1},
  {&__pyx_n_u_build_data_if2, __pyx_k_build_data_if2, sizeof(__pyx_k_build_data_if2), 0, 1, 0, 1},
  {&__pyx_n_u_builtins, __pyx_k_builtins, sizeof(__pyx_k_builtins), 0, 1, 0, 1},
  {&__pyx_kp_u_but_columns_implied, __pyx_k_but_columns_implied, sizeof(__pyx_k_but_columns_implied), 0, 1, 0, 0},
  {&__pyx_n_u_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 1, 0, 1},
  {&__pyx_n_u_cache, __pyx_k_cache, sizeof(__pyx_k_cache), 0, 1, 0, 1},
  {&__pyx_n_s_callable_obj, __pyx_k_callable_obj, sizeof(__pyx_k_callable_obj), 0, 0, 1, 1},
  {&__pyx_kp_u_cannot_be_converted_to_DataFram, __pyx_k_cannot_be_converted_to_DataFram, sizeof(__pyx_k_cannot_be_converted_to_DataFram), 0, 1, 0, 0},
  {&__pyx_n_s_casting, __pyx_k_casting, sizeof(__pyx_k_casting), 0, 0, 1, 1},
  {&__pyx_n_s_catch_warnings, __pyx_k_catch_warnings, sizeof(__pyx_k_catch_warnings), 0, 0, 1, 1},
  {&__pyx_n_u_categoric, __pyx_k_categoric, sizeof(__pyx_k_categoric), 0, 1, 0, 1},
  {&__pyx_kp_u_categoric_al__only_categorical, __pyx_k_categoric_al__only_categorical, sizeof(__pyx_k_categoric_al__only_categorical), 0, 1, 0, 0},
  {&__pyx_n_u_categoric_only, __pyx_k_categoric_only, sizeof(__pyx_k_categoric_only), 0, 1, 0, 1},
  {&__pyx_n_s_categoric_pattern, __pyx_k_categoric_pattern, sizeof(__pyx_k_categoric_pattern), 0, 0, 1, 1},
  {&__pyx_n_u_category, __pyx_k_category, sizeof(__pyx_k_category), 0, 1, 0, 1},
  {&__pyx_n_s_ceil, __pyx_k_ceil, sizeof(__pyx_k_ceil), 0, 0, 1, 1},
  {&__pyx_n_u_ceil, __pyx_k_ceil, sizeof(__pyx_k_ceil), 0, 1, 0, 1},
  {&__pyx_n_s_changed_format, __pyx_k_changed_format, sizeof(__pyx_k_changed_format), 0, 0, 1, 1},
  {&__pyx_n_s_check, __pyx_k_check, sizeof(__pyx_k_check), 0, 0, 1, 1},
  {&__pyx_n_s_check_X_y, __pyx_k_check_X_y, sizeof(__pyx_k_check_X_y), 0, 0, 1, 1},
  {&__pyx_n_u_check_X_y, __pyx_k_check_X_y, sizeof(__pyx_k_check_X_y), 0, 1, 0, 1},
  {&__pyx_n_s_check_array, __pyx_k_check_array, sizeof(__pyx_k_check_array), 0, 0, 1, 1},
  {&__pyx_n_u_check_array, __pyx_k_check_array, sizeof(__pyx_k_check_array), 0, 1, 0, 1},
  {&__pyx_n_s_check_array_in, __pyx_k_check_array_in, sizeof(__pyx_k_check_array_in), 0, 0, 1, 1},
  {&__pyx_n_s_check_array_locals_genexpr, __pyx_k_check_array_locals_genexpr, sizeof(__pyx_k_check_array_locals_genexpr), 0, 0, 1, 1},
  {&__pyx_n_s_check_classification_targets, __pyx_k_check_classification_targets, sizeof(__pyx_k_check_classification_targets), 0, 0, 1, 1},
  {&__pyx_n_u_check_classification_targets, __pyx_k_check_classification_targets, sizeof(__pyx_k_check_classification_targets), 0, 1, 0, 1},
  {&__pyx_kp_u_check_classification_targets_lin, __pyx_k_check_classification_targets_lin, sizeof(__pyx_k_check_classification_targets_lin), 0, 1, 0, 0},
  {&__pyx_n_s_check_classification_targets_loc, __pyx_k_check_classification_targets_loc, sizeof(__pyx_k_check_classification_targets_loc), 0, 0, 1, 1},
  {&__pyx_n_s_check_consistency_size, __pyx_k_check_consistency_size, sizeof(__pyx_k_check_consistency_size), 0, 0, 1, 1},
  {&__pyx_n_u_check_consistency_size, __pyx_k_check_consistency_size, sizeof(__pyx_k_check_consistency_size), 0, 1, 0, 1},
  {&__pyx_n_s_check_consistency_size_2, __pyx_k_check_consistency_size_2, sizeof(__pyx_k_check_consistency_size_2), 0, 0, 1, 1},
  {&__pyx_n_s_check_consistent_length, __pyx_k_check_consistent_length, sizeof(__pyx_k_check_consistent_length), 0, 0, 1, 1},
  {&__pyx_n_u_check_consistent_length, __pyx_k_check_consistent_length, sizeof(__pyx_k_check_consistent_length), 0, 1, 0, 1},
  {&__pyx_n_s_check_epsilon, __pyx_k_check_epsilon, sizeof(__pyx_k_check_epsilon), 0, 0, 1, 1},
  {&__pyx_n_u_check_epsilon, __pyx_k_check_epsilon, sizeof(__pyx_k_check_epsilon), 0, 1, 0, 1},
  {&__pyx_kp_u_check_epsilon_line_1868, __pyx_k_check_epsilon_line_1868, sizeof(__pyx_k_check_epsilon_line_1868), 0, 1, 0, 0},
  {&__pyx_n_s_check_estimator_name, __pyx_k_check_estimator_name, sizeof(__pyx_k_check_estimator_name), 0, 0, 1, 1},
  {&__pyx_n_s_check_feature_names_in, __pyx_k_check_feature_names_in, sizeof(__pyx_k_check_feature_names_in), 0, 0, 1, 1},
  {&__pyx_n_s_check_is_fitted, __pyx_k_check_is_fitted, sizeof(__pyx_k_check_is_fitted), 0, 0, 1, 1},
  {&__pyx_n_u_check_is_fitted, __pyx_k_check_is_fitted, sizeof(__pyx_k_check_is_fitted), 0, 1, 0, 1},
  {&__pyx_n_s_check_is_fitted2, __pyx_k_check_is_fitted2, sizeof(__pyx_k_check_is_fitted2), 0, 0, 1, 1},
  {&__pyx_n_u_check_is_fitted2, __pyx_k_check_is_fitted2, sizeof(__pyx_k_check_is_fitted2), 0, 1, 0, 1},
  {&__pyx_kp_u_check_is_fitted2_line_2836, __pyx_k_check_is_fitted2_line_2836, sizeof(__pyx_k_check_is_fitted2_line_2836), 0, 1, 0, 0},
  {&__pyx_n_s_check_large_sparse, __pyx_k_check_large_sparse, sizeof(__pyx_k_check_large_sparse), 0, 0, 1, 1},
  {&__pyx_n_s_check_memory, __pyx_k_check_memory, sizeof(__pyx_k_check_memory), 0, 0, 1, 1},
  {&__pyx_n_u_check_memory, __pyx_k_check_memory, sizeof(__pyx_k_check_memory), 0, 1, 0, 1},
  {&__pyx_n_s_check_mixed_data_types, __pyx_k_check_mixed_data_types, sizeof(__pyx_k_check_mixed_data_types), 0, 0, 1, 1},
  {&__pyx_n_u_check_mixed_data_types, __pyx_k_check_mixed_data_types, sizeof(__pyx_k_check_mixed_data_types), 0, 1, 0, 1},
  {&__pyx_kp_u_check_mixed_data_types_line_2276, __pyx_k_check_mixed_data_types_line_2276, sizeof(__pyx_k_check_mixed_data_types_line_2276), 0, 1, 0, 0},
  {&__pyx_n_s_check_mixed_data_types_locals_la, __pyx_k_check_mixed_data_types_locals_la, sizeof(__pyx_k_check_mixed_data_types_locals_la), 0, 0, 1, 1},
  {&__pyx_n_s_check_mode, __pyx_k_check_mode, sizeof(__pyx_k_check_mode), 0, 0, 1, 1},
  {&__pyx_n_s_check_random_state, __pyx_k_check_random_state, sizeof(__pyx_k_check_random_state), 0, 0, 1, 1},
  {&__pyx_n_u_check_random_state, __pyx_k_check_random_state, sizeof(__pyx_k_check_random_state), 0, 1, 0, 1},
  {&__pyx_n_s_check_scalar, __pyx_k_check_scalar, sizeof(__pyx_k_check_scalar), 0, 0, 1, 1},
  {&__pyx_n_u_check_scalar, __pyx_k_check_scalar, sizeof(__pyx_k_check_scalar), 0, 1, 0, 1},
  {&__pyx_n_s_check_scalar_locals_genexpr, __pyx_k_check_scalar_locals_genexpr, sizeof(__pyx_k_check_scalar_locals_genexpr), 0, 0, 1, 1},
  {&__pyx_n_s_check_scalar_locals_type_name, __pyx_k_check_scalar_locals_type_name, sizeof(__pyx_k_check_scalar_locals_type_name), 0, 0, 1, 1},
  {&__pyx_n_s_check_symmetric, __pyx_k_check_symmetric, sizeof(__pyx_k_check_symmetric), 0, 0, 1, 1},
  {&__pyx_n_u_check_symmetric, __pyx_k_check_symmetric, sizeof(__pyx_k_check_symmetric), 0, 1, 0, 1},
  {&__pyx_n_s_check_time_interval, __pyx_k_check_time_interval, sizeof(__pyx_k_check_time_interval), 0, 0, 1, 1},
  {&__pyx_n_s_check_y, __pyx_k_check_y, sizeof(__pyx_k_check_y), 0, 0, 1, 1},
  {&__pyx_n_u_check_y, __pyx_k_check_y, sizeof(__pyx_k_check_y), 0, 1, 0, 1},
  {&__pyx_n_s_check_y_1d, __pyx_k_check_y_1d, sizeof(__pyx_k_check_y_1d), 0, 0, 1, 1},
  {&__pyx_n_s_check_y_2, __pyx_k_check_y_2, sizeof(__pyx_k_check_y_2), 0, 0, 1, 1},
  {&__pyx_n_s_check_y_locals_genexpr, __pyx_k_check_y_locals_genexpr, sizeof(__pyx_k_check_y_locals_genexpr), 0, 0, 1, 1},
  {&__pyx_n_s_class, __pyx_k_class, sizeof(__pyx_k_class), 0, 0, 1, 1},
  {&__pyx_n_u_class, __pyx_k_class, sizeof(__pyx_k_class), 0, 1, 0, 1},
  {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
  {&__pyx_n_s_close, __pyx_k_close, sizeof(__pyx_k_close), 0, 0, 1, 1},
  {&__pyx_n_s_cls_name, __pyx_k_cls_name, sizeof(__pyx_k_cls_name), 0, 0, 1, 1},
  {&__pyx_n_u_coerce, __pyx_k_coerce, sizeof(__pyx_k_coerce), 0, 1, 0, 1},
  {&__pyx_n_s_coerce_datetime, __pyx_k_coerce_datetime, sizeof(__pyx_k_coerce_datetime), 0, 0, 1, 1},
  {&__pyx_n_s_coerce_numeric, __pyx_k_coerce_numeric, sizeof(__pyx_k_coerce_numeric), 0, 0, 1, 1},
  {&__pyx_n_u_col, __pyx_k_col, sizeof(__pyx_k_col), 0, 1, 0, 1},
  {&__pyx_n_s_col_data, __pyx_k_col_data, sizeof(__pyx_k_col_data), 0, 0, 1, 1},
  {&__pyx_n_s_col_type, __pyx_k_col_type, sizeof(__pyx_k_col_type), 0, 0, 1, 1},
  {&__pyx_n_s_column, __pyx_k_column, sizeof(__pyx_k_column), 0, 0, 1, 1},
  {&__pyx_n_s_column_orig, __pyx_k_column_orig, sizeof(__pyx_k_column_orig), 0, 0, 1, 1},
  {&__pyx_n_s_column_prefix, __pyx_k_column_prefix, sizeof(__pyx_k_column_prefix), 0, 0, 1, 1},
  {&__pyx_n_s_column_stack, __pyx_k_column_stack, sizeof(__pyx_k_column_stack), 0, 0, 1, 1},
  {&__pyx_n_s_columns, __pyx_k_columns, sizeof(__pyx_k_columns), 0, 0, 1, 1},
  {&__pyx_n_u_columns, __pyx_k_columns, sizeof(__pyx_k_columns), 0, 1, 0, 1},
  {&__pyx_n_u_columns_to_index, __pyx_k_columns_to_index, sizeof(__pyx_k_columns_to_index), 0, 1, 0, 1},
  {&__pyx_n_s_comparison_operator, __pyx_k_comparison_operator, sizeof(__pyx_k_comparison_operator), 0, 0, 1, 1},
  {&__pyx_n_u_compile, __pyx_k_compile, sizeof(__pyx_k_compile), 0, 1, 0, 1},
  {&__pyx_n_s_complex_warning, __pyx_k_complex_warning, sizeof(__pyx_k_complex_warning), 0, 0, 1, 1},
  {&__pyx_kp_u_computation, __pyx_k_computation, sizeof(__pyx_k_computation), 0, 1, 0, 0},
  {&__pyx_n_s_concatenate, __pyx_k_concatenate, sizeof(__pyx_k_concatenate), 0, 0, 1, 1},
  {&__pyx_n_s_condition, __pyx_k_condition, sizeof(__pyx_k_condition), 0, 0, 1, 1},
  {&__pyx_n_u_contains, __pyx_k_contains, sizeof(__pyx_k_contains), 0, 1, 0, 1},
  {&__pyx_kp_u_contains_2, __pyx_k_contains_2, sizeof(__pyx_k_contains_2), 0, 1, 0, 0},
  {&__pyx_kp_u_contains_negative_values_Expect, __pyx_k_contains_negative_values_Expect, sizeof(__pyx_k_contains_negative_values_Expect), 0, 1, 0, 0},
  {&__pyx_n_s_contains_nested_objects, __pyx_k_contains_nested_objects, sizeof(__pyx_k_contains_nested_objects), 0, 0, 1, 1},
  {&__pyx_n_u_contains_nested_objects, __pyx_k_contains_nested_objects, sizeof(__pyx_k_contains_nested_objects), 0, 1, 0, 1},
  {&__pyx_kp_u_contains_nested_objects_line_148, __pyx_k_contains_nested_objects_line_148, sizeof(__pyx_k_contains_nested_objects_line_148), 0, 1, 0, 0},
  {&__pyx_n_s_contains_nested_objects_locals_g, __pyx_k_contains_nested_objects_locals_g, sizeof(__pyx_k_contains_nested_objects_locals_g), 0, 0, 1, 1},
  {&__pyx_n_s_contains_nested_objects_locals_i, __pyx_k_contains_nested_objects_locals_i, sizeof(__pyx_k_contains_nested_objects_locals_i), 0, 0, 1, 1},
  {&__pyx_kp_u_contains_non_numeric_values_whi, __pyx_k_contains_non_numeric_values_whi, sizeof(__pyx_k_contains_non_numeric_values_whi), 0, 1, 0, 0},
  {&__pyx_n_s_contextlib, __pyx_k_contextlib, sizeof(__pyx_k_contextlib), 0, 0, 1, 1},
  {&__pyx_n_u_continuous, __pyx_k_continuous, sizeof(__pyx_k_continuous), 0, 1, 0, 1},
  {&__pyx_n_s_conversion, __pyx_k_conversion, sizeof(__pyx_k_conversion), 0, 0, 1, 1},
  {&__pyx_n_s_convert_array_to_pandas, __pyx_k_convert_array_to_pandas, sizeof(__pyx_k_convert_array_to_pandas), 0, 0, 1, 1},
  {&__pyx_n_u_convert_array_to_pandas, __pyx_k_convert_array_to_pandas, sizeof(__pyx_k_convert_array_to_pandas), 0, 1, 0, 1},
  {&__pyx_n_s_convert_to, __pyx_k_convert_to, sizeof(__pyx_k_convert_to), 0, 0, 1, 1},
  {&__pyx_n_u_coo, __pyx_k_coo, sizeof(__pyx_k_coo), 0, 1, 0, 1},
  {&__pyx_n_s_copy, __pyx_k_copy, sizeof(__pyx_k_copy), 0, 0, 1, 1},
  {&__pyx_n_s_coreutils, __pyx_k_coreutils, sizeof(__pyx_k_coreutils), 0, 0, 1, 1},
  {&__pyx_n_u_csc, __pyx_k_csc, sizeof(__pyx_k_csc), 0, 1, 0, 1},
  {&__pyx_n_u_csr, __pyx_k_csr, sizeof(__pyx_k_csr), 0, 1, 0, 1},
  {&__pyx_n_s_current_year, __pyx_k_current_year, sizeof(__pyx_k_current_year), 0, 0, 1, 1},
  {&__pyx_n_s_custom_check, __pyx_k_custom_check, sizeof(__pyx_k_custom_check), 0, 0, 1, 1},
  {&__pyx_n_u_d, __pyx_k_d, sizeof(__pyx_k_d), 0, 1, 0, 1},
  {&__pyx_n_s_data, __pyx_k_data, sizeof(__pyx_k_data), 0, 0, 1, 1},
  {&__pyx_n_u_data, __pyx_k_data, sizeof(__pyx_k_data), 0, 1, 0, 1},
  {&__pyx_kp_u_data_frame_or_series, __pyx_k_data_frame_or_series, sizeof(__pyx_k_data_frame_or_series), 0, 1, 0, 0},
  {&__pyx_n_s_data_type, __pyx_k_data_type, sizeof(__pyx_k_data_type), 0, 0, 1, 1},
  {&__pyx_kp_u_data_type_must_be_either_array_o, __pyx_k_data_type_must_be_either_array_o, sizeof(__pyx_k_data_type_must_be_either_array_o), 0, 1, 0, 0},
  {&__pyx_n_u_dataframe, __pyx_k_dataframe, sizeof(__pyx_k_dataframe), 0, 1, 0, 1},
  {&__pyx_n_s_date_format, __pyx_k_date_format, sizeof(__pyx_k_date_format), 0, 0, 1, 1},
  {&__pyx_n_s_datetime, __pyx_k_datetime, sizeof(__pyx_k_datetime), 0, 0, 1, 1},
  {&__pyx_n_u_datetime, __pyx_k_datetime, sizeof(__pyx_k_datetime), 0, 1, 0, 1},
  {&__pyx_n_s_datetime_pattern, __pyx_k_datetime_pattern, sizeof(__pyx_k_datetime_pattern), 0, 0, 1, 1},
  {&__pyx_n_s_deep_check, __pyx_k_deep_check, sizeof(__pyx_k_deep_check), 0, 0, 1, 1},
  {&__pyx_n_s_dependency, __pyx_k_dependency, sizeof(__pyx_k_dependency), 0, 0, 1, 1},
  {&__pyx_n_s_deprecate_positional_args, __pyx_k_deprecate_positional_args, sizeof(__pyx_k_deprecate_positional_args), 0, 0, 1, 1},
  {&__pyx_n_s_deprecate_positional_args_local, __pyx_k_deprecate_positional_args_local, sizeof(__pyx_k_deprecate_positional_args_local), 0, 0, 1, 1},
  {&__pyx_n_s_deprecate_positional_args_local_2, __pyx_k_deprecate_positional_args_local_2, sizeof(__pyx_k_deprecate_positional_args_local_2), 0, 0, 1, 1},
  {&__pyx_n_s_determine_epsilon, __pyx_k_determine_epsilon, sizeof(__pyx_k_determine_epsilon), 0, 0, 1, 1},
  {&__pyx_n_s_df, __pyx_k_df, sizeof(__pyx_k_df), 0, 0, 1, 1},
  {&__pyx_n_s_df_only, __pyx_k_df_only, sizeof(__pyx_k_df_only), 0, 0, 1, 1},
  {&__pyx_n_s_diff, __pyx_k_diff, sizeof(__pyx_k_diff), 0, 0, 1, 1},
  {&__pyx_n_s_distributed_elements, __pyx_k_distributed_elements, sizeof(__pyx_k_distributed_elements), 0, 0, 1, 1},
  {&__pyx_kp_u_distributed_elements_must_be_sp, __pyx_k_distributed_elements_must_be_sp, sizeof(__pyx_k_distributed_elements_must_be_sp), 0, 1, 0, 0},
  {&__pyx_n_s_distribution, __pyx_k_distribution, sizeof(__pyx_k_distribution), 0, 0, 1, 1},
  {&__pyx_kp_u_distribution_must_be_auto_a_tupl, __pyx_k_distribution_must_be_auto_a_tupl, sizeof(__pyx_k_distribution_must_be_auto_a_tupl), 0, 1, 0, 0},
  {&__pyx_n_s_doc, __pyx_k_doc, sizeof(__pyx_k_doc), 0, 0, 1, 1},
  {&__pyx_kp_u_does_not_accept_missing_values, __pyx_k_does_not_accept_missing_values, sizeof(__pyx_k_does_not_accept_missing_values), 0, 1, 0, 0},
  {&__pyx_kp_u_does_not_accept_missing_values_2, __pyx_k_does_not_accept_missing_values_2, sizeof(__pyx_k_does_not_accept_missing_values_2), 0, 1, 0, 0},
  {&__pyx_kp_u_does_not_contain_datetime_objec, __pyx_k_does_not_contain_datetime_objec, sizeof(__pyx_k_does_not_contain_datetime_objec), 0, 1, 0, 0},
  {&__pyx_n_s_dropna, __pyx_k_dropna, sizeof(__pyx_k_dropna), 0, 0, 1, 1},
  {&__pyx_kp_u_dt_datetime, __pyx_k_dt_datetime, sizeof(__pyx_k_dt_datetime), 0, 1, 0, 0},
  {&__pyx_n_s_dtype, __pyx_k_dtype, sizeof(__pyx_k_dtype), 0, 0, 1, 1},
  {&__pyx_n_u_dtype, __pyx_k_dtype, sizeof(__pyx_k_dtype), 0, 1, 0, 1},
  {&__pyx_n_s_dtype_numeric, __pyx_k_dtype_numeric, sizeof(__pyx_k_dtype_numeric), 0, 0, 1, 1},
  {&__pyx_kp_u_dtype_numeric_is_not_compatible, __pyx_k_dtype_numeric_is_not_compatible, sizeof(__pyx_k_dtype_numeric_is_not_compatible), 0, 1, 0, 0},
  {&__pyx_n_s_dtype_orig, __pyx_k_dtype_orig, sizeof(__pyx_k_dtype_orig), 0, 0, 1, 1},
  {&__pyx_n_s_dtype_selector, __pyx_k_dtype_selector, sizeof(__pyx_k_dtype_selector), 0, 0, 1, 1},
  {&__pyx_n_s_dtypes, __pyx_k_dtypes, sizeof(__pyx_k_dtypes), 0, 0, 1, 1},
  {&__pyx_n_u_dtypes, __pyx_k_dtypes, sizeof(__pyx_k_dtypes), 0, 1, 0, 1},
  {&__pyx_n_s_dtypes_orig, __pyx_k_dtypes_orig, sizeof(__pyx_k_dtypes_orig), 0, 0, 1, 1},
  {&__pyx_n_s_e, __pyx_k_e, sizeof(__pyx_k_e), 0, 0, 1, 1},
  {&__pyx_n_s_elements, __pyx_k_elements, sizeof(__pyx_k_elements), 0, 0, 1, 1},
  {&__pyx_kp_u_elements_2, __pyx_k_elements_2, sizeof(__pyx_k_elements_2), 0, 1, 0, 0},
  {&__pyx_kp_u_elements_must_be_an_integer_or, __pyx_k_elements_must_be_an_integer_or, sizeof(__pyx_k_elements_must_be_an_integer_or), 0, 1, 0, 0},
  {&__pyx_n_s_empty, __pyx_k_empty, sizeof(__pyx_k_empty), 0, 0, 1, 1},
  {&__pyx_n_s_end_date, __pyx_k_end_date, sizeof(__pyx_k_end_date), 0, 0, 1, 1},
  {&__pyx_n_s_endswith, __pyx_k_endswith, sizeof(__pyx_k_endswith), 0, 0, 1, 1},
  {&__pyx_n_s_ensure_2d, __pyx_k_ensure_2d, sizeof(__pyx_k_ensure_2d), 0, 0, 1, 1},
  {&__pyx_n_u_ensure_2d, __pyx_k_ensure_2d, sizeof(__pyx_k_ensure_2d), 0, 1, 0, 1},
  {&__pyx_kp_u_ensure_2d_line_1144, __pyx_k_ensure_2d_line_1144, sizeof(__pyx_k_ensure_2d_line_1144), 0, 1, 0, 0},
  {&__pyx_n_s_ensure_min_features, __pyx_k_ensure_min_features, sizeof(__pyx_k_ensure_min_features), 0, 0, 1, 1},
  {&__pyx_n_s_ensure_min_samples, __pyx_k_ensure_min_samples, sizeof(__pyx_k_ensure_min_samples), 0, 0, 1, 1},
  {&__pyx_n_s_ensure_no_complex_data, __pyx_k_ensure_no_complex_data, sizeof(__pyx_k_ensure_no_complex_data), 0, 0, 1, 1},
  {&__pyx_n_s_ensure_non_negative, __pyx_k_ensure_non_negative, sizeof(__pyx_k_ensure_non_negative), 0, 0, 1, 1},
  {&__pyx_n_u_ensure_non_negative, __pyx_k_ensure_non_negative, sizeof(__pyx_k_ensure_non_negative), 0, 1, 0, 1},
  {&__pyx_kp_u_ensure_non_negative_line_1826, __pyx_k_ensure_non_negative_line_1826, sizeof(__pyx_k_ensure_non_negative_line_1826), 0, 1, 0, 0},
  {&__pyx_n_s_ensure_sparse_format, __pyx_k_ensure_sparse_format, sizeof(__pyx_k_ensure_sparse_format), 0, 0, 1, 1},
  {&__pyx_n_s_ensure_y_is_valid, __pyx_k_ensure_y_is_valid, sizeof(__pyx_k_ensure_y_is_valid), 0, 0, 1, 1},
  {&__pyx_kp_u_ensure_y_is_valid_line_1957, __pyx_k_ensure_y_is_valid_line_1957, sizeof(__pyx_k_ensure_y_is_valid_line_1957), 0, 1, 0, 0},
  {&__pyx_n_s_enter, __pyx_k_enter, sizeof(__pyx_k_enter), 0, 0, 1, 1},
  {&__pyx_n_s_enumerate, __pyx_k_enumerate, sizeof(__pyx_k_enumerate), 0, 0, 1, 1},
  {&__pyx_n_s_eps, __pyx_k_eps, sizeof(__pyx_k_eps), 0, 0, 1, 1},
  {&__pyx_n_s_epsilon, __pyx_k_epsilon, sizeof(__pyx_k_epsilon), 0, 0, 1, 1},
  {&__pyx_n_s_equals, __pyx_k_equals, sizeof(__pyx_k_equals), 0, 0, 1, 1},
  {&__pyx_n_s_err, __pyx_k_err, sizeof(__pyx_k_err), 0, 0, 1, 1},
  {&__pyx_n_s_err_msg, __pyx_k_err_msg, sizeof(__pyx_k_err_msg), 0, 0, 1, 1},
  {&__pyx_n_s_error, __pyx_k_error, sizeof(__pyx_k_error), 0, 0, 1, 1},
  {&__pyx_n_u_error, __pyx_k_error, sizeof(__pyx_k_error), 0, 1, 0, 1},
  {&__pyx_n_s_errors, __pyx_k_errors, sizeof(__pyx_k_errors), 0, 0, 1, 1},
  {&__pyx_n_s_errstate, __pyx_k_errstate, sizeof(__pyx_k_errstate), 0, 0, 1, 1},
  {&__pyx_n_s_estimator, __pyx_k_estimator, sizeof(__pyx_k_estimator), 0, 0, 1, 1},
  {&__pyx_n_u_estimator, __pyx_k_estimator, sizeof(__pyx_k_estimator), 0, 1, 0, 1},
  {&__pyx_n_s_estimator_name, __pyx_k_estimator_name, sizeof(__pyx_k_estimator_name), 0, 0, 1, 1},
  {&__pyx_n_s_exceptions, __pyx_k_exceptions, sizeof(__pyx_k_exceptions), 0, 0, 1, 1},
  {&__pyx_n_s_exist_features, __pyx_k_exist_features, sizeof(__pyx_k_exist_features), 0, 0, 1, 1},
  {&__pyx_n_s_exit, __pyx_k_exit, sizeof(__pyx_k_exit), 0, 0, 1, 1},
  {&__pyx_kp_u_expected_2, __pyx_k_expected_2, sizeof(__pyx_k_expected_2), 0, 1, 0, 0},
  {&__pyx_n_s_expected_include_boundaries, __pyx_k_expected_include_boundaries, sizeof(__pyx_k_expected_include_boundaries), 0, 0, 1, 1},
  {&__pyx_n_s_expected_type, __pyx_k_expected_type, sizeof(__pyx_k_expected_type), 0, 0, 1, 1},
  {&__pyx_n_u_expected_type, __pyx_k_expected_type, sizeof(__pyx_k_expected_type), 0, 1, 0, 1},
  {&__pyx_kp_u_expects, __pyx_k_expects, sizeof(__pyx_k_expects), 0, 1, 0, 0},
  {&__pyx_kp_u_expects_strict_or_soft, __pyx_k_expects_strict_or_soft, sizeof(__pyx_k_expects_strict_or_soft), 0, 1, 0, 0},
  {&__pyx_n_s_extra, __pyx_k_extra, sizeof(__pyx_k_extra), 0, 0, 1, 1},
  {&__pyx_n_s_extra_args, __pyx_k_extra_args, sizeof(__pyx_k_extra_args), 0, 0, 1, 1},
  {&__pyx_n_s_f, __pyx_k_f, sizeof(__pyx_k_f), 0, 0, 1, 1},
  {&__pyx_n_u_f, __pyx_k_f, sizeof(__pyx_k_f), 0, 1, 0, 1},
  {&__pyx_n_u_fc, __pyx_k_fc, sizeof(__pyx_k_fc), 0, 1, 0, 1},
  {&__pyx_n_u_feature, __pyx_k_feature, sizeof(__pyx_k_feature), 0, 1, 0, 1},
  {&__pyx_n_s_feature_names, __pyx_k_feature_names, sizeof(__pyx_k_feature_names), 0, 0, 1, 1},
  {&__pyx_n_s_feature_names_in, __pyx_k_feature_names_in, sizeof(__pyx_k_feature_names_in), 0, 0, 1, 1},
  {&__pyx_n_u_feature_names_in, __pyx_k_feature_names_in, sizeof(__pyx_k_feature_names_in), 0, 1, 0, 1},
  {&__pyx_kp_u_feature_s_shape, __pyx_k_feature_s_shape, sizeof(__pyx_k_feature_s_shape), 0, 1, 0, 0},
  {&__pyx_n_s_fill_value, __pyx_k_fill_value, sizeof(__pyx_k_fill_value), 0, 0, 1, 1},
  {&__pyx_n_s_filter_valid_kwargs, __pyx_k_filter_valid_kwargs, sizeof(__pyx_k_filter_valid_kwargs), 0, 0, 1, 1},
  {&__pyx_n_u_filter_valid_kwargs, __pyx_k_filter_valid_kwargs, sizeof(__pyx_k_filter_valid_kwargs), 0, 1, 0, 1},
  {&__pyx_kp_u_filter_valid_kwargs_line_99, __pyx_k_filter_valid_kwargs_line_99, sizeof(__pyx_k_filter_valid_kwargs_line_99), 0, 1, 0, 0},
  {&__pyx_n_s_find_spec, __pyx_k_find_spec, sizeof(__pyx_k_find_spec), 0, 0, 1, 1},
  {&__pyx_n_s_first_pass_isfinite, __pyx_k_first_pass_isfinite, sizeof(__pyx_k_first_pass_isfinite), 0, 0, 1, 1},
  {&__pyx_n_s_first_sample, __pyx_k_first_sample, sizeof(__pyx_k_first_sample), 0, 0, 1, 1},
  {&__pyx_n_s_fit, __pyx_k_fit, sizeof(__pyx_k_fit), 0, 0, 1, 1},
  {&__pyx_n_u_fit, __pyx_k_fit, sizeof(__pyx_k_fit), 0, 1, 0, 1},
  {&__pyx_n_s_fitted, __pyx_k_fitted, sizeof(__pyx_k_fitted), 0, 0, 1, 1},
  {&__pyx_n_s_flatten, __pyx_k_flatten, sizeof(__pyx_k_flatten), 0, 0, 1, 1},
  {&__pyx_n_s_float, __pyx_k_float, sizeof(__pyx_k_float), 0, 0, 1, 1},
  {&__pyx_n_u_float, __pyx_k_float, sizeof(__pyx_k_float), 0, 1, 0, 1},
  {&__pyx_n_s_float16, __pyx_k_float16, sizeof(__pyx_k_float16), 0, 0, 1, 1},
  {&__pyx_n_s_float32, __pyx_k_float32, sizeof(__pyx_k_float32), 0, 0, 1, 1},
  {&__pyx_n_s_float64, __pyx_k_float64, sizeof(__pyx_k_float64), 0, 0, 1, 1},
  {&__pyx_n_s_floating, __pyx_k_floating, sizeof(__pyx_k_floating), 0, 0, 1, 1},
  {&__pyx_n_s_floor, __pyx_k_floor, sizeof(__pyx_k_floor), 0, 0, 1, 1},
  {&__pyx_n_u_floor, __pyx_k_floor, sizeof(__pyx_k_floor), 0, 1, 0, 1},
  {&__pyx_kp_u_for_both_y_true_and_y_pred_but, __pyx_k_for_both_y_true_and_y_pred_but, sizeof(__pyx_k_for_both_y_true_and_y_pred_but), 0, 1, 0, 0},
  {&__pyx_n_s_force, __pyx_k_force, sizeof(__pyx_k_force), 0, 0, 1, 1},
  {&__pyx_n_s_force_all_finite, __pyx_k_force_all_finite, sizeof(__pyx_k_force_all_finite), 0, 0, 1, 1},
  {&__pyx_kp_u_force_all_finite_should_be_a_boo, __pyx_k_force_all_finite_should_be_a_boo, sizeof(__pyx_k_force_all_finite_should_be_a_boo), 0, 1, 0, 0},
  {&__pyx_n_s_format, __pyx_k_format, sizeof(__pyx_k_format), 0, 0, 1, 1},
  {&__pyx_n_u_frame, __pyx_k_frame, sizeof(__pyx_k_frame), 0, 1, 0, 1},
  {&__pyx_kp_u_from, __pyx_k_from, sizeof(__pyx_k_from), 0, 1, 0, 0},
  {&__pyx_n_s_full_like, __pyx_k_full_like, sizeof(__pyx_k_full_like), 0, 0, 1, 1},
  {&__pyx_n_s_func, __pyx_k_func, sizeof(__pyx_k_func), 0, 0, 1, 1},
  {&__pyx_n_s_functools, __pyx_k_functools, sizeof(__pyx_k_functools), 0, 0, 1, 1},
  {&__pyx_n_s_ge, __pyx_k_ge, sizeof(__pyx_k_ge), 0, 0, 1, 1},
  {&__pyx_n_s_generate_get_feature_names_out, __pyx_k_generate_get_feature_names_out, sizeof(__pyx_k_generate_get_feature_names_out), 0, 0, 1, 1},
  {&__pyx_n_s_generate_names, __pyx_k_generate_names, sizeof(__pyx_k_generate_names), 0, 0, 1, 1},
  {&__pyx_n_s_genexpr, __pyx_k_genexpr, sizeof(__pyx_k_genexpr), 0, 0, 1, 1},
  {&__pyx_n_s_get, __pyx_k_get, sizeof(__pyx_k_get), 0, 0, 1, 1},
  {&__pyx_n_s_get_estimator_name, __pyx_k_get_estimator_name, sizeof(__pyx_k_get_estimator_name), 0, 0, 1, 1},
  {&__pyx_n_u_get_estimator_name, __pyx_k_get_estimator_name, sizeof(__pyx_k_get_estimator_name), 0, 1, 0, 1},
  {&__pyx_n_s_get_feature_names, __pyx_k_get_feature_names, sizeof(__pyx_k_get_feature_names), 0, 0, 1, 1},
  {&__pyx_n_s_get_feature_names_locals_genexp, __pyx_k_get_feature_names_locals_genexp, sizeof(__pyx_k_get_feature_names_locals_genexp), 0, 0, 1, 1},
  {&__pyx_n_s_get_feature_names_locals_genexp_2, __pyx_k_get_feature_names_locals_genexp_2, sizeof(__pyx_k_get_feature_names_locals_genexp_2), 0, 0, 1, 1},
  {&__pyx_n_s_get_namespace, __pyx_k_get_namespace, sizeof(__pyx_k_get_namespace), 0, 0, 1, 1},
  {&__pyx_n_s_getformat, __pyx_k_getformat, sizeof(__pyx_k_getformat), 0, 0, 1, 1},
  {&__pyx_kp_u_got, __pyx_k_got, sizeof(__pyx_k_got), 0, 1, 0, 0},
  {&__pyx_kp_u_got_2, __pyx_k_got_2, sizeof(__pyx_k_got_2), 0, 1, 0, 0},
  {&__pyx_n_s_gt, __pyx_k_gt, sizeof(__pyx_k_gt), 0, 0, 1, 1},
  {&__pyx_n_s_handle_categoric, __pyx_k_handle_categoric, sizeof(__pyx_k_handle_categoric), 0, 0, 1, 1},
  {&__pyx_n_s_handle_numeric, __pyx_k_handle_numeric, sizeof(__pyx_k_handle_numeric), 0, 0, 1, 1},
  {&__pyx_n_s_handle_zero_division, __pyx_k_handle_zero_division, sizeof(__pyx_k_handle_zero_division), 0, 0, 1, 1},
  {&__pyx_n_u_handle_zero_division, __pyx_k_handle_zero_division, sizeof(__pyx_k_handle_zero_division), 0, 1, 0, 1},
  {&__pyx_kp_u_handle_zero_division_line_850, __pyx_k_handle_zero_division_line_850, sizeof(__pyx_k_handle_zero_division_line_850), 0, 1, 0, 0},
  {&__pyx_n_s_has_categorical, __pyx_k_has_categorical, sizeof(__pyx_k_has_categorical), 0, 0, 1, 1},
  {&__pyx_n_s_has_fit_parameter, __pyx_k_has_fit_parameter, sizeof(__pyx_k_has_fit_parameter), 0, 0, 1, 1},
  {&__pyx_n_u_has_fit_parameter, __pyx_k_has_fit_parameter, sizeof(__pyx_k_has_fit_parameter), 0, 1, 0, 1},
  {&__pyx_kp_u_has_fit_parameter_line_3596, __pyx_k_has_fit_parameter_line_3596, sizeof(__pyx_k_has_fit_parameter_line_3596), 0, 1, 0, 0},
  {&__pyx_n_s_has_inf, __pyx_k_has_inf, sizeof(__pyx_k_has_inf), 0, 0, 1, 1},
  {&__pyx_n_s_has_nan_error, __pyx_k_has_nan_error, sizeof(__pyx_k_has_nan_error), 0, 0, 1, 1},
  {&__pyx_n_s_has_numerical, __pyx_k_has_numerical, sizeof(__pyx_k_has_numerical), 0, 0, 1, 1},
  {&__pyx_n_s_has_required_attributes, __pyx_k_has_required_attributes, sizeof(__pyx_k_has_required_attributes), 0, 0, 1, 1},
  {&__pyx_n_u_has_required_attributes, __pyx_k_has_required_attributes, sizeof(__pyx_k_has_required_attributes), 0, 1, 0, 1},
  {&__pyx_n_s_has_required_attributes_locals_g, __pyx_k_has_required_attributes_locals_g, sizeof(__pyx_k_has_required_attributes_locals_g), 0, 0, 1, 1},
  {&__pyx_n_s_i, __pyx_k_i, sizeof(__pyx_k_i), 0, 0, 1, 1},
  {&__pyx_n_s_ignore, __pyx_k_ignore, sizeof(__pyx_k_ignore), 0, 0, 1, 1},
  {&__pyx_n_u_ignore, __pyx_k_ignore, sizeof(__pyx_k_ignore), 0, 1, 0, 1},
  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
  {&__pyx_n_s_import_optional_dependency, __pyx_k_import_optional_dependency, sizeof(__pyx_k_import_optional_dependency), 0, 0, 1, 1},
  {&__pyx_n_s_importlib, __pyx_k_importlib, sizeof(__pyx_k_importlib), 0, 0, 1, 1},
  {&__pyx_n_s_importlib_util, __pyx_k_importlib_util, sizeof(__pyx_k_importlib_util), 0, 0, 1, 1},
  {&__pyx_kp_u_in, __pyx_k_in, sizeof(__pyx_k_in), 0, 1, 0, 0},
  {&__pyx_n_s_include_boundaries, __pyx_k_include_boundaries, sizeof(__pyx_k_include_boundaries), 0, 0, 1, 1},
  {&__pyx_kp_u_include_boundaries_left_without, __pyx_k_include_boundaries_left_without, sizeof(__pyx_k_include_boundaries_left_without), 0, 1, 0, 0},
  {&__pyx_kp_u_include_boundaries_right_withou, __pyx_k_include_boundaries_right_withou, sizeof(__pyx_k_include_boundaries_right_withou), 0, 1, 0, 0},
  {&__pyx_n_s_include_zero, __pyx_k_include_zero, sizeof(__pyx_k_include_zero), 0, 0, 1, 1},
  {&__pyx_n_s_index, __pyx_k_index, sizeof(__pyx_k_index), 0, 0, 1, 1},
  {&__pyx_n_s_index_keys, __pyx_k_index_keys, sizeof(__pyx_k_index_keys), 0, 0, 1, 1},
  {&__pyx_n_u_index_to_columns, __pyx_k_index_to_columns, sizeof(__pyx_k_index_to_columns), 0, 1, 0, 1},
  {&__pyx_n_u_indices, __pyx_k_indices, sizeof(__pyx_k_indices), 0, 1, 0, 1},
  {&__pyx_n_s_indices_datatype, __pyx_k_indices_datatype, sizeof(__pyx_k_indices_datatype), 0, 0, 1, 1},
  {&__pyx_n_u_indptr, __pyx_k_indptr, sizeof(__pyx_k_indptr), 0, 1, 0, 1},
  {&__pyx_kp_u_infinity_or_a_value_too_large_fo, __pyx_k_infinity_or_a_value_too_large_fo, sizeof(__pyx_k_infinity_or_a_value_too_large_fo), 0, 1, 0, 0},
  {&__pyx_n_s_inner_deprecate_positional_args, __pyx_k_inner_deprecate_positional_args, sizeof(__pyx_k_inner_deprecate_positional_args), 0, 0, 1, 1},
  {&__pyx_n_s_inner_f, __pyx_k_inner_f, sizeof(__pyx_k_inner_f), 0, 0, 1, 1},
  {&__pyx_n_s_input_features, __pyx_k_input_features, sizeof(__pyx_k_input_features), 0, 0, 1, 1},
  {&__pyx_kp_u_input_features_is_not_equal_to_f, __pyx_k_input_features_is_not_equal_to_f, sizeof(__pyx_k_input_features_is_not_equal_to_f), 0, 1, 0, 0},
  {&__pyx_kp_u_input_features_should_have_lengt, __pyx_k_input_features_should_have_lengt, sizeof(__pyx_k_input_features_should_have_lengt), 0, 1, 0, 0},
  {&__pyx_n_s_input_name, __pyx_k_input_name, sizeof(__pyx_k_input_name), 0, 0, 1, 1},
  {&__pyx_n_s_inspect, __pyx_k_inspect, sizeof(__pyx_k_inspect), 0, 0, 1, 1},
  {&__pyx_kp_u_instead, __pyx_k_instead, sizeof(__pyx_k_instead), 0, 1, 0, 0},
  {&__pyx_n_u_int, __pyx_k_int, sizeof(__pyx_k_int), 0, 1, 0, 1},
  {&__pyx_n_u_int32, __pyx_k_int32, sizeof(__pyx_k_int32), 0, 1, 0, 1},
  {&__pyx_n_s_int64, __pyx_k_int64, sizeof(__pyx_k_int64), 0, 0, 1, 1},
  {&__pyx_n_u_int64, __pyx_k_int64, sizeof(__pyx_k_int64), 0, 1, 0, 1},
  {&__pyx_n_s_integer, __pyx_k_integer, sizeof(__pyx_k_integer), 0, 0, 1, 1},
  {&__pyx_n_s_intervals, __pyx_k_intervals, sizeof(__pyx_k_intervals), 0, 0, 1, 1},
  {&__pyx_kp_u_is, __pyx_k_is, sizeof(__pyx_k_is), 0, 1, 0, 0},
  {&__pyx_kp_u_is_1d_array_only_pandas_Series, __pyx_k_is_1d_array_only_pandas_Series, sizeof(__pyx_k_is_1d_array_only_pandas_Series), 0, 1, 0, 0},
  {&__pyx_kp_u_is_a_class_not_an_instance, __pyx_k_is_a_class_not_an_instance, sizeof(__pyx_k_is_a_class_not_an_instance), 0, 1, 0, 0},
  {&__pyx_n_s_is_array_api, __pyx_k_is_array_api, sizeof(__pyx_k_is_array_api), 0, 0, 1, 1},
  {&__pyx_n_s_is_arraylike, __pyx_k_is_arraylike, sizeof(__pyx_k_is_arraylike), 0, 0, 1, 1},
  {&__pyx_n_s_is_arraylike_1d, __pyx_k_is_arraylike_1d, sizeof(__pyx_k_is_arraylike_1d), 0, 0, 1, 1},
  {&__pyx_n_s_is_arraylike_not_scalar, __pyx_k_is_arraylike_not_scalar, sizeof(__pyx_k_is_arraylike_not_scalar), 0, 0, 1, 1},
  {&__pyx_n_s_is_binary_class, __pyx_k_is_binary_class, sizeof(__pyx_k_is_binary_class), 0, 0, 1, 1},
  {&__pyx_n_u_is_binary_class, __pyx_k_is_binary_class, sizeof(__pyx_k_is_binary_class), 0, 1, 0, 1},
  {&__pyx_kp_u_is_binary_class_line_798, __pyx_k_is_binary_class_line_798, sizeof(__pyx_k_is_binary_class_line_798), 0, 1, 0, 0},
  {&__pyx_n_s_is_bool_dtype, __pyx_k_is_bool_dtype, sizeof(__pyx_k_is_bool_dtype), 0, 0, 1, 1},
  {&__pyx_n_s_is_buildin, __pyx_k_is_buildin, sizeof(__pyx_k_is_buildin), 0, 0, 1, 1},
  {&__pyx_n_s_is_categoric, __pyx_k_is_categoric, sizeof(__pyx_k_is_categoric), 0, 0, 1, 1},
  {&__pyx_n_s_is_categorical, __pyx_k_is_categorical, sizeof(__pyx_k_is_categorical), 0, 0, 1, 1},
  {&__pyx_n_u_is_categorical, __pyx_k_is_categorical, sizeof(__pyx_k_is_categorical), 0, 1, 0, 1},
  {&__pyx_n_s_is_categorical_dtype, __pyx_k_is_categorical_dtype, sizeof(__pyx_k_is_categorical_dtype), 0, 0, 1, 1},
  {&__pyx_kp_u_is_categorical_line_1215, __pyx_k_is_categorical_line_1215, sizeof(__pyx_k_is_categorical_line_1215), 0, 1, 0, 0},
  {&__pyx_n_s_is_cross_validated, __pyx_k_is_cross_validated, sizeof(__pyx_k_is_cross_validated), 0, 0, 1, 1},
  {&__pyx_n_s_is_dataframe, __pyx_k_is_dataframe, sizeof(__pyx_k_is_dataframe), 0, 0, 1, 1},
  {&__pyx_n_s_is_datetime64_any_dtype, __pyx_k_is_datetime64_any_dtype, sizeof(__pyx_k_is_datetime64_any_dtype), 0, 0, 1, 1},
  {&__pyx_n_s_is_extension_array_dtype, __pyx_k_is_extension_array_dtype, sizeof(__pyx_k_is_extension_array_dtype), 0, 0, 1, 1},
  {&__pyx_n_s_is_float_dtype, __pyx_k_is_float_dtype, sizeof(__pyx_k_is_float_dtype), 0, 0, 1, 1},
  {&__pyx_n_s_is_frame, __pyx_k_is_frame, sizeof(__pyx_k_is_frame), 0, 0, 1, 1},
  {&__pyx_n_u_is_frame, __pyx_k_is_frame, sizeof(__pyx_k_is_frame), 0, 1, 0, 1},
  {&__pyx_kp_u_is_greater_than_the_maximum_all, __pyx_k_is_greater_than_the_maximum_all, sizeof(__pyx_k_is_greater_than_the_maximum_all), 0, 1, 0, 0},
  {&__pyx_n_s_is_installed, __pyx_k_is_installed, sizeof(__pyx_k_is_installed), 0, 0, 1, 1},
  {&__pyx_n_u_is_installed, __pyx_k_is_installed, sizeof(__pyx_k_is_installed), 0, 1, 0, 1},
  {&__pyx_kp_u_is_installed_line_2764, __pyx_k_is_installed_line_2764, sizeof(__pyx_k_is_installed_line_2764), 0, 1, 0, 0},
  {&__pyx_n_s_is_integer_dtype, __pyx_k_is_integer_dtype, sizeof(__pyx_k_is_integer_dtype), 0, 0, 1, 1},
  {&__pyx_n_s_is_keras_model, __pyx_k_is_keras_model, sizeof(__pyx_k_is_keras_model), 0, 0, 1, 1},
  {&__pyx_n_u_is_keras_model, __pyx_k_is_keras_model, sizeof(__pyx_k_is_keras_model), 0, 1, 0, 1},
  {&__pyx_kp_u_is_less_than_the_minimum_allowe, __pyx_k_is_less_than_the_minimum_allowe, sizeof(__pyx_k_is_less_than_the_minimum_allowe), 0, 1, 0, 0},
  {&__pyx_n_s_is_nested, __pyx_k_is_nested, sizeof(__pyx_k_is_nested), 0, 0, 1, 1},
  {&__pyx_n_s_is_normalized, __pyx_k_is_normalized, sizeof(__pyx_k_is_normalized), 0, 0, 1, 1},
  {&__pyx_n_u_is_normalized, __pyx_k_is_normalized, sizeof(__pyx_k_is_normalized), 0, 1, 0, 1},
  {&__pyx_kp_u_is_normalized_line_660, __pyx_k_is_normalized_line_660, sizeof(__pyx_k_is_normalized_line_660), 0, 1, 0, 0},
  {&__pyx_n_s_is_normed, __pyx_k_is_normed, sizeof(__pyx_k_is_normed), 0, 0, 1, 1},
  {&__pyx_kp_u_is_not_a_numeric_type, __pyx_k_is_not_a_numeric_type, sizeof(__pyx_k_is_not_a_numeric_type), 0, 1, 0, 0},
  {&__pyx_kp_u_is_not_a_valid_numeric_string, __pyx_k_is_not_a_valid_numeric_string, sizeof(__pyx_k_is_not_a_valid_numeric_string), 0, 1, 0, 0},
  {&__pyx_n_s_is_numeric, __pyx_k_is_numeric, sizeof(__pyx_k_is_numeric), 0, 0, 1, 1},
  {&__pyx_n_s_is_numeric_dtype, __pyx_k_is_numeric_dtype, sizeof(__pyx_k_is_numeric_dtype), 0, 0, 1, 1},
  {&__pyx_n_s_is_object_dtype, __pyx_k_is_object_dtype, sizeof(__pyx_k_is_object_dtype), 0, 0, 1, 1},
  {&__pyx_kp_u_is_originally_not_a_frame_Frame, __pyx_k_is_originally_not_a_frame_Frame, sizeof(__pyx_k_is_originally_not_a_frame_Frame), 0, 1, 0, 0},
  {&__pyx_kp_u_is_out_of_the_valid_range_1900, __pyx_k_is_out_of_the_valid_range_1900, sizeof(__pyx_k_is_out_of_the_valid_range_1900), 0, 1, 0, 0},
  {&__pyx_n_s_is_probability_distribution, __pyx_k_is_probability_distribution, sizeof(__pyx_k_is_probability_distribution), 0, 0, 1, 1},
  {&__pyx_kp_u_is_probability_distribution_lin, __pyx_k_is_probability_distribution_lin, sizeof(__pyx_k_is_probability_distribution_lin), 0, 1, 0, 0},
  {&__pyx_kp_u_is_required, __pyx_k_is_required, sizeof(__pyx_k_is_required), 0, 1, 0, 0},
  {&__pyx_n_s_is_square_matrix, __pyx_k_is_square_matrix, sizeof(__pyx_k_is_square_matrix), 0, 0, 1, 1},
  {&__pyx_n_u_is_square_matrix, __pyx_k_is_square_matrix, sizeof(__pyx_k_is_square_matrix), 0, 1, 0, 1},
  {&__pyx_kp_u_is_square_matrix_line_360, __pyx_k_is_square_matrix_line_360, sizeof(__pyx_k_is_square_matrix_line_360), 0, 1, 0, 0},
  {&__pyx_n_s_is_time_series, __pyx_k_is_time_series, sizeof(__pyx_k_is_time_series), 0, 0, 1, 1},
  {&__pyx_n_u_is_time_series, __pyx_k_is_time_series, sizeof(__pyx_k_is_time_series), 0, 1, 0, 1},
  {&__pyx_kp_u_is_time_series_line_2787, __pyx_k_is_time_series_line_2787, sizeof(__pyx_k_is_time_series_line_2787), 0, 1, 0, 0},
  {&__pyx_n_s_is_valid_policies, __pyx_k_is_valid_policies, sizeof(__pyx_k_is_valid_policies), 0, 0, 1, 1},
  {&__pyx_n_u_is_valid_policies, __pyx_k_is_valid_policies, sizeof(__pyx_k_is_valid_policies), 0, 1, 0, 1},
  {&__pyx_kp_u_is_valid_policies_line_1700, __pyx_k_is_valid_policies_line_1700, sizeof(__pyx_k_is_valid_policies_line_1700), 0, 1, 0, 0},
  {&__pyx_n_s_isbuiltin, __pyx_k_isbuiltin, sizeof(__pyx_k_isbuiltin), 0, 0, 1, 1},
  {&__pyx_n_s_isclass, __pyx_k_isclass, sizeof(__pyx_k_isclass), 0, 0, 1, 1},
  {&__pyx_n_s_isclose, __pyx_k_isclose, sizeof(__pyx_k_isclose), 0, 0, 1, 1},
  {&__pyx_n_s_isf, __pyx_k_isf, sizeof(__pyx_k_isf), 0, 0, 1, 1},
  {&__pyx_n_s_isfinite, __pyx_k_isfinite, sizeof(__pyx_k_isfinite), 0, 0, 1, 1},
  {&__pyx_n_s_isin, __pyx_k_isin, sizeof(__pyx_k_isin), 0, 0, 1, 1},
  {&__pyx_n_s_isinf, __pyx_k_isinf, sizeof(__pyx_k_isinf), 0, 0, 1, 1},
  {&__pyx_n_s_isnan, __pyx_k_isnan, sizeof(__pyx_k_isnan), 0, 0, 1, 1},
  {&__pyx_n_s_isnull, __pyx_k_isnull, sizeof(__pyx_k_isnull), 0, 0, 1, 1},
  {&__pyx_n_s_isscalar, __pyx_k_isscalar, sizeof(__pyx_k_isscalar), 0, 0, 1, 1},
  {&__pyx_n_s_issparse, __pyx_k_issparse, sizeof(__pyx_k_issparse), 0, 0, 1, 1},
  {&__pyx_n_s_issubdtype, __pyx_k_issubdtype, sizeof(__pyx_k_issubdtype), 0, 0, 1, 1},
  {&__pyx_n_s_item, __pyx_k_item, sizeof(__pyx_k_item), 0, 0, 1, 1},
  {&__pyx_n_s_items, __pyx_k_items, sizeof(__pyx_k_items), 0, 0, 1, 1},
  {&__pyx_n_u_iter, __pyx_k_iter, sizeof(__pyx_k_iter), 0, 1, 0, 1},
  {&__pyx_n_u_iu, __pyx_k_iu, sizeof(__pyx_k_iu), 0, 1, 0, 1},
  {&__pyx_n_s_joblib, __pyx_k_joblib, sizeof(__pyx_k_joblib), 0, 0, 1, 1},
  {&__pyx_n_s_k, __pyx_k_k, sizeof(__pyx_k_k), 0, 0, 1, 1},
  {&__pyx_n_s_keras, __pyx_k_keras, sizeof(__pyx_k_keras), 0, 0, 1, 1},
  {&__pyx_n_s_key, __pyx_k_key, sizeof(__pyx_k_key), 0, 0, 1, 1},
  {&__pyx_n_s_keys, __pyx_k_keys, sizeof(__pyx_k_keys), 0, 0, 1, 1},
  {&__pyx_n_s_kind, __pyx_k_kind, sizeof(__pyx_k_kind), 0, 0, 1, 1},
  {&__pyx_n_u_kind, __pyx_k_kind, sizeof(__pyx_k_kind), 0, 1, 0, 1},
  {&__pyx_n_s_kwargs, __pyx_k_kwargs, sizeof(__pyx_k_kwargs), 0, 0, 1, 1},
  {&__pyx_n_s_kwonly_args, __pyx_k_kwonly_args, sizeof(__pyx_k_kwonly_args), 0, 0, 1, 1},
  {&__pyx_n_s_kws, __pyx_k_kws, sizeof(__pyx_k_kws), 0, 0, 1, 1},
  {&__pyx_n_s_l, __pyx_k_l, sizeof(__pyx_k_l), 0, 0, 1, 1},
  {&__pyx_n_s_le, __pyx_k_le, sizeof(__pyx_k_le), 0, 0, 1, 1},
  {&__pyx_n_u_left, __pyx_k_left, sizeof(__pyx_k_left), 0, 1, 0, 1},
  {&__pyx_n_u_len, __pyx_k_len, sizeof(__pyx_k_len), 0, 1, 0, 1},
  {&__pyx_n_s_length_range, __pyx_k_length_range, sizeof(__pyx_k_length_range), 0, 0, 1, 1},
  {&__pyx_n_u_length_range, __pyx_k_length_range, sizeof(__pyx_k_length_range), 0, 1, 0, 1},
  {&__pyx_n_s_lengths, __pyx_k_lengths, sizeof(__pyx_k_lengths), 0, 0, 1, 1},
  {&__pyx_n_s_loc, __pyx_k_loc, sizeof(__pyx_k_loc), 0, 0, 1, 1},
  {&__pyx_n_s_location, __pyx_k_location, sizeof(__pyx_k_location), 0, 0, 1, 1},
  {&__pyx_n_s_lower, __pyx_k_lower, sizeof(__pyx_k_lower), 0, 0, 1, 1},
  {&__pyx_n_s_lst, __pyx_k_lst, sizeof(__pyx_k_lst), 0, 0, 1, 1},
  {&__pyx_n_s_lt, __pyx_k_lt, sizeof(__pyx_k_lt), 0, 0, 1, 1},
  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
  {&__pyx_n_s_map, __pyx_k_map, sizeof(__pyx_k_map), 0, 0, 1, 1},
  {&__pyx_n_s_match, __pyx_k_match, sizeof(__pyx_k_match), 0, 0, 1, 1},
  {&__pyx_n_s_match_method, __pyx_k_match_method, sizeof(__pyx_k_match_method), 0, 0, 1, 1},
  {&__pyx_n_s_math, __pyx_k_math, sizeof(__pyx_k_math), 0, 0, 1, 1},
  {&__pyx_n_s_mathex, __pyx_k_mathex, sizeof(__pyx_k_mathex), 0, 0, 1, 1},
  {&__pyx_n_s_matrix, __pyx_k_matrix, sizeof(__pyx_k_matrix), 0, 0, 1, 1},
  {&__pyx_n_s_max, __pyx_k_max, sizeof(__pyx_k_max), 0, 0, 1, 1},
  {&__pyx_n_s_max_length, __pyx_k_max_length, sizeof(__pyx_k_max_length), 0, 0, 1, 1},
  {&__pyx_n_s_max_val, __pyx_k_max_val, sizeof(__pyx_k_max_val), 0, 0, 1, 1},
  {&__pyx_n_s_max_value, __pyx_k_max_value, sizeof(__pyx_k_max_value), 0, 0, 1, 1},
  {&__pyx_n_s_may_share_memory, __pyx_k_may_share_memory, sizeof(__pyx_k_may_share_memory), 0, 0, 1, 1},
  {&__pyx_n_s_mean, __pyx_k_mean, sizeof(__pyx_k_mean), 0, 0, 1, 1},
  {&__pyx_n_s_memory, __pyx_k_memory, sizeof(__pyx_k_memory), 0, 0, 1, 1},
  {&__pyx_kp_u_memory_should_be_None_a_string, __pyx_k_memory_should_be_None_a_string, sizeof(__pyx_k_memory_should_be_None_a_string), 0, 1, 0, 0},
  {&__pyx_n_s_message, __pyx_k_message, sizeof(__pyx_k_message), 0, 0, 1, 1},
  {&__pyx_n_s_metaclass, __pyx_k_metaclass, sizeof(__pyx_k_metaclass), 0, 0, 1, 1},
  {&__pyx_n_s_method, __pyx_k_method, sizeof(__pyx_k_method), 0, 0, 1, 1},
  {&__pyx_n_u_method, __pyx_k_method, sizeof(__pyx_k_method), 0, 1, 0, 1},
  {&__pyx_kp_u_metric_computation, __pyx_k_metric_computation, sizeof(__pyx_k_metric_computation), 0, 1, 0, 0},
  {&__pyx_n_s_metric_name, __pyx_k_metric_name, sizeof(__pyx_k_metric_name), 0, 0, 1, 1},
  {&__pyx_n_s_min, __pyx_k_min, sizeof(__pyx_k_min), 0, 0, 1, 1},
  {&__pyx_n_s_min_length, __pyx_k_min_length, sizeof(__pyx_k_min_length), 0, 0, 1, 1},
  {&__pyx_n_s_min_val, __pyx_k_min_val, sizeof(__pyx_k_min_val), 0, 0, 1, 1},
  {&__pyx_n_s_min_value, __pyx_k_min_value, sizeof(__pyx_k_min_value), 0, 0, 1, 1},
  {&__pyx_n_s_mode, __pyx_k_mode, sizeof(__pyx_k_mode), 0, 0, 1, 1},
  {&__pyx_n_s_model, __pyx_k_model, sizeof(__pyx_k_model), 0, 0, 1, 1},
  {&__pyx_n_s_models, __pyx_k_models, sizeof(__pyx_k_models), 0, 0, 1, 1},
  {&__pyx_n_s_module, __pyx_k_module, sizeof(__pyx_k_module), 0, 0, 1, 1},
  {&__pyx_n_s_module_2, __pyx_k_module_2, sizeof(__pyx_k_module_2), 0, 0, 1, 1},
  {&__pyx_n_s_module_spec, __pyx_k_module_spec, sizeof(__pyx_k_module_spec), 0, 0, 1, 1},
  {&__pyx_n_s_msg, __pyx_k_msg, sizeof(__pyx_k_msg), 0, 0, 1, 1},
  {&__pyx_n_s_msg_dtype, __pyx_k_msg_dtype, sizeof(__pyx_k_msg_dtype), 0, 0, 1, 1},
  {&__pyx_n_s_msg_err, __pyx_k_msg_err, sizeof(__pyx_k_msg_err), 0, 0, 1, 1},
  {&__pyx_n_s_mtrand, __pyx_k_mtrand, sizeof(__pyx_k_mtrand), 0, 0, 1, 1},
  {&__pyx_n_s_multi_output, __pyx_k_multi_output, sizeof(__pyx_k_multi_output), 0, 0, 1, 1},
  {&__pyx_kp_u_multilabel_indicator, __pyx_k_multilabel_indicator, sizeof(__pyx_k_multilabel_indicator), 0, 1, 0, 0},
  {&__pyx_kp_u_must_be, __pyx_k_must_be, sizeof(__pyx_k_must_be), 0, 1, 0, 0},
  {&__pyx_kp_u_must_be_2, __pyx_k_must_be_2, sizeof(__pyx_k_must_be_2), 0, 1, 0, 0},
  {&__pyx_kp_u_must_be_a_list_or_a_single_stri, __pyx_k_must_be_a_list_or_a_single_stri, sizeof(__pyx_k_must_be_a_list_or_a_single_stri), 0, 1, 0, 0},
  {&__pyx_kp_u_must_be_a_tuple_of_two_values, __pyx_k_must_be_a_tuple_of_two_values, sizeof(__pyx_k_must_be_a_tuple_of_two_values), 0, 1, 0, 0},
  {&__pyx_kp_u_must_be_a_tuple_with_two_elemen, __pyx_k_must_be_a_tuple_with_two_elemen, sizeof(__pyx_k_must_be_a_tuple_with_two_elemen), 0, 1, 0, 0},
  {&__pyx_kp_u_must_be_an_instance_of, __pyx_k_must_be_an_instance_of, sizeof(__pyx_k_must_be_an_instance_of), 0, 1, 0, 0},
  {&__pyx_kp_u_must_be_an_integer_or_float, __pyx_k_must_be_an_integer_or_float, sizeof(__pyx_k_must_be_an_integer_or_float), 0, 1, 0, 0},
  {&__pyx_kp_u_must_be_integers, __pyx_k_must_be_integers, sizeof(__pyx_k_must_be_integers), 0, 1, 0, 0},
  {&__pyx_kp_u_must_be_less_than_the_second, __pyx_k_must_be_less_than_the_second, sizeof(__pyx_k_must_be_less_than_the_second), 0, 1, 0, 0},
  {&__pyx_kp_u_must_contain_numerical_values, __pyx_k_must_contain_numerical_values, sizeof(__pyx_k_must_contain_numerical_values), 0, 1, 0, 0},
  {&__pyx_n_u_mute, __pyx_k_mute, sizeof(__pyx_k_mute), 0, 1, 0, 1},
  {&__pyx_n_s_n_features, __pyx_k_n_features, sizeof(__pyx_k_n_features), 0, 0, 1, 1},
  {&__pyx_n_s_n_features_in, __pyx_k_n_features_in, sizeof(__pyx_k_n_features_in), 0, 0, 1, 1},
  {&__pyx_n_u_n_features_in, __pyx_k_n_features_in, sizeof(__pyx_k_n_features_in), 0, 1, 0, 1},
  {&__pyx_n_s_n_features_out, __pyx_k_n_features_out, sizeof(__pyx_k_n_features_out), 0, 0, 1, 1},
  {&__pyx_n_s_n_samples, __pyx_k_n_samples, sizeof(__pyx_k_n_samples), 0, 0, 1, 1},
  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
  {&__pyx_n_u_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 1, 0, 1},
  {&__pyx_n_s_name_2, __pyx_k_name_2, sizeof(__pyx_k_name_2), 0, 0, 1, 1},
  {&__pyx_n_u_name_2, __pyx_k_name_2, sizeof(__pyx_k_name_2), 0, 1, 0, 1},
  {&__pyx_n_s_nan, __pyx_k_nan, sizeof(__pyx_k_nan), 0, 0, 1, 1},
  {&__pyx_n_s_nan_policy, __pyx_k_nan_policy, sizeof(__pyx_k_nan_policy), 0, 0, 1, 1},
  {&__pyx_n_s_ndarray, __pyx_k_ndarray, sizeof(__pyx_k_ndarray), 0, 0, 1, 1},
  {&__pyx_n_s_ndim, __pyx_k_ndim, sizeof(__pyx_k_ndim), 0, 0, 1, 1},
  {&__pyx_n_u_neither, __pyx_k_neither, sizeof(__pyx_k_neither), 0, 1, 0, 1},
  {&__pyx_n_s_new_dtype, __pyx_k_new_dtype, sizeof(__pyx_k_new_dtype), 0, 0, 1, 1},
  {&__pyx_n_s_newaxis, __pyx_k_newaxis, sizeof(__pyx_k_newaxis), 0, 0, 1, 1},
  {&__pyx_kp_u_nly_supports_array_got, __pyx_k_nly_supports_array_got, sizeof(__pyx_k_nly_supports_array_got), 0, 1, 0, 0},
  {&__pyx_n_s_non_numeric, __pyx_k_non_numeric, sizeof(__pyx_k_non_numeric), 0, 0, 1, 1},
  {&__pyx_n_s_normalize, __pyx_k_normalize, sizeof(__pyx_k_normalize), 0, 0, 1, 1},
  {&__pyx_n_u_normalize, __pyx_k_normalize, sizeof(__pyx_k_normalize), 0, 1, 0, 1},
  {&__pyx_n_s_normalize_array, __pyx_k_normalize_array, sizeof(__pyx_k_normalize_array), 0, 0, 1, 1},
  {&__pyx_n_u_normalize_array, __pyx_k_normalize_array, sizeof(__pyx_k_normalize_array), 0, 1, 0, 1},
  {&__pyx_kp_u_normalize_array_line_712, __pyx_k_normalize_array_line_712, sizeof(__pyx_k_normalize_array_line_712), 0, 1, 0, 0},
  {&__pyx_n_s_normalize_string, __pyx_k_normalize_string, sizeof(__pyx_k_normalize_string), 0, 0, 1, 1},
  {&__pyx_kp_u_not, __pyx_k_not, sizeof(__pyx_k_not), 0, 1, 0, 0},
  {&__pyx_kp_u_not_found_in_DataFrame, __pyx_k_not_found_in_DataFrame, sizeof(__pyx_k_not_found_in_DataFrame), 0, 1, 0, 0},
  {&__pyx_kp_u_not_found_in_the_dataframe, __pyx_k_not_found_in_the_dataframe, sizeof(__pyx_k_not_found_in_the_dataframe), 0, 1, 0, 0},
  {&__pyx_n_s_not_nan_mask, __pyx_k_not_nan_mask, sizeof(__pyx_k_not_nan_mask), 0, 0, 1, 1},
  {&__pyx_n_s_notna, __pyx_k_notna, sizeof(__pyx_k_notna), 0, 0, 1, 1},
  {&__pyx_n_s_now, __pyx_k_now, sizeof(__pyx_k_now), 0, 0, 1, 1},
  {&__pyx_n_s_np, __pyx_k_np, sizeof(__pyx_k_np), 0, 0, 1, 1},
  {&__pyx_kp_u_np_matrix_is_not_supported_Pleas, __pyx_k_np_matrix_is_not_supported_Pleas, sizeof(__pyx_k_np_matrix_is_not_supported_Pleas), 0, 1, 0, 0},
  {&__pyx_n_s_num_features, __pyx_k_num_features, sizeof(__pyx_k_num_features), 0, 0, 1, 1},
  {&__pyx_n_s_num_samples, __pyx_k_num_samples, sizeof(__pyx_k_num_samples), 0, 0, 1, 1},
  {&__pyx_n_s_number, __pyx_k_number, sizeof(__pyx_k_number), 0, 0, 1, 1},
  {&__pyx_n_s_numbers, __pyx_k_numbers, sizeof(__pyx_k_numbers), 0, 0, 1, 1},
  {&__pyx_n_u_numeric, __pyx_k_numeric, sizeof(__pyx_k_numeric), 0, 1, 0, 1},
  {&__pyx_kp_u_numeric__only, __pyx_k_numeric__only, sizeof(__pyx_k_numeric__only), 0, 1, 0, 0},
  {&__pyx_n_u_numeric_only, __pyx_k_numeric_only, sizeof(__pyx_k_numeric_only), 0, 1, 0, 1},
  {&__pyx_n_s_numeric_pattern, __pyx_k_numeric_pattern, sizeof(__pyx_k_numeric_pattern), 0, 0, 1, 1},
  {&__pyx_n_s_numeric_types, __pyx_k_numeric_types, sizeof(__pyx_k_numeric_types), 0, 0, 1, 1},
  {&__pyx_n_s_numeric_y, __pyx_k_numeric_y, sizeof(__pyx_k_numeric_y), 0, 0, 1, 1},
  {&__pyx_n_s_numpy, __pyx_k_numpy, sizeof(__pyx_k_numpy), 0, 0, 1, 1},
  {&__pyx_n_u_numpy, __pyx_k_numpy, sizeof(__pyx_k_numpy), 0, 1, 0, 1},
  {&__pyx_kp_u_numpy_array_api, __pyx_k_numpy_array_api, sizeof(__pyx_k_numpy_array_api), 0, 1, 0, 0},
  {&__pyx_n_s_numpy_core_numeric, __pyx_k_numpy_core_numeric, sizeof(__pyx_k_numpy_core_numeric), 0, 0, 1, 1},
  {&__pyx_n_s_nunique, __pyx_k_nunique, sizeof(__pyx_k_nunique), 0, 0, 1, 1},
  {&__pyx_n_s_o, __pyx_k_o, sizeof(__pyx_k_o), 0, 0, 1, 1},
  {&__pyx_kp_u_o_2, __pyx_k_o_2, sizeof(__pyx_k_o_2), 0, 1, 0, 0},
  {&__pyx_n_s_o_3, __pyx_k_o_3, sizeof(__pyx_k_o_3), 0, 0, 1, 1},
  {&__pyx_kp_u_o_is_expected_to_be_an_iterable, __pyx_k_o_is_expected_to_be_an_iterable, sizeof(__pyx_k_o_is_expected_to_be_an_iterable), 0, 1, 0, 0},
  {&__pyx_n_s_obj, __pyx_k_obj, sizeof(__pyx_k_obj), 0, 0, 1, 1},
  {&__pyx_n_s_object, __pyx_k_object, sizeof(__pyx_k_object), 0, 0, 1, 1},
  {&__pyx_n_u_object, __pyx_k_object, sizeof(__pyx_k_object), 0, 1, 0, 1},
  {&__pyx_n_s_object_dtype_isnan, __pyx_k_object_dtype_isnan, sizeof(__pyx_k_object_dtype_isnan), 0, 0, 1, 1},
  {&__pyx_n_s_objname, __pyx_k_objname, sizeof(__pyx_k_objname), 0, 0, 1, 1},
  {&__pyx_n_u_omit, __pyx_k_omit, sizeof(__pyx_k_omit), 0, 1, 0, 1},
  {&__pyx_n_s_ones_like, __pyx_k_ones_like, sizeof(__pyx_k_ones_like), 0, 0, 1, 1},
  {&__pyx_n_u_only, __pyx_k_only, sizeof(__pyx_k_only), 0, 1, 0, 1},
  {&__pyx_n_u_only_2, __pyx_k_only_2, sizeof(__pyx_k_only_2), 0, 1, 0, 1},
  {&__pyx_n_s_operator, __pyx_k_operator, sizeof(__pyx_k_operator), 0, 0, 1, 1},
  {&__pyx_n_s_order, __pyx_k_order, sizeof(__pyx_k_order), 0, 0, 1, 1},
  {&__pyx_n_s_output_format, __pyx_k_output_format, sizeof(__pyx_k_output_format), 0, 0, 1, 1},
  {&__pyx_n_u_output_format, __pyx_k_output_format, sizeof(__pyx_k_output_format), 0, 1, 0, 1},
  {&__pyx_n_s_over, __pyx_k_over, sizeof(__pyx_k_over), 0, 0, 1, 1},
  {&__pyx_n_s_padded_input_name, __pyx_k_padded_input_name, sizeof(__pyx_k_padded_input_name), 0, 0, 1, 1},
  {&__pyx_n_s_pandas, __pyx_k_pandas, sizeof(__pyx_k_pandas), 0, 0, 1, 1},
  {&__pyx_kp_u_pandas_DataFrame_with_sparse_col, __pyx_k_pandas_DataFrame_with_sparse_col, sizeof(__pyx_k_pandas_DataFrame_with_sparse_col), 0, 1, 0, 0},
  {&__pyx_n_s_pandas_api_types, __pyx_k_pandas_api_types, sizeof(__pyx_k_pandas_api_types), 0, 0, 1, 1},
  {&__pyx_n_s_pandas_dtype_needs_early_conver, __pyx_k_pandas_dtype_needs_early_conver, sizeof(__pyx_k_pandas_dtype_needs_early_conver), 0, 0, 1, 1},
  {&__pyx_n_s_pandas_requires_conversion, __pyx_k_pandas_requires_conversion, sizeof(__pyx_k_pandas_requires_conversion), 0, 0, 1, 1},
  {&__pyx_n_s_param, __pyx_k_param, sizeof(__pyx_k_param), 0, 0, 1, 1},
  {&__pyx_n_s_param_name, __pyx_k_param_name, sizeof(__pyx_k_param_name), 0, 0, 1, 1},
  {&__pyx_n_s_param_value, __pyx_k_param_value, sizeof(__pyx_k_param_value), 0, 0, 1, 1},
  {&__pyx_n_s_parameter, __pyx_k_parameter, sizeof(__pyx_k_parameter), 0, 0, 1, 1},
  {&__pyx_n_s_parameter_validator, __pyx_k_parameter_validator, sizeof(__pyx_k_parameter_validator), 0, 0, 1, 1},
  {&__pyx_n_u_parameter_validator, __pyx_k_parameter_validator, sizeof(__pyx_k_parameter_validator), 0, 1, 0, 1},
  {&__pyx_kp_u_parameter_validator_line_1275, __pyx_k_parameter_validator_line_1275, sizeof(__pyx_k_parameter_validator_line_1275), 0, 1, 0, 0},
  {&__pyx_n_s_parameter_validator_locals_valid, __pyx_k_parameter_validator_locals_valid, sizeof(__pyx_k_parameter_validator_locals_valid), 0, 0, 1, 1},
  {&__pyx_n_s_parameters, __pyx_k_parameters, sizeof(__pyx_k_parameters), 0, 0, 1, 1},
  {&__pyx_n_s_parse_year_input, __pyx_k_parse_year_input, sizeof(__pyx_k_parse_year_input), 0, 0, 1, 1},
  {&__pyx_kp_u_passing_these_as_positional_arg, __pyx_k_passing_these_as_positional_arg, sizeof(__pyx_k_passing_these_as_positional_arg), 0, 1, 0, 0},
  {&__pyx_n_u_passthrough, __pyx_k_passthrough, sizeof(__pyx_k_passthrough), 0, 1, 0, 1},
  {&__pyx_n_s_pd, __pyx_k_pd, sizeof(__pyx_k_pd), 0, 0, 1, 1},
  {&__pyx_n_s_pd_dtype, __pyx_k_pd_dtype, sizeof(__pyx_k_pd_dtype), 0, 0, 1, 1},
  {&__pyx_n_u_predict, __pyx_k_predict, sizeof(__pyx_k_predict), 0, 1, 0, 1},
  {&__pyx_n_s_prepare, __pyx_k_prepare, sizeof(__pyx_k_prepare), 0, 0, 1, 1},
  {&__pyx_n_s_print, __pyx_k_print, sizeof(__pyx_k_print), 0, 0, 1, 1},
  {&__pyx_n_u_propagate, __pyx_k_propagate, sizeof(__pyx_k_propagate), 0, 1, 0, 1},
  {&__pyx_n_s_qualname, __pyx_k_qualname, sizeof(__pyx_k_qualname), 0, 0, 1, 1},
  {&__pyx_n_u_qualname, __pyx_k_qualname, sizeof(__pyx_k_qualname), 0, 1, 0, 1},
  {&__pyx_n_s_qualname_2, __pyx_k_qualname_2, sizeof(__pyx_k_qualname_2), 0, 0, 1, 1},
  {&__pyx_kp_u_r_cannot_be_used_to_seed_a_nump, __pyx_k_r_cannot_be_used_to_seed_a_nump, sizeof(__pyx_k_r_cannot_be_used_to_seed_a_nump), 0, 1, 0, 0},
  {&__pyx_n_u_raise, __pyx_k_raise, sizeof(__pyx_k_raise), 0, 1, 0, 1},
  {&__pyx_n_s_raise_exception, __pyx_k_raise_exception, sizeof(__pyx_k_raise_exception), 0, 0, 1, 1},
  {&__pyx_n_s_raise_warning, __pyx_k_raise_warning, sizeof(__pyx_k_raise_warning), 0, 0, 1, 1},
  {&__pyx_n_s_rand, __pyx_k_rand, sizeof(__pyx_k_rand), 0, 0, 1, 1},
  {&__pyx_n_s_rand_2, __pyx_k_rand_2, sizeof(__pyx_k_rand_2), 0, 0, 1, 1},
  {&__pyx_n_s_random, __pyx_k_random, sizeof(__pyx_k_random), 0, 0, 1, 1},
  {&__pyx_n_s_random_values, __pyx_k_random_values, sizeof(__pyx_k_random_values), 0, 0, 1, 1},
  {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
  {&__pyx_n_s_range_name, __pyx_k_range_name, sizeof(__pyx_k_range_name), 0, 0, 1, 1},
  {&__pyx_n_s_range_tuple, __pyx_k_range_tuple, sizeof(__pyx_k_range_tuple), 0, 0, 1, 1},
  {&__pyx_n_s_ravel, __pyx_k_ravel, sizeof(__pyx_k_ravel), 0, 0, 1, 1},
  {&__pyx_n_u_raw_values, __pyx_k_raw_values, sizeof(__pyx_k_raw_values), 0, 1, 0, 1},
  {&__pyx_n_s_re, __pyx_k_re, sizeof(__pyx_k_re), 0, 0, 1, 1},
  {&__pyx_n_s_recheck_data_types, __pyx_k_recheck_data_types, sizeof(__pyx_k_recheck_data_types), 0, 0, 1, 1},
  {&__pyx_kp_u_recheck_data_types_line_2604, __pyx_k_recheck_data_types_line_2604, sizeof(__pyx_k_recheck_data_types_line_2604), 0, 1, 0, 0},
  {&__pyx_n_s_replace, __pyx_k_replace, sizeof(__pyx_k_replace), 0, 0, 1, 1},
  {&__pyx_n_s_replace_with, __pyx_k_replace_with, sizeof(__pyx_k_replace_with), 0, 0, 1, 1},
  {&__pyx_n_s_replacement_value, __pyx_k_replacement_value, sizeof(__pyx_k_replacement_value), 0, 0, 1, 1},
  {&__pyx_kp_u_requires_column_names_for_conve, __pyx_k_requires_column_names_for_conve, sizeof(__pyx_k_requires_column_names_for_conve), 0, 1, 0, 0},
  {&__pyx_kp_u_requires_y_to_be_passed_but_the, __pyx_k_requires_y_to_be_passed_but_the, sizeof(__pyx_k_requires_y_to_be_passed_but_the), 0, 1, 0, 0},
  {&__pyx_n_s_reshape, __pyx_k_reshape, sizeof(__pyx_k_reshape), 0, 0, 1, 1},
  {&__pyx_kp_u_respectively, __pyx_k_respectively, sizeof(__pyx_k_respectively), 0, 1, 0, 0},
  {&__pyx_n_s_result, __pyx_k_result, sizeof(__pyx_k_result), 0, 0, 1, 1},
  {&__pyx_n_s_result_type, __pyx_k_result_type, sizeof(__pyx_k_result_type), 0, 0, 1, 1},
  {&__pyx_n_s_results, __pyx_k_results, sizeof(__pyx_k_results), 0, 0, 1, 1},
  {&__pyx_n_s_return_as_date_str, __pyx_k_return_as_date_str, sizeof(__pyx_k_return_as_date_str), 0, 0, 1, 1},
  {&__pyx_n_s_return_as_numpy, __pyx_k_return_as_numpy, sizeof(__pyx_k_return_as_numpy), 0, 0, 1, 1},
  {&__pyx_n_u_return_as_numpy, __pyx_k_return_as_numpy, sizeof(__pyx_k_return_as_numpy), 0, 1, 0, 1},
  {&__pyx_n_s_return_classes, __pyx_k_return_classes, sizeof(__pyx_k_return_classes), 0, 0, 1, 1},
  {&__pyx_n_s_return_data, __pyx_k_return_data, sizeof(__pyx_k_return_data), 0, 0, 1, 1},
  {&__pyx_n_s_return_target_only, __pyx_k_return_target_only, sizeof(__pyx_k_return_target_only), 0, 0, 1, 1},
  {&__pyx_n_s_return_values, __pyx_k_return_values, sizeof(__pyx_k_return_values), 0, 0, 1, 1},
  {&__pyx_n_u_right, __pyx_k_right, sizeof(__pyx_k_right), 0, 1, 0, 1},
  {&__pyx_n_s_round_float, __pyx_k_round_float, sizeof(__pyx_k_round_float), 0, 0, 1, 1},
  {&__pyx_n_u_row, __pyx_k_row, sizeof(__pyx_k_row), 0, 1, 0, 1},
  {&__pyx_kp_u_s_is_not_an_estimator_instance, __pyx_k_s_is_not_an_estimator_instance, sizeof(__pyx_k_s_is_not_an_estimator_instance), 0, 1, 0, 0},
  {&__pyx_n_u_safe, __pyx_k_safe, sizeof(__pyx_k_safe), 0, 1, 0, 1},
  {&__pyx_kp_u_sample_s_shape, __pyx_k_sample_s_shape, sizeof(__pyx_k_sample_s_shape), 0, 1, 0, 0},
  {&__pyx_n_s_sample_weight, __pyx_k_sample_weight, sizeof(__pyx_k_sample_weight), 0, 0, 1, 1},
  {&__pyx_n_s_sample_weights, __pyx_k_sample_weights, sizeof(__pyx_k_sample_weights), 0, 0, 1, 1},
  {&__pyx_n_s_scale_factor, __pyx_k_scale_factor, sizeof(__pyx_k_scale_factor), 0, 0, 1, 1},
  {&__pyx_n_s_scipy_sparse, __pyx_k_scipy_sparse, sizeof(__pyx_k_scipy_sparse), 0, 0, 1, 1},
  {&__pyx_n_s_scores, __pyx_k_scores, sizeof(__pyx_k_scores), 0, 0, 1, 1},
  {&__pyx_n_s_seed, __pyx_k_seed, sizeof(__pyx_k_seed), 0, 0, 1, 1},
  {&__pyx_n_s_send, __pyx_k_send, sizeof(__pyx_k_send), 0, 0, 1, 1},
  {&__pyx_n_s_set_array_back, __pyx_k_set_array_back, sizeof(__pyx_k_set_array_back), 0, 0, 1, 1},
  {&__pyx_n_s_shape, __pyx_k_shape, sizeof(__pyx_k_shape), 0, 0, 1, 1},
  {&__pyx_n_u_shape, __pyx_k_shape, sizeof(__pyx_k_shape), 0, 1, 0, 1},
  {&__pyx_kp_u_should_be_a_1d_array_got_an_arr, __pyx_k_should_be_a_1d_array_got_an_arr, sizeof(__pyx_k_should_be_a_1d_array_got_an_arr), 0, 1, 0, 0},
  {&__pyx_kp_u_should_be_an_array_like_or_spar, __pyx_k_should_be_an_array_like_or_spar, sizeof(__pyx_k_should_be_an_array_like_or_spar), 0, 1, 0, 0},
  {&__pyx_kp_u_should_be_array_like_or_a_spars, __pyx_k_should_be_array_like_or_a_spars, sizeof(__pyx_k_should_be_array_like_or_a_spars), 0, 1, 0, 0},
  {&__pyx_n_s_sig, __pyx_k_sig, sizeof(__pyx_k_sig), 0, 0, 1, 1},
  {&__pyx_n_s_signature, __pyx_k_signature, sizeof(__pyx_k_signature), 0, 0, 1, 1},
  {&__pyx_n_u_silence, __pyx_k_silence, sizeof(__pyx_k_silence), 0, 1, 0, 1},
  {&__pyx_n_s_simplefilter, __pyx_k_simplefilter, sizeof(__pyx_k_simplefilter), 0, 0, 1, 1},
  {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
  {&__pyx_n_s_sklearn_is_fitted, __pyx_k_sklearn_is_fitted, sizeof(__pyx_k_sklearn_is_fitted), 0, 0, 1, 1},
  {&__pyx_n_u_sklearn_is_fitted, __pyx_k_sklearn_is_fitted, sizeof(__pyx_k_sklearn_is_fitted), 0, 1, 0, 1},
  {&__pyx_n_u_soft, __pyx_k_soft, sizeof(__pyx_k_soft), 0, 1, 0, 1},
  {&__pyx_n_s_sorted_values, __pyx_k_sorted_values, sizeof(__pyx_k_sorted_values), 0, 0, 1, 1},
  {&__pyx_n_s_sp, __pyx_k_sp, sizeof(__pyx_k_sp), 0, 0, 1, 1},
  {&__pyx_n_u_sparse, __pyx_k_sparse, sizeof(__pyx_k_sparse), 0, 1, 0, 1},
  {&__pyx_n_s_spmatrix, __pyx_k_spmatrix, sizeof(__pyx_k_spmatrix), 0, 0, 1, 1},
  {&__pyx_n_s_sqrt, __pyx_k_sqrt, sizeof(__pyx_k_sqrt), 0, 0, 1, 1},
  {&__pyx_n_s_stacklevel, __pyx_k_stacklevel, sizeof(__pyx_k_stacklevel), 0, 0, 1, 1},
  {&__pyx_n_s_start, __pyx_k_start, sizeof(__pyx_k_start), 0, 0, 1, 1},
  {&__pyx_n_s_start_date, __pyx_k_start_date, sizeof(__pyx_k_start_date), 0, 0, 1, 1},
  {&__pyx_n_s_startswith, __pyx_k_startswith, sizeof(__pyx_k_startswith), 0, 0, 1, 1},
  {&__pyx_n_s_std, __pyx_k_std, sizeof(__pyx_k_std), 0, 0, 1, 1},
  {&__pyx_n_u_str, __pyx_k_str, sizeof(__pyx_k_str), 0, 1, 0, 1},
  {&__pyx_n_s_strategy, __pyx_k_strategy, sizeof(__pyx_k_strategy), 0, 0, 1, 1},
  {&__pyx_n_s_strftime, __pyx_k_strftime, sizeof(__pyx_k_strftime), 0, 0, 1, 1},
  {&__pyx_n_s_strict, __pyx_k_strict, sizeof(__pyx_k_strict), 0, 0, 1, 1},
  {&__pyx_n_u_strict, __pyx_k_strict, sizeof(__pyx_k_strict), 0, 1, 0, 1},
  {&__pyx_n_s_strip, __pyx_k_strip, sizeof(__pyx_k_strip), 0, 0, 1, 1},
  {&__pyx_n_s_strptime, __pyx_k_strptime, sizeof(__pyx_k_strptime), 0, 0, 1, 1},
  {&__pyx_n_s_suffix, __pyx_k_suffix, sizeof(__pyx_k_suffix), 0, 0, 1, 1},
  {&__pyx_n_s_sum, __pyx_k_sum, sizeof(__pyx_k_sum), 0, 0, 1, 1},
  {&__pyx_n_u_sum, __pyx_k_sum, sizeof(__pyx_k_sum), 0, 1, 0, 1},
  {&__pyx_n_u_summary, __pyx_k_summary, sizeof(__pyx_k_summary), 0, 1, 0, 1},
  {&__pyx_n_s_supported_indices, __pyx_k_supported_indices, sizeof(__pyx_k_supported_indices), 0, 0, 1, 1},
  {&__pyx_n_s_suppress, __pyx_k_suppress, sizeof(__pyx_k_suppress), 0, 0, 1, 1},
  {&__pyx_n_s_symmetric, __pyx_k_symmetric, sizeof(__pyx_k_symmetric), 0, 0, 1, 1},
  {&__pyx_n_s_t, __pyx_k_t, sizeof(__pyx_k_t), 0, 0, 1, 1},
  {&__pyx_n_s_target, __pyx_k_target, sizeof(__pyx_k_target), 0, 0, 1, 1},
  {&__pyx_n_s_target_strs, __pyx_k_target_strs, sizeof(__pyx_k_target_strs), 0, 0, 1, 1},
  {&__pyx_n_s_target_type, __pyx_k_target_type, sizeof(__pyx_k_target_type), 0, 0, 1, 1},
  {&__pyx_n_s_target_type_str, __pyx_k_target_type_str, sizeof(__pyx_k_target_type_str), 0, 0, 1, 1},
  {&__pyx_n_s_tensorflow, __pyx_k_tensorflow, sizeof(__pyx_k_tensorflow), 0, 0, 1, 1},
  {&__pyx_n_u_tensorflow, __pyx_k_tensorflow, sizeof(__pyx_k_tensorflow), 0, 1, 0, 1},
  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
  {&__pyx_n_s_tf, __pyx_k_tf, sizeof(__pyx_k_tf), 0, 0, 1, 1},
  {&__pyx_n_s_throw, __pyx_k_throw, sizeof(__pyx_k_throw), 0, 0, 1, 1},
  {&__pyx_n_s_time_col, __pyx_k_time_col, sizeof(__pyx_k_time_col), 0, 0, 1, 1},
  {&__pyx_n_u_to, __pyx_k_to, sizeof(__pyx_k_to), 0, 1, 0, 1},
  {&__pyx_kp_u_to_DataFrame_requires_column_na, __pyx_k_to_DataFrame_requires_column_na, sizeof(__pyx_k_to_DataFrame_requires_column_na), 0, 1, 0, 0},
  {&__pyx_n_s_to_array, __pyx_k_to_array, sizeof(__pyx_k_to_array), 0, 0, 1, 1},
  {&__pyx_kp_u_to_be_a_one_dimensional_array_l, __pyx_k_to_be_a_one_dimensional_array_l, sizeof(__pyx_k_to_be_a_one_dimensional_array_l), 0, 1, 0, 0},
  {&__pyx_n_s_to_datetime, __pyx_k_to_datetime, sizeof(__pyx_k_to_datetime), 0, 0, 1, 1},
  {&__pyx_n_s_to_dtype_str, __pyx_k_to_dtype_str, sizeof(__pyx_k_to_dtype_str), 0, 0, 1, 1},
  {&__pyx_n_u_to_dtype_str, __pyx_k_to_dtype_str, sizeof(__pyx_k_to_dtype_str), 0, 1, 0, 1},
  {&__pyx_n_s_to_frame, __pyx_k_to_frame, sizeof(__pyx_k_to_frame), 0, 0, 1, 1},
  {&__pyx_kp_u_to_integers_Ensure_all_values_a, __pyx_k_to_integers_Ensure_all_values_a, sizeof(__pyx_k_to_integers_Ensure_all_values_a), 0, 1, 0, 0},
  {&__pyx_n_s_to_numeric, __pyx_k_to_numeric, sizeof(__pyx_k_to_numeric), 0, 0, 1, 1},
  {&__pyx_n_s_to_numpy, __pyx_k_to_numpy, sizeof(__pyx_k_to_numpy), 0, 0, 1, 1},
  {&__pyx_n_s_tocsr, __pyx_k_tocsr, sizeof(__pyx_k_tocsr), 0, 0, 1, 1},
  {&__pyx_n_s_tol, __pyx_k_tol, sizeof(__pyx_k_tol), 0, 0, 1, 1},
  {&__pyx_n_s_total, __pyx_k_total, sizeof(__pyx_k_total), 0, 0, 1, 1},
  {&__pyx_n_s_true_labels, __pyx_k_true_labels, sizeof(__pyx_k_true_labels), 0, 0, 1, 1},
  {&__pyx_n_s_type, __pyx_k_type, sizeof(__pyx_k_type), 0, 0, 1, 1},
  {&__pyx_n_s_type_col_name, __pyx_k_type_col_name, sizeof(__pyx_k_type_col_name), 0, 0, 1, 1},
  {&__pyx_n_s_type_err, __pyx_k_type_err, sizeof(__pyx_k_type_err), 0, 0, 1, 1},
  {&__pyx_n_s_type_error, __pyx_k_type_error, sizeof(__pyx_k_type_error), 0, 0, 1, 1},
  {&__pyx_n_s_type_name, __pyx_k_type_name, sizeof(__pyx_k_type_name), 0, 0, 1, 1},
  {&__pyx_n_s_type_of_target, __pyx_k_type_of_target, sizeof(__pyx_k_type_of_target), 0, 0, 1, 1},
  {&__pyx_n_s_types, __pyx_k_types, sizeof(__pyx_k_types), 0, 0, 1, 1},
  {&__pyx_n_s_types_str, __pyx_k_types_str, sizeof(__pyx_k_types_str), 0, 0, 1, 1},
  {&__pyx_n_s_typing, __pyx_k_typing, sizeof(__pyx_k_typing), 0, 0, 1, 1},
  {&__pyx_n_u_uniform_average, __pyx_k_uniform_average, sizeof(__pyx_k_uniform_average), 0, 1, 0, 1},
  {&__pyx_n_s_unique, __pyx_k_unique, sizeof(__pyx_k_unique), 0, 0, 1, 1},
  {&__pyx_n_s_unique_classes, __pyx_k_unique_classes, sizeof(__pyx_k_unique_classes), 0, 0, 1, 1},
  {&__pyx_n_s_unique_values, __pyx_k_unique_values, sizeof(__pyx_k_unique_values), 0, 0, 1, 1},
  {&__pyx_n_s_uniques, __pyx_k_uniques, sizeof(__pyx_k_uniques), 0, 0, 1, 1},
  {&__pyx_n_u_unknown, __pyx_k_unknown, sizeof(__pyx_k_unknown), 0, 1, 0, 1},
  {&__pyx_n_s_update, __pyx_k_update, sizeof(__pyx_k_update), 0, 0, 1, 1},
  {&__pyx_n_s_util, __pyx_k_util, sizeof(__pyx_k_util), 0, 0, 1, 1},
  {&__pyx_n_s_v, __pyx_k_v, sizeof(__pyx_k_v), 0, 0, 1, 1},
  {&__pyx_n_s_valid_kwargs, __pyx_k_valid_kwargs, sizeof(__pyx_k_valid_kwargs), 0, 0, 1, 1},
  {&__pyx_n_s_valid_params, __pyx_k_valid_params, sizeof(__pyx_k_valid_params), 0, 0, 1, 1},
  {&__pyx_n_s_valid_policies, __pyx_k_valid_policies, sizeof(__pyx_k_valid_policies), 0, 0, 1, 1},
  {&__pyx_n_s_valid_values, __pyx_k_valid_values, sizeof(__pyx_k_valid_values), 0, 0, 1, 1},
  {&__pyx_n_s_validate_and_adjust_ranges, __pyx_k_validate_and_adjust_ranges, sizeof(__pyx_k_validate_and_adjust_ranges), 0, 0, 1, 1},
  {&__pyx_n_u_validate_and_adjust_ranges, __pyx_k_validate_and_adjust_ranges, sizeof(__pyx_k_validate_and_adjust_ranges), 0, 1, 0, 1},
  {&__pyx_kp_u_validate_and_adjust_ranges_line, __pyx_k_validate_and_adjust_ranges_line, sizeof(__pyx_k_validate_and_adjust_ranges_line), 0, 1, 0, 0},
  {&__pyx_n_s_validate_and_adjust_ranges_local, __pyx_k_validate_and_adjust_ranges_local, sizeof(__pyx_k_validate_and_adjust_ranges_local), 0, 0, 1, 1},
  {&__pyx_n_s_validate_comparison_data, __pyx_k_validate_comparison_data, sizeof(__pyx_k_validate_comparison_data), 0, 0, 1, 1},
  {&__pyx_n_u_validate_comparison_data, __pyx_k_validate_comparison_data, sizeof(__pyx_k_validate_comparison_data), 0, 1, 0, 1},
  {&__pyx_kp_u_validate_comparison_data_line_92, __pyx_k_validate_comparison_data_line_92, sizeof(__pyx_k_validate_comparison_data_line_92), 0, 1, 0, 0},
  {&__pyx_n_s_validate_data_types, __pyx_k_validate_data_types, sizeof(__pyx_k_validate_data_types), 0, 0, 1, 1},
  {&__pyx_n_u_validate_data_types, __pyx_k_validate_data_types, sizeof(__pyx_k_validate_data_types), 0, 1, 0, 1},
  {&__pyx_kp_u_validate_data_types_line_999, __pyx_k_validate_data_types_line_999, sizeof(__pyx_k_validate_data_types_line_999), 0, 1, 0, 0},
  {&__pyx_n_s_validate_data_types_locals__hand, __pyx_k_validate_data_types_locals__hand, sizeof(__pyx_k_validate_data_types_locals__hand), 0, 0, 1, 1},
  {&__pyx_n_s_validate_data_types_locals__hand_2, __pyx_k_validate_data_types_locals__hand_2, sizeof(__pyx_k_validate_data_types_locals__hand_2), 0, 0, 1, 1},
  {&__pyx_n_s_validate_data_types_locals__hand_3, __pyx_k_validate_data_types_locals__hand_3, sizeof(__pyx_k_validate_data_types_locals__hand_3), 0, 0, 1, 1},
  {&__pyx_n_s_validate_dates, __pyx_k_validate_dates, sizeof(__pyx_k_validate_dates), 0, 0, 1, 1},
  {&__pyx_n_u_validate_dates, __pyx_k_validate_dates, sizeof(__pyx_k_validate_dates), 0, 1, 0, 1},
  {&__pyx_kp_u_validate_dates_line_2377, __pyx_k_validate_dates_line_2377, sizeof(__pyx_k_validate_dates_line_2377), 0, 1, 0, 0},
  {&__pyx_n_s_validate_dates_locals_parse_year, __pyx_k_validate_dates_locals_parse_year, sizeof(__pyx_k_validate_dates_locals_parse_year), 0, 0, 1, 1},
  {&__pyx_n_s_validate_distribution, __pyx_k_validate_distribution, sizeof(__pyx_k_validate_distribution), 0, 0, 1, 1},
  {&__pyx_n_u_validate_distribution, __pyx_k_validate_distribution, sizeof(__pyx_k_validate_distribution), 0, 1, 0, 1},
  {&__pyx_kp_u_validate_distribution_line_1352, __pyx_k_validate_distribution_line_1352, sizeof(__pyx_k_validate_distribution_line_1352), 0, 1, 0, 0},
  {&__pyx_n_s_validate_dtype_selector, __pyx_k_validate_dtype_selector, sizeof(__pyx_k_validate_dtype_selector), 0, 0, 1, 1},
  {&__pyx_n_u_validate_dtype_selector, __pyx_k_validate_dtype_selector, sizeof(__pyx_k_validate_dtype_selector), 0, 1, 0, 1},
  {&__pyx_n_s_validate_fit_weights, __pyx_k_validate_fit_weights, sizeof(__pyx_k_validate_fit_weights), 0, 0, 1, 1},
  {&__pyx_n_u_validate_fit_weights, __pyx_k_validate_fit_weights, sizeof(__pyx_k_validate_fit_weights), 0, 1, 0, 1},
  {&__pyx_kp_u_validate_fit_weights_line_1629, __pyx_k_validate_fit_weights_line_1629, sizeof(__pyx_k_validate_fit_weights_line_1629), 0, 1, 0, 0},
  {&__pyx_n_s_validate_input, __pyx_k_validate_input, sizeof(__pyx_k_validate_input), 0, 0, 1, 1},
  {&__pyx_n_s_validate_input_locals_lambda, __pyx_k_validate_input_locals_lambda, sizeof(__pyx_k_validate_input_locals_lambda), 0, 0, 1, 1},
  {&__pyx_n_s_validate_keras_model, __pyx_k_validate_keras_model, sizeof(__pyx_k_validate_keras_model), 0, 0, 1, 1},
  {&__pyx_n_u_validate_keras_model, __pyx_k_validate_keras_model, sizeof(__pyx_k_validate_keras_model), 0, 1, 0, 1},
  {&__pyx_kp_u_validate_keras_model_line_2685, __pyx_k_validate_keras_model_line_2685, sizeof(__pyx_k_validate_keras_model_line_2685), 0, 1, 0, 0},
  {&__pyx_n_s_validate_length_range, __pyx_k_validate_length_range, sizeof(__pyx_k_validate_length_range), 0, 0, 1, 1},
  {&__pyx_n_u_validate_length_range, __pyx_k_validate_length_range, sizeof(__pyx_k_validate_length_range), 0, 1, 0, 1},
  {&__pyx_kp_u_validate_length_range_line_1424, __pyx_k_validate_length_range_line_1424, sizeof(__pyx_k_validate_length_range_line_1424), 0, 1, 0, 0},
  {&__pyx_n_s_validate_length_range_locals_gen, __pyx_k_validate_length_range_locals_gen, sizeof(__pyx_k_validate_length_range_locals_gen), 0, 0, 1, 1},
  {&__pyx_n_s_validate_multiclass_target, __pyx_k_validate_multiclass_target, sizeof(__pyx_k_validate_multiclass_target), 0, 0, 1, 1},
  {&__pyx_n_u_validate_multiclass_target, __pyx_k_validate_multiclass_target, sizeof(__pyx_k_validate_multiclass_target), 0, 1, 0, 1},
  {&__pyx_kp_u_validate_multiclass_target_line, __pyx_k_validate_multiclass_target_line, sizeof(__pyx_k_validate_multiclass_target_line), 0, 1, 0, 0},
  {&__pyx_n_s_validate_multioutput, __pyx_k_validate_multioutput, sizeof(__pyx_k_validate_multioutput), 0, 0, 1, 1},
  {&__pyx_n_u_validate_multioutput, __pyx_k_validate_multioutput, sizeof(__pyx_k_validate_multioutput), 0, 1, 0, 1},
  {&__pyx_kp_u_validate_multioutput_line_1756, __pyx_k_validate_multioutput_line_1756, sizeof(__pyx_k_validate_multioutput_line_1756), 0, 1, 0, 0},
  {&__pyx_n_s_validate_nan_policy, __pyx_k_validate_nan_policy, sizeof(__pyx_k_validate_nan_policy), 0, 0, 1, 1},
  {&__pyx_n_u_validate_nan_policy, __pyx_k_validate_nan_policy, sizeof(__pyx_k_validate_nan_policy), 0, 1, 0, 1},
  {&__pyx_kp_u_validate_nan_policy_line_1542, __pyx_k_validate_nan_policy_line_1542, sizeof(__pyx_k_validate_nan_policy_line_1542), 0, 1, 0, 0},
  {&__pyx_n_s_validate_nan_policy_locals_genex, __pyx_k_validate_nan_policy_locals_genex, sizeof(__pyx_k_validate_nan_policy_locals_genex), 0, 0, 1, 1},
  {&__pyx_n_s_validate_numeric, __pyx_k_validate_numeric, sizeof(__pyx_k_validate_numeric), 0, 0, 1, 1},
  {&__pyx_n_u_validate_numeric, __pyx_k_validate_numeric, sizeof(__pyx_k_validate_numeric), 0, 1, 0, 1},
  {&__pyx_kp_u_validate_numeric_line_3008, __pyx_k_validate_numeric_line_3008, sizeof(__pyx_k_validate_numeric_line_3008), 0, 1, 0, 0},
  {&__pyx_n_s_validate_positive_integer, __pyx_k_validate_positive_integer, sizeof(__pyx_k_validate_positive_integer), 0, 0, 1, 1},
  {&__pyx_n_u_validate_positive_integer, __pyx_k_validate_positive_integer, sizeof(__pyx_k_validate_positive_integer), 0, 1, 0, 1},
  {&__pyx_n_s_validate_sample_weights, __pyx_k_validate_sample_weights, sizeof(__pyx_k_validate_sample_weights), 0, 0, 1, 1},
  {&__pyx_n_u_validate_sample_weights, __pyx_k_validate_sample_weights, sizeof(__pyx_k_validate_sample_weights), 0, 1, 0, 1},
  {&__pyx_kp_u_validate_sample_weights_line_507, __pyx_k_validate_sample_weights_line_507, sizeof(__pyx_k_validate_sample_weights_line_507), 0, 1, 0, 0},
  {&__pyx_n_s_validate_scores, __pyx_k_validate_scores, sizeof(__pyx_k_validate_scores), 0, 0, 1, 1},
  {&__pyx_n_u_validate_scores, __pyx_k_validate_scores, sizeof(__pyx_k_validate_scores), 0, 1, 0, 1},
  {&__pyx_kp_u_validate_scores_line_159, __pyx_k_validate_scores_line_159, sizeof(__pyx_k_validate_scores_line_159), 0, 1, 0, 0},
  {&__pyx_n_s_validate_scores_locals_genexpr, __pyx_k_validate_scores_locals_genexpr, sizeof(__pyx_k_validate_scores_locals_genexpr), 0, 0, 1, 1},
  {&__pyx_n_s_validate_square_matrix, __pyx_k_validate_square_matrix, sizeof(__pyx_k_validate_square_matrix), 0, 0, 1, 1},
  {&__pyx_n_u_validate_square_matrix, __pyx_k_validate_square_matrix, sizeof(__pyx_k_validate_square_matrix), 0, 1, 0, 1},
  {&__pyx_kp_u_validate_square_matrix_line_311, __pyx_k_validate_square_matrix_line_311, sizeof(__pyx_k_validate_square_matrix_line_311), 0, 1, 0, 0},
  {&__pyx_n_s_validate_weights, __pyx_k_validate_weights, sizeof(__pyx_k_validate_weights), 0, 0, 1, 1},
  {&__pyx_n_u_validate_weights, __pyx_k_validate_weights, sizeof(__pyx_k_validate_weights), 0, 1, 0, 1},
  {&__pyx_kp_u_validate_weights_line_577, __pyx_k_validate_weights_line_577, sizeof(__pyx_k_validate_weights_line_577), 0, 1, 0, 0},
  {&__pyx_n_s_validate_yy, __pyx_k_validate_yy, sizeof(__pyx_k_validate_yy), 0, 0, 1, 1},
  {&__pyx_n_u_validate_yy, __pyx_k_validate_yy, sizeof(__pyx_k_validate_yy), 0, 1, 0, 1},
  {&__pyx_n_s_validated_distribution, __pyx_k_validated_distribution, sizeof(__pyx_k_validated_distribution), 0, 0, 1, 1},
  {&__pyx_n_s_validated_targets, __pyx_k_validated_targets, sizeof(__pyx_k_validated_targets), 0, 0, 1, 1},
  {&__pyx_n_s_validation_checks, __pyx_k_validation_checks, sizeof(__pyx_k_validation_checks), 0, 0, 1, 1},
  {&__pyx_n_s_validation_mode, __pyx_k_validation_mode, sizeof(__pyx_k_validation_mode), 0, 0, 1, 1},
  {&__pyx_n_s_validator, __pyx_k_validator, sizeof(__pyx_k_validator), 0, 0, 1, 1},
  {&__pyx_kp_s_validator_pyx, __pyx_k_validator_pyx, sizeof(__pyx_k_validator_pyx), 0, 0, 1, 0},
  {&__pyx_n_s_value, __pyx_k_value, sizeof(__pyx_k_value), 0, 0, 1, 1},
  {&__pyx_n_s_value_err, __pyx_k_value_err, sizeof(__pyx_k_value_err), 0, 0, 1, 1},
  {&__pyx_n_s_value_lower, __pyx_k_value_lower, sizeof(__pyx_k_value_lower), 0, 0, 1, 1},
  {&__pyx_n_s_values, __pyx_k_values, sizeof(__pyx_k_values), 0, 0, 1, 1},
  {&__pyx_n_s_variable_name, __pyx_k_variable_name, sizeof(__pyx_k_variable_name), 0, 0, 1, 1},
  {&__pyx_n_s_vars, __pyx_k_vars, sizeof(__pyx_k_vars), 0, 0, 1, 1},
  {&__pyx_n_s_verbose, __pyx_k_verbose, sizeof(__pyx_k_verbose), 0, 0, 1, 1},
  {&__pyx_n_s_version, __pyx_k_version, sizeof(__pyx_k_version), 0, 0, 1, 1},
  {&__pyx_n_s_warn, __pyx_k_warn, sizeof(__pyx_k_warn), 0, 0, 1, 1},
  {&__pyx_n_u_warn, __pyx_k_warn, sizeof(__pyx_k_warn), 0, 1, 0, 1},
  {&__pyx_n_s_warn_msg, __pyx_k_warn_msg, sizeof(__pyx_k_warn_msg), 0, 0, 1, 1},
  {&__pyx_n_s_warnings, __pyx_k_warnings, sizeof(__pyx_k_warnings), 0, 0, 1, 1},
  {&__pyx_n_s_weighted_y, __pyx_k_weighted_y, sizeof(__pyx_k_weighted_y), 0, 0, 1, 1},
  {&__pyx_n_s_weighted_y_values, __pyx_k_weighted_y_values, sizeof(__pyx_k_weighted_y_values), 0, 0, 1, 1},
  {&__pyx_n_s_weights, __pyx_k_weights, sizeof(__pyx_k_weights), 0, 0, 1, 1},
  {&__pyx_n_s_weights_array, __pyx_k_weights_array, sizeof(__pyx_k_weights_array), 0, 0, 1, 1},
  {&__pyx_kp_u_where_the_samples_are_of_type, __pyx_k_where_the_samples_are_of_type, sizeof(__pyx_k_where_the_samples_are_of_type), 0, 1, 0, 0},
  {&__pyx_kp_u_while_a_minimum_of, __pyx_k_while_a_minimum_of, sizeof(__pyx_k_while_a_minimum_of), 0, 1, 0, 0},
  {&__pyx_kp_u_with_shape, __pyx_k_with_shape, sizeof(__pyx_k_with_shape), 0, 1, 0, 0},
  {&__pyx_n_s_wraps, __pyx_k_wraps, sizeof(__pyx_k_wraps), 0, 0, 1, 1},
  {&__pyx_n_s_x, __pyx_k_x, sizeof(__pyx_k_x), 0, 0, 1, 1},
  {&__pyx_n_u_x, __pyx_k_x, sizeof(__pyx_k_x), 0, 1, 0, 1},
  {&__pyx_kp_u_x_and_y_must_be_a_numeric_array, __pyx_k_x_and_y_must_be_a_numeric_array, sizeof(__pyx_k_x_and_y_must_be_a_numeric_array), 0, 1, 0, 0},
  {&__pyx_n_s_xp, __pyx_k_xp, sizeof(__pyx_k_xp), 0, 0, 1, 1},
  {&__pyx_n_s_xy_numeric, __pyx_k_xy_numeric, sizeof(__pyx_k_xy_numeric), 0, 0, 1, 1},
  {&__pyx_n_s_y, __pyx_k_y, sizeof(__pyx_k_y), 0, 0, 1, 1},
  {&__pyx_n_u_y, __pyx_k_y, sizeof(__pyx_k_y), 0, 1, 0, 1},
  {&__pyx_n_s_y_arrays, __pyx_k_y_arrays, sizeof(__pyx_k_y_arrays), 0, 0, 1, 1},
  {&__pyx_n_s_y_eval, __pyx_k_y_eval, sizeof(__pyx_k_y_eval), 0, 0, 1, 1},
  {&__pyx_n_s_y_numeric, __pyx_k_y_numeric, sizeof(__pyx_k_y_numeric), 0, 0, 1, 1},
  {&__pyx_n_s_y_pred, __pyx_k_y_pred, sizeof(__pyx_k_y_pred), 0, 0, 1, 1},
  {&__pyx_n_s_y_true, __pyx_k_y_true, sizeof(__pyx_k_y_true), 0, 0, 1, 1},
  {&__pyx_n_s_y_true_processed, __pyx_k_y_true_processed, sizeof(__pyx_k_y_true_processed), 0, 0, 1, 1},
  {&__pyx_n_s_year, __pyx_k_year, sizeof(__pyx_k_year), 0, 0, 1, 1},
  {&__pyx_n_s_year_input, __pyx_k_year_input, sizeof(__pyx_k_year_input), 0, 0, 1, 1},
  {&__pyx_n_s_zero_division, __pyx_k_zero_division, sizeof(__pyx_k_zero_division), 0, 0, 1, 1},
  {&__pyx_n_u_zero_division, __pyx_k_zero_division, sizeof(__pyx_k_zero_division), 0, 1, 0, 1},
  {&__pyx_n_s_zeros_mask, __pyx_k_zeros_mask, sizeof(__pyx_k_zeros_mask), 0, 0, 1, 1},
  {&__pyx_n_s_zip, __pyx_k_zip, sizeof(__pyx_k_zip), 0, 0, 1, 1},
  {&__pyx_n_u_zscore, __pyx_k_zscore, sizeof(__pyx_k_zscore), 0, 1, 0, 1},
  {0, 0, 0, 0, 0, 0, 0}
};
static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_all = __Pyx_GetBuiltinName(__pyx_n_s_all); if (!__pyx_builtin_all) __PYX_ERR(0, 3823, __pyx_L1_error)
  __pyx_builtin_UserWarning = __Pyx_GetBuiltinName(__pyx_n_s_UserWarning); if (!__pyx_builtin_UserWarning) __PYX_ERR(0, 5342, __pyx_L1_error)
  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 235, __pyx_L1_error)
  __pyx_builtin_TypeError = __Pyx_GetBuiltinName(__pyx_n_s_TypeError); if (!__pyx_builtin_TypeError) __PYX_ERR(0, 429, __pyx_L1_error)
  __pyx_builtin_RuntimeWarning = __Pyx_GetBuiltinName(__pyx_n_s_RuntimeWarning); if (!__pyx_builtin_RuntimeWarning) __PYX_ERR(0, 914, __pyx_L1_error)
  __pyx_builtin_sum = __Pyx_GetBuiltinName(__pyx_n_s_sum); if (!__pyx_builtin_sum) __PYX_ERR(0, 1417, __pyx_L1_error)
  __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(0, 1861, __pyx_L1_error)
  __pyx_builtin_print = __Pyx_GetBuiltinName(__pyx_n_s_print); if (!__pyx_builtin_print) __PYX_ERR(0, 2154, __pyx_L1_error)
  __pyx_builtin_object = __Pyx_GetBuiltinName(__pyx_n_s_object); if (!__pyx_builtin_object) __PYX_ERR(0, 2171, __pyx_L1_error)
  __pyx_builtin_any = __Pyx_GetBuiltinName(__pyx_n_s_any); if (!__pyx_builtin_any) __PYX_ERR(0, 2328, __pyx_L1_error)
  __pyx_builtin_map = __Pyx_GetBuiltinName(__pyx_n_s_map); if (!__pyx_builtin_map) __PYX_ERR(0, 2457, __pyx_L1_error)
  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 2653, __pyx_L1_error)
  __pyx_builtin_AttributeError = __Pyx_GetBuiltinName(__pyx_n_s_AttributeError); if (!__pyx_builtin_AttributeError) __PYX_ERR(0, 3319, __pyx_L1_error)
  __pyx_builtin_FutureWarning = __Pyx_GetBuiltinName(__pyx_n_s_FutureWarning); if (!__pyx_builtin_FutureWarning) __PYX_ERR(0, 3387, __pyx_L1_error)
  __pyx_builtin_zip = __Pyx_GetBuiltinName(__pyx_n_s_zip); if (!__pyx_builtin_zip) __PYX_ERR(0, 3389, __pyx_L1_error)
  __pyx_builtin_vars = __Pyx_GetBuiltinName(__pyx_n_s_vars); if (!__pyx_builtin_vars) __PYX_ERR(0, 3888, __pyx_L1_error)
  __pyx_builtin_ImportError = __Pyx_GetBuiltinName(__pyx_n_s_ImportError); if (!__pyx_builtin_ImportError) __PYX_ERR(0, 3968, __pyx_L1_error)
  return 0;
  __pyx_L1_error:;
  return -1;
}

static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);

  /* "validator.pyx":235
 *     if isinstance(scores, list):
 *         if not accept_multi_output:
 *             raise ValueError("Multi-output scores provided but not accepted.")             # <<<<<<<<<<<<<<
 *         if true_labels is not None and len(scores) != len(true_labels):
 *             raise ValueError("Mismatch in the number of outputs between"
 */
  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_u_Multi_output_scores_provided_but); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 235, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple_);
  __Pyx_GIVEREF(__pyx_tuple_);

  /* "validator.pyx":237
 *             raise ValueError("Multi-output scores provided but not accepted.")
 *         if true_labels is not None and len(scores) != len(true_labels):
 *             raise ValueError("Mismatch in the number of outputs between"             # <<<<<<<<<<<<<<
 *                              " scores and true_labels.")
 *         if any(not _is_probability_distribution(
 */
  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_u_Mismatch_in_the_number_of_output); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(0, 237, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__2);
  __Pyx_GIVEREF(__pyx_tuple__2);

  /* "validator.pyx":241
 *         if any(not _is_probability_distribution(
 *                 score, mode=mode) for score in scores):
 *             raise ValueError("Each set of scores must be a valid"             # <<<<<<<<<<<<<<
 *                              " probability distribution.")
 *     else:
 */
  __pyx_tuple__3 = PyTuple_Pack(1, __pyx_kp_u_Each_set_of_scores_must_be_a_val); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 241, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__3);
  __Pyx_GIVEREF(__pyx_tuple__3);

  /* "validator.pyx":245
 *     else:
 *         if not _is_probability_distribution(scores, mode=mode):
 *             raise ValueError("Scores must be a valid probability distribution.")             # <<<<<<<<<<<<<<
 *         if true_labels is not None:
 *             if accept_multi_output and not isinstance(true_labels, list):
 */
  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_kp_u_Scores_must_be_a_valid_probabili); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(0, 245, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__4);
  __Pyx_GIVEREF(__pyx_tuple__4);

  /* "validator.pyx":248
 *         if true_labels is not None:
 *             if accept_multi_output and not isinstance(true_labels, list):
 *                 raise ValueError("Expected multi-output for true_labels"             # <<<<<<<<<<<<<<
 *                                  " but got a single output.")
 *             if not accept_multi_output and isinstance(true_labels, list):
 */
  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_kp_u_Expected_multi_output_for_true_l); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(0, 248, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__5);
  __Pyx_GIVEREF(__pyx_tuple__5);

  /* "validator.pyx":251
 *                                  " but got a single output.")
 *             if not accept_multi_output and isinstance(true_labels, list):
 *                 raise ValueError("Non-multi-output scores with multi-output"             # <<<<<<<<<<<<<<
 *                                  " true_labels.")
 *     # Return scores as numpy array
 */
  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_u_Non_multi_output_scores_with_mul); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(0, 251, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__6);
  __Pyx_GIVEREF(__pyx_tuple__6);

  /* "validator.pyx":419
 * 
 *     if data_type not in ['array', 'dataframe']:
 *         raise ValueError("data_type must be either 'array' or 'dataframe'")             # <<<<<<<<<<<<<<
 * 
 *     # Check if the data is a square matrix
 */
  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_u_data_type_must_be_either_array_o); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(0, 419, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__8);
  __Pyx_GIVEREF(__pyx_tuple__8);

  /* "validator.pyx":485
 *     # Ensure the array is one-dimensional if multi-output is not accepted
 *     if not accept_multioutput and y.ndim > 1:
 *         raise ValueError("Target array must be one-dimensional unless"             # <<<<<<<<<<<<<<
 *                          " multi-output is accepted.")
 * 
 */
  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_u_Target_array_must_be_one_dimensi); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(0, 485, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__9);
  __Pyx_GIVEREF(__pyx_tuple__9);

  /* "validator.pyx":490
 *     # Validate that all elements are non-negative integers
 *     if not (np.issubdtype(y_eval.dtype, np.integer) and np.all(y_eval >= 0)):
 *         raise ValueError("All elements in the target array must be non-negative integers.")             # <<<<<<<<<<<<<<
 * 
 *     # Flatten the array for unique class check if multi-output is accepted
 */
  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_u_All_elements_in_the_target_array); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(0, 490, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__10);
  __Pyx_GIVEREF(__pyx_tuple__10);

  /* "validator.pyx":499
 *     unique_classes = np.unique(y_eval)
 *     if unique_classes.size < 2:
 *         raise ValueError("Target array must contain at least two distinct classes.")             # <<<<<<<<<<<<<<
 * 
 *     # Return the original array and the number of unique classes if requested
 */
  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_kp_u_Target_array_must_contain_at_lea); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(0, 499, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__11);
  __Pyx_GIVEREF(__pyx_tuple__11);

  /* "validator.pyx":562
 *     # Check if weights are one-dimensional
 *     if weights.ndim != 1:
 *         raise ValueError("Sample weights must be one-dimensional.")             # <<<<<<<<<<<<<<
 * 
 *     # Check if any weights are negative
 */
  __pyx_tuple__12 = PyTuple_Pack(1, __pyx_kp_u_Sample_weights_must_be_one_dimen); if (unlikely(!__pyx_tuple__12)) __PYX_ERR(0, 562, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__12);
  __Pyx_GIVEREF(__pyx_tuple__12);

  /* "validator.pyx":566
 *     # Check if any weights are negative
 *     if np.any(weights < 0):
 *         raise ValueError("Sample weights must be non-negative.")             # <<<<<<<<<<<<<<
 * 
 *     # Check if the length of weights matches the length of y
 */
  __pyx_tuple__13 = PyTuple_Pack(1, __pyx_kp_u_Sample_weights_must_be_non_negat); if (unlikely(!__pyx_tuple__13)) __PYX_ERR(0, 566, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__13);
  __Pyx_GIVEREF(__pyx_tuple__13);

  /* "validator.pyx":570
 *     # Check if the length of weights matches the length of y
 *     if weights.size != y.size:
 *         raise ValueError("Length of sample weights must match length of y.")             # <<<<<<<<<<<<<<
 * 
 *     weights = normalize_array(weights, normalize=normalize, method="sum")
 */
  __pyx_tuple__14 = PyTuple_Pack(1, __pyx_kp_u_Length_of_sample_weights_must_ma); if (unlikely(!__pyx_tuple__14)) __PYX_ERR(0, 570, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__14);
  __Pyx_GIVEREF(__pyx_tuple__14);

  /* "validator.pyx":632
 *         weights_array = np.asarray(weights, dtype=float)
 *     except Exception as e:
 *         raise ValueError("Weights must be provided in a format that can be"             # <<<<<<<<<<<<<<
 *                          " converted to a numpy array.") from e
 * 
 */
  __pyx_tuple__15 = PyTuple_Pack(1, __pyx_kp_u_Weights_must_be_provided_in_a_fo); if (unlikely(!__pyx_tuple__15)) __PYX_ERR(0, 632, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__15);
  __Pyx_GIVEREF(__pyx_tuple__15);

  /* "validator.pyx":643
 *     if min_value is None:
 *         if np.any(weights_array < 0):
 *             raise ValueError("Weights must be non-negative unless 'min_value'"             # <<<<<<<<<<<<<<
 *                              " is explicitly set to allow negative values.")
 *         min_value=0.
 */
  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_u_Weights_must_be_non_negative_unl); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(0, 643, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__17);
  __Pyx_GIVEREF(__pyx_tuple__17);

  /* "validator.pyx":653
 *     if normalize:
 *         if np.sum(weights_array) == 0:
 *             raise ValueError("Cannot normalize weights because their sum is zero.")             # <<<<<<<<<<<<<<
 * 
 *         if not is_normalized(weights_array, method ='sum'):
 */
  __pyx_tuple__19 = PyTuple_Pack(1, __pyx_kp_u_Cannot_normalize_weights_because); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(0, 653, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__19);
  __Pyx_GIVEREF(__pyx_tuple__19);

  /* "validator.pyx":696
 *     """
 *     arr = np.asarray(arr, dtype=float)
 *     method =parameter_validator(             # <<<<<<<<<<<<<<
 *         "method", target_strs={"01", "zscore", "sum"}) ( method)
 * 
 */
  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_n_u_method); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(0, 696, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__20);
  __Pyx_GIVEREF(__pyx_tuple__20);

  /* "validator.pyx":770
 *     is_normed = is_normalized(arr, method=method)
 * 
 *     normalize = parameter_validator(             # <<<<<<<<<<<<<<
 *         "normalize", target_strs={True, False, "auto"})( normalize)
 * 
 */
  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_n_u_normalize); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(0, 770, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__21);
  __Pyx_GIVEREF(__pyx_tuple__21);

  /* "validator.pyx":781
 *             max_val = np.max(arr)
 *             if min_val == max_val:
 *                 raise ValueError("Normalization impossible with zero variance.")             # <<<<<<<<<<<<<<
 *             arr = (arr - min_val) / (max_val - min_val)
 *         elif method == 'zscore':
 */
  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_u_Normalization_impossible_with_ze); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(0, 781, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__22);
  __Pyx_GIVEREF(__pyx_tuple__22);

  /* "validator.pyx":787
 *             std = np.std(arr)
 *             if std == 0:
 *                 raise ValueError("Standardization impossible with zero variance.")             # <<<<<<<<<<<<<<
 *             arr = (arr - mean) / std
 *         elif method == 'sum':
 */
  __pyx_tuple__23 = PyTuple_Pack(1, __pyx_kp_u_Standardization_impossible_with); if (unlikely(!__pyx_tuple__23)) __PYX_ERR(0, 787, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__23);
  __Pyx_GIVEREF(__pyx_tuple__23);

  /* "validator.pyx":792
 *             total = np.sum(arr)
 *             if total == 0:
 *                 raise ValueError("Normalization by sum impossible with zero sum.")             # <<<<<<<<<<<<<<
 *             arr = arr / total
 * 
 */
  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_kp_u_Normalization_by_sum_impossible); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(0, 792, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__24);
  __Pyx_GIVEREF(__pyx_tuple__24);

  /* "validator.pyx":838
 *     if y.ndim == 1:
 *         # If the array is 1D and multioutput is expected, treat it as a single column
 *         y = y.reshape(-1, 1)             # <<<<<<<<<<<<<<
 * 
 *     if y.ndim > 1:
 */
  __pyx_tuple__25 = PyTuple_Pack(2, __pyx_int_neg_1, __pyx_int_1); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(0, 838, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__25);
  __Pyx_GIVEREF(__pyx_tuple__25);

  /* "validator.pyx":905
 *     """
 *     y_true_processed = np.asarray(y_true, dtype=float)
 *     zero_division = parameter_validator(             # <<<<<<<<<<<<<<
 *         "zero_division", target_strs=["warn", "raise", "ignore"]) (
 *             zero_division)
 */
  __pyx_tuple__26 = PyTuple_Pack(1, __pyx_n_u_zero_division); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(0, 905, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__26);
  __Pyx_GIVEREF(__pyx_tuple__26);

  /* "validator.pyx":972
 *     # Check if DataFrame is square
 *     if df.shape[0] != df.shape[1]:
 *         raise ValueError("DataFrame must be square (equal number of rows and columns).")             # <<<<<<<<<<<<<<
 * 
 *     # Check if indices and columns match
 */
  __pyx_tuple__27 = PyTuple_Pack(1, __pyx_kp_u_DataFrame_must_be_square_equal_n); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(0, 972, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__27);
  __Pyx_GIVEREF(__pyx_tuple__27);

  /* "validator.pyx":987
 *                 df.columns = df.index
 *             else:
 *                 raise ValueError(             # <<<<<<<<<<<<<<
 *                     "Automatic alignment failed. Index and column names do not match "
 *                     "and are of the same type. Please specify alignment explicitly."
 */
  __pyx_tuple__28 = PyTuple_Pack(1, __pyx_kp_u_Automatic_alignment_failed_Index); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(0, 987, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__28);
  __Pyx_GIVEREF(__pyx_tuple__28);

  /* "validator.pyx":992
 *                 )
 *         else:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "Invalid alignment option provided. Please choose from 'index_to_columns', "
 *                 "'columns_to_index', or 'auto'."
 */
  __pyx_tuple__29 = PyTuple_Pack(1, __pyx_kp_u_Invalid_alignment_option_provide); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(0, 992, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__29);
  __Pyx_GIVEREF(__pyx_tuple__29);

  /* "validator.pyx":1101
 *         if not is_numeric.all():
 *             if error == 'raise':
 *                 raise TypeError(             # <<<<<<<<<<<<<<
 *                     "Mixed types detected. Please encode categorical variables first.")
 *             elif error == 'warn':
 */
  __pyx_tuple__30 = PyTuple_Pack(1, __pyx_kp_u_Mixed_types_detected_Please_enco); if (unlikely(!__pyx_tuple__30)) __PYX_ERR(0, 1101, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__30);
  __Pyx_GIVEREF(__pyx_tuple__30);

  /* "validator.pyx":1115
 *         if not is_categoric.all():
 *             if error == 'raise':
 *                 raise TypeError("Mixed types detected with unexpected numeric data.")             # <<<<<<<<<<<<<<
 *             elif error == 'warn':
 *                 warnings.warn("Expected categoric types but found numeric data.")
 */
  __pyx_tuple__31 = PyTuple_Pack(1, __pyx_kp_u_Mixed_types_detected_with_unexpe); if (unlikely(!__pyx_tuple__31)) __PYX_ERR(0, 1115, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__31);
  __Pyx_GIVEREF(__pyx_tuple__31);

  /* "validator.pyx":1079
 *     on can prevent issues in model training and evaluation.
 *     """
 *     expected_type= parameter_validator(             # <<<<<<<<<<<<<<
 *         "expected_type", target_strs={"numeric", "categoric", "both"},
 *         )(expected_type)
 */
  __pyx_tuple__32 = PyTuple_Pack(1, __pyx_n_u_expected_type); if (unlikely(!__pyx_tuple__32)) __PYX_ERR(0, 1079, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__32);
  __Pyx_GIVEREF(__pyx_tuple__32);

  /* "validator.pyx":1093
 *     nan_policy= is_valid_policies(nan_policy)
 *     if nan_policy == 'raise' and data.isnull().any().any():
 *         raise ValueError("NaN values found in the data.")             # <<<<<<<<<<<<<<
 *     elif nan_policy == 'propagate' and data.isnull().any().any():
 *         warnings.warn("NaN values found in the data, but processing will continue.")
 */
  __pyx_tuple__33 = PyTuple_Pack(1, __pyx_kp_u_NaN_values_found_in_the_data); if (unlikely(!__pyx_tuple__33)) __PYX_ERR(0, 1093, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__33);
  __Pyx_GIVEREF(__pyx_tuple__33);

  /* "validator.pyx":1097
 *         warnings.warn("NaN values found in the data, but processing will continue.")
 * 
 *     def _handle_numeric(data, return_data):             # <<<<<<<<<<<<<<
 *         is_numeric = pd.to_numeric(data, errors='coerce').notna()
 *         if not is_numeric.all():
 */
  __pyx_tuple__34 = PyTuple_Pack(3, __pyx_n_s_data, __pyx_n_s_return_data, __pyx_n_s_is_numeric); if (unlikely(!__pyx_tuple__34)) __PYX_ERR(0, 1097, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__34);
  __Pyx_GIVEREF(__pyx_tuple__34);
  __pyx_codeobj__35 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__34, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_handle_numeric, 1097, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__35)) __PYX_ERR(0, 1097, __pyx_L1_error)

  /* "validator.pyx":1111
 *         return data[is_numeric] if return_data else None
 * 
 *     def _handle_categoric(data, return_data):             # <<<<<<<<<<<<<<
 *         is_categoric = data.apply(lambda x: isinstance(x, (str, pd.CategoricalDtype)))
 *         if not is_categoric.all():
 */
  __pyx_tuple__36 = PyTuple_Pack(3, __pyx_n_s_data, __pyx_n_s_return_data, __pyx_n_s_is_categoric); if (unlikely(!__pyx_tuple__36)) __PYX_ERR(0, 1111, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__36);
  __Pyx_GIVEREF(__pyx_tuple__36);
  __pyx_codeobj__37 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__36, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_handle_categoric, 1111, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__37)) __PYX_ERR(0, 1111, __pyx_L1_error)

  /* "validator.pyx":1136
 *             result = col_data if return_data else None
 *         else:
 *             raise ValueError("Unsupported expected_type provided. Choose"             # <<<<<<<<<<<<<<
 *                              " 'numeric', 'categoric', or 'both'.")
 * 
 */
  __pyx_tuple__38 = PyTuple_Pack(1, __pyx_kp_u_Unsupported_expected_type_provid); if (unlikely(!__pyx_tuple__38)) __PYX_ERR(0, 1136, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__38);
  __Pyx_GIVEREF(__pyx_tuple__38);

  /* "validator.pyx":1185
 *     """
 *     # Check for allowed output_format values
 *     output_format= parameter_validator(             # <<<<<<<<<<<<<<
 *         "output_format", target_strs=["auto", "array", "frame"]
 *         ) (output_format)
 */
  __pyx_tuple__39 = PyTuple_Pack(1, __pyx_n_u_output_format); if (unlikely(!__pyx_tuple__39)) __PYX_ERR(0, 1185, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__39);
  __Pyx_GIVEREF(__pyx_tuple__39);

  /* "validator.pyx":1195
 *     if isinstance(X, np.ndarray):
 *         if X.ndim == 1:
 *             X = X[:, np.newaxis]             # <<<<<<<<<<<<<<
 *     elif isinstance(X, pd.DataFrame):
 *         if X.shape[1] == 0:  # Implies an empty DataFrame or misshapen
 */
  __pyx_slice__40 = PySlice_New(Py_None, Py_None, Py_None); if (unlikely(!__pyx_slice__40)) __PYX_ERR(0, 1195, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_slice__40);
  __Pyx_GIVEREF(__pyx_slice__40);

  /* "validator.pyx":1339
 *     from .coreutils import normalize_string
 * 
 *     def validator(param_value):             # <<<<<<<<<<<<<<
 *         """Validate param value from :func:`~normalize_string`"""
 *         if param_value:
 */
  __pyx_tuple__41 = PyTuple_Pack(1, __pyx_n_s_param_value); if (unlikely(!__pyx_tuple__41)) __PYX_ERR(0, 1339, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__41);
  __Pyx_GIVEREF(__pyx_tuple__41);
  __pyx_codeobj__42 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__41, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validator, 1339, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__42)) __PYX_ERR(0, 1339, __pyx_L1_error)

  /* "validator.pyx":1390
 *         distributed_elements = int (elements)
 *     else:
 *         raise ValueError("'elements' must be an integer or a list of strings.")             # <<<<<<<<<<<<<<
 * 
 *     if str(distribution).lower() == 'auto':
 */
  __pyx_tuple__43 = PyTuple_Pack(1, __pyx_kp_u_elements_must_be_an_integer_or); if (unlikely(!__pyx_tuple__43)) __PYX_ERR(0, 1390, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__43);
  __Pyx_GIVEREF(__pyx_tuple__43);

  /* "validator.pyx":1394
 *     if str(distribution).lower() == 'auto':
 *         if distributed_elements is None:
 *             raise ValueError("'distributed_elements' must be specified when"             # <<<<<<<<<<<<<<
 *                              " using 'auto' distribution.")
 *         # Generate a random distribution
 */
  __pyx_tuple__44 = PyTuple_Pack(1, __pyx_kp_u_distributed_elements_must_be_sp); if (unlikely(!__pyx_tuple__44)) __PYX_ERR(0, 1394, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__44);
  __Pyx_GIVEREF(__pyx_tuple__44);

  /* "validator.pyx":1402
 *         if not hasattr(distribution, '__iter__') or isinstance(distribution, str):
 *             # If distribution is not iterable (or a single string), raise an error
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "distribution must be 'auto', a tuple, or a list of distributions")
 * 
 */
  __pyx_tuple__45 = PyTuple_Pack(1, __pyx_kp_u_distribution_must_be_auto_a_tupl); if (unlikely(!__pyx_tuple__45)) __PYX_ERR(0, 1402, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__45);
  __Pyx_GIVEREF(__pyx_tuple__45);

  /* "validator.pyx":1414
 *         for value in distribution:
 *             if not isinstance(value, (int, float)):
 *                 raise ValueError("All distribution values must be numeric")             # <<<<<<<<<<<<<<
 *             validated_distribution.append(float(value))
 * 
 */
  __pyx_tuple__46 = PyTuple_Pack(1, __pyx_kp_u_All_distribution_values_must_be); if (unlikely(!__pyx_tuple__46)) __PYX_ERR(0, 1414, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__46);
  __Pyx_GIVEREF(__pyx_tuple__46);

  /* "validator.pyx":1418
 * 
 *         if not np.isclose(sum(validated_distribution), 1):
 *             raise ValueError("The sum of the distribution values must be equal to 1")             # <<<<<<<<<<<<<<
 * 
 *         distribution = tuple(validated_distribution)
 */
  __pyx_tuple__47 = PyTuple_Pack(1, __pyx_kp_u_The_sum_of_the_distribution_valu); if (unlikely(!__pyx_tuple__47)) __PYX_ERR(0, 1418, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__47);
  __Pyx_GIVEREF(__pyx_tuple__47);

  /* "validator.pyx":1532
 * 
 *     # Function to check if an item is a nested type
 *     def is_nested(item):             # <<<<<<<<<<<<<<
 *         return isinstance(item, allowed_types)
 * 
 */
  __pyx_tuple__48 = PyTuple_Pack(1, __pyx_n_s_item); if (unlikely(!__pyx_tuple__48)) __PYX_ERR(0, 1532, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__48);
  __Pyx_GIVEREF(__pyx_tuple__48);
  __pyx_codeobj__49 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__48, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_is_nested, 1532, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__49)) __PYX_ERR(0, 1532, __pyx_L1_error)

  /* "validator.pyx":1621
 *         if any(np.isnan(array).any() for array in arrays) or (
 *                 sample_weights is not None and np.isnan(sample_weights).any()):
 *             raise ValueError("Input values contain NaNs and nan_policy is 'raise'.")             # <<<<<<<<<<<<<<
 * 
 *     # Return adjusted arrays and sample_weights
 */
  __pyx_tuple__50 = PyTuple_Pack(1, __pyx_kp_u_Input_values_contain_NaNs_and_na); if (unlikely(!__pyx_tuple__50)) __PYX_ERR(0, 1621, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__50);
  __Pyx_GIVEREF(__pyx_tuple__50);

  /* "validator.pyx":1692
 * 
 *         if not np.all(sample_weight >= 0):
 *             raise ValueError("Sample weights must be non-negative")             # <<<<<<<<<<<<<<
 * 
 *     if weighted_y:
 */
  __pyx_tuple__51 = PyTuple_Pack(1, __pyx_kp_u_Sample_weights_must_be_non_negat_2); if (unlikely(!__pyx_tuple__51)) __PYX_ERR(0, 1692, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__51);
  __Pyx_GIVEREF(__pyx_tuple__51);

  /* "validator.pyx":2154
 * 
 *     if verbose:
 *         print("Targets are suitable for classification.")             # <<<<<<<<<<<<<<
 * 
 *     return validated_targets
 */
  __pyx_tuple__55 = PyTuple_Pack(1, __pyx_kp_u_Targets_are_suitable_for_classif); if (unlikely(!__pyx_tuple__55)) __PYX_ERR(0, 2154, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__55);
  __Pyx_GIVEREF(__pyx_tuple__55);

  /* "validator.pyx":2178
 *         numeric_y = y.astype(float, casting='safe')  # Safely cast numeric types to float
 *         if not np.all(np.isfinite(numeric_y)):
 *             raise ValueError("Numeric target values contain NaN or infinite numbers,"             # <<<<<<<<<<<<<<
 *                              " not suitable for classification.")
 *     else:
 */
  __pyx_tuple__56 = PyTuple_Pack(1, __pyx_kp_u_Numeric_target_values_contain_Na); if (unlikely(!__pyx_tuple__56)) __PYX_ERR(0, 2178, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__56);
  __Pyx_GIVEREF(__pyx_tuple__56);

  /* "validator.pyx":2183
 *         # For non-numeric data, ensure no elements are None or equivalent to np.nan
 *         if any(el is None or el is np.nan for el in y):
 *             raise ValueError("Non-numeric target values contain None or NaN,"             # <<<<<<<<<<<<<<
 *                              " not suitable for classification.")
 *     unique_values = np.unique(y)
 */
  __pyx_tuple__57 = PyTuple_Pack(1, __pyx_kp_u_Non_numeric_target_values_contai); if (unlikely(!__pyx_tuple__57)) __PYX_ERR(0, 2183, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__57);
  __Pyx_GIVEREF(__pyx_tuple__57);

  /* "validator.pyx":2191
 *         target_type = type_of_target(y)
 *         if target_type == 'continuous':
 *             raise ValueError("Continuous data not suitable for classification"             # <<<<<<<<<<<<<<
 *                              " without explicit binning.")
 *         elif target_type == "multilabel-indicator":
 */
  __pyx_tuple__58 = PyTuple_Pack(1, __pyx_kp_u_Continuous_data_not_suitable_for); if (unlikely(!__pyx_tuple__58)) __PYX_ERR(0, 2191, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__58);
  __Pyx_GIVEREF(__pyx_tuple__58);

  /* "validator.pyx":2194
 *                              " without explicit binning.")
 *         elif target_type == "multilabel-indicator":
 *             raise ValueError("Multilabel-indicator format detected,"             # <<<<<<<<<<<<<<
 *                              " requiring different handling.")
 *         elif target_type == 'unknown':
 */
  __pyx_tuple__59 = PyTuple_Pack(1, __pyx_kp_u_Multilabel_indicator_format_dete); if (unlikely(!__pyx_tuple__59)) __PYX_ERR(0, 2194, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__59);
  __Pyx_GIVEREF(__pyx_tuple__59);

  /* "validator.pyx":2197
 *                              " requiring different handling.")
 *         elif target_type == 'unknown':
 *             raise ValueError("Unable to determine the target type,"             # <<<<<<<<<<<<<<
 *                              " please check the input data.")
 *     else:
 */
  __pyx_tuple__60 = PyTuple_Pack(1, __pyx_kp_u_Unable_to_determine_the_target_t); if (unlikely(!__pyx_tuple__60)) __PYX_ERR(0, 2197, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__60);
  __Pyx_GIVEREF(__pyx_tuple__60);

  /* "validator.pyx":2202
 *         # Auto detection based on unique values count
 *         if unique_values.shape[0] > np.sqrt(len(y)):
 *             raise ValueError("Automatic strategy detected too many unique values"             # <<<<<<<<<<<<<<
 *                              " for a classification task.")
 * 
 */
  __pyx_tuple__61 = PyTuple_Pack(1, __pyx_kp_u_Automatic_strategy_detected_too); if (unlikely(!__pyx_tuple__61)) __PYX_ERR(0, 2202, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__61);
  __Pyx_GIVEREF(__pyx_tuple__61);

  /* "validator.pyx":2208
 *     if y.dtype.kind not in numeric_types:
 *         if not all(isinstance(val, (str, bool, int)) for val in unique_values):
 *             raise ValueError("Target values must be categorical, numeric,"             # <<<<<<<<<<<<<<
 *                              " or convertible to categories.")
 * 
 */
  __pyx_tuple__62 = PyTuple_Pack(1, __pyx_kp_u_Target_values_must_be_categorica); if (unlikely(!__pyx_tuple__62)) __PYX_ERR(0, 2208, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__62);
  __Pyx_GIVEREF(__pyx_tuple__62);

  /* "validator.pyx":2438
 *             return datetime(int(year_input), 1, 1)
 *         elif isinstance(year_input, str):
 *             year_input = year_input.replace("/", "-")             # <<<<<<<<<<<<<<
 *             try:
 *                 return  datetime.strptime(year_input, date_format)
 */
  __pyx_tuple__65 = PyTuple_Pack(2, __pyx_kp_u__63, __pyx_kp_u__64); if (unlikely(!__pyx_tuple__65)) __PYX_ERR(0, 2438, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__65);
  __Pyx_GIVEREF(__pyx_tuple__65);

  /* "validator.pyx":2451
 *                         ) from type_err
 *                 except ValueError as value_err :
 *                     raise ValueError (             # <<<<<<<<<<<<<<
 *                         "Check your date data. For datetime value, set `date_format`"
 *                         " to '%Y-%m-%d %H:%M:%S'") from value_err
 */
  __pyx_tuple__66 = PyTuple_Pack(1, __pyx_kp_u_Check_your_date_data_For_datetim); if (unlikely(!__pyx_tuple__66)) __PYX_ERR(0, 2451, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__66);
  __Pyx_GIVEREF(__pyx_tuple__66);

  /* "validator.pyx":2434
 *     customization of the output format for date strings.
 *     """
 *     def parse_year_input(year_input):             # <<<<<<<<<<<<<<
 *         if isinstance(year_input, (int, float)):
 *             return datetime(int(year_input), 1, 1)
 */
  __pyx_tuple__67 = PyTuple_Pack(3, __pyx_n_s_year_input, __pyx_n_s_type_err, __pyx_n_s_value_err); if (unlikely(!__pyx_tuple__67)) __PYX_ERR(0, 2434, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__67);
  __Pyx_GIVEREF(__pyx_tuple__67);
  __pyx_codeobj__68 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__67, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_parse_year_input, 2434, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__68)) __PYX_ERR(0, 2434, __pyx_L1_error)

  /* "validator.pyx":2460
 * 
 *     if start_date >= end_date:
 *         raise ValueError("Start date/time must be earlier than end date/time.")             # <<<<<<<<<<<<<<
 * 
 *     if return_as_date_str:
 */
  __pyx_tuple__69 = PyTuple_Pack(1, __pyx_kp_u_Start_date_time_must_be_earlier); if (unlikely(!__pyx_tuple__69)) __PYX_ERR(0, 2460, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__69);
  __Pyx_GIVEREF(__pyx_tuple__69);

  /* "validator.pyx":2477
 *         and not return_as_date_str
 *         ):
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             "Start and end dates are within the same year but not the same date. "
 *             "Consider using return_as_date_str=True or providing specific dates.")
 */
  __pyx_tuple__70 = PyTuple_Pack(1, __pyx_kp_u_Start_and_end_dates_are_within_t); if (unlikely(!__pyx_tuple__70)) __PYX_ERR(0, 2477, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__70);
  __Pyx_GIVEREF(__pyx_tuple__70);

  /* "validator.pyx":2646
 *     c           float64
 *     """
 *     return_as_numpy= parameter_validator(             # <<<<<<<<<<<<<<
 *         "return_as_numpy", target_strs={"auto", True, False})(return_as_numpy)
 *     is_frame = True
 */
  __pyx_tuple__71 = PyTuple_Pack(1, __pyx_n_u_return_as_numpy); if (unlikely(!__pyx_tuple__71)) __PYX_ERR(0, 2646, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__71);
  __Pyx_GIVEREF(__pyx_tuple__71);

  /* "validator.pyx":2655
 *                 column_prefix + str(i) for i in range(len(data))])
 *         except Exception as e:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "Failed to construct a DataFrame from the provided data. "
 *                 "Ensure that your input data is structured correctly, such as "
 */
  __pyx_tuple__72 = PyTuple_Pack(1, __pyx_kp_u_Failed_to_construct_a_DataFrame); if (unlikely(!__pyx_tuple__72)) __PYX_ERR(0, 2655, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__72);
  __Pyx_GIVEREF(__pyx_tuple__72);

  /* "validator.pyx":2747
 *     if not is_keras_model(model):
 *         if raise_exception:
 *             raise TypeError("Provided object is not a Keras model.")             # <<<<<<<<<<<<<<
 *         return False
 * 
 */
  __pyx_tuple__73 = PyTuple_Pack(1, __pyx_kp_u_Provided_object_is_not_a_Keras_m); if (unlikely(!__pyx_tuple__73)) __PYX_ERR(0, 2747, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__73);
  __Pyx_GIVEREF(__pyx_tuple__73);

  /* "validator.pyx":2753
 *             model, ['fit', 'predict', 'compile', 'summary']):
 *         if raise_exception:
 *             raise TypeError("Model does not support essential Keras functionalities.")             # <<<<<<<<<<<<<<
 *         return False
 * 
 */
  __pyx_tuple__74 = PyTuple_Pack(1, __pyx_kp_u_Model_does_not_support_essential); if (unlikely(!__pyx_tuple__74)) __PYX_ERR(0, 2753, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__74);
  __Pyx_GIVEREF(__pyx_tuple__74);

  /* "validator.pyx":2831
 *         intervals = pd.to_datetime(data[time_col]).diff().dropna()
 *         if not intervals.nunique() == 1:
 *             print("Time intervals are not regular.")             # <<<<<<<<<<<<<<
 *             return False
 * 
 */
  __pyx_tuple__75 = PyTuple_Pack(1, __pyx_kp_u_Time_intervals_are_not_regular); if (unlikely(!__pyx_tuple__75)) __PYX_ERR(0, 2831, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__75);
  __Pyx_GIVEREF(__pyx_tuple__75);

  /* "validator.pyx":2975
 *             ( isinstance (x, str) or isinstance (y, str))
 *             and data is None) :
 *         raise TypeError("Data cannot be None when x and y have string"             # <<<<<<<<<<<<<<
 *                         " arguments.")
 *     if  (
 */
  __pyx_tuple__76 = PyTuple_Pack(1, __pyx_kp_u_Data_cannot_be_None_when_x_and_y); if (unlikely(!__pyx_tuple__76)) __PYX_ERR(0, 2975, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__76);
  __Pyx_GIVEREF(__pyx_tuple__76);

  /* "validator.pyx":2980
 *             (x is None or y is None)
 *             and data is None):
 *         raise TypeError ( "Missing x and y. NoneType not supported.")             # <<<<<<<<<<<<<<
 * 
 *     if isinstance (x, str):
 */
  __pyx_tuple__77 = PyTuple_Pack(1, __pyx_kp_u_Missing_x_and_y_NoneType_not_sup); if (unlikely(!__pyx_tuple__77)) __PYX_ERR(0, 2980, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__77);
  __Pyx_GIVEREF(__pyx_tuple__77);

  /* "validator.pyx":3001
 *                 or not _is_numeric_dtype(y, to_array=True )
 *                 ):
 *             raise ValueError ("x and y must be a numeric array.")             # <<<<<<<<<<<<<<
 * 
 *         x = x.astype (np.float64)
 */
  __pyx_tuple__78 = PyTuple_Pack(1, __pyx_kp_u_x_and_y_must_be_a_numeric_array); if (unlikely(!__pyx_tuple__78)) __PYX_ERR(0, 3001, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__78);
  __Pyx_GIVEREF(__pyx_tuple__78);

  /* "validator.pyx":3119
 *     if isinstance(value, np.ndarray):
 *         if value.size != 1:
 *             raise ValueError("Numpy array must contain exactly one element.")             # <<<<<<<<<<<<<<
 *         value = value.item()
 * 
 */
  __pyx_tuple__79 = PyTuple_Pack(1, __pyx_kp_u_Numpy_array_must_contain_exactly); if (unlikely(!__pyx_tuple__79)) __PYX_ERR(0, 3119, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__79);
  __Pyx_GIVEREF(__pyx_tuple__79);

  /* "validator.pyx":3190
 *                              " a one-dimensional array-like structure.")
 *         else:
 *             raise ValueError("Expected both 'x' and 'y' to be one-dimensional "             # <<<<<<<<<<<<<<
 *                              "array-like structures.")
 * 
 */
  __pyx_tuple__80 = PyTuple_Pack(1, __pyx_kp_u_Expected_both_x_and_y_to_be_one); if (unlikely(!__pyx_tuple__80)) __PYX_ERR(0, 3190, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__80);
  __Pyx_GIVEREF(__pyx_tuple__80);

  /* "validator.pyx":3372
 * 
 *         @wraps(f)
 *         def inner_f(*args, **kwargs):             # <<<<<<<<<<<<<<
 *             extra_args = len(args) - len(all_args)
 *             if extra_args <= 0:
 */
  __pyx_tuple__84 = PyTuple_Pack(6, __pyx_n_s_args, __pyx_n_s_kwargs, __pyx_n_s_extra_args, __pyx_n_s_args_msg, __pyx_n_s_name_2, __pyx_n_s_arg); if (unlikely(!__pyx_tuple__84)) __PYX_ERR(0, 3372, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__84);
  __Pyx_GIVEREF(__pyx_tuple__84);
  __pyx_codeobj__85 = (PyObject*)__Pyx_PyCode_New(0, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARARGS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__84, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_inner_f, 3372, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__85)) __PYX_ERR(0, 3372, __pyx_L1_error)

  /* "validator.pyx":3360
 *     """
 * 
 *     def _inner_deprecate_positional_args(f):             # <<<<<<<<<<<<<<
 *         sig = signature(f)
 *         kwonly_args = []
 */
  __pyx_tuple__86 = PyTuple_Pack(8, __pyx_n_s_f, __pyx_n_s_sig, __pyx_n_s_kwonly_args, __pyx_n_s_all_args, __pyx_n_s_name_2, __pyx_n_s_param, __pyx_n_s_inner_f, __pyx_n_s_inner_f); if (unlikely(!__pyx_tuple__86)) __PYX_ERR(0, 3360, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__86);
  __Pyx_GIVEREF(__pyx_tuple__86);
  __pyx_codeobj__87 = (PyObject*)__Pyx_PyCode_New(1, 0, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__86, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_inner_deprecate_positional_args, 3360, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__87)) __PYX_ERR(0, 3360, __pyx_L1_error)

  /* "validator.pyx":3658
 *     if not symmetric:
 *         if raise_exception:
 *             raise ValueError("Array must be symmetric")             # <<<<<<<<<<<<<<
 *         if raise_warning:
 *             warnings.warn(
 */
  __pyx_tuple__88 = PyTuple_Pack(1, __pyx_kp_u_Array_must_be_symmetric); if (unlikely(!__pyx_tuple__88)) __PYX_ERR(0, 3658, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__88);
  __Pyx_GIVEREF(__pyx_tuple__88);

  /* "validator.pyx":3660
 *             raise ValueError("Array must be symmetric")
 *         if raise_warning:
 *             warnings.warn(             # <<<<<<<<<<<<<<
 *                 "Array is not symmetric, and will be converted "
 *                 "to symmetric by average with its transpose.",
 */
  __pyx_tuple__89 = PyTuple_Pack(1, __pyx_kp_u_Array_is_not_symmetric_and_will); if (unlikely(!__pyx_tuple__89)) __PYX_ERR(0, 3660, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__89);
  __Pyx_GIVEREF(__pyx_tuple__89);

  /* "validator.pyx":3721
 *     """
 * 
 *     def type_name(t):             # <<<<<<<<<<<<<<
 *         """Convert type into humman readable string."""
 *         module = t.__module__
 */
  __pyx_tuple__90 = PyTuple_Pack(3, __pyx_n_s_t, __pyx_n_s_module_2, __pyx_n_s_qualname_2); if (unlikely(!__pyx_tuple__90)) __PYX_ERR(0, 3721, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__90);
  __Pyx_GIVEREF(__pyx_tuple__90);
  __pyx_codeobj__91 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__90, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_type_name, 3721, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__91)) __PYX_ERR(0, 3721, __pyx_L1_error)

  /* "validator.pyx":3745
 *         )
 * 
 *     expected_include_boundaries = ("left", "right", "both", "neither")             # <<<<<<<<<<<<<<
 *     if include_boundaries not in expected_include_boundaries:
 *         raise ValueError(
 */
  __pyx_tuple__94 = PyTuple_Pack(4, __pyx_n_u_left, __pyx_n_u_right, __pyx_n_u_both, __pyx_n_u_neither); if (unlikely(!__pyx_tuple__94)) __PYX_ERR(0, 3745, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__94);
  __Pyx_GIVEREF(__pyx_tuple__94);

  /* "validator.pyx":3753
 * 
 *     if max_val is None and include_boundaries == "right":
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             "`include_boundaries`='right' without specifying explicitly `max_val` "
 *             "is inconsistent."
 */
  __pyx_tuple__95 = PyTuple_Pack(1, __pyx_kp_u_include_boundaries_right_withou); if (unlikely(!__pyx_tuple__95)) __PYX_ERR(0, 3753, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__95);
  __Pyx_GIVEREF(__pyx_tuple__95);

  /* "validator.pyx":3759
 * 
 *     if min_val is None and include_boundaries == "left":
 *         raise ValueError(             # <<<<<<<<<<<<<<
 *             "`include_boundaries`='left' without specifying explicitly `min_val` "
 *             "is inconsistent."
 */
  __pyx_tuple__96 = PyTuple_Pack(1, __pyx_kp_u_include_boundaries_left_without); if (unlikely(!__pyx_tuple__96)) __PYX_ERR(0, 3759, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__96);
  __Pyx_GIVEREF(__pyx_tuple__96);

  /* "validator.pyx":3926
 *             feature_names_in_, input_features
 *         ):
 *             raise ValueError("input_features is not equal to feature_names_in_")             # <<<<<<<<<<<<<<
 * 
 *         if n_features_in_ is not None and len(input_features) != n_features_in_:
 */
  __pyx_tuple__104 = PyTuple_Pack(1, __pyx_kp_u_input_features_is_not_equal_to_f); if (unlikely(!__pyx_tuple__104)) __PYX_ERR(0, 3926, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__104);
  __Pyx_GIVEREF(__pyx_tuple__104);

  /* "validator.pyx":3943
 *     # Generates feature names if `n_features_in_` is defined
 *     if n_features_in_ is None:
 *         raise ValueError("Unable to generate feature names without n_features_in_")             # <<<<<<<<<<<<<<
 * 
 *     return np.asarray([f"x{i}" for i in range(n_features_in_)], dtype=object)
 */
  __pyx_tuple__105 = PyTuple_Pack(1, __pyx_kp_u_Unable_to_generate_feature_names); if (unlikely(!__pyx_tuple__105)) __PYX_ERR(0, 3943, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__105);
  __Pyx_GIVEREF(__pyx_tuple__105);

  /* "validator.pyx":4049
 *         ):
 *         if columns is None :
 *             raise ValueError ("Name or columns must be supplied for"             # <<<<<<<<<<<<<<
 *                               " frame conversion.")
 *         # if not string is given as name
 */
  __pyx_tuple__106 = PyTuple_Pack(1, __pyx_kp_u_Name_or_columns_must_be_supplied); if (unlikely(!__pyx_tuple__106)) __PYX_ERR(0, 4049, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__106);
  __Pyx_GIVEREF(__pyx_tuple__106);

  /* "validator.pyx":4135
 *     if to_frame and not sp.issparse(X):
 *         if columns is None:
 *             raise ValueError("Columns must be provided for DataFrame conversion.")             # <<<<<<<<<<<<<<
 * 
 *         # Ensure columns is list-like for DataFrame conversion, single string for Series
 */
  __pyx_tuple__107 = PyTuple_Pack(1, __pyx_kp_u_Columns_must_be_provided_for_Dat); if (unlikely(!__pyx_tuple__107)) __PYX_ERR(0, 4135, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__107);
  __Pyx_GIVEREF(__pyx_tuple__107);

  /* "validator.pyx":4270
 *     """
 *     if isinstance(array, np.matrix):
 *         raise TypeError(             # <<<<<<<<<<<<<<
 *             "np.matrix is not supported. Please convert to a numpy array with "
 *             "np.asarray. For more information see: "
 */
  __pyx_tuple__108 = PyTuple_Pack(1, __pyx_kp_u_np_matrix_is_not_supported_Pleas); if (unlikely(!__pyx_tuple__108)) __PYX_ERR(0, 4270, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__108);
  __Pyx_GIVEREF(__pyx_tuple__108);

  /* "validator.pyx":4304
 *         # throw warning if columns are sparse. If all columns are sparse, then
 *         # array.sparse exists and sparsity will be preserved (later).
 *         with suppress(ImportError):             # <<<<<<<<<<<<<<
 *             # from pandas.api.types import is_sparse
 * 
 */
  __pyx_tuple__109 = PyTuple_Pack(3, Py_None, Py_None, Py_None); if (unlikely(!__pyx_tuple__109)) __PYX_ERR(0, 4304, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__109);
  __Pyx_GIVEREF(__pyx_tuple__109);

  /* "validator.pyx":4404
 * 
 *         if len(array) ==0:
 *            raise ValueError (             # <<<<<<<<<<<<<<
 *                "Found array with 0 length while a minimum of 1 is required." )
 *         if ensure_2d:
 */
  __pyx_tuple__110 = PyTuple_Pack(1, __pyx_kp_u_Found_array_with_0_length_while); if (unlikely(!__pyx_tuple__110)) __PYX_ERR(0, 4404, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__110);
  __Pyx_GIVEREF(__pyx_tuple__110);

  /* "validator.pyx":4417
 *             # If input is 1D raise error
 *             if array.ndim == 1:
 *                 raise ValueError(             # <<<<<<<<<<<<<<
 *                     "Expected 2D array, got 1D array instead. "
 *                     "Reshape your data either using array.reshape(-1, 1) if "
 */
  __pyx_tuple__111 = PyTuple_Pack(1, __pyx_kp_u_Expected_2D_array_got_1D_array_i); if (unlikely(!__pyx_tuple__111)) __PYX_ERR(0, 4417, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__111);
  __Pyx_GIVEREF(__pyx_tuple__111);

  /* "validator.pyx":4429
 *              in "USV"
 *              ):
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "dtype='numeric' is not compatible with arrays of bytes/strings."
 *                 "Convert your data to numeric values explicitly instead."
 */
  __pyx_tuple__112 = PyTuple_Pack(1, __pyx_kp_u_dtype_numeric_is_not_compatible); if (unlikely(!__pyx_tuple__112)) __PYX_ERR(0, 4429, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__112);
  __Pyx_GIVEREF(__pyx_tuple__112);

  /* "validator.pyx":4870
 *     if not is_frame ( data, df_only=True ):
 *         if not to_frame:
 *             raise TypeError("Expect a dataframe while columns is missing.")             # <<<<<<<<<<<<<<
 *         if to_frame and not force:
 *             raise TypeError(
 */
  __pyx_tuple__114 = PyTuple_Pack(1, __pyx_kp_u_Expect_a_dataframe_while_columns); if (unlikely(!__pyx_tuple__114)) __PYX_ERR(0, 4870, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__114);
  __Pyx_GIVEREF(__pyx_tuple__114);

  /* "validator.pyx":5163
 * 
 *     if accept_sparse is False:
 *         raise TypeError(             # <<<<<<<<<<<<<<
 *             "A sparse matrix was passed, but dense "
 *             "data is required. Use X.toarray() to "
 */
  __pyx_tuple__115 = PyTuple_Pack(1, __pyx_kp_u_A_sparse_matrix_was_passed_but_d); if (unlikely(!__pyx_tuple__115)) __PYX_ERR(0, 5163, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__115);
  __Pyx_GIVEREF(__pyx_tuple__115);

  /* "validator.pyx":5170
 *     elif isinstance(accept_sparse, (list, tuple)):
 *         if len(accept_sparse) == 0:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "When providing 'accept_sparse' "
 *                 "as a tuple or list, it must contain at "
 */
  __pyx_tuple__116 = PyTuple_Pack(1, __pyx_kp_u_When_providing_accept_sparse_as); if (unlikely(!__pyx_tuple__116)) __PYX_ERR(0, 5170, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__116);
  __Pyx_GIVEREF(__pyx_tuple__116);

  /* "validator.pyx":99
 *  ]
 * 
 * def filter_valid_kwargs(callable_obj, kwargs):             # <<<<<<<<<<<<<<
 *     """
 *     Filter and return only the valid keyword arguments for a given callable object.
 */
  __pyx_tuple__119 = PyTuple_Pack(7, __pyx_n_s_callable_obj, __pyx_n_s_kwargs, __pyx_n_s_signature, __pyx_n_s_valid_params, __pyx_n_s_valid_kwargs, __pyx_n_s_k, __pyx_n_s_v); if (unlikely(!__pyx_tuple__119)) __PYX_ERR(0, 99, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__119);
  __Pyx_GIVEREF(__pyx_tuple__119);
  __pyx_codeobj__120 = (PyObject*)__Pyx_PyCode_New(2, 0, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__119, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_filter_valid_kwargs, 99, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__120)) __PYX_ERR(0, 99, __pyx_L1_error)

  /* "validator.pyx":159
 *     return valid_kwargs
 * 
 * def validate_scores(             # <<<<<<<<<<<<<<
 *     scores, true_labels=None,
 *     mode="strict",
 */
  __pyx_tuple__121 = PyTuple_Pack(6, __pyx_n_s_scores, __pyx_n_s_true_labels, __pyx_n_s_mode, __pyx_n_s_accept_multi_output, __pyx_n_s_genexpr, __pyx_n_s_genexpr); if (unlikely(!__pyx_tuple__121)) __PYX_ERR(0, 159, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__121);
  __Pyx_GIVEREF(__pyx_tuple__121);
  __pyx_codeobj__122 = (PyObject*)__Pyx_PyCode_New(4, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__121, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_scores, 159, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__122)) __PYX_ERR(0, 159, __pyx_L1_error)

  /* "validator.pyx":256
 *     return np.asarray(scores)
 * 
 * def _is_probability_distribution(y, mode='strict'):             # <<<<<<<<<<<<<<
 *     """
 *     Checks if `y` is a probability distribution across the last axis according
 */
  __pyx_tuple__123 = PyTuple_Pack(2, __pyx_n_s_y, __pyx_n_s_mode); if (unlikely(!__pyx_tuple__123)) __PYX_ERR(0, 256, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__123);
  __Pyx_GIVEREF(__pyx_tuple__123);
  __pyx_codeobj__124 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__123, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_is_probability_distribution, 256, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__124)) __PYX_ERR(0, 256, __pyx_L1_error)

  /* "validator.pyx":311
 *                          " are 'strict', 'soft', or 'passthrough'.")
 * 
 * def validate_square_matrix(data, align=False, align_mode="auto", message=''):             # <<<<<<<<<<<<<<
 *     """
 *     Validate that the input data forms a square matrix and optionally aligns its
 */
  __pyx_tuple__125 = PyTuple_Pack(4, __pyx_n_s_data, __pyx_n_s_align, __pyx_n_s_align_mode, __pyx_n_s_message); if (unlikely(!__pyx_tuple__125)) __PYX_ERR(0, 311, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__125);
  __Pyx_GIVEREF(__pyx_tuple__125);
  __pyx_codeobj__126 = (PyObject*)__Pyx_PyCode_New(4, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__125, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_square_matrix, 311, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__126)) __PYX_ERR(0, 311, __pyx_L1_error)

  /* "validator.pyx":360
 *     return data
 * 
 * def is_square_matrix(data, data_type=None):             # <<<<<<<<<<<<<<
 *     """
 *     Determine whether the input, either a DataFrame or an array-like
 */
  __pyx_tuple__127 = PyTuple_Pack(2, __pyx_n_s_data, __pyx_n_s_data_type); if (unlikely(!__pyx_tuple__127)) __PYX_ERR(0, 360, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__127);
  __Pyx_GIVEREF(__pyx_tuple__127);
  __pyx_codeobj__128 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__127, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_is_square_matrix, 360, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__128)) __PYX_ERR(0, 360, __pyx_L1_error)

  /* "validator.pyx":433
 *     return True
 * 
 * def validate_multiclass_target(             # <<<<<<<<<<<<<<
 *         y, accept_multioutput=False, return_classes=False):
 *     """
 */
  __pyx_tuple__129 = PyTuple_Pack(5, __pyx_n_s_y, __pyx_n_s_accept_multioutput, __pyx_n_s_return_classes, __pyx_n_s_y_eval, __pyx_n_s_unique_classes); if (unlikely(!__pyx_tuple__129)) __PYX_ERR(0, 433, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__129);
  __Pyx_GIVEREF(__pyx_tuple__129);
  __pyx_codeobj__130 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__129, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_multiclass_target, 433, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__130)) __PYX_ERR(0, 433, __pyx_L1_error)

  /* "validator.pyx":507
 *     return y
 * 
 * def validate_sample_weights(weights, y, normalize =False):             # <<<<<<<<<<<<<<
 *     """
 *     Validates that the sample weights are suitable for use in calculations.
 */
  __pyx_tuple__131 = PyTuple_Pack(3, __pyx_n_s_weights, __pyx_n_s_y, __pyx_n_s_normalize); if (unlikely(!__pyx_tuple__131)) __PYX_ERR(0, 507, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__131);
  __Pyx_GIVEREF(__pyx_tuple__131);
  __pyx_codeobj__132 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__131, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_sample_weights, 507, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__132)) __PYX_ERR(0, 507, __pyx_L1_error)

  /* "validator.pyx":577
 * 
 * 
 * def validate_weights(             # <<<<<<<<<<<<<<
 *         weights, min_value=None, max_value=None, normalize=False,
 *         allowed_dims=1):
 */
  __pyx_tuple__133 = PyTuple_Pack(7, __pyx_n_s_weights, __pyx_n_s_min_value, __pyx_n_s_max_value, __pyx_n_s_normalize, __pyx_n_s_allowed_dims, __pyx_n_s_weights_array, __pyx_n_s_e); if (unlikely(!__pyx_tuple__133)) __PYX_ERR(0, 577, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__133);
  __Pyx_GIVEREF(__pyx_tuple__133);
  __pyx_codeobj__134 = (PyObject*)__Pyx_PyCode_New(5, 0, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__133, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_weights, 577, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__134)) __PYX_ERR(0, 577, __pyx_L1_error)

  /* "validator.pyx":660
 *     return weights_array
 * 
 * def is_normalized(arr, method='sum'):             # <<<<<<<<<<<<<<
 *     """
 *     Checks if the provided array is normalized according to the specified method.
 */
  __pyx_tuple__135 = PyTuple_Pack(4, __pyx_n_s_arr, __pyx_n_s_method, __pyx_n_s_mean, __pyx_n_s_std); if (unlikely(!__pyx_tuple__135)) __PYX_ERR(0, 660, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__135);
  __Pyx_GIVEREF(__pyx_tuple__135);
  __pyx_codeobj__136 = (PyObject*)__Pyx_PyCode_New(2, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__135, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_is_normalized, 660, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__136)) __PYX_ERR(0, 660, __pyx_L1_error)

  /* "validator.pyx":712
 *         return np.isclose(np.sum(arr), 1)
 * 
 * def normalize_array(arr, normalize="auto", method='01'):             # <<<<<<<<<<<<<<
 *     """
 *     Checks if an array is normalized according to the specified method and
 */
  __pyx_tuple__137 = PyTuple_Pack(9, __pyx_n_s_arr, __pyx_n_s_normalize, __pyx_n_s_method, __pyx_n_s_is_normed, __pyx_n_s_min_val, __pyx_n_s_max_val, __pyx_n_s_mean, __pyx_n_s_std, __pyx_n_s_total); if (unlikely(!__pyx_tuple__137)) __PYX_ERR(0, 712, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__137);
  __Pyx_GIVEREF(__pyx_tuple__137);
  __pyx_codeobj__138 = (PyObject*)__Pyx_PyCode_New(3, 0, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__137, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_normalize_array, 712, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__138)) __PYX_ERR(0, 712, __pyx_L1_error)

  /* "validator.pyx":798
 *     return arr
 * 
 * def is_binary_class(y, accept_multioutput=False):             # <<<<<<<<<<<<<<
 *     """
 *     Check whether the target array represents binary classification. Optionally,
 */
  __pyx_tuple__139 = PyTuple_Pack(4, __pyx_n_s_y, __pyx_n_s_accept_multioutput, __pyx_n_s_unique_values, __pyx_n_s_column); if (unlikely(!__pyx_tuple__139)) __PYX_ERR(0, 798, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__139);
  __Pyx_GIVEREF(__pyx_tuple__139);
  __pyx_codeobj__140 = (PyObject*)__Pyx_PyCode_New(2, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__139, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_is_binary_class, 798, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__140)) __PYX_ERR(0, 798, __pyx_L1_error)

  /* "validator.pyx":850
 *     return False
 * 
 * def handle_zero_division(             # <<<<<<<<<<<<<<
 *     y_true,
 *     zero_division='warn',
 */
  __pyx_tuple__141 = PyTuple_Pack(8, __pyx_n_s_y_true, __pyx_n_s_zero_division, __pyx_n_s_metric_name, __pyx_n_s_epsilon, __pyx_n_s_replace_with, __pyx_n_s_y_true_processed, __pyx_n_s_zeros_mask, __pyx_n_s_replacement_value); if (unlikely(!__pyx_tuple__141)) __PYX_ERR(0, 850, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__141);
  __Pyx_GIVEREF(__pyx_tuple__141);
  __pyx_codeobj__142 = (PyObject*)__Pyx_PyCode_New(5, 0, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__141, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_handle_zero_division, 850, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__142)) __PYX_ERR(0, 850, __pyx_L1_error)

  /* "validator.pyx":925
 *     return y_true_processed
 * 
 * def validate_comparison_data(df,  alignment="auto"):             # <<<<<<<<<<<<<<
 *     """
 *     Validates a DataFrame to ensure it is a square matrix and that the index
 */
  __pyx_tuple__143 = PyTuple_Pack(2, __pyx_n_s_df, __pyx_n_s_alignment); if (unlikely(!__pyx_tuple__143)) __PYX_ERR(0, 925, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__143);
  __Pyx_GIVEREF(__pyx_tuple__143);
  __pyx_codeobj__144 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__143, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_comparison_data, 925, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__144)) __PYX_ERR(0, 925, __pyx_L1_error)

  /* "validator.pyx":999
 *     return df
 * 
 * def validate_data_types(             # <<<<<<<<<<<<<<
 *     data, expected_type='numeric',
 *     nan_policy='omit',
 */
  __pyx_tuple__145 = PyTuple_Pack(13, __pyx_n_s_data, __pyx_n_s_expected_type, __pyx_n_s_nan_policy, __pyx_n_s_return_data, __pyx_n_s_error, __pyx_n_s_handle_numeric, __pyx_n_s_handle_numeric, __pyx_n_s_handle_categoric, __pyx_n_s_handle_categoric, __pyx_n_s_results, __pyx_n_s_column, __pyx_n_s_col_data, __pyx_n_s_result); if (unlikely(!__pyx_tuple__145)) __PYX_ERR(0, 999, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__145);
  __Pyx_GIVEREF(__pyx_tuple__145);
  __pyx_codeobj__146 = (PyObject*)__Pyx_PyCode_New(5, 0, 13, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__145, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_data_types, 999, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__146)) __PYX_ERR(0, 999, __pyx_L1_error)

  /* "validator.pyx":1144
 *     return results if not results.empty else None
 * 
 * def ensure_2d(X, output_format="auto"):             # <<<<<<<<<<<<<<
 *     """
 *     Ensure that the input X is converted to a 2-dimensional structure.
 */
  __pyx_tuple__147 = PyTuple_Pack(3, __pyx_n_s_X, __pyx_n_s_output_format, __pyx_n_s_is_dataframe); if (unlikely(!__pyx_tuple__147)) __PYX_ERR(0, 1144, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__147);
  __Pyx_GIVEREF(__pyx_tuple__147);
  __pyx_codeobj__148 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__147, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_ensure_2d, 1144, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__148)) __PYX_ERR(0, 1144, __pyx_L1_error)

  /* "validator.pyx":1215
 *         return pd.DataFrame(X) if is_dataframe else X
 * 
 * def is_categorical(data, column, strict=False, error='raise'):             # <<<<<<<<<<<<<<
 *     """
 *     Checks if a specified column in a DataFrame or Series is of
 */
  __pyx_tuple__149 = PyTuple_Pack(6, __pyx_n_s_data, __pyx_n_s_column, __pyx_n_s_strict, __pyx_n_s_error, __pyx_n_s_message, __pyx_n_s_col_type); if (unlikely(!__pyx_tuple__149)) __PYX_ERR(0, 1215, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__149);
  __Pyx_GIVEREF(__pyx_tuple__149);
  __pyx_codeobj__150 = (PyObject*)__Pyx_PyCode_New(4, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__149, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_is_categorical, 1215, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__150)) __PYX_ERR(0, 1215, __pyx_L1_error)

  /* "validator.pyx":1275
 *         return pd.api.types.is_categorical_dtype(col_type) or pd.api.types.is_object_dtype(col_type)
 * 
 * def parameter_validator(             # <<<<<<<<<<<<<<
 *         param_name, target_strs, match_method='contains',
 *         raise_exception=True, **kws):
 */
  __pyx_tuple__151 = PyTuple_Pack(8, __pyx_n_s_param_name, __pyx_n_s_target_strs, __pyx_n_s_match_method, __pyx_n_s_raise_exception, __pyx_n_s_kws, __pyx_n_s_normalize_string, __pyx_n_s_validator, __pyx_n_s_validator); if (unlikely(!__pyx_tuple__151)) __PYX_ERR(0, 1275, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__151);
  __Pyx_GIVEREF(__pyx_tuple__151);
  __pyx_codeobj__152 = (PyObject*)__Pyx_PyCode_New(4, 0, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__151, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_parameter_validator, 1275, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__152)) __PYX_ERR(0, 1275, __pyx_L1_error)

  /* "validator.pyx":1352
 *     return validator
 * 
 * def validate_distribution(distribution, elements=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates or generates distributions for given elements ensuring the
 */
  __pyx_tuple__153 = PyTuple_Pack(6, __pyx_n_s_distribution, __pyx_n_s_elements, __pyx_n_s_distributed_elements, __pyx_n_s_random_values, __pyx_n_s_validated_distribution, __pyx_n_s_value); if (unlikely(!__pyx_tuple__153)) __PYX_ERR(0, 1352, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__153);
  __Pyx_GIVEREF(__pyx_tuple__153);
  __pyx_codeobj__154 = (PyObject*)__Pyx_PyCode_New(2, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__153, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_distribution, 1352, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__154)) __PYX_ERR(0, 1352, __pyx_L1_error)

  /* "validator.pyx":1424
 *     return distribution
 * 
 * def validate_length_range(length_range, sorted_values=True, param_name=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates the review length range ensuring it's a tuple with two integers
 */
  __pyx_tuple__155 = PyTuple_Pack(7, __pyx_n_s_length_range, __pyx_n_s_sorted_values, __pyx_n_s_param_name, __pyx_n_s_min_length, __pyx_n_s_max_length, __pyx_n_s_genexpr, __pyx_n_s_genexpr); if (unlikely(!__pyx_tuple__155)) __PYX_ERR(0, 1424, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__155);
  __Pyx_GIVEREF(__pyx_tuple__155);
  __pyx_codeobj__156 = (PyObject*)__Pyx_PyCode_New(3, 0, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__155, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_length_range, 1424, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__156)) __PYX_ERR(0, 1424, __pyx_L1_error)

  /* "validator.pyx":1481
 *     return length_range
 * 
 * def contains_nested_objects(lst, strict=False, allowed_types=None):             # <<<<<<<<<<<<<<
 *     """
 *     Determines whether a list contains nested objects.
 */
  __pyx_tuple__157 = PyTuple_Pack(8, __pyx_n_s_lst, __pyx_n_s_strict, __pyx_n_s_allowed_types, __pyx_n_s_is_nested, __pyx_n_s_is_nested, __pyx_n_s_genexpr, __pyx_n_s_genexpr, __pyx_n_s_genexpr); if (unlikely(!__pyx_tuple__157)) __PYX_ERR(0, 1481, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__157);
  __Pyx_GIVEREF(__pyx_tuple__157);
  __pyx_codeobj__158 = (PyObject*)__Pyx_PyCode_New(3, 0, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__157, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_contains_nested_objects, 1481, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__158)) __PYX_ERR(0, 1481, __pyx_L1_error)

  /* "validator.pyx":1542
 *         return any(is_nested(item) for item in lst)
 * 
 * def validate_nan_policy(nan_policy, *arrays, sample_weights=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates and applies a specified nan_policy to input arrays and
 */
  __pyx_tuple__159 = PyTuple_Pack(8, __pyx_n_s_nan_policy, __pyx_n_s_sample_weights, __pyx_n_s_arrays, __pyx_n_s_valid_policies, __pyx_n_s_not_nan_mask, __pyx_n_s_genexpr, __pyx_n_s_genexpr, __pyx_n_s_genexpr); if (unlikely(!__pyx_tuple__159)) __PYX_ERR(0, 1542, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__159);
  __Pyx_GIVEREF(__pyx_tuple__159);
  __pyx_codeobj__160 = (PyObject*)__Pyx_PyCode_New(1, 1, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARARGS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__159, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_nan_policy, 1542, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__160)) __PYX_ERR(0, 1542, __pyx_L1_error)

  /* "validator.pyx":1629
 *     return arrays
 * 
 * def validate_fit_weights(y, sample_weight=None, weighted_y=False):             # <<<<<<<<<<<<<<
 *     """
 *     Validate and compute sample weights for fitting.
 */
  __pyx_tuple__161 = PyTuple_Pack(4, __pyx_n_s_y, __pyx_n_s_sample_weight, __pyx_n_s_weighted_y, __pyx_n_s_weighted_y_values); if (unlikely(!__pyx_tuple__161)) __PYX_ERR(0, 1629, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__161);
  __Pyx_GIVEREF(__pyx_tuple__161);
  __pyx_codeobj__162 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__161, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_fit_weights, 1629, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__162)) __PYX_ERR(0, 1629, __pyx_L1_error)

  /* "validator.pyx":1700
 *     return sample_weight
 * 
 * def is_valid_policies(nan_policy, allowed_policies=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates the `nan_policy` or any policy argument to ensure it is one
 */
  __pyx_tuple__163 = PyTuple_Pack(2, __pyx_n_s_nan_policy, __pyx_n_s_allowed_policies); if (unlikely(!__pyx_tuple__163)) __PYX_ERR(0, 1700, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__163);
  __Pyx_GIVEREF(__pyx_tuple__163);
  __pyx_codeobj__164 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__163, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_is_valid_policies, 1700, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__164)) __PYX_ERR(0, 1700, __pyx_L1_error)

  /* "validator.pyx":1756
 *     return nan_policy
 * 
 * def validate_multioutput(value, extra=''):             # <<<<<<<<<<<<<<
 *     """
 *     Validate the `multioutput` parameter value and handle special cases.
 */
  __pyx_tuple__165 = PyTuple_Pack(5, __pyx_n_s_value, __pyx_n_s_extra, __pyx_n_s_valid_values, __pyx_n_s_value_lower, __pyx_n_s_warn_msg); if (unlikely(!__pyx_tuple__165)) __PYX_ERR(0, 1756, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__165);
  __Pyx_GIVEREF(__pyx_tuple__165);
  __pyx_codeobj__166 = (PyObject*)__Pyx_PyCode_New(2, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__165, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_multioutput, 1756, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__166)) __PYX_ERR(0, 1756, __pyx_L1_error)

  /* "validator.pyx":1826
 *     return value_lower
 * 
 * def ensure_non_negative(*arrays, err_msg=None):             # <<<<<<<<<<<<<<
 *     """
 *     Ensure that provided arrays contain only non-negative values.
 */
  __pyx_tuple__167 = PyTuple_Pack(4, __pyx_n_s_err_msg, __pyx_n_s_arrays, __pyx_n_s_i, __pyx_n_s_array); if (unlikely(!__pyx_tuple__167)) __PYX_ERR(0, 1826, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__167);
  __Pyx_GIVEREF(__pyx_tuple__167);
  __pyx_codeobj__168 = (PyObject*)__Pyx_PyCode_New(0, 1, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARARGS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__167, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_ensure_non_negative, 1826, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__168)) __PYX_ERR(0, 1826, __pyx_L1_error)

  /* "validator.pyx":1868
 *             raise ValueError(err_msg)
 * 
 * def check_epsilon(             # <<<<<<<<<<<<<<
 *     eps,
 *     y_true=None,
 */
  __pyx_tuple__169 = PyTuple_Pack(7, __pyx_n_s_eps, __pyx_n_s_y_true, __pyx_n_s_y_pred, __pyx_n_s_base_epsilon, __pyx_n_s_scale_factor, __pyx_n_s_determine_epsilon, __pyx_n_s_y_arrays); if (unlikely(!__pyx_tuple__169)) __PYX_ERR(0, 1868, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__169);
  __Pyx_GIVEREF(__pyx_tuple__169);
  __pyx_codeobj__170 = (PyObject*)__Pyx_PyCode_New(5, 0, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__169, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_epsilon, 1868, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__170)) __PYX_ERR(0, 1868, __pyx_L1_error)

  /* "validator.pyx":1957
 *     return eps
 * 
 * def _ensure_y_is_valid(y_true, y_pred, **kwargs):             # <<<<<<<<<<<<<<
 *     """
 *     Validates that the true and predicted target arrays are suitable for further
 */
  __pyx_tuple__171 = PyTuple_Pack(3, __pyx_n_s_y_true, __pyx_n_s_y_pred, __pyx_n_s_kwargs); if (unlikely(!__pyx_tuple__171)) __PYX_ERR(0, 1957, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__171);
  __Pyx_GIVEREF(__pyx_tuple__171);
  __pyx_codeobj__172 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__171, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_ensure_y_is_valid, 1957, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__172)) __PYX_ERR(0, 1957, __pyx_L1_error)

  /* "validator.pyx":2011
 *     return y_true, y_pred
 * 
 * def check_classification_targets(             # <<<<<<<<<<<<<<
 *     *y,
 *     target_type='numeric',
 */
  __pyx_tuple__173 = PyTuple_Pack(13, __pyx_n_s_target_type, __pyx_n_s_strategy, __pyx_n_s_verbose, __pyx_n_s_y, __pyx_n_s_validated_targets, __pyx_n_s_i, __pyx_n_s_target, __pyx_n_s_e, __pyx_n_s_non_numeric, __pyx_n_s_target, __pyx_n_s_genexpr, __pyx_n_s_genexpr, __pyx_n_s_item); if (unlikely(!__pyx_tuple__173)) __PYX_ERR(0, 2011, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__173);
  __Pyx_GIVEREF(__pyx_tuple__173);
  __pyx_codeobj__174 = (PyObject*)__Pyx_PyCode_New(0, 3, 13, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARARGS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__173, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_classification_targets, 2011, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__174)) __PYX_ERR(0, 2011, __pyx_L1_error)

  /* "validator.pyx":2158
 *     return validated_targets
 * 
 * def _check_y(y, strategy='auto'):             # <<<<<<<<<<<<<<
 *     """
 *     Validates the target array `y`, ensuring it is suitable for classification
 */
  __pyx_tuple__175 = PyTuple_Pack(10, __pyx_n_s_y, __pyx_n_s_strategy, __pyx_n_s_type_of_target, __pyx_n_s_numeric_types, __pyx_n_s_numeric_y, __pyx_n_s_unique_values, __pyx_n_s_target_type, __pyx_n_s_genexpr, __pyx_n_s_genexpr, __pyx_n_s_genexpr); if (unlikely(!__pyx_tuple__175)) __PYX_ERR(0, 2158, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__175);
  __Pyx_GIVEREF(__pyx_tuple__175);
  __pyx_codeobj__176 = (PyObject*)__Pyx_PyCode_New(2, 0, 10, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__175, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_y_2, 2158, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__176)) __PYX_ERR(0, 2158, __pyx_L1_error)

  /* "validator.pyx":2213
 *     return y
 * 
 * def validate_yy(             # <<<<<<<<<<<<<<
 *     y_true, y_pred,
 *     expected_type=None, *,
 */
  __pyx_tuple__177 = PyTuple_Pack(9, __pyx_n_s_y_true, __pyx_n_s_y_pred, __pyx_n_s_expected_type, __pyx_n_s_validation_mode, __pyx_n_s_flatten, __pyx_n_s_type_of_target, __pyx_n_s_msg, __pyx_n_s_actual_type_y_true, __pyx_n_s_actual_type_y_pred); if (unlikely(!__pyx_tuple__177)) __PYX_ERR(0, 2213, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__177);
  __Pyx_GIVEREF(__pyx_tuple__177);
  __pyx_codeobj__178 = (PyObject*)__Pyx_PyCode_New(3, 2, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__177, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_yy, 2213, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__178)) __PYX_ERR(0, 2213, __pyx_L1_error)

  /* "validator.pyx":2276
 *     return y_true, y_pred
 * 
 * def check_mixed_data_types(data ) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Checks if the given data (DataFrame or numpy array) contains both numerical
 */
  __pyx_tuple__179 = PyTuple_Pack(3, __pyx_n_s_data, __pyx_n_s_has_numerical, __pyx_n_s_has_categorical); if (unlikely(!__pyx_tuple__179)) __PYX_ERR(0, 2276, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__179);
  __Pyx_GIVEREF(__pyx_tuple__179);
  __pyx_codeobj__180 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__179, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_mixed_data_types, 2276, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__180)) __PYX_ERR(0, 2276, __pyx_L1_error)

  /* "validator.pyx":2334
 *     return has_numerical and has_categorical
 * 
 * def is_keras_model(model: Any) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Determine whether the provided object is an instance of a Keras model.
 */
  __pyx_tuple__181 = PyTuple_Pack(3, __pyx_n_s_model, __pyx_n_s_import_optional_dependency, __pyx_n_s_tf); if (unlikely(!__pyx_tuple__181)) __PYX_ERR(0, 2334, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__181);
  __Pyx_GIVEREF(__pyx_tuple__181);
  __pyx_codeobj__182 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__181, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_is_keras_model, 2334, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__182)) __PYX_ERR(0, 2334, __pyx_L1_error)

  /* "validator.pyx":2354
 *     return isinstance(model, (tf.keras.models.Model, tf.keras.Sequential))
 * 
 * def has_required_attributes(model: Any, attributes: list[str]) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Check if the model has all required Keras-specific attributes.
 */
  __pyx_tuple__183 = PyTuple_Pack(4, __pyx_n_s_model, __pyx_n_s_attributes, __pyx_n_s_genexpr, __pyx_n_s_genexpr); if (unlikely(!__pyx_tuple__183)) __PYX_ERR(0, 2354, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__183);
  __Pyx_GIVEREF(__pyx_tuple__183);
  __pyx_codeobj__184 = (PyObject*)__Pyx_PyCode_New(2, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__183, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_has_required_attributes, 2354, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__184)) __PYX_ERR(0, 2354, __pyx_L1_error)

  /* "validator.pyx":2377
 *     return all(hasattr(model, attr) for attr in attributes)
 * 
 * def validate_dates(             # <<<<<<<<<<<<<<
 *         start_date, end_date, return_as_date_str=False, date_format="%Y-%m-%d"):
 *     """
 */
  __pyx_tuple__185 = PyTuple_Pack(8, __pyx_n_s_start_date, __pyx_n_s_end_date, __pyx_n_s_return_as_date_str, __pyx_n_s_date_format, __pyx_n_s_parse_year_input, __pyx_n_s_parse_year_input, __pyx_n_s_current_year, __pyx_n_s_year); if (unlikely(!__pyx_tuple__185)) __PYX_ERR(0, 2377, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__185);
  __Pyx_GIVEREF(__pyx_tuple__185);
  __pyx_codeobj__186 = (PyObject*)__Pyx_PyCode_New(4, 0, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__185, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_dates, 2377, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__186)) __PYX_ERR(0, 2377, __pyx_L1_error)

  /* "validator.pyx":2486
 * 
 * 
 * def validate_positive_integer(value, variable_name, include_zero=False, round_float=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates whether the given value is a positive integer or zero based
 */
  __pyx_tuple__187 = PyTuple_Pack(7, __pyx_n_s_value, __pyx_n_s_variable_name, __pyx_n_s_include_zero, __pyx_n_s_round_float, __pyx_n_s_math, __pyx_n_s_min_value, __pyx_n_s_condition); if (unlikely(!__pyx_tuple__187)) __PYX_ERR(0, 2486, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__187);
  __Pyx_GIVEREF(__pyx_tuple__187);
  __pyx_codeobj__188 = (PyObject*)__Pyx_PyCode_New(4, 0, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__187, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_positive_integer, 2486, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__188)) __PYX_ERR(0, 2486, __pyx_L1_error)

  /* "validator.pyx":2541
 *     return int(value)
 * 
 * def validate_and_adjust_ranges(**kwargs):             # <<<<<<<<<<<<<<
 *     """
 *     Validates and adjusts the provided range tuples to ensure each is
 */
  __pyx_tuple__189 = PyTuple_Pack(8, __pyx_n_s_kwargs, __pyx_n_s_adjusted_ranges, __pyx_n_s_range_name, __pyx_n_s_range_tuple, __pyx_n_s_min_value, __pyx_n_s_max_value, __pyx_n_s_genexpr, __pyx_n_s_genexpr); if (unlikely(!__pyx_tuple__189)) __PYX_ERR(0, 2541, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__189);
  __Pyx_GIVEREF(__pyx_tuple__189);
  __pyx_codeobj__190 = (PyObject*)__Pyx_PyCode_New(0, 0, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__189, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_and_adjust_ranges, 2541, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__190)) __PYX_ERR(0, 2541, __pyx_L1_error)

  /* "validator.pyx":2604
 *     return adjusted_ranges
 * 
 * def recheck_data_types(             # <<<<<<<<<<<<<<
 *     data: Union[pd.DataFrame, pd.Series, list, dict],
 *     coerce_numeric: bool = True,
 */
  __pyx_tuple__191 = PyTuple_Pack(9, __pyx_n_s_data, __pyx_n_s_coerce_numeric, __pyx_n_s_coerce_datetime, __pyx_n_s_column_prefix, __pyx_n_s_return_as_numpy, __pyx_n_s_is_frame, __pyx_n_s_e, __pyx_n_s_column, __pyx_n_s_i); if (unlikely(!__pyx_tuple__191)) __PYX_ERR(0, 2604, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__191);
  __Pyx_GIVEREF(__pyx_tuple__191);
  __pyx_codeobj__192 = (PyObject*)__Pyx_PyCode_New(5, 0, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__191, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_recheck_data_types, 2604, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__192)) __PYX_ERR(0, 2604, __pyx_L1_error)

  /* "validator.pyx":2685
 * 
 * 
 * def validate_keras_model(             # <<<<<<<<<<<<<<
 *         model: Any, custom_check: Optional[Callable[[Any], bool]] = None,
 *         deep_check: bool = False, raise_exception =False ) -> bool:
 */
  __pyx_tuple__193 = PyTuple_Pack(5, __pyx_n_s_model, __pyx_n_s_custom_check, __pyx_n_s_deep_check, __pyx_n_s_raise_exception, __pyx_n_s_e); if (unlikely(!__pyx_tuple__193)) __PYX_ERR(0, 2685, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__193);
  __Pyx_GIVEREF(__pyx_tuple__193);
  __pyx_codeobj__194 = (PyObject*)__Pyx_PyCode_New(4, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__193, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_keras_model, 2685, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__194)) __PYX_ERR(0, 2685, __pyx_L1_error)

  /* "validator.pyx":2764
 *     return True
 * 
 * def is_installed(module: str ) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Checks if TensorFlow is installed.
 */
  __pyx_tuple__195 = PyTuple_Pack(3, __pyx_n_s_module_2, __pyx_n_s_importlib, __pyx_n_s_module_spec); if (unlikely(!__pyx_tuple__195)) __PYX_ERR(0, 2764, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__195);
  __Pyx_GIVEREF(__pyx_tuple__195);
  __pyx_codeobj__196 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__195, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_is_installed, 2764, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__196)) __PYX_ERR(0, 2764, __pyx_L1_error)

  /* "validator.pyx":2787
 *     return module_spec is not None
 * 
 * def is_time_series(data, time_col, check_time_interval=False ):             # <<<<<<<<<<<<<<
 *     """
 *     Check if the provided DataFrame is time series data.
 */
  __pyx_tuple__197 = PyTuple_Pack(4, __pyx_n_s_data, __pyx_n_s_time_col, __pyx_n_s_check_time_interval, __pyx_n_s_intervals); if (unlikely(!__pyx_tuple__197)) __PYX_ERR(0, 2787, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__197);
  __Pyx_GIVEREF(__pyx_tuple__197);
  __pyx_codeobj__198 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__197, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_is_time_series, 2787, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__198)) __PYX_ERR(0, 2787, __pyx_L1_error)

  /* "validator.pyx":2836
 *     return True
 * 
 * def check_is_fitted2(estimator, attributes, *, msg=None):             # <<<<<<<<<<<<<<
 *     """
 *     Perform is_fitted validation for estimator.
 */
  __pyx_tuple__199 = PyTuple_Pack(7, __pyx_n_s_estimator, __pyx_n_s_attributes, __pyx_n_s_msg, __pyx_n_s_NotFittedError, __pyx_n_s_fitted, __pyx_n_s_cls_name, __pyx_n_s_attr); if (unlikely(!__pyx_tuple__199)) __PYX_ERR(0, 2836, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__199);
  __Pyx_GIVEREF(__pyx_tuple__199);
  __pyx_codeobj__200 = (PyObject*)__Pyx_PyCode_New(2, 1, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__199, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_is_fitted2, 2836, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__200)) __PYX_ERR(0, 2836, __pyx_L1_error)

  /* "validator.pyx":2884
 *         raise NotFittedError(msg)
 * 
 * def assert_xy_in (             # <<<<<<<<<<<<<<
 *     x,
 *     y, *,
 */
  __pyx_tuple__201 = PyTuple_Pack(10, __pyx_n_s_x, __pyx_n_s_y, __pyx_n_s_data, __pyx_n_s_asarray, __pyx_n_s_to_frame, __pyx_n_s_columns, __pyx_n_s_xy_numeric, __pyx_n_s_ignore, __pyx_n_s_kws, __pyx_n_s_exist_features); if (unlikely(!__pyx_tuple__201)) __PYX_ERR(0, 2884, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__201);
  __Pyx_GIVEREF(__pyx_tuple__201);
  __pyx_codeobj__202 = (PyObject*)__Pyx_PyCode_New(2, 6, 10, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__201, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_assert_xy_in, 2884, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__202)) __PYX_ERR(0, 2884, __pyx_L1_error)

  /* "validator.pyx":3008
 *     return ( np.array(x), np.array (y) ) if asarray else (x, y )
 * 
 * def validate_numeric(             # <<<<<<<<<<<<<<
 *     value,
 *     convert_to='float',
 */
  __pyx_tuple__203 = PyTuple_Pack(6, __pyx_n_s_value, __pyx_n_s_convert_to, __pyx_n_s_allow_negative, __pyx_n_s_min_value, __pyx_n_s_max_value, __pyx_n_s_check_mode); if (unlikely(!__pyx_tuple__203)) __PYX_ERR(0, 3008, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__203);
  __Pyx_GIVEREF(__pyx_tuple__203);
  __pyx_codeobj__204 = (PyObject*)__Pyx_PyCode_New(6, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__203, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_numeric, 3008, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__204)) __PYX_ERR(0, 3008, __pyx_L1_error)

  /* "validator.pyx":3159
 * 
 * 
 * def _validate_input(ignore: str, x, y, _is_arraylike_1d):             # <<<<<<<<<<<<<<
 *     """
 *     Validates that x and y are one-dimensional array-like structures based
 */
  __pyx_tuple__205 = PyTuple_Pack(6, __pyx_n_s_ignore, __pyx_n_s_x, __pyx_n_s_y, __pyx_n_s_is_arraylike_1d, __pyx_n_s_validation_checks, __pyx_n_s_check); if (unlikely(!__pyx_tuple__205)) __PYX_ERR(0, 3159, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__205);
  __Pyx_GIVEREF(__pyx_tuple__205);
  __pyx_codeobj__206 = (PyObject*)__Pyx_PyCode_New(4, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__205, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_input, 3159, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__206)) __PYX_ERR(0, 3159, __pyx_L1_error)

  /* "validator.pyx":3193
 *                              "array-like structures.")
 * 
 * def _is_numeric_dtype (o, to_array =False ):             # <<<<<<<<<<<<<<
 *     """ Determine whether the argument has a numeric datatype, when
 *     converted to a NumPy array.
 */
  __pyx_tuple__207 = PyTuple_Pack(3, __pyx_n_s_o, __pyx_n_s_to_array, __pyx_n_s_NUMERIC_KINDS); if (unlikely(!__pyx_tuple__207)) __PYX_ERR(0, 3193, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__207);
  __Pyx_GIVEREF(__pyx_tuple__207);
  __pyx_codeobj__208 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__207, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_is_numeric_dtype, 3193, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__208)) __PYX_ERR(0, 3193, __pyx_L1_error)

  /* "validator.pyx":3222
 *             else o.dtype.kind ) in _NUMERIC_KINDS
 * 
 * def _check_consistency_size (ar1, ar2 ,  error ='raise') :             # <<<<<<<<<<<<<<
 *     """ Check consistency of two arrays and raises error if both sizes
 *     are differents.
 */
  __pyx_tuple__209 = PyTuple_Pack(4, __pyx_n_s_ar1, __pyx_n_s_ar2, __pyx_n_s_error, __pyx_n_s_msg); if (unlikely(!__pyx_tuple__209)) __PYX_ERR(0, 3222, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__209);
  __Pyx_GIVEREF(__pyx_tuple__209);
  __pyx_codeobj__210 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__209, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_consistency_size_2, 3222, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__210)) __PYX_ERR(0, 3222, __pyx_L1_error)

  /* "validator.pyx":3233
 *     return len(ar1)==len(ar2)
 * 
 * def check_consistency_size ( *arrays ):             # <<<<<<<<<<<<<<
 *     """ Check consistency of array and raises error otherwise."""
 *     lengths = [len(X) for X in arrays if X is not None]
 */
  __pyx_tuple__211 = PyTuple_Pack(5, __pyx_n_s_arrays, __pyx_n_s_lengths, __pyx_n_s_uniques, __pyx_n_s_X, __pyx_n_s_l); if (unlikely(!__pyx_tuple__211)) __PYX_ERR(0, 3233, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__211);
  __Pyx_GIVEREF(__pyx_tuple__211);
  __pyx_codeobj__212 = (PyObject*)__Pyx_PyCode_New(0, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARARGS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__211, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_consistency_size, 3233, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__212)) __PYX_ERR(0, 3233, __pyx_L1_error)

  /* "validator.pyx":3243
 *         )
 * 
 * def _is_buildin (o,  mode ='soft'):             # <<<<<<<<<<<<<<
 *     """ Returns 'True' wether the module is a Python buidling function.
 * 
 */
  __pyx_tuple__213 = PyTuple_Pack(2, __pyx_n_s_o, __pyx_n_s_mode); if (unlikely(!__pyx_tuple__213)) __PYX_ERR(0, 3243, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__213);
  __Pyx_GIVEREF(__pyx_tuple__213);
  __pyx_codeobj__214 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__213, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_is_buildin, 3243, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__214)) __PYX_ERR(0, 3243, __pyx_L1_error)

  /* "validator.pyx":3264
 * 
 * 
 * def get_estimator_name (estimator ):             # <<<<<<<<<<<<<<
 *     """ Get the estimator name whatever it is an instanciated object or not
 * 
 */
  __pyx_tuple__215 = PyTuple_Pack(2, __pyx_n_s_estimator, __pyx_n_s_name_2); if (unlikely(!__pyx_tuple__215)) __PYX_ERR(0, 3264, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__215);
  __Pyx_GIVEREF(__pyx_tuple__215);
  __pyx_codeobj__216 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__215, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_get_estimator_name, 3264, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__216)) __PYX_ERR(0, 3264, __pyx_L1_error)

  /* "validator.pyx":3282
 *     return name
 * 
 * def _is_cross_validated (estimator ):             # <<<<<<<<<<<<<<
 *     """ Check whether the estimator has already passed the cross validation
 *      procedure.
 */
  __pyx_tuple__217 = PyTuple_Pack(1, __pyx_n_s_estimator); if (unlikely(!__pyx_tuple__217)) __PYX_ERR(0, 3282, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__217);
  __Pyx_GIVEREF(__pyx_tuple__217);
  __pyx_codeobj__218 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__217, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_is_cross_validated, 3282, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__218)) __PYX_ERR(0, 3282, __pyx_L1_error)

  /* "validator.pyx":3298
 * 
 * 
 * def _check_array_in(obj,  arr_name):             # <<<<<<<<<<<<<<
 *     """Returns the array from the array name attribute. Note that the singleton
 *     array is not admitted.
 */
  __pyx_tuple__219 = PyTuple_Pack(7, __pyx_n_s_obj, __pyx_n_s_arr_name, __pyx_n_s_type, __pyx_n_s_type_name, __pyx_n_s_o_3, __pyx_n_s_message, __pyx_n_s_X); if (unlikely(!__pyx_tuple__219)) __PYX_ERR(0, 3298, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__219);
  __Pyx_GIVEREF(__pyx_tuple__219);
  __pyx_codeobj__220 = (PyObject*)__Pyx_PyCode_New(2, 0, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__219, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_array_in, 3298, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__220)) __PYX_ERR(0, 3298, __pyx_L1_error)

  /* "validator.pyx":3348
 * 
 * 
 * def _deprecate_positional_args(func=None, *, version="1.3"):             # <<<<<<<<<<<<<<
 *     """Decorator for methods that issues warnings for positional arguments.
 *     Using the keyword-only argument syntax in pep 3102, arguments after the
 */
  __pyx_tuple__221 = PyTuple_Pack(4, __pyx_n_s_func, __pyx_n_s_version, __pyx_n_s_inner_deprecate_positional_args, __pyx_n_s_inner_deprecate_positional_args); if (unlikely(!__pyx_tuple__221)) __PYX_ERR(0, 3348, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__221);
  __Pyx_GIVEREF(__pyx_tuple__221);
  __pyx_codeobj__222 = (PyObject*)__Pyx_PyCode_New(1, 1, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__221, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_deprecate_positional_args, 3348, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__222)) __PYX_ERR(0, 3348, __pyx_L1_error)

  /* "validator.pyx":3399
 *     return _inner_deprecate_positional_args
 * 
 * def to_dtype_str (arr, return_values = False ):             # <<<<<<<<<<<<<<
 *     """ Convert numeric or object dtype to string dtype.
 * 
 */
  __pyx_tuple__223 = PyTuple_Pack(2, __pyx_n_s_arr, __pyx_n_s_return_values); if (unlikely(!__pyx_tuple__223)) __PYX_ERR(0, 3399, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__223);
  __Pyx_GIVEREF(__pyx_tuple__223);
  __pyx_codeobj__224 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__223, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_to_dtype_str, 3399, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__224)) __PYX_ERR(0, 3399, __pyx_L1_error)

  /* "validator.pyx":3426
 *     return arr.astype (str )
 * 
 * def _is_arraylike_1d (x) :             # <<<<<<<<<<<<<<
 *     """ Returns whether the input is arraylike one dimensional and not a scalar"""
 *     if not hasattr (x, '__array__'):
 */
  __pyx_tuple__225 = PyTuple_Pack(1, __pyx_n_s_x); if (unlikely(!__pyx_tuple__225)) __PYX_ERR(0, 3426, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__225);
  __Pyx_GIVEREF(__pyx_tuple__225);
  __pyx_codeobj__226 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__225, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_is_arraylike_1d, 3426, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__226)) __PYX_ERR(0, 3426, __pyx_L1_error)

  /* "validator.pyx":3435
 *         len(x.shape ) ==2 and x.shape [1]==1 ))
 * 
 * def _is_arraylike(x):             # <<<<<<<<<<<<<<
 *     """Returns whether the input is array-like."""
 *     return hasattr(x, "__len__") or hasattr(x, "shape") or hasattr(x, "__array__")
 */
  __pyx_tuple__227 = PyTuple_Pack(1, __pyx_n_s_x); if (unlikely(!__pyx_tuple__227)) __PYX_ERR(0, 3435, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__227);
  __Pyx_GIVEREF(__pyx_tuple__227);
  __pyx_codeobj__228 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__227, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_is_arraylike, 3435, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__228)) __PYX_ERR(0, 3435, __pyx_L1_error)

  /* "validator.pyx":3440
 * 
 * 
 * def _is_arraylike_not_scalar(array):             # <<<<<<<<<<<<<<
 *     """Return True if array is array-like and not a scalar"""
 *     return _is_arraylike(array) and not np.isscalar(array)
 */
  __pyx_tuple__229 = PyTuple_Pack(1, __pyx_n_s_array); if (unlikely(!__pyx_tuple__229)) __PYX_ERR(0, 3440, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__229);
  __Pyx_GIVEREF(__pyx_tuple__229);
  __pyx_codeobj__230 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__229, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_is_arraylike_not_scalar, 3440, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__230)) __PYX_ERR(0, 3440, __pyx_L1_error)

  /* "validator.pyx":3444
 *     return _is_arraylike(array) and not np.isscalar(array)
 * 
 * def _num_features(X):             # <<<<<<<<<<<<<<
 *     """Return the number of features in an array-like X.
 *     This helper function tries hard to avoid to materialize an array version
 */
  __pyx_tuple__231 = PyTuple_Pack(6, __pyx_n_s_X, __pyx_n_s_type, __pyx_n_s_type_name, __pyx_n_s_message, __pyx_n_s_first_sample, __pyx_n_s_err); if (unlikely(!__pyx_tuple__231)) __PYX_ERR(0, 3444, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__231);
  __Pyx_GIVEREF(__pyx_tuple__231);
  __pyx_codeobj__232 = (PyObject*)__Pyx_PyCode_New(1, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__231, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_num_features, 3444, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__232)) __PYX_ERR(0, 3444, __pyx_L1_error)

  /* "validator.pyx":3495
 * 
 * 
 * def _num_samples(x):             # <<<<<<<<<<<<<<
 *     """Return number of samples in array-like x."""
 *     message = "Expected sequence or array-like, got %s" % type(x)
 */
  __pyx_tuple__233 = PyTuple_Pack(3, __pyx_n_s_x, __pyx_n_s_message, __pyx_n_s_type_error); if (unlikely(!__pyx_tuple__233)) __PYX_ERR(0, 3495, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__233);
  __Pyx_GIVEREF(__pyx_tuple__233);
  __pyx_codeobj__234 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__233, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_num_samples, 3495, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__234)) __PYX_ERR(0, 3495, __pyx_L1_error)

  /* "validator.pyx":3524
 * 
 * 
 * def check_memory(memory):             # <<<<<<<<<<<<<<
 *     """Check that ``memory`` is joblib.Memory-like.
 *     joblib.Memory-like means that ``memory`` can be converted into a
 */
  __pyx_tuple__235 = PyTuple_Pack(1, __pyx_n_s_memory); if (unlikely(!__pyx_tuple__235)) __PYX_ERR(0, 3524, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__235);
  __Pyx_GIVEREF(__pyx_tuple__235);
  __pyx_codeobj__236 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__235, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_memory, 3524, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__236)) __PYX_ERR(0, 3524, __pyx_L1_error)

  /* "validator.pyx":3554
 * 
 * 
 * def check_consistent_length(*arrays):             # <<<<<<<<<<<<<<
 *     """Check that all arrays have consistent first dimensions.
 *     Checks whether all objects in arrays have the same shape or length.
 */
  __pyx_tuple__237 = PyTuple_Pack(5, __pyx_n_s_arrays, __pyx_n_s_lengths, __pyx_n_s_uniques, __pyx_n_s_X, __pyx_n_s_l); if (unlikely(!__pyx_tuple__237)) __PYX_ERR(0, 3554, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__237);
  __Pyx_GIVEREF(__pyx_tuple__237);
  __pyx_codeobj__238 = (PyObject*)__Pyx_PyCode_New(0, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARARGS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__237, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_consistent_length, 3554, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__238)) __PYX_ERR(0, 3554, __pyx_L1_error)

  /* "validator.pyx":3572
 * 
 * 
 * def check_random_state(seed):             # <<<<<<<<<<<<<<
 *     """Turn seed into a np.random.RandomState instance.
 *     Parameters
 */
  __pyx_tuple__239 = PyTuple_Pack(1, __pyx_n_s_seed); if (unlikely(!__pyx_tuple__239)) __PYX_ERR(0, 3572, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__239);
  __Pyx_GIVEREF(__pyx_tuple__239);
  __pyx_codeobj__240 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__239, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_random_state, 3572, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__240)) __PYX_ERR(0, 3572, __pyx_L1_error)

  /* "validator.pyx":3596
 *     )
 * 
 * def has_fit_parameter(estimator, parameter):             # <<<<<<<<<<<<<<
 *     """Check whether the estimator's fit method supports the given parameter.
 *     Parameters
 */
  __pyx_tuple__241 = PyTuple_Pack(2, __pyx_n_s_estimator, __pyx_n_s_parameter); if (unlikely(!__pyx_tuple__241)) __PYX_ERR(0, 3596, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__241);
  __Pyx_GIVEREF(__pyx_tuple__241);
  __pyx_codeobj__242 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__241, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_has_fit_parameter, 3596, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__242)) __PYX_ERR(0, 3596, __pyx_L1_error)

  /* "validator.pyx":3619
 * 
 * 
 * def check_symmetric(array, *, tol=1e-10, raise_warning=True, raise_exception=False):             # <<<<<<<<<<<<<<
 *     """Make sure that array is 2D, square and symmetric.
 *     If the array is not symmetric, then a symmetrized version is returned.
 */
  __pyx_tuple__243 = PyTuple_Pack(7, __pyx_n_s_array, __pyx_n_s_tol, __pyx_n_s_raise_warning, __pyx_n_s_raise_exception, __pyx_n_s_diff, __pyx_n_s_symmetric, __pyx_n_s_conversion); if (unlikely(!__pyx_tuple__243)) __PYX_ERR(0, 3619, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__243);
  __Pyx_GIVEREF(__pyx_tuple__243);
  __pyx_codeobj__244 = (PyObject*)__Pyx_PyCode_New(1, 3, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__243, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_symmetric, 3619, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__244)) __PYX_ERR(0, 3619, __pyx_L1_error)

  /* "validator.pyx":3673
 *     return array
 * 
 * def check_scalar(             # <<<<<<<<<<<<<<
 *     x,
 *     name,
 */
  __pyx_tuple__245 = PyTuple_Pack(14, __pyx_n_s_x, __pyx_n_s_name_2, __pyx_n_s_target_type, __pyx_n_s_min_val, __pyx_n_s_max_val, __pyx_n_s_include_boundaries, __pyx_n_s_type_name, __pyx_n_s_type_name, __pyx_n_s_types_str, __pyx_n_s_target_type_str, __pyx_n_s_expected_include_boundaries, __pyx_n_s_comparison_operator, __pyx_n_s_genexpr, __pyx_n_s_genexpr); if (unlikely(!__pyx_tuple__245)) __PYX_ERR(0, 3673, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__245);
  __Pyx_GIVEREF(__pyx_tuple__245);
  __pyx_codeobj__246 = (PyObject*)__Pyx_PyCode_New(3, 3, 14, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__245, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_scalar, 3673, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__246)) __PYX_ERR(0, 3673, __pyx_L1_error)

  /* "validator.pyx":3785
 * 
 * 
 * def _get_feature_names(X):             # <<<<<<<<<<<<<<
 *     """Get feature names from X.
 *     Support for other array containers should place its implementation here.
 */
  __pyx_tuple__247 = PyTuple_Pack(5, __pyx_n_s_X, __pyx_n_s_feature_names, __pyx_n_s_types, __pyx_n_s_genexpr, __pyx_n_s_genexpr); if (unlikely(!__pyx_tuple__247)) __PYX_ERR(0, 3785, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__247);
  __Pyx_GIVEREF(__pyx_tuple__247);
  __pyx_codeobj__248 = (PyObject*)__Pyx_PyCode_New(1, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__247, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_get_feature_names, 3785, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__248)) __PYX_ERR(0, 3785, __pyx_L1_error)

  /* "validator.pyx":3823
 *         return feature_names
 * 
 * def check_is_fitted(estimator, attributes=None, *, msg=None, all_or_any=all):             # <<<<<<<<<<<<<<
 *     """Perform is_fitted validation for estimator.
 * 
 */
  __pyx_tuple__249 = PyTuple_Pack(8, __pyx_n_s_estimator, __pyx_n_s_attributes, __pyx_n_s_msg, __pyx_n_s_all_or_any, __pyx_n_s_NotFittedError, __pyx_n_s_fitted, __pyx_n_s_attr, __pyx_n_s_v); if (unlikely(!__pyx_tuple__249)) __PYX_ERR(0, 3823, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__249);
  __Pyx_GIVEREF(__pyx_tuple__249);
  __pyx_codeobj__250 = (PyObject*)__Pyx_PyCode_New(2, 2, 8, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__249, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_is_fitted, 3823, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__250)) __PYX_ERR(0, 3823, __pyx_L1_error)

  /* "validator.pyx":3894
 *         raise NotFittedError(msg % {"name": type(estimator).__name__})
 * 
 * def _check_feature_names_in(estimator, input_features=None, *, generate_names=True):             # <<<<<<<<<<<<<<
 *     """Check `input_features` and generate names if needed.
 *     Commonly used in :term:`get_feature_names_out`.
 */
  __pyx_tuple__251 = PyTuple_Pack(6, __pyx_n_s_estimator, __pyx_n_s_input_features, __pyx_n_s_generate_names, __pyx_n_s_feature_names_in, __pyx_n_s_n_features_in, __pyx_n_s_i); if (unlikely(!__pyx_tuple__251)) __PYX_ERR(0, 3894, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__251);
  __Pyx_GIVEREF(__pyx_tuple__251);
  __pyx_codeobj__252 = (PyObject*)__Pyx_PyCode_New(2, 1, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__251, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_feature_names_in, 3894, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__252)) __PYX_ERR(0, 3894, __pyx_L1_error)

  /* "validator.pyx":3947
 *     return np.asarray([f"x{i}" for i in range(n_features_in_)], dtype=object)
 * 
 * def _pandas_dtype_needs_early_conversion(pd_dtype):             # <<<<<<<<<<<<<<
 *     """Return True if pandas extension pd_dtype need to be converted early."""
 *     # Check these early for pandas versions without extension dtypes
 */
  __pyx_tuple__253 = PyTuple_Pack(5, __pyx_n_s_pd_dtype, __pyx_n_s_is_bool_dtype, __pyx_n_s_is_float_dtype, __pyx_n_s_is_integer_dtype, __pyx_n_s_is_extension_array_dtype); if (unlikely(!__pyx_tuple__253)) __PYX_ERR(0, 3947, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__253);
  __Pyx_GIVEREF(__pyx_tuple__253);
  __pyx_codeobj__254 = (PyObject*)__Pyx_PyCode_New(1, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__253, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_pandas_dtype_needs_early_conver, 3947, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__254)) __PYX_ERR(0, 3947, __pyx_L1_error)

  /* "validator.pyx":3986
 *     return False
 * 
 * def _ensure_no_complex_data(array):             # <<<<<<<<<<<<<<
 *     if (
 *         hasattr(array, "dtype")
 */
  __pyx_tuple__255 = PyTuple_Pack(1, __pyx_n_s_array); if (unlikely(!__pyx_tuple__255)) __PYX_ERR(0, 3986, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__255);
  __Pyx_GIVEREF(__pyx_tuple__255);
  __pyx_codeobj__256 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__255, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_ensure_no_complex_data, 3986, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__256)) __PYX_ERR(0, 3986, __pyx_L1_error)

  /* "validator.pyx":3996
 * 
 * 
 * def _check_estimator_name(estimator):             # <<<<<<<<<<<<<<
 *     if estimator is not None:
 *         if isinstance(estimator, str):
 */
  __pyx_tuple__257 = PyTuple_Pack(1, __pyx_n_s_estimator); if (unlikely(!__pyx_tuple__257)) __PYX_ERR(0, 3996, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__257);
  __Pyx_GIVEREF(__pyx_tuple__257);
  __pyx_codeobj__258 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__257, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_estimator_name, 3996, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__258)) __PYX_ERR(0, 3996, __pyx_L1_error)

  /* "validator.pyx":4004
 *     return None
 * 
 * def set_array_back (X, *,  to_frame=False, columns = None, input_name ='X'):             # <<<<<<<<<<<<<<
 *     """ Set array back to frame, reconvert the Numpy array to pandas series
 *     or dataframe.
 */
  __pyx_tuple__259 = PyTuple_Pack(5, __pyx_n_s_X, __pyx_n_s_to_frame, __pyx_n_s_columns, __pyx_n_s_input_name, __pyx_n_s_type_col_name); if (unlikely(!__pyx_tuple__259)) __PYX_ERR(0, 4004, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__259);
  __Pyx_GIVEREF(__pyx_tuple__259);
  __pyx_codeobj__260 = (PyObject*)__Pyx_PyCode_New(1, 3, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__259, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_set_array_back, 4004, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__260)) __PYX_ERR(0, 4004, __pyx_L1_error)

  /* "validator.pyx":4085
 *     return X, columns
 * 
 * def convert_array_to_pandas(X, *, to_frame=False, columns=None, input_name='X'):             # <<<<<<<<<<<<<<
 *     """
 *     Converts an array-like object to a pandas DataFrame or Series, applying
 */
  __pyx_tuple__261 = PyTuple_Pack(4, __pyx_n_s_X, __pyx_n_s_to_frame, __pyx_n_s_columns, __pyx_n_s_input_name); if (unlikely(!__pyx_tuple__261)) __PYX_ERR(0, 4085, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__261);
  __Pyx_GIVEREF(__pyx_tuple__261);
  __pyx_codeobj__262 = (PyObject*)__Pyx_PyCode_New(1, 3, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__261, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_convert_array_to_pandas, 4085, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__262)) __PYX_ERR(0, 4085, __pyx_L1_error)

  /* "validator.pyx":4157
 *     return X, columns
 * 
 * def is_frame (arr, df_only =False, raise_exception: bool=False,             # <<<<<<<<<<<<<<
 *               objname=None  ):
 *     """ Return bool wether array is a frame ( pd.Series or pd.DataFrame )
 */
  __pyx_tuple__263 = PyTuple_Pack(5, __pyx_n_s_arr, __pyx_n_s_df_only, __pyx_n_s_raise_exception, __pyx_n_s_objname, __pyx_n_s_isf); if (unlikely(!__pyx_tuple__263)) __PYX_ERR(0, 4157, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__263);
  __Pyx_GIVEREF(__pyx_tuple__263);
  __pyx_codeobj__264 = (PyObject*)__Pyx_PyCode_New(4, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__263, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_is_frame, 4157, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__264)) __PYX_ERR(0, 4157, __pyx_L1_error)

  /* "validator.pyx":4179
 * 
 * 
 * def check_array(             # <<<<<<<<<<<<<<
 *     array,
 *     *,
 */
  __pyx_tuple__265 = PyTuple_Pack(30, __pyx_n_s_array, __pyx_n_s_accept_large_sparse, __pyx_n_s_dtype, __pyx_n_s_accept_sparse, __pyx_n_s_order, __pyx_n_s_copy, __pyx_n_s_force_all_finite, __pyx_n_s_ensure_2d, __pyx_n_s_allow_nd, __pyx_n_s_ensure_min_samples, __pyx_n_s_ensure_min_features, __pyx_n_s_estimator, __pyx_n_s_input_name, __pyx_n_s_to_frame, __pyx_n_s_xp, __pyx_n_s_is_array_api, __pyx_n_s_column_orig, __pyx_n_s_array_orig, __pyx_n_s_dtype_numeric, __pyx_n_s_dtype_orig, __pyx_n_s_dtypes_orig, __pyx_n_s_pandas_requires_conversion, __pyx_n_s_new_dtype, __pyx_n_s_estimator_name, __pyx_n_s_complex_warning, __pyx_n_s_n_samples, __pyx_n_s_n_features, __pyx_n_s_genexpr, __pyx_n_s_genexpr, __pyx_n_s_genexpr); if (unlikely(!__pyx_tuple__265)) __PYX_ERR(0, 4179, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__265);
  __Pyx_GIVEREF(__pyx_tuple__265);
  __pyx_codeobj__266 = (PyObject*)__Pyx_PyCode_New(1, 13, 30, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__265, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_array, 4179, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__266)) __PYX_ERR(0, 4179, __pyx_L1_error)

  /* "validator.pyx":4489
 *     return array
 * 
 * def check_X_y(             # <<<<<<<<<<<<<<
 *     X,
 *     y,
 */
  __pyx_tuple__267 = PyTuple_Pack(17, __pyx_n_s_X, __pyx_n_s_y, __pyx_n_s_accept_sparse, __pyx_n_s_accept_large_sparse, __pyx_n_s_dtype, __pyx_n_s_order, __pyx_n_s_copy, __pyx_n_s_force_all_finite, __pyx_n_s_ensure_2d, __pyx_n_s_allow_nd, __pyx_n_s_multi_output, __pyx_n_s_ensure_min_samples, __pyx_n_s_ensure_min_features, __pyx_n_s_y_numeric, __pyx_n_s_estimator, __pyx_n_s_to_frame, __pyx_n_s_estimator_name); if (unlikely(!__pyx_tuple__267)) __PYX_ERR(0, 4489, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__267);
  __Pyx_GIVEREF(__pyx_tuple__267);
  __pyx_codeobj__268 = (PyObject*)__Pyx_PyCode_New(3, 13, 17, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__267, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_X_y, 4489, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__268)) __PYX_ERR(0, 4489, __pyx_L1_error)

  /* "validator.pyx":4622
 * 
 * 
 * def check_y(y,             # <<<<<<<<<<<<<<
 *     multi_output=False,
 *     y_numeric=False,
 */
  __pyx_tuple__269 = PyTuple_Pack(9, __pyx_n_s_y, __pyx_n_s_multi_output, __pyx_n_s_y_numeric, __pyx_n_s_input_name, __pyx_n_s_estimator, __pyx_n_s_to_frame, __pyx_n_s_allow_nan_2, __pyx_n_s_column_orig, __pyx_n_s_estimator_name); if (unlikely(!__pyx_tuple__269)) __PYX_ERR(0, 4622, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__269);
  __Pyx_GIVEREF(__pyx_tuple__269);
  __pyx_codeobj__270 = (PyObject*)__Pyx_PyCode_New(7, 0, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__269, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_y, 4622, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__270)) __PYX_ERR(0, 4622, __pyx_L1_error)

  /* "validator.pyx":4693
 *     return y
 * 
 * def validate_dtype_selector(dtype_selector: str) -> str:             # <<<<<<<<<<<<<<
 *     """
 *     Validates and categorizes the dtype_selector using regex, including handling
 */
  __pyx_tuple__271 = PyTuple_Pack(7, __pyx_n_s_dtype_selector, __pyx_n_s_types, __pyx_n_s_numeric_pattern, __pyx_n_s_categoric_pattern, __pyx_n_s_datetime_pattern, __pyx_n_s_biselect_pattern, __pyx_n_s_suffix); if (unlikely(!__pyx_tuple__271)) __PYX_ERR(0, 4693, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__271);
  __Pyx_GIVEREF(__pyx_tuple__271);
  __pyx_codeobj__272 = (PyObject*)__Pyx_PyCode_New(1, 0, 7, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__271, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_validate_dtype_selector, 4693, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__272)) __PYX_ERR(0, 4693, __pyx_L1_error)

  /* "validator.pyx":4735
 *         f"Invalid dtype_selector provided. Valid options are :{types}")
 * 
 * def build_data_if(             # <<<<<<<<<<<<<<
 *     data,
 *     columns=None,
 */
  __pyx_tuple__273 = PyTuple_Pack(10, __pyx_n_s_data, __pyx_n_s_columns, __pyx_n_s_to_frame, __pyx_n_s_input_name, __pyx_n_s_force, __pyx_n_s_raise_warning, __pyx_n_s_raise_exception, __pyx_n_s_coerce_datetime, __pyx_n_s_msg, __pyx_n_s_i); if (unlikely(!__pyx_tuple__273)) __PYX_ERR(0, 4735, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__273);
  __Pyx_GIVEREF(__pyx_tuple__273);
  __pyx_codeobj__274 = (PyObject*)__Pyx_PyCode_New(8, 0, 10, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__273, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_build_data_if, 4735, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__274)) __PYX_ERR(0, 4735, __pyx_L1_error)

  /* "validator.pyx":4821
 *     return data  # Return original data if conditions are not met
 * 
 * def build_data_if2(             # <<<<<<<<<<<<<<
 *     data: Union[dict, np.ndarray, pd.DataFrame],
 *     columns=None,
 */
  __pyx_tuple__275 = PyTuple_Pack(6, __pyx_n_s_data, __pyx_n_s_columns, __pyx_n_s_to_frame, __pyx_n_s_input_name, __pyx_n_s_force, __pyx_n_s_kws); if (unlikely(!__pyx_tuple__275)) __PYX_ERR(0, 4821, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__275);
  __Pyx_GIVEREF(__pyx_tuple__275);
  __pyx_codeobj__276 = (PyObject*)__Pyx_PyCode_New(5, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS|CO_VARKEYWORDS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__275, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_build_data_if2, 4821, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__276)) __PYX_ERR(0, 4821, __pyx_L1_error)

  /* "validator.pyx":4885
 *         )
 * 
 * def array_to_frame(             # <<<<<<<<<<<<<<
 *     X,
 *     *,
 */
  __pyx_tuple__277 = PyTuple_Pack(10, __pyx_n_s_X, __pyx_n_s_to_frame, __pyx_n_s_columns, __pyx_n_s_raise_exception, __pyx_n_s_raise_warning, __pyx_n_s_input_name, __pyx_n_s_force, __pyx_n_s_msg, __pyx_n_s__102, __pyx_n_s_i); if (unlikely(!__pyx_tuple__277)) __PYX_ERR(0, 4885, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__277);
  __Pyx_GIVEREF(__pyx_tuple__277);
  __pyx_codeobj__278 = (PyObject*)__Pyx_PyCode_New(1, 6, 10, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__277, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_array_to_frame, 4885, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__278)) __PYX_ERR(0, 4885, __pyx_L1_error)

  /* "validator.pyx":4956
 *     return X
 * 
 * def array_to_frame2(             # <<<<<<<<<<<<<<
 *     X,
 *     *,
 */
  __pyx_tuple__279 = PyTuple_Pack(11, __pyx_n_s_X, __pyx_n_s_to_frame, __pyx_n_s_columns, __pyx_n_s_raise_exception, __pyx_n_s_raise_warning, __pyx_n_s_input_name, __pyx_n_s_force, __pyx_n_s_isf, __pyx_n_s_msg, __pyx_n_s__102, __pyx_n_s_i); if (unlikely(!__pyx_tuple__279)) __PYX_ERR(0, 4956, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__279);
  __Pyx_GIVEREF(__pyx_tuple__279);
  __pyx_codeobj__280 = (PyObject*)__Pyx_PyCode_New(1, 6, 11, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__279, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_array_to_frame2, 4956, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__280)) __PYX_ERR(0, 4956, __pyx_L1_error)

  /* "validator.pyx":5045
 *     return X
 * 
 * def _check_y_1d(y, *, warn=False, input_name ='y'):             # <<<<<<<<<<<<<<
 *     """Ravel column or 1d numpy array, else raises an error.
 * 
 */
  __pyx_tuple__281 = PyTuple_Pack(6, __pyx_n_s_y, __pyx_n_s_warn, __pyx_n_s_input_name, __pyx_n_s_xp, __pyx_n_s__102, __pyx_n_s_shape); if (unlikely(!__pyx_tuple__281)) __PYX_ERR(0, 5045, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__281);
  __Pyx_GIVEREF(__pyx_tuple__281);
  __pyx_codeobj__282 = (PyObject*)__Pyx_PyCode_New(1, 2, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__281, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_y_1d, 5045, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__282)) __PYX_ERR(0, 5045, __pyx_L1_error)

  /* "validator.pyx":5084
 *                      f" an array of shape {shape} instead.")
 * 
 * def _check_large_sparse(X, accept_large_sparse=False):             # <<<<<<<<<<<<<<
 *     """Raise a ValueError if X has 64bit indices and accept_large_sparse=False"""
 *     if not accept_large_sparse:
 */
  __pyx_tuple__283 = PyTuple_Pack(6, __pyx_n_s_X, __pyx_n_s_accept_large_sparse, __pyx_n_s_supported_indices, __pyx_n_s_index_keys, __pyx_n_s_key, __pyx_n_s_indices_datatype); if (unlikely(!__pyx_tuple__283)) __PYX_ERR(0, 5084, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__283);
  __Pyx_GIVEREF(__pyx_tuple__283);
  __pyx_codeobj__284 = (PyObject*)__Pyx_PyCode_New(2, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__283, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_check_large_sparse, 5084, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__284)) __PYX_ERR(0, 5084, __pyx_L1_error)

  /* "validator.pyx":5101
 *                     " indices are accepted. Got %s indices." % indices_datatype
 *                 )
 * def _ensure_sparse_format(             # <<<<<<<<<<<<<<
 *     spmatrix,
 *     accept_sparse,
 */
  __pyx_tuple__285 = PyTuple_Pack(9, __pyx_n_s_spmatrix, __pyx_n_s_accept_sparse, __pyx_n_s_dtype, __pyx_n_s_copy, __pyx_n_s_force_all_finite, __pyx_n_s_accept_large_sparse, __pyx_n_s_estimator_name, __pyx_n_s_input_name, __pyx_n_s_changed_format); if (unlikely(!__pyx_tuple__285)) __PYX_ERR(0, 5101, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__285);
  __Pyx_GIVEREF(__pyx_tuple__285);
  __pyx_codeobj__286 = (PyObject*)__Pyx_PyCode_New(8, 0, 9, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__285, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_ensure_sparse_format, 5101, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__286)) __PYX_ERR(0, 5101, __pyx_L1_error)

  /* "validator.pyx":5211
 *     return spmatrix
 * 
 * def _object_dtype_isnan(X):             # <<<<<<<<<<<<<<
 *     return X != X
 * 
 */
  __pyx_tuple__287 = PyTuple_Pack(1, __pyx_n_s_X); if (unlikely(!__pyx_tuple__287)) __PYX_ERR(0, 5211, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__287);
  __Pyx_GIVEREF(__pyx_tuple__287);
  __pyx_codeobj__288 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__287, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_object_dtype_isnan, 5211, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__288)) __PYX_ERR(0, 5211, __pyx_L1_error)

  /* "validator.pyx":5214
 *     return X != X
 * 
 * def _assert_all_finite(             # <<<<<<<<<<<<<<
 *     X, allow_nan=False, msg_dtype=None, estimator_name=None, input_name=""
 * ):
 */
  __pyx_tuple__289 = PyTuple_Pack(14, __pyx_n_s_X, __pyx_n_s_allow_nan_2, __pyx_n_s_msg_dtype, __pyx_n_s_estimator_name, __pyx_n_s_input_name, __pyx_n_s_err_msg, __pyx_n_s_xp, __pyx_n_s__102, __pyx_n_s_first_pass_isfinite, __pyx_n_s_has_inf, __pyx_n_s_has_nan_error, __pyx_n_s_type_err, __pyx_n_s_padded_input_name, __pyx_n_s_msg_err); if (unlikely(!__pyx_tuple__289)) __PYX_ERR(0, 5214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__289);
  __Pyx_GIVEREF(__pyx_tuple__289);
  __pyx_codeobj__290 = (PyObject*)__Pyx_PyCode_New(5, 0, 14, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__289, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_assert_all_finite, 5214, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__290)) __PYX_ERR(0, 5214, __pyx_L1_error)

  /* "validator.pyx":5290
 *         raise ValueError(msg_err)
 * 
 * def assert_all_finite(             # <<<<<<<<<<<<<<
 *     X,
 *     *,
 */
  __pyx_tuple__291 = PyTuple_Pack(4, __pyx_n_s_X, __pyx_n_s_allow_nan_2, __pyx_n_s_estimator_name, __pyx_n_s_input_name); if (unlikely(!__pyx_tuple__291)) __PYX_ERR(0, 5290, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__291);
  __Pyx_GIVEREF(__pyx_tuple__291);
  __pyx_codeobj__292 = (PyObject*)__Pyx_PyCode_New(1, 3, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__291, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_assert_all_finite_2, 5290, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__292)) __PYX_ERR(0, 5290, __pyx_L1_error)

  /* "validator.pyx":5319
 *     )
 * 
 * def _generate_get_feature_names_out(estimator, n_features_out, input_features=None):             # <<<<<<<<<<<<<<
 *     """Generate feature names out for estimator using the estimator name as the prefix.
 *     The input_feature names are validated but not used. This function is useful
 */
  __pyx_tuple__293 = PyTuple_Pack(5, __pyx_n_s_estimator, __pyx_n_s_n_features_out, __pyx_n_s_input_features, __pyx_n_s_estimator_name, __pyx_n_s_i); if (unlikely(!__pyx_tuple__293)) __PYX_ERR(0, 5319, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__293);
  __Pyx_GIVEREF(__pyx_tuple__293);
  __pyx_codeobj__294 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__293, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_validator_pyx, __pyx_n_s_generate_get_feature_names_out, 5319, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__294)) __PYX_ERR(0, 5319, __pyx_L1_error)

  /* "validator.pyx":5342
 *     )
 * 
 * class PositiveSpectrumWarning(UserWarning):             # <<<<<<<<<<<<<<
 *     """Warning raised when the eigenvalues of a PSD matrix have issues
 *     This warning is typically raised by ``_check_psd_eigenvalues`` when the
 */
  __pyx_tuple__295 = PyTuple_Pack(1, __pyx_builtin_UserWarning); if (unlikely(!__pyx_tuple__295)) __PYX_ERR(0, 5342, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__295);
  __Pyx_GIVEREF(__pyx_tuple__295);

  /* "validator.pyx":5350
 *     .. versionadded:: 0.22
 *     """
 * class DataConversionWarning(UserWarning):             # <<<<<<<<<<<<<<
 *     """Warning used to notify implicit data conversions happening in the code.
 *     This warning occurs when some input data needs to be converted or
 */
  __pyx_tuple__296 = PyTuple_Pack(1, __pyx_builtin_UserWarning); if (unlikely(!__pyx_tuple__296)) __PYX_ERR(0, 5350, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__296);
  __Pyx_GIVEREF(__pyx_tuple__296);
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
  __pyx_umethod_PyDict_Type_get.type = (PyObject*)&PyDict_Type;
  __pyx_umethod_PyDict_Type_update.type = (PyObject*)&PyDict_Type;
  __pyx_umethod_PyUnicode_Type_format.type = (PyObject*)&PyUnicode_Type;
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_ = PyFloat_FromDouble(0.); if (unlikely(!__pyx_float_0_)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_0_5 = PyFloat_FromDouble(0.5); if (unlikely(!__pyx_float_0_5)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_1eneg_5 = PyFloat_FromDouble(1e-5); if (unlikely(!__pyx_float_1eneg_5)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_1eneg_10 = PyFloat_FromDouble(1e-10); if (unlikely(!__pyx_float_1eneg_10)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_float_1eneg_15 = PyFloat_FromDouble(1e-15); if (unlikely(!__pyx_float_1eneg_15)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_2 = PyInt_FromLong(2); if (unlikely(!__pyx_int_2)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_3 = PyInt_FromLong(3); if (unlikely(!__pyx_int_3)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_1900 = PyInt_FromLong(1900); if (unlikely(!__pyx_int_1900)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_neg_1 = PyInt_FromLong(-1); if (unlikely(!__pyx_int_neg_1)) __PYX_ERR(0, 1, __pyx_L1_error)
  return 0;
  __pyx_L1_error:;
  return -1;
}

static CYTHON_SMALL_CODE int __Pyx_modinit_global_init_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_variable_export_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_function_export_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_type_init_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_type_import_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_variable_import_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_function_import_code(void); /*proto*/

static int __Pyx_modinit_global_init_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_global_init_code", 0);
  /*--- Global init code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_variable_export_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_variable_export_code", 0);
  /*--- Variable export code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_function_export_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_function_export_code", 0);
  /*--- Function export code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_type_init_code(void) {
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
  /*--- Type init code ---*/
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct__validate_scores) < 0) __PYX_ERR(0, 159, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct__validate_scores.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct__validate_scores.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct__validate_scores.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct__validate_scores.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct__validate_scores = &__pyx_type_9validator___pyx_scope_struct__validate_scores;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_1_genexpr) < 0) __PYX_ERR(0, 239, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_1_genexpr.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_1_genexpr.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_1_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_1_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_1_genexpr = &__pyx_type_9validator___pyx_scope_struct_1_genexpr;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_2_validate_data_types) < 0) __PYX_ERR(0, 999, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_2_validate_data_types.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_2_validate_data_types.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_2_validate_data_types.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_2_validate_data_types.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_2_validate_data_types = &__pyx_type_9validator___pyx_scope_struct_2_validate_data_types;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_3_parameter_validator) < 0) __PYX_ERR(0, 1275, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_3_parameter_validator.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_3_parameter_validator.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_3_parameter_validator.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_3_parameter_validator.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_3_parameter_validator = &__pyx_type_9validator___pyx_scope_struct_3_parameter_validator;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_4_validate_length_range) < 0) __PYX_ERR(0, 1424, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_4_validate_length_range.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_4_validate_length_range.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_4_validate_length_range.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_4_validate_length_range.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_4_validate_length_range = &__pyx_type_9validator___pyx_scope_struct_4_validate_length_range;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_5_genexpr) < 0) __PYX_ERR(0, 1467, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_5_genexpr.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_5_genexpr.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_5_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_5_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_5_genexpr = &__pyx_type_9validator___pyx_scope_struct_5_genexpr;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_6_contains_nested_objects) < 0) __PYX_ERR(0, 1481, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_6_contains_nested_objects.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_6_contains_nested_objects.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_6_contains_nested_objects.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_6_contains_nested_objects.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_6_contains_nested_objects = &__pyx_type_9validator___pyx_scope_struct_6_contains_nested_objects;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_7_genexpr) < 0) __PYX_ERR(0, 1537, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_7_genexpr.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_7_genexpr.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_7_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_7_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_7_genexpr = &__pyx_type_9validator___pyx_scope_struct_7_genexpr;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_8_genexpr) < 0) __PYX_ERR(0, 1540, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_8_genexpr.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_8_genexpr.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_8_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_8_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_8_genexpr = &__pyx_type_9validator___pyx_scope_struct_8_genexpr;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_9_validate_nan_policy) < 0) __PYX_ERR(0, 1542, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_9_validate_nan_policy.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_9_validate_nan_policy.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_9_validate_nan_policy.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_9_validate_nan_policy.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_9_validate_nan_policy = &__pyx_type_9validator___pyx_scope_struct_9_validate_nan_policy;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_10_genexpr) < 0) __PYX_ERR(0, 1613, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_10_genexpr.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_10_genexpr.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_10_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_10_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_10_genexpr = &__pyx_type_9validator___pyx_scope_struct_10_genexpr;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_11_genexpr) < 0) __PYX_ERR(0, 1619, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_11_genexpr.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_11_genexpr.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_11_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_11_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_11_genexpr = &__pyx_type_9validator___pyx_scope_struct_11_genexpr;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_12_check_classification_targets) < 0) __PYX_ERR(0, 2011, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_12_check_classification_targets.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_12_check_classification_targets.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_12_check_classification_targets.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_12_check_classification_targets.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_12_check_classification_targets = &__pyx_type_9validator___pyx_scope_struct_12_check_classification_targets;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_13_genexpr) < 0) __PYX_ERR(0, 2132, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_13_genexpr.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_13_genexpr.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_13_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_13_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_13_genexpr = &__pyx_type_9validator___pyx_scope_struct_13_genexpr;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_14__check_y) < 0) __PYX_ERR(0, 2158, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_14__check_y.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_14__check_y.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_14__check_y.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_14__check_y.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_14__check_y = &__pyx_type_9validator___pyx_scope_struct_14__check_y;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_15_genexpr) < 0) __PYX_ERR(0, 2182, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_15_genexpr.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_15_genexpr.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_15_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_15_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_15_genexpr = &__pyx_type_9validator___pyx_scope_struct_15_genexpr;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_16_genexpr) < 0) __PYX_ERR(0, 2207, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_16_genexpr.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_16_genexpr.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_16_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_16_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_16_genexpr = &__pyx_type_9validator___pyx_scope_struct_16_genexpr;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_17_has_required_attributes) < 0) __PYX_ERR(0, 2354, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_17_has_required_attributes.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_17_has_required_attributes.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_17_has_required_attributes.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_17_has_required_attributes.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_17_has_required_attributes = &__pyx_type_9validator___pyx_scope_struct_17_has_required_attributes;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_18_genexpr) < 0) __PYX_ERR(0, 2375, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_18_genexpr.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_18_genexpr.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_18_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_18_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_18_genexpr = &__pyx_type_9validator___pyx_scope_struct_18_genexpr;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_19_validate_dates) < 0) __PYX_ERR(0, 2377, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_19_validate_dates.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_19_validate_dates.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_19_validate_dates.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_19_validate_dates.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_19_validate_dates = &__pyx_type_9validator___pyx_scope_struct_19_validate_dates;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_20_validate_and_adjust_ranges) < 0) __PYX_ERR(0, 2541, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_20_validate_and_adjust_ranges.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_20_validate_and_adjust_ranges.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_20_validate_and_adjust_ranges.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_20_validate_and_adjust_ranges.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_20_validate_and_adjust_ranges = &__pyx_type_9validator___pyx_scope_struct_20_validate_and_adjust_ranges;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_21_genexpr) < 0) __PYX_ERR(0, 2595, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_21_genexpr.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_21_genexpr.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_21_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_21_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_21_genexpr = &__pyx_type_9validator___pyx_scope_struct_21_genexpr;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_22__validate_input) < 0) __PYX_ERR(0, 3159, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_22__validate_input.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_22__validate_input.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_22__validate_input.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_22__validate_input.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_22__validate_input = &__pyx_type_9validator___pyx_scope_struct_22__validate_input;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_23__deprecate_positional_args) < 0) __PYX_ERR(0, 3348, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_23__deprecate_positional_args.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_23__deprecate_positional_args.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_23__deprecate_positional_args.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_23__deprecate_positional_args.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_23__deprecate_positional_args = &__pyx_type_9validator___pyx_scope_struct_23__deprecate_positional_args;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_24__inner_deprecate_positional_args) < 0) __PYX_ERR(0, 3360, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_24__inner_deprecate_positional_args.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_24__inner_deprecate_positional_args.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_24__inner_deprecate_positional_args.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_24__inner_deprecate_positional_args.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_24__inner_deprecate_positional_args = &__pyx_type_9validator___pyx_scope_struct_24__inner_deprecate_positional_args;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_25_check_scalar) < 0) __PYX_ERR(0, 3673, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_25_check_scalar.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_25_check_scalar.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_25_check_scalar.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_25_check_scalar.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_25_check_scalar = &__pyx_type_9validator___pyx_scope_struct_25_check_scalar;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_26_genexpr) < 0) __PYX_ERR(0, 3735, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_26_genexpr.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_26_genexpr.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_26_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_26_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_26_genexpr = &__pyx_type_9validator___pyx_scope_struct_26_genexpr;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_27__get_feature_names) < 0) __PYX_ERR(0, 3785, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_27__get_feature_names.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_27__get_feature_names.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_27__get_feature_names.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_27__get_feature_names.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_27__get_feature_names = &__pyx_type_9validator___pyx_scope_struct_27__get_feature_names;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_28_genexpr) < 0) __PYX_ERR(0, 3810, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_28_genexpr.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_28_genexpr.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_28_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_28_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_28_genexpr = &__pyx_type_9validator___pyx_scope_struct_28_genexpr;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_29_genexpr) < 0) __PYX_ERR(0, 3810, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_29_genexpr.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_29_genexpr.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_29_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_29_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_29_genexpr = &__pyx_type_9validator___pyx_scope_struct_29_genexpr;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_30_check_array) < 0) __PYX_ERR(0, 4179, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_30_check_array.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_30_check_array.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_30_check_array.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_30_check_array.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_30_check_array = &__pyx_type_9validator___pyx_scope_struct_30_check_array;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_31_genexpr) < 0) __PYX_ERR(0, 4315, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_31_genexpr.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_31_genexpr.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_31_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_31_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_31_genexpr = &__pyx_type_9validator___pyx_scope_struct_31_genexpr;
  if (PyType_Ready(&__pyx_type_9validator___pyx_scope_struct_32_genexpr) < 0) __PYX_ERR(0, 4317, __pyx_L1_error)
  #if PY_VERSION_HEX < 0x030800B1
  __pyx_type_9validator___pyx_scope_struct_32_genexpr.tp_print = 0;
  #endif
  if ((CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP) && likely(!__pyx_type_9validator___pyx_scope_struct_32_genexpr.tp_dictoffset && __pyx_type_9validator___pyx_scope_struct_32_genexpr.tp_getattro == PyObject_GenericGetAttr)) {
    __pyx_type_9validator___pyx_scope_struct_32_genexpr.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
  }
  __pyx_ptype_9validator___pyx_scope_struct_32_genexpr = &__pyx_type_9validator___pyx_scope_struct_32_genexpr;
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_modinit_type_import_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
  /*--- Type import code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_variable_import_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_variable_import_code", 0);
  /*--- Variable import code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_function_import_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_function_import_code", 0);
  /*--- Function import code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}


#ifndef CYTHON_NO_PYINIT_EXPORT
#define __Pyx_PyMODINIT_FUNC PyMODINIT_FUNC
#elif PY_MAJOR_VERSION < 3
#ifdef __cplusplus
#define __Pyx_PyMODINIT_FUNC extern "C" void
#else
#define __Pyx_PyMODINIT_FUNC void
#endif
#else
#ifdef __cplusplus
#define __Pyx_PyMODINIT_FUNC extern "C" PyObject *
#else
#define __Pyx_PyMODINIT_FUNC PyObject *
#endif
#endif


#if PY_MAJOR_VERSION < 3
__Pyx_PyMODINIT_FUNC initvalidator(void) CYTHON_SMALL_CODE; /*proto*/
__Pyx_PyMODINIT_FUNC initvalidator(void)
#else
__Pyx_PyMODINIT_FUNC PyInit_validator(void) CYTHON_SMALL_CODE; /*proto*/
__Pyx_PyMODINIT_FUNC PyInit_validator(void)
#if CYTHON_PEP489_MULTI_PHASE_INIT
{
  return PyModuleDef_Init(&__pyx_moduledef);
}
static CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {
    #if PY_VERSION_HEX >= 0x030700A1
    static PY_INT64_T main_interpreter_id = -1;
    PY_INT64_T current_id = PyInterpreterState_GetID(PyThreadState_Get()->interp);
    if (main_interpreter_id == -1) {
        main_interpreter_id = current_id;
        return (unlikely(current_id == -1)) ? -1 : 0;
    } else if (unlikely(main_interpreter_id != current_id))
    #else
    static PyInterpreterState *main_interpreter = NULL;
    PyInterpreterState *current_interpreter = PyThreadState_Get()->interp;
    if (!main_interpreter) {
        main_interpreter = current_interpreter;
    } else if (unlikely(main_interpreter != current_interpreter))
    #endif
    {
        PyErr_SetString(
            PyExc_ImportError,
            "Interpreter change detected - this module can only be loaded into one interpreter per process.");
        return -1;
    }
    return 0;
}
static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none) {
    PyObject *value = PyObject_GetAttrString(spec, from_name);
    int result = 0;
    if (likely(value)) {
        if (allow_none || value != Py_None) {
            result = PyDict_SetItemString(moddict, to_name, value);
        }
        Py_DECREF(value);
    } else if (PyErr_ExceptionMatches(PyExc_AttributeError)) {
        PyErr_Clear();
    } else {
        result = -1;
    }
    return result;
}
static CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {
    PyObject *module = NULL, *moddict, *modname;
    if (__Pyx_check_single_interpreter())
        return NULL;
    if (__pyx_m)
        return __Pyx_NewRef(__pyx_m);
    modname = PyObject_GetAttrString(spec, "name");
    if (unlikely(!modname)) goto bad;
    module = PyModule_NewObject(modname);
    Py_DECREF(modname);
    if (unlikely(!module)) goto bad;
    moddict = PyModule_GetDict(module);
    if (unlikely(!moddict)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "loader", "__loader__", 1) < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "origin", "__file__", 1) < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "parent", "__package__", 1) < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "submodule_search_locations", "__path__", 0) < 0)) goto bad;
    return module;
bad:
    Py_XDECREF(module);
    return NULL;
}


static CYTHON_SMALL_CODE int __pyx_pymod_exec_validator(PyObject *__pyx_pyinit_module)
#endif
#endif
{
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  if (__pyx_m) {
    if (__pyx_m == __pyx_pyinit_module) return 0;
    PyErr_SetString(PyExc_RuntimeError, "Module 'validator' has already been imported. Re-initialisation is not supported.");
    return -1;
  }
  #elif PY_MAJOR_VERSION >= 3
  if (__pyx_m) return __Pyx_NewRef(__pyx_m);
  #endif
  #if CYTHON_REFNANNY
__Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
if (!__Pyx_RefNanny) {
  PyErr_Clear();
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
  if (!__Pyx_RefNanny)
      Py_FatalError("failed to import 'refnanny' module");
}
#endif
  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit_validator(void)", 0);
  if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #ifdef __Pxy_PyFrame_Initialize_Offsets
  __Pxy_PyFrame_Initialize_Offsets();
  #endif
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
  #ifdef __Pyx_CyFunction_USED
  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_FusedFunction_USED
  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Coroutine_USED
  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Generator_USED
  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_AsyncGen_USED
  if (__pyx_AsyncGen_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_StopAsyncIteration_USED
  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(WITH_THREAD) && PY_VERSION_HEX < 0x030700F0 && defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  PyEval_InitThreads();
  #endif
  /*--- Module creation code ---*/
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  __pyx_m = __pyx_pyinit_module;
  Py_INCREF(__pyx_m);
  #else
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4("validator", __pyx_methods, __pyx_k_validator_module_provides_a_com, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_d);
  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_b);
  __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_cython_runtime);
  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Initialize various global constants etc. ---*/
  if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
  if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  if (__pyx_module_is_main_validator) {
    if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  }
  #if PY_MAJOR_VERSION >= 3
  {
    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
    if (!PyDict_GetItemString(modules, "validator")) {
      if (unlikely(PyDict_SetItemString(modules, "validator", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
    }
  }
  #endif
  /*--- Builtin init code ---*/
  if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Constants init code ---*/
  if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Global type/function init code ---*/
  (void)__Pyx_modinit_global_init_code();
  (void)__Pyx_modinit_variable_export_code();
  (void)__Pyx_modinit_function_export_code();
  if (unlikely(__Pyx_modinit_type_init_code() < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
  (void)__Pyx_modinit_type_import_code();
  (void)__Pyx_modinit_variable_import_code();
  (void)__Pyx_modinit_function_import_code();
  /*--- Execution code ---*/
  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif

  /* "validator.pyx":13
 * """
 * 
 * from functools import wraps             # <<<<<<<<<<<<<<
 * from typing import Any, Callable, Optional, Union
 * import re
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 13, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_wraps);
  __Pyx_GIVEREF(__pyx_n_s_wraps);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_wraps);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_functools, __pyx_t_1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_wraps); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 13, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_wraps, __pyx_t_1) < 0) __PYX_ERR(0, 13, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":14
 * 
 * from functools import wraps
 * from typing import Any, Callable, Optional, Union             # <<<<<<<<<<<<<<
 * import re
 * import inspect
 */
  __pyx_t_2 = PyList_New(4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 14, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_n_s_Any);
  __Pyx_GIVEREF(__pyx_n_s_Any);
  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_Any);
  __Pyx_INCREF(__pyx_n_s_Callable);
  __Pyx_GIVEREF(__pyx_n_s_Callable);
  PyList_SET_ITEM(__pyx_t_2, 1, __pyx_n_s_Callable);
  __Pyx_INCREF(__pyx_n_s_Optional);
  __Pyx_GIVEREF(__pyx_n_s_Optional);
  PyList_SET_ITEM(__pyx_t_2, 2, __pyx_n_s_Optional);
  __Pyx_INCREF(__pyx_n_s_Union);
  __Pyx_GIVEREF(__pyx_n_s_Union);
  PyList_SET_ITEM(__pyx_t_2, 3, __pyx_n_s_Union);
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_typing, __pyx_t_2, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 14, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_Any); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 14, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Any, __pyx_t_2) < 0) __PYX_ERR(0, 14, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_Callable); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 14, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Callable, __pyx_t_2) < 0) __PYX_ERR(0, 14, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_Optional); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 14, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Optional, __pyx_t_2) < 0) __PYX_ERR(0, 14, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_Union); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 14, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Union, __pyx_t_2) < 0) __PYX_ERR(0, 14, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":15
 * from functools import wraps
 * from typing import Any, Callable, Optional, Union
 * import re             # <<<<<<<<<<<<<<
 * import inspect
 * import types
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_re, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 15, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_re, __pyx_t_1) < 0) __PYX_ERR(0, 15, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":16
 * from typing import Any, Callable, Optional, Union
 * import re
 * import inspect             # <<<<<<<<<<<<<<
 * import types
 * import warnings
 */
  __pyx_t_1 = __Pyx_patch_inspect(__Pyx_Import(__pyx_n_s_inspect, 0, 0)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 16, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_inspect, __pyx_t_1) < 0) __PYX_ERR(0, 16, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":17
 * import re
 * import inspect
 * import types             # <<<<<<<<<<<<<<
 * import warnings
 * import numbers
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_types, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 17, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_types, __pyx_t_1) < 0) __PYX_ERR(0, 17, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":18
 * import inspect
 * import types
 * import warnings             # <<<<<<<<<<<<<<
 * import numbers
 * import operator
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_warnings, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 18, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_warnings, __pyx_t_1) < 0) __PYX_ERR(0, 18, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":19
 * import types
 * import warnings
 * import numbers             # <<<<<<<<<<<<<<
 * import operator
 * import joblib
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_numbers, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 19, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_numbers, __pyx_t_1) < 0) __PYX_ERR(0, 19, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":20
 * import warnings
 * import numbers
 * import operator             # <<<<<<<<<<<<<<
 * import joblib
 * from datetime import datetime
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_operator, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 20, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_operator, __pyx_t_1) < 0) __PYX_ERR(0, 20, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":21
 * import numbers
 * import operator
 * import joblib             # <<<<<<<<<<<<<<
 * from datetime import datetime
 * from contextlib import suppress
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_joblib, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 21, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_joblib, __pyx_t_1) < 0) __PYX_ERR(0, 21, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":22
 * import operator
 * import joblib
 * from datetime import datetime             # <<<<<<<<<<<<<<
 * from contextlib import suppress
 * 
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 22, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_datetime);
  __Pyx_GIVEREF(__pyx_n_s_datetime);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_datetime);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_datetime, __pyx_t_1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 22, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_datetime); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 22, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_datetime, __pyx_t_1) < 0) __PYX_ERR(0, 22, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":23
 * import joblib
 * from datetime import datetime
 * from contextlib import suppress             # <<<<<<<<<<<<<<
 * 
 * import numpy as np
 */
  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 23, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_n_s_suppress);
  __Pyx_GIVEREF(__pyx_n_s_suppress);
  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_suppress);
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_contextlib, __pyx_t_2, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 23, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_suppress); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 23, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_suppress, __pyx_t_2) < 0) __PYX_ERR(0, 23, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":25
 * from contextlib import suppress
 * 
 * import numpy as np             # <<<<<<<<<<<<<<
 * import pandas as pd
 * from numpy.core.numeric import ComplexWarning
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_numpy, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 25, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_np, __pyx_t_1) < 0) __PYX_ERR(0, 25, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":26
 * 
 * import numpy as np
 * import pandas as pd             # <<<<<<<<<<<<<<
 * from numpy.core.numeric import ComplexWarning
 * import scipy.sparse as sp
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_pandas, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 26, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pd, __pyx_t_1) < 0) __PYX_ERR(0, 26, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":27
 * import numpy as np
 * import pandas as pd
 * from numpy.core.numeric import ComplexWarning             # <<<<<<<<<<<<<<
 * import scipy.sparse as sp
 * from inspect import signature, Parameter, isclass
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 27, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_ComplexWarning);
  __Pyx_GIVEREF(__pyx_n_s_ComplexWarning);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_ComplexWarning);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_numpy_core_numeric, __pyx_t_1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 27, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_ComplexWarning); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 27, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ComplexWarning, __pyx_t_1) < 0) __PYX_ERR(0, 27, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":28
 * import pandas as pd
 * from numpy.core.numeric import ComplexWarning
 * import scipy.sparse as sp             # <<<<<<<<<<<<<<
 * from inspect import signature, Parameter, isclass
 * 
 */
  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 28, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_n_s__118);
  __Pyx_GIVEREF(__pyx_n_s__118);
  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s__118);
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_scipy_sparse, __pyx_t_2, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 28, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_sp, __pyx_t_1) < 0) __PYX_ERR(0, 28, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":29
 * from numpy.core.numeric import ComplexWarning
 * import scipy.sparse as sp
 * from inspect import signature, Parameter, isclass             # <<<<<<<<<<<<<<
 * 
 * from ._array_api import get_namespace, _asarray_with_order
 */
  __pyx_t_1 = PyList_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 29, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_signature);
  __Pyx_GIVEREF(__pyx_n_s_signature);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_signature);
  __Pyx_INCREF(__pyx_n_s_Parameter);
  __Pyx_GIVEREF(__pyx_n_s_Parameter);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_Parameter);
  __Pyx_INCREF(__pyx_n_s_isclass);
  __Pyx_GIVEREF(__pyx_n_s_isclass);
  PyList_SET_ITEM(__pyx_t_1, 2, __pyx_n_s_isclass);
  __pyx_t_2 = __Pyx_patch_inspect(__Pyx_Import(__pyx_n_s_inspect, __pyx_t_1, 0)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 29, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_signature); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 29, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_signature, __pyx_t_1) < 0) __PYX_ERR(0, 29, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_Parameter); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 29, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Parameter, __pyx_t_1) < 0) __PYX_ERR(0, 29, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_isclass); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 29, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_isclass, __pyx_t_1) < 0) __PYX_ERR(0, 29, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "validator.pyx":31
 * from inspect import signature, Parameter, isclass
 * 
 * from ._array_api import get_namespace, _asarray_with_order             # <<<<<<<<<<<<<<
 * FLOAT_DTYPES = (np.float64, np.float32, np.float16)
 * 
 */
  __pyx_t_2 = PyList_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 31, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_n_s_get_namespace);
  __Pyx_GIVEREF(__pyx_n_s_get_namespace);
  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_get_namespace);
  __Pyx_INCREF(__pyx_n_s_asarray_with_order);
  __Pyx_GIVEREF(__pyx_n_s_asarray_with_order);
  PyList_SET_ITEM(__pyx_t_2, 1, __pyx_n_s_asarray_with_order);
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_array_api, __pyx_t_2, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 31, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_get_namespace); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 31, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_get_namespace, __pyx_t_2) < 0) __PYX_ERR(0, 31, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_1, __pyx_n_s_asarray_with_order); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 31, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_asarray_with_order, __pyx_t_2) < 0) __PYX_ERR(0, 31, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":32
 * 
 * from ._array_api import get_namespace, _asarray_with_order
 * FLOAT_DTYPES = (np.float64, np.float32, np.float16)             # <<<<<<<<<<<<<<
 * 
 * __all__=[
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 32, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_float64); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 32, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 32, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_float32); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 32, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_np); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 32, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_float16); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 32, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PyTuple_New(3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 32, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_t_4);
  __pyx_t_2 = 0;
  __pyx_t_3 = 0;
  __pyx_t_4 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_FLOAT_DTYPES, __pyx_t_1) < 0) __PYX_ERR(0, 32, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":34
 * FLOAT_DTYPES = (np.float64, np.float32, np.float16)
 * 
 * __all__=[             # <<<<<<<<<<<<<<
 *      'DataConversionWarning',
 *      'PositiveSpectrumWarning',
 */
  __pyx_t_1 = PyList_New(62); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 34, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_u_DataConversionWarning);
  __Pyx_GIVEREF(__pyx_n_u_DataConversionWarning);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_u_DataConversionWarning);
  __Pyx_INCREF(__pyx_n_u_PositiveSpectrumWarning);
  __Pyx_GIVEREF(__pyx_n_u_PositiveSpectrumWarning);
  PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_u_PositiveSpectrumWarning);
  __Pyx_INCREF(__pyx_n_u_array_to_frame);
  __Pyx_GIVEREF(__pyx_n_u_array_to_frame);
  PyList_SET_ITEM(__pyx_t_1, 2, __pyx_n_u_array_to_frame);
  __Pyx_INCREF(__pyx_n_u_array_to_frame2);
  __Pyx_GIVEREF(__pyx_n_u_array_to_frame2);
  PyList_SET_ITEM(__pyx_t_1, 3, __pyx_n_u_array_to_frame2);
  __Pyx_INCREF(__pyx_n_u_assert_all_finite_2);
  __Pyx_GIVEREF(__pyx_n_u_assert_all_finite_2);
  PyList_SET_ITEM(__pyx_t_1, 4, __pyx_n_u_assert_all_finite_2);
  __Pyx_INCREF(__pyx_n_u_assert_xy_in);
  __Pyx_GIVEREF(__pyx_n_u_assert_xy_in);
  PyList_SET_ITEM(__pyx_t_1, 5, __pyx_n_u_assert_xy_in);
  __Pyx_INCREF(__pyx_n_u_build_data_if);
  __Pyx_GIVEREF(__pyx_n_u_build_data_if);
  PyList_SET_ITEM(__pyx_t_1, 6, __pyx_n_u_build_data_if);
  __Pyx_INCREF(__pyx_n_u_build_data_if2);
  __Pyx_GIVEREF(__pyx_n_u_build_data_if2);
  PyList_SET_ITEM(__pyx_t_1, 7, __pyx_n_u_build_data_if2);
  __Pyx_INCREF(__pyx_n_u_check_X_y);
  __Pyx_GIVEREF(__pyx_n_u_check_X_y);
  PyList_SET_ITEM(__pyx_t_1, 8, __pyx_n_u_check_X_y);
  __Pyx_INCREF(__pyx_n_u_check_array);
  __Pyx_GIVEREF(__pyx_n_u_check_array);
  PyList_SET_ITEM(__pyx_t_1, 9, __pyx_n_u_check_array);
  __Pyx_INCREF(__pyx_n_u_check_classification_targets);
  __Pyx_GIVEREF(__pyx_n_u_check_classification_targets);
  PyList_SET_ITEM(__pyx_t_1, 10, __pyx_n_u_check_classification_targets);
  __Pyx_INCREF(__pyx_n_u_check_consistency_size);
  __Pyx_GIVEREF(__pyx_n_u_check_consistency_size);
  PyList_SET_ITEM(__pyx_t_1, 11, __pyx_n_u_check_consistency_size);
  __Pyx_INCREF(__pyx_n_u_check_consistent_length);
  __Pyx_GIVEREF(__pyx_n_u_check_consistent_length);
  PyList_SET_ITEM(__pyx_t_1, 12, __pyx_n_u_check_consistent_length);
  __Pyx_INCREF(__pyx_n_u_check_epsilon);
  __Pyx_GIVEREF(__pyx_n_u_check_epsilon);
  PyList_SET_ITEM(__pyx_t_1, 13, __pyx_n_u_check_epsilon);
  __Pyx_INCREF(__pyx_n_u_check_is_fitted);
  __Pyx_GIVEREF(__pyx_n_u_check_is_fitted);
  PyList_SET_ITEM(__pyx_t_1, 14, __pyx_n_u_check_is_fitted);
  __Pyx_INCREF(__pyx_n_u_check_is_fitted2);
  __Pyx_GIVEREF(__pyx_n_u_check_is_fitted2);
  PyList_SET_ITEM(__pyx_t_1, 15, __pyx_n_u_check_is_fitted2);
  __Pyx_INCREF(__pyx_n_u_check_memory);
  __Pyx_GIVEREF(__pyx_n_u_check_memory);
  PyList_SET_ITEM(__pyx_t_1, 16, __pyx_n_u_check_memory);
  __Pyx_INCREF(__pyx_n_u_check_mixed_data_types);
  __Pyx_GIVEREF(__pyx_n_u_check_mixed_data_types);
  PyList_SET_ITEM(__pyx_t_1, 17, __pyx_n_u_check_mixed_data_types);
  __Pyx_INCREF(__pyx_n_u_check_random_state);
  __Pyx_GIVEREF(__pyx_n_u_check_random_state);
  PyList_SET_ITEM(__pyx_t_1, 18, __pyx_n_u_check_random_state);
  __Pyx_INCREF(__pyx_n_u_check_scalar);
  __Pyx_GIVEREF(__pyx_n_u_check_scalar);
  PyList_SET_ITEM(__pyx_t_1, 19, __pyx_n_u_check_scalar);
  __Pyx_INCREF(__pyx_n_u_check_symmetric);
  __Pyx_GIVEREF(__pyx_n_u_check_symmetric);
  PyList_SET_ITEM(__pyx_t_1, 20, __pyx_n_u_check_symmetric);
  __Pyx_INCREF(__pyx_n_u_check_y);
  __Pyx_GIVEREF(__pyx_n_u_check_y);
  PyList_SET_ITEM(__pyx_t_1, 21, __pyx_n_u_check_y);
  __Pyx_INCREF(__pyx_n_u_contains_nested_objects);
  __Pyx_GIVEREF(__pyx_n_u_contains_nested_objects);
  PyList_SET_ITEM(__pyx_t_1, 22, __pyx_n_u_contains_nested_objects);
  __Pyx_INCREF(__pyx_n_u_convert_array_to_pandas);
  __Pyx_GIVEREF(__pyx_n_u_convert_array_to_pandas);
  PyList_SET_ITEM(__pyx_t_1, 23, __pyx_n_u_convert_array_to_pandas);
  __Pyx_INCREF(__pyx_n_u_ensure_2d);
  __Pyx_GIVEREF(__pyx_n_u_ensure_2d);
  PyList_SET_ITEM(__pyx_t_1, 24, __pyx_n_u_ensure_2d);
  __Pyx_INCREF(__pyx_n_u_ensure_non_negative);
  __Pyx_GIVEREF(__pyx_n_u_ensure_non_negative);
  PyList_SET_ITEM(__pyx_t_1, 25, __pyx_n_u_ensure_non_negative);
  __Pyx_INCREF(__pyx_n_u_filter_valid_kwargs);
  __Pyx_GIVEREF(__pyx_n_u_filter_valid_kwargs);
  PyList_SET_ITEM(__pyx_t_1, 26, __pyx_n_u_filter_valid_kwargs);
  __Pyx_INCREF(__pyx_n_u_get_estimator_name);
  __Pyx_GIVEREF(__pyx_n_u_get_estimator_name);
  PyList_SET_ITEM(__pyx_t_1, 27, __pyx_n_u_get_estimator_name);
  __Pyx_INCREF(__pyx_n_u_handle_zero_division);
  __Pyx_GIVEREF(__pyx_n_u_handle_zero_division);
  PyList_SET_ITEM(__pyx_t_1, 28, __pyx_n_u_handle_zero_division);
  __Pyx_INCREF(__pyx_n_u_has_fit_parameter);
  __Pyx_GIVEREF(__pyx_n_u_has_fit_parameter);
  PyList_SET_ITEM(__pyx_t_1, 29, __pyx_n_u_has_fit_parameter);
  __Pyx_INCREF(__pyx_n_u_has_required_attributes);
  __Pyx_GIVEREF(__pyx_n_u_has_required_attributes);
  PyList_SET_ITEM(__pyx_t_1, 30, __pyx_n_u_has_required_attributes);
  __Pyx_INCREF(__pyx_n_u_is_binary_class);
  __Pyx_GIVEREF(__pyx_n_u_is_binary_class);
  PyList_SET_ITEM(__pyx_t_1, 31, __pyx_n_u_is_binary_class);
  __Pyx_INCREF(__pyx_n_u_is_categorical);
  __Pyx_GIVEREF(__pyx_n_u_is_categorical);
  PyList_SET_ITEM(__pyx_t_1, 32, __pyx_n_u_is_categorical);
  __Pyx_INCREF(__pyx_n_u_is_frame);
  __Pyx_GIVEREF(__pyx_n_u_is_frame);
  PyList_SET_ITEM(__pyx_t_1, 33, __pyx_n_u_is_frame);
  __Pyx_INCREF(__pyx_n_u_is_installed);
  __Pyx_GIVEREF(__pyx_n_u_is_installed);
  PyList_SET_ITEM(__pyx_t_1, 34, __pyx_n_u_is_installed);
  __Pyx_INCREF(__pyx_n_u_is_keras_model);
  __Pyx_GIVEREF(__pyx_n_u_is_keras_model);
  PyList_SET_ITEM(__pyx_t_1, 35, __pyx_n_u_is_keras_model);
  __Pyx_INCREF(__pyx_n_u_is_normalized);
  __Pyx_GIVEREF(__pyx_n_u_is_normalized);
  PyList_SET_ITEM(__pyx_t_1, 36, __pyx_n_u_is_normalized);
  __Pyx_INCREF(__pyx_n_u_is_square_matrix);
  __Pyx_GIVEREF(__pyx_n_u_is_square_matrix);
  PyList_SET_ITEM(__pyx_t_1, 37, __pyx_n_u_is_square_matrix);
  __Pyx_INCREF(__pyx_n_u_is_time_series);
  __Pyx_GIVEREF(__pyx_n_u_is_time_series);
  PyList_SET_ITEM(__pyx_t_1, 38, __pyx_n_u_is_time_series);
  __Pyx_INCREF(__pyx_n_u_is_valid_policies);
  __Pyx_GIVEREF(__pyx_n_u_is_valid_policies);
  PyList_SET_ITEM(__pyx_t_1, 39, __pyx_n_u_is_valid_policies);
  __Pyx_INCREF(__pyx_n_u_normalize_array);
  __Pyx_GIVEREF(__pyx_n_u_normalize_array);
  PyList_SET_ITEM(__pyx_t_1, 40, __pyx_n_u_normalize_array);
  __Pyx_INCREF(__pyx_n_u_parameter_validator);
  __Pyx_GIVEREF(__pyx_n_u_parameter_validator);
  PyList_SET_ITEM(__pyx_t_1, 41, __pyx_n_u_parameter_validator);
  __Pyx_INCREF(__pyx_n_u_to_dtype_str);
  __Pyx_GIVEREF(__pyx_n_u_to_dtype_str);
  PyList_SET_ITEM(__pyx_t_1, 42, __pyx_n_u_to_dtype_str);
  __Pyx_INCREF(__pyx_n_u_validate_and_adjust_ranges);
  __Pyx_GIVEREF(__pyx_n_u_validate_and_adjust_ranges);
  PyList_SET_ITEM(__pyx_t_1, 43, __pyx_n_u_validate_and_adjust_ranges);
  __Pyx_INCREF(__pyx_n_u_validate_comparison_data);
  __Pyx_GIVEREF(__pyx_n_u_validate_comparison_data);
  PyList_SET_ITEM(__pyx_t_1, 44, __pyx_n_u_validate_comparison_data);
  __Pyx_INCREF(__pyx_n_u_validate_data_types);
  __Pyx_GIVEREF(__pyx_n_u_validate_data_types);
  PyList_SET_ITEM(__pyx_t_1, 45, __pyx_n_u_validate_data_types);
  __Pyx_INCREF(__pyx_n_u_validate_dates);
  __Pyx_GIVEREF(__pyx_n_u_validate_dates);
  PyList_SET_ITEM(__pyx_t_1, 46, __pyx_n_u_validate_dates);
  __Pyx_INCREF(__pyx_n_u_validate_distribution);
  __Pyx_GIVEREF(__pyx_n_u_validate_distribution);
  PyList_SET_ITEM(__pyx_t_1, 47, __pyx_n_u_validate_distribution);
  __Pyx_INCREF(__pyx_n_u_validate_dtype_selector);
  __Pyx_GIVEREF(__pyx_n_u_validate_dtype_selector);
  PyList_SET_ITEM(__pyx_t_1, 48, __pyx_n_u_validate_dtype_selector);
  __Pyx_INCREF(__pyx_n_u_validate_fit_weights);
  __Pyx_GIVEREF(__pyx_n_u_validate_fit_weights);
  PyList_SET_ITEM(__pyx_t_1, 49, __pyx_n_u_validate_fit_weights);
  __Pyx_INCREF(__pyx_n_u_validate_keras_model);
  __Pyx_GIVEREF(__pyx_n_u_validate_keras_model);
  PyList_SET_ITEM(__pyx_t_1, 50, __pyx_n_u_validate_keras_model);
  __Pyx_INCREF(__pyx_n_u_validate_length_range);
  __Pyx_GIVEREF(__pyx_n_u_validate_length_range);
  PyList_SET_ITEM(__pyx_t_1, 51, __pyx_n_u_validate_length_range);
  __Pyx_INCREF(__pyx_n_u_validate_multiclass_target);
  __Pyx_GIVEREF(__pyx_n_u_validate_multiclass_target);
  PyList_SET_ITEM(__pyx_t_1, 52, __pyx_n_u_validate_multiclass_target);
  __Pyx_INCREF(__pyx_n_u_validate_multioutput);
  __Pyx_GIVEREF(__pyx_n_u_validate_multioutput);
  PyList_SET_ITEM(__pyx_t_1, 53, __pyx_n_u_validate_multioutput);
  __Pyx_INCREF(__pyx_n_u_validate_nan_policy);
  __Pyx_GIVEREF(__pyx_n_u_validate_nan_policy);
  PyList_SET_ITEM(__pyx_t_1, 54, __pyx_n_u_validate_nan_policy);
  __Pyx_INCREF(__pyx_n_u_validate_numeric);
  __Pyx_GIVEREF(__pyx_n_u_validate_numeric);
  PyList_SET_ITEM(__pyx_t_1, 55, __pyx_n_u_validate_numeric);
  __Pyx_INCREF(__pyx_n_u_validate_positive_integer);
  __Pyx_GIVEREF(__pyx_n_u_validate_positive_integer);
  PyList_SET_ITEM(__pyx_t_1, 56, __pyx_n_u_validate_positive_integer);
  __Pyx_INCREF(__pyx_n_u_validate_sample_weights);
  __Pyx_GIVEREF(__pyx_n_u_validate_sample_weights);
  PyList_SET_ITEM(__pyx_t_1, 57, __pyx_n_u_validate_sample_weights);
  __Pyx_INCREF(__pyx_n_u_validate_scores);
  __Pyx_GIVEREF(__pyx_n_u_validate_scores);
  PyList_SET_ITEM(__pyx_t_1, 58, __pyx_n_u_validate_scores);
  __Pyx_INCREF(__pyx_n_u_validate_square_matrix);
  __Pyx_GIVEREF(__pyx_n_u_validate_square_matrix);
  PyList_SET_ITEM(__pyx_t_1, 59, __pyx_n_u_validate_square_matrix);
  __Pyx_INCREF(__pyx_n_u_validate_weights);
  __Pyx_GIVEREF(__pyx_n_u_validate_weights);
  PyList_SET_ITEM(__pyx_t_1, 60, __pyx_n_u_validate_weights);
  __Pyx_INCREF(__pyx_n_u_validate_yy);
  __Pyx_GIVEREF(__pyx_n_u_validate_yy);
  PyList_SET_ITEM(__pyx_t_1, 61, __pyx_n_u_validate_yy);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_all_2, __pyx_t_1) < 0) __PYX_ERR(0, 34, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":99
 *  ]
 * 
 * def filter_valid_kwargs(callable_obj, kwargs):             # <<<<<<<<<<<<<<
 *     """
 *     Filter and return only the valid keyword arguments for a given callable object.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_1filter_valid_kwargs, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 99, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_filter_valid_kwargs, __pyx_t_1) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":159
 *     return valid_kwargs
 * 
 * def validate_scores(             # <<<<<<<<<<<<<<
 *     scores, true_labels=None,
 *     mode="strict",
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_3validate_scores, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 159, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_scores, __pyx_t_1) < 0) __PYX_ERR(0, 159, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":256
 *     return np.asarray(scores)
 * 
 * def _is_probability_distribution(y, mode='strict'):             # <<<<<<<<<<<<<<
 *     """
 *     Checks if `y` is a probability distribution across the last axis according
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_5_is_probability_distribution, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 256, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_is_probability_distribution, __pyx_t_1) < 0) __PYX_ERR(0, 256, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":311
 *                          " are 'strict', 'soft', or 'passthrough'.")
 * 
 * def validate_square_matrix(data, align=False, align_mode="auto", message=''):             # <<<<<<<<<<<<<<
 *     """
 *     Validate that the input data forms a square matrix and optionally aligns its
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_7validate_square_matrix, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 311, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_square_matrix, __pyx_t_1) < 0) __PYX_ERR(0, 311, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":360
 *     return data
 * 
 * def is_square_matrix(data, data_type=None):             # <<<<<<<<<<<<<<
 *     """
 *     Determine whether the input, either a DataFrame or an array-like
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_9is_square_matrix, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 360, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_is_square_matrix, __pyx_t_1) < 0) __PYX_ERR(0, 360, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":433
 *     return True
 * 
 * def validate_multiclass_target(             # <<<<<<<<<<<<<<
 *         y, accept_multioutput=False, return_classes=False):
 *     """
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_11validate_multiclass_target, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 433, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_multiclass_target, __pyx_t_1) < 0) __PYX_ERR(0, 433, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":507
 *     return y
 * 
 * def validate_sample_weights(weights, y, normalize =False):             # <<<<<<<<<<<<<<
 *     """
 *     Validates that the sample weights are suitable for use in calculations.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_13validate_sample_weights, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 507, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_sample_weights, __pyx_t_1) < 0) __PYX_ERR(0, 507, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":577
 * 
 * 
 * def validate_weights(             # <<<<<<<<<<<<<<
 *         weights, min_value=None, max_value=None, normalize=False,
 *         allowed_dims=1):
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_15validate_weights, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 577, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_weights, __pyx_t_1) < 0) __PYX_ERR(0, 577, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":660
 *     return weights_array
 * 
 * def is_normalized(arr, method='sum'):             # <<<<<<<<<<<<<<
 *     """
 *     Checks if the provided array is normalized according to the specified method.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_17is_normalized, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 660, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_is_normalized, __pyx_t_1) < 0) __PYX_ERR(0, 660, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":712
 *         return np.isclose(np.sum(arr), 1)
 * 
 * def normalize_array(arr, normalize="auto", method='01'):             # <<<<<<<<<<<<<<
 *     """
 *     Checks if an array is normalized according to the specified method and
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_19normalize_array, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 712, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_normalize_array, __pyx_t_1) < 0) __PYX_ERR(0, 712, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":798
 *     return arr
 * 
 * def is_binary_class(y, accept_multioutput=False):             # <<<<<<<<<<<<<<
 *     """
 *     Check whether the target array represents binary classification. Optionally,
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_21is_binary_class, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 798, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_is_binary_class, __pyx_t_1) < 0) __PYX_ERR(0, 798, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":850
 *     return False
 * 
 * def handle_zero_division(             # <<<<<<<<<<<<<<
 *     y_true,
 *     zero_division='warn',
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_23handle_zero_division, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 850, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_handle_zero_division, __pyx_t_1) < 0) __PYX_ERR(0, 850, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":925
 *     return y_true_processed
 * 
 * def validate_comparison_data(df,  alignment="auto"):             # <<<<<<<<<<<<<<
 *     """
 *     Validates a DataFrame to ensure it is a square matrix and that the index
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_25validate_comparison_data, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 925, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_comparison_data, __pyx_t_1) < 0) __PYX_ERR(0, 925, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":999
 *     return df
 * 
 * def validate_data_types(             # <<<<<<<<<<<<<<
 *     data, expected_type='numeric',
 *     nan_policy='omit',
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_27validate_data_types, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 999, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_data_types, __pyx_t_1) < 0) __PYX_ERR(0, 999, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":1144
 *     return results if not results.empty else None
 * 
 * def ensure_2d(X, output_format="auto"):             # <<<<<<<<<<<<<<
 *     """
 *     Ensure that the input X is converted to a 2-dimensional structure.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_29ensure_2d, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1144, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ensure_2d, __pyx_t_1) < 0) __PYX_ERR(0, 1144, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":1215
 *         return pd.DataFrame(X) if is_dataframe else X
 * 
 * def is_categorical(data, column, strict=False, error='raise'):             # <<<<<<<<<<<<<<
 *     """
 *     Checks if a specified column in a DataFrame or Series is of
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_31is_categorical, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1215, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_is_categorical, __pyx_t_1) < 0) __PYX_ERR(0, 1215, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":1275
 *         return pd.api.types.is_categorical_dtype(col_type) or pd.api.types.is_object_dtype(col_type)
 * 
 * def parameter_validator(             # <<<<<<<<<<<<<<
 *         param_name, target_strs, match_method='contains',
 *         raise_exception=True, **kws):
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_33parameter_validator, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1275, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_parameter_validator, __pyx_t_1) < 0) __PYX_ERR(0, 1275, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":1352
 *     return validator
 * 
 * def validate_distribution(distribution, elements=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates or generates distributions for given elements ensuring the
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_35validate_distribution, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1352, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_distribution, __pyx_t_1) < 0) __PYX_ERR(0, 1352, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":1424
 *     return distribution
 * 
 * def validate_length_range(length_range, sorted_values=True, param_name=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates the review length range ensuring it's a tuple with two integers
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_37validate_length_range, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1424, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_length_range, __pyx_t_1) < 0) __PYX_ERR(0, 1424, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":1481
 *     return length_range
 * 
 * def contains_nested_objects(lst, strict=False, allowed_types=None):             # <<<<<<<<<<<<<<
 *     """
 *     Determines whether a list contains nested objects.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_39contains_nested_objects, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1481, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_contains_nested_objects, __pyx_t_1) < 0) __PYX_ERR(0, 1481, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":1542
 *         return any(is_nested(item) for item in lst)
 * 
 * def validate_nan_policy(nan_policy, *arrays, sample_weights=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates and applies a specified nan_policy to input arrays and
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_41validate_nan_policy, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1542, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_nan_policy, __pyx_t_1) < 0) __PYX_ERR(0, 1542, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":1629
 *     return arrays
 * 
 * def validate_fit_weights(y, sample_weight=None, weighted_y=False):             # <<<<<<<<<<<<<<
 *     """
 *     Validate and compute sample weights for fitting.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_43validate_fit_weights, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1629, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_fit_weights, __pyx_t_1) < 0) __PYX_ERR(0, 1629, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":1700
 *     return sample_weight
 * 
 * def is_valid_policies(nan_policy, allowed_policies=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates the `nan_policy` or any policy argument to ensure it is one
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_45is_valid_policies, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1700, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_is_valid_policies, __pyx_t_1) < 0) __PYX_ERR(0, 1700, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":1756
 *     return nan_policy
 * 
 * def validate_multioutput(value, extra=''):             # <<<<<<<<<<<<<<
 *     """
 *     Validate the `multioutput` parameter value and handle special cases.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_47validate_multioutput, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1756, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_multioutput, __pyx_t_1) < 0) __PYX_ERR(0, 1756, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":1826
 *     return value_lower
 * 
 * def ensure_non_negative(*arrays, err_msg=None):             # <<<<<<<<<<<<<<
 *     """
 *     Ensure that provided arrays contain only non-negative values.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_49ensure_non_negative, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1826, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ensure_non_negative, __pyx_t_1) < 0) __PYX_ERR(0, 1826, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":1868
 *             raise ValueError(err_msg)
 * 
 * def check_epsilon(             # <<<<<<<<<<<<<<
 *     eps,
 *     y_true=None,
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_51check_epsilon, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1868, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_epsilon, __pyx_t_1) < 0) __PYX_ERR(0, 1868, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":1957
 *     return eps
 * 
 * def _ensure_y_is_valid(y_true, y_pred, **kwargs):             # <<<<<<<<<<<<<<
 *     """
 *     Validates that the true and predicted target arrays are suitable for further
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_53_ensure_y_is_valid, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1957, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ensure_y_is_valid, __pyx_t_1) < 0) __PYX_ERR(0, 1957, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":2011
 *     return y_true, y_pred
 * 
 * def check_classification_targets(             # <<<<<<<<<<<<<<
 *     *y,
 *     target_type='numeric',
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_55check_classification_targets, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2011, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_classification_targets, __pyx_t_1) < 0) __PYX_ERR(0, 2011, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":2158
 *     return validated_targets
 * 
 * def _check_y(y, strategy='auto'):             # <<<<<<<<<<<<<<
 *     """
 *     Validates the target array `y`, ensuring it is suitable for classification
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_57_check_y, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2158, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_y_2, __pyx_t_1) < 0) __PYX_ERR(0, 2158, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":2213
 *     return y
 * 
 * def validate_yy(             # <<<<<<<<<<<<<<
 *     y_true, y_pred,
 *     expected_type=None, *,
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_59validate_yy, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2213, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_yy, __pyx_t_1) < 0) __PYX_ERR(0, 2213, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":2276
 *     return y_true, y_pred
 * 
 * def check_mixed_data_types(data ) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Checks if the given data (DataFrame or numpy array) contains both numerical
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_61check_mixed_data_types, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2276, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_mixed_data_types, __pyx_t_1) < 0) __PYX_ERR(0, 2276, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":2334
 *     return has_numerical and has_categorical
 * 
 * def is_keras_model(model: Any) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Determine whether the provided object is an instance of a Keras model.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_63is_keras_model, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2334, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_is_keras_model, __pyx_t_1) < 0) __PYX_ERR(0, 2334, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":2354
 *     return isinstance(model, (tf.keras.models.Model, tf.keras.Sequential))
 * 
 * def has_required_attributes(model: Any, attributes: list[str]) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Check if the model has all required Keras-specific attributes.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_65has_required_attributes, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2354, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_has_required_attributes, __pyx_t_1) < 0) __PYX_ERR(0, 2354, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":2377
 *     return all(hasattr(model, attr) for attr in attributes)
 * 
 * def validate_dates(             # <<<<<<<<<<<<<<
 *         start_date, end_date, return_as_date_str=False, date_format="%Y-%m-%d"):
 *     """
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_67validate_dates, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2377, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_dates, __pyx_t_1) < 0) __PYX_ERR(0, 2377, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":2486
 * 
 * 
 * def validate_positive_integer(value, variable_name, include_zero=False, round_float=None):             # <<<<<<<<<<<<<<
 *     """
 *     Validates whether the given value is a positive integer or zero based
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_69validate_positive_integer, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2486, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_positive_integer, __pyx_t_1) < 0) __PYX_ERR(0, 2486, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":2541
 *     return int(value)
 * 
 * def validate_and_adjust_ranges(**kwargs):             # <<<<<<<<<<<<<<
 *     """
 *     Validates and adjusts the provided range tuples to ensure each is
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_71validate_and_adjust_ranges, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2541, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_and_adjust_ranges, __pyx_t_1) < 0) __PYX_ERR(0, 2541, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":2604
 *     return adjusted_ranges
 * 
 * def recheck_data_types(             # <<<<<<<<<<<<<<
 *     data: Union[pd.DataFrame, pd.Series, list, dict],
 *     coerce_numeric: bool = True,
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_73recheck_data_types, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2604, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_recheck_data_types, __pyx_t_1) < 0) __PYX_ERR(0, 2604, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":2685
 * 
 * 
 * def validate_keras_model(             # <<<<<<<<<<<<<<
 *         model: Any, custom_check: Optional[Callable[[Any], bool]] = None,
 *         deep_check: bool = False, raise_exception =False ) -> bool:
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_75validate_keras_model, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2685, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_keras_model, __pyx_t_1) < 0) __PYX_ERR(0, 2685, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":2764
 *     return True
 * 
 * def is_installed(module: str ) -> bool:             # <<<<<<<<<<<<<<
 *     """
 *     Checks if TensorFlow is installed.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_77is_installed, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2764, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_is_installed, __pyx_t_1) < 0) __PYX_ERR(0, 2764, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":2787
 *     return module_spec is not None
 * 
 * def is_time_series(data, time_col, check_time_interval=False ):             # <<<<<<<<<<<<<<
 *     """
 *     Check if the provided DataFrame is time series data.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_79is_time_series, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2787, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_is_time_series, __pyx_t_1) < 0) __PYX_ERR(0, 2787, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":2836
 *     return True
 * 
 * def check_is_fitted2(estimator, attributes, *, msg=None):             # <<<<<<<<<<<<<<
 *     """
 *     Perform is_fitted validation for estimator.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_81check_is_fitted2, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2836, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_is_fitted2, __pyx_t_1) < 0) __PYX_ERR(0, 2836, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":2884
 *         raise NotFittedError(msg)
 * 
 * def assert_xy_in (             # <<<<<<<<<<<<<<
 *     x,
 *     y, *,
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_83assert_xy_in, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2884, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_assert_xy_in, __pyx_t_1) < 0) __PYX_ERR(0, 2884, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3008
 *     return ( np.array(x), np.array (y) ) if asarray else (x, y )
 * 
 * def validate_numeric(             # <<<<<<<<<<<<<<
 *     value,
 *     convert_to='float',
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_85validate_numeric, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3008, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_numeric, __pyx_t_1) < 0) __PYX_ERR(0, 3008, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3159
 * 
 * 
 * def _validate_input(ignore: str, x, y, _is_arraylike_1d):             # <<<<<<<<<<<<<<
 *     """
 *     Validates that x and y are one-dimensional array-like structures based
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_87_validate_input, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3159, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_input, __pyx_t_1) < 0) __PYX_ERR(0, 3159, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3193
 *                              "array-like structures.")
 * 
 * def _is_numeric_dtype (o, to_array =False ):             # <<<<<<<<<<<<<<
 *     """ Determine whether the argument has a numeric datatype, when
 *     converted to a NumPy array.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_89_is_numeric_dtype, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3193, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_is_numeric_dtype, __pyx_t_1) < 0) __PYX_ERR(0, 3193, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3222
 *             else o.dtype.kind ) in _NUMERIC_KINDS
 * 
 * def _check_consistency_size (ar1, ar2 ,  error ='raise') :             # <<<<<<<<<<<<<<
 *     """ Check consistency of two arrays and raises error if both sizes
 *     are differents.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_91_check_consistency_size, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3222, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_consistency_size_2, __pyx_t_1) < 0) __PYX_ERR(0, 3222, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3233
 *     return len(ar1)==len(ar2)
 * 
 * def check_consistency_size ( *arrays ):             # <<<<<<<<<<<<<<
 *     """ Check consistency of array and raises error otherwise."""
 *     lengths = [len(X) for X in arrays if X is not None]
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_93check_consistency_size, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3233, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_consistency_size, __pyx_t_1) < 0) __PYX_ERR(0, 3233, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3243
 *         )
 * 
 * def _is_buildin (o,  mode ='soft'):             # <<<<<<<<<<<<<<
 *     """ Returns 'True' wether the module is a Python buidling function.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_95_is_buildin, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3243, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_is_buildin, __pyx_t_1) < 0) __PYX_ERR(0, 3243, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3264
 * 
 * 
 * def get_estimator_name (estimator ):             # <<<<<<<<<<<<<<
 *     """ Get the estimator name whatever it is an instanciated object or not
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_97get_estimator_name, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3264, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_get_estimator_name, __pyx_t_1) < 0) __PYX_ERR(0, 3264, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3282
 *     return name
 * 
 * def _is_cross_validated (estimator ):             # <<<<<<<<<<<<<<
 *     """ Check whether the estimator has already passed the cross validation
 *      procedure.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_99_is_cross_validated, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3282, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_is_cross_validated, __pyx_t_1) < 0) __PYX_ERR(0, 3282, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3298
 * 
 * 
 * def _check_array_in(obj,  arr_name):             # <<<<<<<<<<<<<<
 *     """Returns the array from the array name attribute. Note that the singleton
 *     array is not admitted.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_101_check_array_in, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3298, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_array_in, __pyx_t_1) < 0) __PYX_ERR(0, 3298, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3348
 * 
 * 
 * def _deprecate_positional_args(func=None, *, version="1.3"):             # <<<<<<<<<<<<<<
 *     """Decorator for methods that issues warnings for positional arguments.
 *     Using the keyword-only argument syntax in pep 3102, arguments after the
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_103_deprecate_positional_args, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3348, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_deprecate_positional_args, __pyx_t_1) < 0) __PYX_ERR(0, 3348, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3399
 *     return _inner_deprecate_positional_args
 * 
 * def to_dtype_str (arr, return_values = False ):             # <<<<<<<<<<<<<<
 *     """ Convert numeric or object dtype to string dtype.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_105to_dtype_str, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3399, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_to_dtype_str, __pyx_t_1) < 0) __PYX_ERR(0, 3399, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3426
 *     return arr.astype (str )
 * 
 * def _is_arraylike_1d (x) :             # <<<<<<<<<<<<<<
 *     """ Returns whether the input is arraylike one dimensional and not a scalar"""
 *     if not hasattr (x, '__array__'):
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_107_is_arraylike_1d, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3426, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_is_arraylike_1d, __pyx_t_1) < 0) __PYX_ERR(0, 3426, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3435
 *         len(x.shape ) ==2 and x.shape [1]==1 ))
 * 
 * def _is_arraylike(x):             # <<<<<<<<<<<<<<
 *     """Returns whether the input is array-like."""
 *     return hasattr(x, "__len__") or hasattr(x, "shape") or hasattr(x, "__array__")
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_109_is_arraylike, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3435, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_is_arraylike, __pyx_t_1) < 0) __PYX_ERR(0, 3435, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3440
 * 
 * 
 * def _is_arraylike_not_scalar(array):             # <<<<<<<<<<<<<<
 *     """Return True if array is array-like and not a scalar"""
 *     return _is_arraylike(array) and not np.isscalar(array)
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_111_is_arraylike_not_scalar, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3440, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_is_arraylike_not_scalar, __pyx_t_1) < 0) __PYX_ERR(0, 3440, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3444
 *     return _is_arraylike(array) and not np.isscalar(array)
 * 
 * def _num_features(X):             # <<<<<<<<<<<<<<
 *     """Return the number of features in an array-like X.
 *     This helper function tries hard to avoid to materialize an array version
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_113_num_features, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3444, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_num_features, __pyx_t_1) < 0) __PYX_ERR(0, 3444, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3495
 * 
 * 
 * def _num_samples(x):             # <<<<<<<<<<<<<<
 *     """Return number of samples in array-like x."""
 *     message = "Expected sequence or array-like, got %s" % type(x)
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_115_num_samples, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3495, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_num_samples, __pyx_t_1) < 0) __PYX_ERR(0, 3495, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3524
 * 
 * 
 * def check_memory(memory):             # <<<<<<<<<<<<<<
 *     """Check that ``memory`` is joblib.Memory-like.
 *     joblib.Memory-like means that ``memory`` can be converted into a
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_117check_memory, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3524, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_memory, __pyx_t_1) < 0) __PYX_ERR(0, 3524, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3554
 * 
 * 
 * def check_consistent_length(*arrays):             # <<<<<<<<<<<<<<
 *     """Check that all arrays have consistent first dimensions.
 *     Checks whether all objects in arrays have the same shape or length.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_119check_consistent_length, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3554, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_consistent_length, __pyx_t_1) < 0) __PYX_ERR(0, 3554, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3572
 * 
 * 
 * def check_random_state(seed):             # <<<<<<<<<<<<<<
 *     """Turn seed into a np.random.RandomState instance.
 *     Parameters
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_121check_random_state, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3572, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_random_state, __pyx_t_1) < 0) __PYX_ERR(0, 3572, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3596
 *     )
 * 
 * def has_fit_parameter(estimator, parameter):             # <<<<<<<<<<<<<<
 *     """Check whether the estimator's fit method supports the given parameter.
 *     Parameters
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_123has_fit_parameter, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3596, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_has_fit_parameter, __pyx_t_1) < 0) __PYX_ERR(0, 3596, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3619
 * 
 * 
 * def check_symmetric(array, *, tol=1e-10, raise_warning=True, raise_exception=False):             # <<<<<<<<<<<<<<
 *     """Make sure that array is 2D, square and symmetric.
 *     If the array is not symmetric, then a symmetrized version is returned.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_125check_symmetric, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3619, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_symmetric, __pyx_t_1) < 0) __PYX_ERR(0, 3619, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3673
 *     return array
 * 
 * def check_scalar(             # <<<<<<<<<<<<<<
 *     x,
 *     name,
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_127check_scalar, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3673, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_scalar, __pyx_t_1) < 0) __PYX_ERR(0, 3673, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3785
 * 
 * 
 * def _get_feature_names(X):             # <<<<<<<<<<<<<<
 *     """Get feature names from X.
 *     Support for other array containers should place its implementation here.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_129_get_feature_names, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3785, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_get_feature_names, __pyx_t_1) < 0) __PYX_ERR(0, 3785, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3823
 *         return feature_names
 * 
 * def check_is_fitted(estimator, attributes=None, *, msg=None, all_or_any=all):             # <<<<<<<<<<<<<<
 *     """Perform is_fitted validation for estimator.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_131check_is_fitted, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3823, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_is_fitted, __pyx_t_1) < 0) __PYX_ERR(0, 3823, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3894
 *         raise NotFittedError(msg % {"name": type(estimator).__name__})
 * 
 * def _check_feature_names_in(estimator, input_features=None, *, generate_names=True):             # <<<<<<<<<<<<<<
 *     """Check `input_features` and generate names if needed.
 *     Commonly used in :term:`get_feature_names_out`.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_133_check_feature_names_in, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3894, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_feature_names_in, __pyx_t_1) < 0) __PYX_ERR(0, 3894, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3947
 *     return np.asarray([f"x{i}" for i in range(n_features_in_)], dtype=object)
 * 
 * def _pandas_dtype_needs_early_conversion(pd_dtype):             # <<<<<<<<<<<<<<
 *     """Return True if pandas extension pd_dtype need to be converted early."""
 *     # Check these early for pandas versions without extension dtypes
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_135_pandas_dtype_needs_early_conversion, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3947, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pandas_dtype_needs_early_conver, __pyx_t_1) < 0) __PYX_ERR(0, 3947, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3986
 *     return False
 * 
 * def _ensure_no_complex_data(array):             # <<<<<<<<<<<<<<
 *     if (
 *         hasattr(array, "dtype")
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_137_ensure_no_complex_data, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3986, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ensure_no_complex_data, __pyx_t_1) < 0) __PYX_ERR(0, 3986, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":3996
 * 
 * 
 * def _check_estimator_name(estimator):             # <<<<<<<<<<<<<<
 *     if estimator is not None:
 *         if isinstance(estimator, str):
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_139_check_estimator_name, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3996, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_estimator_name, __pyx_t_1) < 0) __PYX_ERR(0, 3996, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":4004
 *     return None
 * 
 * def set_array_back (X, *,  to_frame=False, columns = None, input_name ='X'):             # <<<<<<<<<<<<<<
 *     """ Set array back to frame, reconvert the Numpy array to pandas series
 *     or dataframe.
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_141set_array_back, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4004, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_set_array_back, __pyx_t_1) < 0) __PYX_ERR(0, 4004, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":4085
 *     return X, columns
 * 
 * def convert_array_to_pandas(X, *, to_frame=False, columns=None, input_name='X'):             # <<<<<<<<<<<<<<
 *     """
 *     Converts an array-like object to a pandas DataFrame or Series, applying
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_143convert_array_to_pandas, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4085, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_convert_array_to_pandas, __pyx_t_1) < 0) __PYX_ERR(0, 4085, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":4157
 *     return X, columns
 * 
 * def is_frame (arr, df_only =False, raise_exception: bool=False,             # <<<<<<<<<<<<<<
 *               objname=None  ):
 *     """ Return bool wether array is a frame ( pd.Series or pd.DataFrame )
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_145is_frame, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4157, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_is_frame, __pyx_t_1) < 0) __PYX_ERR(0, 4157, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":4179
 * 
 * 
 * def check_array(             # <<<<<<<<<<<<<<
 *     array,
 *     *,
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_147check_array, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4179, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_array, __pyx_t_1) < 0) __PYX_ERR(0, 4179, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":4489
 *     return array
 * 
 * def check_X_y(             # <<<<<<<<<<<<<<
 *     X,
 *     y,
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_149check_X_y, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4489, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_X_y, __pyx_t_1) < 0) __PYX_ERR(0, 4489, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":4622
 * 
 * 
 * def check_y(y,             # <<<<<<<<<<<<<<
 *     multi_output=False,
 *     y_numeric=False,
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_151check_y, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4622, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_y, __pyx_t_1) < 0) __PYX_ERR(0, 4622, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":4693
 *     return y
 * 
 * def validate_dtype_selector(dtype_selector: str) -> str:             # <<<<<<<<<<<<<<
 *     """
 *     Validates and categorizes the dtype_selector using regex, including handling
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_153validate_dtype_selector, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4693, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_validate_dtype_selector, __pyx_t_1) < 0) __PYX_ERR(0, 4693, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":4735
 *         f"Invalid dtype_selector provided. Valid options are :{types}")
 * 
 * def build_data_if(             # <<<<<<<<<<<<<<
 *     data,
 *     columns=None,
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_155build_data_if, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4735, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_build_data_if, __pyx_t_1) < 0) __PYX_ERR(0, 4735, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":4821
 *     return data  # Return original data if conditions are not met
 * 
 * def build_data_if2(             # <<<<<<<<<<<<<<
 *     data: Union[dict, np.ndarray, pd.DataFrame],
 *     columns=None,
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_157build_data_if2, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4821, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_build_data_if2, __pyx_t_1) < 0) __PYX_ERR(0, 4821, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":4885
 *         )
 * 
 * def array_to_frame(             # <<<<<<<<<<<<<<
 *     X,
 *     *,
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_159array_to_frame, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4885, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_array_to_frame, __pyx_t_1) < 0) __PYX_ERR(0, 4885, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":4956
 *     return X
 * 
 * def array_to_frame2(             # <<<<<<<<<<<<<<
 *     X,
 *     *,
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_161array_to_frame2, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4956, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_array_to_frame2, __pyx_t_1) < 0) __PYX_ERR(0, 4956, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":5045
 *     return X
 * 
 * def _check_y_1d(y, *, warn=False, input_name ='y'):             # <<<<<<<<<<<<<<
 *     """Ravel column or 1d numpy array, else raises an error.
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_163_check_y_1d, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5045, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_y_1d, __pyx_t_1) < 0) __PYX_ERR(0, 5045, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":5084
 *                      f" an array of shape {shape} instead.")
 * 
 * def _check_large_sparse(X, accept_large_sparse=False):             # <<<<<<<<<<<<<<
 *     """Raise a ValueError if X has 64bit indices and accept_large_sparse=False"""
 *     if not accept_large_sparse:
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_165_check_large_sparse, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5084, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_check_large_sparse, __pyx_t_1) < 0) __PYX_ERR(0, 5084, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":5101
 *                     " indices are accepted. Got %s indices." % indices_datatype
 *                 )
 * def _ensure_sparse_format(             # <<<<<<<<<<<<<<
 *     spmatrix,
 *     accept_sparse,
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_167_ensure_sparse_format, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5101, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_ensure_sparse_format, __pyx_t_1) < 0) __PYX_ERR(0, 5101, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":5211
 *     return spmatrix
 * 
 * def _object_dtype_isnan(X):             # <<<<<<<<<<<<<<
 *     return X != X
 * 
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_169_object_dtype_isnan, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5211, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_object_dtype_isnan, __pyx_t_1) < 0) __PYX_ERR(0, 5211, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":5214
 *     return X != X
 * 
 * def _assert_all_finite(             # <<<<<<<<<<<<<<
 *     X, allow_nan=False, msg_dtype=None, estimator_name=None, input_name=""
 * ):
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_171_assert_all_finite, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5214, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_assert_all_finite, __pyx_t_1) < 0) __PYX_ERR(0, 5214, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":5290
 *         raise ValueError(msg_err)
 * 
 * def assert_all_finite(             # <<<<<<<<<<<<<<
 *     X,
 *     *,
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_173assert_all_finite, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5290, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_assert_all_finite_2, __pyx_t_1) < 0) __PYX_ERR(0, 5290, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":5319
 *     )
 * 
 * def _generate_get_feature_names_out(estimator, n_features_out, input_features=None):             # <<<<<<<<<<<<<<
 *     """Generate feature names out for estimator using the estimator name as the prefix.
 *     The input_feature names are validated but not used. This function is useful
 */
  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_9validator_175_generate_get_feature_names_out, NULL, __pyx_n_s_validator); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5319, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_generate_get_feature_names_out, __pyx_t_1) < 0) __PYX_ERR(0, 5319, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":5342
 *     )
 * 
 * class PositiveSpectrumWarning(UserWarning):             # <<<<<<<<<<<<<<
 *     """Warning raised when the eigenvalues of a PSD matrix have issues
 *     This warning is typically raised by ``_check_psd_eigenvalues`` when the
 */
  __pyx_t_1 = __Pyx_CalculateMetaclass(NULL, __pyx_tuple__295); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5342, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = __Pyx_Py3MetaclassPrepare(__pyx_t_1, __pyx_tuple__295, __pyx_n_s_PositiveSpectrumWarning, __pyx_n_s_PositiveSpectrumWarning, (PyObject *) NULL, __pyx_n_s_validator, __pyx_kp_s_Warning_raised_when_the_eigenval); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5342, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = __Pyx_Py3ClassCreate(__pyx_t_1, __pyx_n_s_PositiveSpectrumWarning, __pyx_tuple__295, __pyx_t_4, NULL, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5342, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_PositiveSpectrumWarning, __pyx_t_3) < 0) __PYX_ERR(0, 5342, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":5350
 *     .. versionadded:: 0.22
 *     """
 * class DataConversionWarning(UserWarning):             # <<<<<<<<<<<<<<
 *     """Warning used to notify implicit data conversions happening in the code.
 *     This warning occurs when some input data needs to be converted or
 */
  __pyx_t_1 = __Pyx_CalculateMetaclass(NULL, __pyx_tuple__296); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 5350, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = __Pyx_Py3MetaclassPrepare(__pyx_t_1, __pyx_tuple__296, __pyx_n_s_DataConversionWarning, __pyx_n_s_DataConversionWarning, (PyObject *) NULL, __pyx_n_s_validator, __pyx_kp_s_Warning_used_to_notify_implicit); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 5350, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = __Pyx_Py3ClassCreate(__pyx_t_1, __pyx_n_s_DataConversionWarning, __pyx_tuple__296, __pyx_t_4, NULL, 0, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 5350, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_DataConversionWarning, __pyx_t_3) < 0) __PYX_ERR(0, 5350, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "validator.pyx":1
 * # -*- coding: utf-8 -*-             # <<<<<<<<<<<<<<
 * # BSD-3-Clause License
 * #   Author: LKouadio <etanoyau@gmail.com>
 */
  __pyx_t_1 = __Pyx_PyDict_NewPresized(41); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_filter_valid_kwargs_line_99, __pyx_kp_u_Filter_and_return_only_the_vali) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_validate_scores_line_159, __pyx_kp_u_Validates_that_the_scores_repre) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_is_probability_distribution_lin, __pyx_kp_u_Checks_if_y_is_a_probability_di) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_validate_square_matrix_line_311, __pyx_kp_u_Validate_that_the_input_data_fo) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_is_square_matrix_line_360, __pyx_kp_u_Determine_whether_the_input_eit) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_validate_multiclass_target_line, __pyx_kp_u_Validates_that_the_target_data) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_validate_sample_weights_line_507, __pyx_kp_u_Validates_that_the_sample_weigh) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_validate_weights_line_577, __pyx_kp_u_Validates_and_optionally_normal) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_is_normalized_line_660, __pyx_kp_u_Checks_if_the_provided_array_is) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_normalize_array_line_712, __pyx_kp_u_Checks_if_an_array_is_normalize) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_is_binary_class_line_798, __pyx_kp_u_Check_whether_the_target_array) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_handle_zero_division_line_850, __pyx_kp_u_Preprocess_input_arrays_to_hand) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_validate_comparison_data_line_92, __pyx_kp_u_Validates_a_DataFrame_to_ensure) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_validate_data_types_line_999, __pyx_kp_u_Checks_for_mixed_data_types_in) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_ensure_2d_line_1144, __pyx_kp_u_Ensure_that_the_input_X_is_conv) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_is_categorical_line_1215, __pyx_kp_u_Checks_if_a_specified_column_in) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_parameter_validator_line_1275, __pyx_kp_u_Creates_a_validator_function_fo) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_validate_distribution_line_1352, __pyx_kp_u_Validates_or_generates_distribu) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_validate_length_range_line_1424, __pyx_kp_u_Validates_the_review_length_ran) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_contains_nested_objects_line_148, __pyx_kp_u_Determines_whether_a_list_conta) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_validate_nan_policy_line_1542, __pyx_kp_u_Validates_and_applies_a_specifi) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_validate_fit_weights_line_1629, __pyx_kp_u_Validate_and_compute_sample_wei) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_is_valid_policies_line_1700, __pyx_kp_u_Validates_the_nan_policy_or_any) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_validate_multioutput_line_1756, __pyx_kp_u_Validate_the_multioutput_parame) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_ensure_non_negative_line_1826, __pyx_kp_u_Ensure_that_provided_arrays_con) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_check_epsilon_line_1868, __pyx_kp_u_Dynamically_determine_or_valida) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_ensure_y_is_valid_line_1957, __pyx_kp_u_Validates_that_the_true_and_pre) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_check_classification_targets_lin, __pyx_kp_u_Validate_that_the_target_arrays) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_check_mixed_data_types_line_2276, __pyx_kp_u_Checks_if_the_given_data_DataFr) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_validate_dates_line_2377, __pyx_kp_u_Validates_and_parses_start_and) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_validate_and_adjust_ranges_line, __pyx_kp_u_Validates_and_adjusts_the_provi) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_recheck_data_types_line_2604, __pyx_kp_u_Rechecks_and_coerces_column_dat) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_validate_keras_model_line_2685, __pyx_kp_u_Validates_whether_a_given_objec) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_is_installed_line_2764, __pyx_kp_u_Checks_if_TensorFlow_is_install) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_is_time_series_line_2787, __pyx_kp_u_Check_if_the_provided_DataFrame) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_check_is_fitted2_line_2836, __pyx_kp_u_Perform_is_fitted_validation_fo) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_assert_xy_in_line_2884, __pyx_kp_u_Assert_the_name_of_x_and_y_in_t) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_validate_numeric_line_3008, __pyx_kp_u_Validates_if_a_given_value_is_n) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_has_fit_parameter_line_3596, __pyx_kp_u_Check_whether_the_estimator_s_fi) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_array_to_frame_line_4885, __pyx_kp_u_Validates_and_optionally_conver) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_1, __pyx_kp_u_array_to_frame2_line_4956, __pyx_kp_u_Added_part_of_is_frame_dedicated) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_1) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /*--- Wrapped vars code ---*/

  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  if (__pyx_m) {
    if (__pyx_d) {
      __Pyx_AddTraceback("init validator", __pyx_clineno, __pyx_lineno, __pyx_filename);
    }
    Py_CLEAR(__pyx_m);
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init validator");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  return (__pyx_m != NULL) ? 0 : -1;
  #elif PY_MAJOR_VERSION >= 3
  return __pyx_m;
  #else
  return;
  #endif
}

/* --- Runtime support code --- */
/* Refnanny */
#if CYTHON_REFNANNY
static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule(modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, "RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
}
#endif

/* PyObjectGetAttrStr */
#if CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_getattro))
        return tp->tp_getattro(obj, attr_name);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_getattr))
        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
#endif
    return PyObject_GetAttr(obj, attr_name);
}
#endif

/* GetBuiltinName */
static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
    if (unlikely(!result)) {
        PyErr_Format(PyExc_NameError,
#if PY_MAJOR_VERSION >= 3
            "name '%U' is not defined", name);
#else
            "name '%.200s' is not defined", PyString_AS_STRING(name));
#endif
    }
    return result;
}

/* RaiseArgTupleInvalid */
static void __Pyx_RaiseArgtupleInvalid(
    const char* func_name,
    int exact,
    Py_ssize_t num_min,
    Py_ssize_t num_max,
    Py_ssize_t num_found)
{
    Py_ssize_t num_expected;
    const char *more_or_less;
    if (num_found < num_min) {
        num_expected = num_min;
        more_or_less = "at least";
    } else {
        num_expected = num_max;
        more_or_less = "at most";
    }
    if (exact) {
        more_or_less = "exactly";
    }
    PyErr_Format(PyExc_TypeError,
                 "%.200s() takes %.8s %" CYTHON_FORMAT_SSIZE_T "d positional argument%.1s (%" CYTHON_FORMAT_SSIZE_T "d given)",
                 func_name, more_or_less, num_expected,
                 (num_expected == 1) ? "" : "s", num_found);
}

/* RaiseDoubleKeywords */
static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name,
    PyObject* kw_name)
{
    PyErr_Format(PyExc_TypeError,
        #if PY_MAJOR_VERSION >= 3
        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
        #else
        "%s() got multiple values for keyword argument '%s'", func_name,
        PyString_AsString(kw_name));
        #endif
}

/* ParseKeywords */
static int __Pyx_ParseOptionalKeywords(
    PyObject *kwds,
    PyObject **argnames[],
    PyObject *kwds2,
    PyObject *values[],
    Py_ssize_t num_pos_args,
    const char* function_name)
{
    PyObject *key = 0, *value = 0;
    Py_ssize_t pos = 0;
    PyObject*** name;
    PyObject*** first_kw_arg = argnames + num_pos_args;
    while (PyDict_Next(kwds, &pos, &key, &value)) {
        name = first_kw_arg;
        while (*name && (**name != key)) name++;
        if (*name) {
            values[name-argnames] = value;
            continue;
        }
        name = first_kw_arg;
        #if PY_MAJOR_VERSION < 3
        if (likely(PyString_Check(key))) {
            while (*name) {
                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
                        && _PyString_Eq(**name, key)) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    if ((**argname == key) || (
                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
                             && _PyString_Eq(**argname, key))) {
                        goto arg_passed_twice;
                    }
                    argname++;
                }
            }
        } else
        #endif
        if (likely(PyUnicode_Check(key))) {
            while (*name) {
                int cmp = (**name == key) ? 0 :
                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                    (__Pyx_PyUnicode_GET_LENGTH(**name) != __Pyx_PyUnicode_GET_LENGTH(key)) ? 1 :
                #endif
                    PyUnicode_Compare(**name, key);
                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                if (cmp == 0) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    int cmp = (**argname == key) ? 0 :
                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                        (__Pyx_PyUnicode_GET_LENGTH(**argname) != __Pyx_PyUnicode_GET_LENGTH(key)) ? 1 :
                    #endif
                        PyUnicode_Compare(**argname, key);
                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                    if (cmp == 0) goto arg_passed_twice;
                    argname++;
                }
            }
        } else
            goto invalid_keyword_type;
        if (kwds2) {
            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
        } else {
            goto invalid_keyword;
        }
    }
    return 0;
arg_passed_twice:
    __Pyx_RaiseDoubleKeywordsError(function_name, key);
    goto bad;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    goto bad;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
bad:
    return -1;
}

/* PyDictVersioning */
#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj) {
    PyObject *dict = Py_TYPE(obj)->tp_dict;
    return likely(dict) ? __PYX_GET_DICT_VERSION(dict) : 0;
}
static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj) {
    PyObject **dictptr = NULL;
    Py_ssize_t offset = Py_TYPE(obj)->tp_dictoffset;
    if (offset) {
#if CYTHON_COMPILING_IN_CPYTHON
        dictptr = (likely(offset > 0)) ? (PyObject **) ((char *)obj + offset) : _PyObject_GetDictPtr(obj);
#else
        dictptr = _PyObject_GetDictPtr(obj);
#endif
    }
    return (dictptr && *dictptr) ? __PYX_GET_DICT_VERSION(*dictptr) : 0;
}
static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version) {
    PyObject *dict = Py_TYPE(obj)->tp_dict;
    if (unlikely(!dict) || unlikely(tp_dict_version != __PYX_GET_DICT_VERSION(dict)))
        return 0;
    return obj_dict_version == __Pyx_get_object_dict_version(obj);
}
#endif

/* GetModuleGlobalName */
#if CYTHON_USE_DICT_VERSIONS
static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value)
#else
static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name)
#endif
{
    PyObject *result;
#if !CYTHON_AVOID_BORROWED_REFS
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1
    result = _PyDict_GetItem_KnownHash(__pyx_d, name, ((PyASCIIObject *) name)->hash);
    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
    if (likely(result)) {
        return __Pyx_NewRef(result);
    } else if (unlikely(PyErr_Occurred())) {
        return NULL;
    }
#else
    result = PyDict_GetItem(__pyx_d, name);
    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
    if (likely(result)) {
        return __Pyx_NewRef(result);
    }
#endif
#else
    result = PyObject_GetItem(__pyx_d, name);
    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
    if (likely(result)) {
        return __Pyx_NewRef(result);
    }
    PyErr_Clear();
#endif
    return __Pyx_GetBuiltinName(name);
}

/* PyCFunctionFastCall */
#if CYTHON_FAST_PYCCALL
static CYTHON_INLINE PyObject * __Pyx_PyCFunction_FastCall(PyObject *func_obj, PyObject **args, Py_ssize_t nargs) {
    PyCFunctionObject *func = (PyCFunctionObject*)func_obj;
    PyCFunction meth = PyCFunction_GET_FUNCTION(func);
    PyObject *self = PyCFunction_GET_SELF(func);
    int flags = PyCFunction_GET_FLAGS(func);
    assert(PyCFunction_Check(func));
    assert(METH_FASTCALL == (flags & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)));
    assert(nargs >= 0);
    assert(nargs == 0 || args != NULL);
    /* _PyCFunction_FastCallDict() must not be called with an exception set,
       because it may clear it (directly or indirectly) and so the
       caller loses its exception */
    assert(!PyErr_Occurred());
    if ((PY_VERSION_HEX < 0x030700A0) || unlikely(flags & METH_KEYWORDS)) {
        return (*((__Pyx_PyCFunctionFastWithKeywords)(void*)meth)) (self, args, nargs, NULL);
    } else {
        return (*((__Pyx_PyCFunctionFast)(void*)meth)) (self, args, nargs);
    }
}
#endif

/* PyFunctionFastCall */
#if CYTHON_FAST_PYCALL
static PyObject* __Pyx_PyFunction_FastCallNoKw(PyCodeObject *co, PyObject **args, Py_ssize_t na,
                                               PyObject *globals) {
    PyFrameObject *f;
    PyThreadState *tstate = __Pyx_PyThreadState_Current;
    PyObject **fastlocals;
    Py_ssize_t i;
    PyObject *result;
    assert(globals != NULL);
    /* XXX Perhaps we should create a specialized
       PyFrame_New() that doesn't take locals, but does
       take builtins without sanity checking them.
       */
    assert(tstate != NULL);
    f = PyFrame_New(tstate, co, globals, NULL);
    if (f == NULL) {
        return NULL;
    }
    fastlocals = __Pyx_PyFrame_GetLocalsplus(f);
    for (i = 0; i < na; i++) {
        Py_INCREF(*args);
        fastlocals[i] = *args++;
    }
    result = PyEval_EvalFrameEx(f,0);
    ++tstate->recursion_depth;
    Py_DECREF(f);
    --tstate->recursion_depth;
    return result;
}
#if 1 || PY_VERSION_HEX < 0x030600B1
static PyObject *__Pyx_PyFunction_FastCallDict(PyObject *func, PyObject **args, Py_ssize_t nargs, PyObject *kwargs) {
    PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
    PyObject *globals = PyFunction_GET_GLOBALS(func);
    PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
    PyObject *closure;
#if PY_MAJOR_VERSION >= 3
    PyObject *kwdefs;
#endif
    PyObject *kwtuple, **k;
    PyObject **d;
    Py_ssize_t nd;
    Py_ssize_t nk;
    PyObject *result;
    assert(kwargs == NULL || PyDict_Check(kwargs));
    nk = kwargs ? PyDict_Size(kwargs) : 0;
    if (Py_EnterRecursiveCall((char*)" while calling a Python object")) {
        return NULL;
    }
    if (
#if PY_MAJOR_VERSION >= 3
            co->co_kwonlyargcount == 0 &&
#endif
            likely(kwargs == NULL || nk == 0) &&
            co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
        if (argdefs == NULL && co->co_argcount == nargs) {
            result = __Pyx_PyFunction_FastCallNoKw(co, args, nargs, globals);
            goto done;
        }
        else if (nargs == 0 && argdefs != NULL
                 && co->co_argcount == Py_SIZE(argdefs)) {
            /* function called with no arguments, but all parameters have
               a default value: use default values as arguments .*/
            args = &PyTuple_GET_ITEM(argdefs, 0);
            result =__Pyx_PyFunction_FastCallNoKw(co, args, Py_SIZE(argdefs), globals);
            goto done;
        }
    }
    if (kwargs != NULL) {
        Py_ssize_t pos, i;
        kwtuple = PyTuple_New(2 * nk);
        if (kwtuple == NULL) {
            result = NULL;
            goto done;
        }
        k = &PyTuple_GET_ITEM(kwtuple, 0);
        pos = i = 0;
        while (PyDict_Next(kwargs, &pos, &k[i], &k[i+1])) {
            Py_INCREF(k[i]);
            Py_INCREF(k[i+1]);
            i += 2;
        }
        nk = i / 2;
    }
    else {
        kwtuple = NULL;
        k = NULL;
    }
    closure = PyFunction_GET_CLOSURE(func);
#if PY_MAJOR_VERSION >= 3
    kwdefs = PyFunction_GET_KW_DEFAULTS(func);
#endif
    if (argdefs != NULL) {
        d = &PyTuple_GET_ITEM(argdefs, 0);
        nd = Py_SIZE(argdefs);
    }
    else {
        d = NULL;
        nd = 0;
    }
#if PY_MAJOR_VERSION >= 3
    result = PyEval_EvalCodeEx((PyObject*)co, globals, (PyObject *)NULL,
                               args, (int)nargs,
                               k, (int)nk,
                               d, (int)nd, kwdefs, closure);
#else
    result = PyEval_EvalCodeEx(co, globals, (PyObject *)NULL,
                               args, (int)nargs,
                               k, (int)nk,
                               d, (int)nd, closure);
#endif
    Py_XDECREF(kwtuple);
done:
    Py_LeaveRecursiveCall();
    return result;
}
#endif
#endif

/* PyObjectCall */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    PyObject *result;
    ternaryfunc call = Py_TYPE(func)->tp_call;
    if (unlikely(!call))
        return PyObject_Call(func, arg, kw);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = (*call)(func, arg, kw);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyObjectCall2Args */
static CYTHON_UNUSED PyObject* __Pyx_PyObject_Call2Args(PyObject* function, PyObject* arg1, PyObject* arg2) {
    PyObject *args, *result = NULL;
    #if CYTHON_FAST_PYCALL
    if (PyFunction_Check(function)) {
        PyObject *args[2] = {arg1, arg2};
        return __Pyx_PyFunction_FastCall(function, args, 2);
    }
    #endif
    #if CYTHON_FAST_PYCCALL
    if (__Pyx_PyFastCFunction_Check(function)) {
        PyObject *args[2] = {arg1, arg2};
        return __Pyx_PyCFunction_FastCall(function, args, 2);
    }
    #endif
    args = PyTuple_New(2);
    if (unlikely(!args)) goto done;
    Py_INCREF(arg1);
    PyTuple_SET_ITEM(args, 0, arg1);
    Py_INCREF(arg2);
    PyTuple_SET_ITEM(args, 1, arg2);
    Py_INCREF(function);
    result = __Pyx_PyObject_Call(function, args, NULL);
    Py_DECREF(args);
    Py_DECREF(function);
done:
    return result;
}

/* PyObjectCallMethO */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
    PyObject *self, *result;
    PyCFunction cfunc;
    cfunc = PyCFunction_GET_FUNCTION(func);
    self = PyCFunction_GET_SELF(func);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = cfunc(self, arg);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyObjectCallOneArg */
#if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_New(1);
    if (unlikely(!args)) return NULL;
    Py_INCREF(arg);
    PyTuple_SET_ITEM(args, 0, arg);
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
#if CYTHON_FAST_PYCALL
    if (PyFunction_Check(func)) {
        return __Pyx_PyFunction_FastCall(func, &arg, 1);
    }
#endif
    if (likely(PyCFunction_Check(func))) {
        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
            return __Pyx_PyObject_CallMethO(func, arg);
#if CYTHON_FAST_PYCCALL
        } else if (__Pyx_PyFastCFunction_Check(func)) {
            return __Pyx_PyCFunction_FastCall(func, &arg, 1);
#endif
        }
    }
    return __Pyx__PyObject_CallOneArg(func, arg);
}
#else
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_Pack(1, arg);
    if (unlikely(!args)) return NULL;
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
#endif

/* PyObjectCallNoArg */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
#if CYTHON_FAST_PYCALL
    if (PyFunction_Check(func)) {
        return __Pyx_PyFunction_FastCall(func, NULL, 0);
    }
#endif
#if defined(__Pyx_CyFunction_USED) && defined(NDEBUG)
    if (likely(PyCFunction_Check(func) || __Pyx_CyFunction_Check(func)))
#else
    if (likely(PyCFunction_Check(func)))
#endif
    {
        if (likely(PyCFunction_GET_FLAGS(func) & METH_NOARGS)) {
            return __Pyx_PyObject_CallMethO(func, NULL);
        }
    }
    return __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL);
}
#endif

/* IterFinish */
static CYTHON_INLINE int __Pyx_IterFinish(void) {
#if CYTHON_FAST_THREAD_STATE
    PyThreadState *tstate = __Pyx_PyThreadState_Current;
    PyObject* exc_type = tstate->curexc_type;
    if (unlikely(exc_type)) {
        if (likely(__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) {
            PyObject *exc_value, *exc_tb;
            exc_value = tstate->curexc_value;
            exc_tb = tstate->curexc_traceback;
            tstate->curexc_type = 0;
            tstate->curexc_value = 0;
            tstate->curexc_traceback = 0;
            Py_DECREF(exc_type);
            Py_XDECREF(exc_value);
            Py_XDECREF(exc_tb);
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#else
    if (unlikely(PyErr_Occurred())) {
        if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) {
            PyErr_Clear();
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#endif
}

/* PyObjectGetMethod */
static int __Pyx_PyObject_GetMethod(PyObject *obj, PyObject *name, PyObject **method) {
    PyObject *attr;
#if CYTHON_UNPACK_METHODS && CYTHON_COMPILING_IN_CPYTHON && CYTHON_USE_PYTYPE_LOOKUP
    PyTypeObject *tp = Py_TYPE(obj);
    PyObject *descr;
    descrgetfunc f = NULL;
    PyObject **dictptr, *dict;
    int meth_found = 0;
    assert (*method == NULL);
    if (unlikely(tp->tp_getattro != PyObject_GenericGetAttr)) {
        attr = __Pyx_PyObject_GetAttrStr(obj, name);
        goto try_unpack;
    }
    if (unlikely(tp->tp_dict == NULL) && unlikely(PyType_Ready(tp) < 0)) {
        return 0;
    }
    descr = _PyType_Lookup(tp, name);
    if (likely(descr != NULL)) {
        Py_INCREF(descr);
#if PY_MAJOR_VERSION >= 3
        #ifdef __Pyx_CyFunction_USED
        if (likely(PyFunction_Check(descr) || (Py_TYPE(descr) == &PyMethodDescr_Type) || __Pyx_CyFunction_Check(descr)))
        #else
        if (likely(PyFunction_Check(descr) || (Py_TYPE(descr) == &PyMethodDescr_Type)))
        #endif
#else
        #ifdef __Pyx_CyFunction_USED
        if (likely(PyFunction_Check(descr) || __Pyx_CyFunction_Check(descr)))
        #else
        if (likely(PyFunction_Check(descr)))
        #endif
#endif
        {
            meth_found = 1;
        } else {
            f = Py_TYPE(descr)->tp_descr_get;
            if (f != NULL && PyDescr_IsData(descr)) {
                attr = f(descr, obj, (PyObject *)Py_TYPE(obj));
                Py_DECREF(descr);
                goto try_unpack;
            }
        }
    }
    dictptr = _PyObject_GetDictPtr(obj);
    if (dictptr != NULL && (dict = *dictptr) != NULL) {
        Py_INCREF(dict);
        attr = __Pyx_PyDict_GetItemStr(dict, name);
        if (attr != NULL) {
            Py_INCREF(attr);
            Py_DECREF(dict);
            Py_XDECREF(descr);
            goto try_unpack;
        }
        Py_DECREF(dict);
    }
    if (meth_found) {
        *method = descr;
        return 1;
    }
    if (f != NULL) {
        attr = f(descr, obj, (PyObject *)Py_TYPE(obj));
        Py_DECREF(descr);
        goto try_unpack;
    }
    if (descr != NULL) {
        *method = descr;
        return 0;
    }
    PyErr_Format(PyExc_AttributeError,
#if PY_MAJOR_VERSION >= 3
                 "'%.50s' object has no attribute '%U'",
                 tp->tp_name, name);
#else
                 "'%.50s' object has no attribute '%.400s'",
                 tp->tp_name, PyString_AS_STRING(name));
#endif
    return 0;
#else
    attr = __Pyx_PyObject_GetAttrStr(obj, name);
    goto try_unpack;
#endif
try_unpack:
#if CYTHON_UNPACK_METHODS
    if (likely(attr) && PyMethod_Check(attr) && likely(PyMethod_GET_SELF(attr) == obj)) {
        PyObject *function = PyMethod_GET_FUNCTION(attr);
        Py_INCREF(function);
        Py_DECREF(attr);
        *method = function;
        return 1;
    }
#endif
    *method = attr;
    return 0;
}

/* PyObjectCallMethod0 */
static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name) {
    PyObject *method = NULL, *result = NULL;
    int is_method = __Pyx_PyObject_GetMethod(obj, method_name, &method);
    if (likely(is_method)) {
        result = __Pyx_PyObject_CallOneArg(method, obj);
        Py_DECREF(method);
        return result;
    }
    if (unlikely(!method)) goto bad;
    result = __Pyx_PyObject_CallNoArg(method);
    Py_DECREF(method);
bad:
    return result;
}

/* RaiseNeedMoreValuesToUnpack */
static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
    PyErr_Format(PyExc_ValueError,
                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
                 index, (index == 1) ? "" : "s");
}

/* RaiseTooManyValuesToUnpack */
static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
    PyErr_Format(PyExc_ValueError,
                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
}

/* UnpackItemEndCheck */
static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
    if (unlikely(retval)) {
        Py_DECREF(retval);
        __Pyx_RaiseTooManyValuesError(expected);
        return -1;
    }
    return __Pyx_IterFinish();
}

/* RaiseNoneIterError */
static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
}

/* UnpackTupleError */
static void __Pyx_UnpackTupleError(PyObject *t, Py_ssize_t index) {
    if (t == Py_None) {
      __Pyx_RaiseNoneNotIterableError();
    } else if (PyTuple_GET_SIZE(t) < index) {
      __Pyx_RaiseNeedMoreValuesError(PyTuple_GET_SIZE(t));
    } else {
      __Pyx_RaiseTooManyValuesError(index);
    }
}

/* UnpackTuple2 */
static CYTHON_INLINE int __Pyx_unpack_tuple2_exact(
        PyObject* tuple, PyObject** pvalue1, PyObject** pvalue2, int decref_tuple) {
    PyObject *value1 = NULL, *value2 = NULL;
#if CYTHON_COMPILING_IN_PYPY
    value1 = PySequence_ITEM(tuple, 0);  if (unlikely(!value1)) goto bad;
    value2 = PySequence_ITEM(tuple, 1);  if (unlikely(!value2)) goto bad;
#else
    value1 = PyTuple_GET_ITEM(tuple, 0);  Py_INCREF(value1);
    value2 = PyTuple_GET_ITEM(tuple, 1);  Py_INCREF(value2);
#endif
    if (decref_tuple) {
        Py_DECREF(tuple);
    }
    *pvalue1 = value1;
    *pvalue2 = value2;
    return 0;
#if CYTHON_COMPILING_IN_PYPY
bad:
    Py_XDECREF(value1);
    Py_XDECREF(value2);
    if (decref_tuple) { Py_XDECREF(tuple); }
    return -1;
#endif
}
static int __Pyx_unpack_tuple2_generic(PyObject* tuple, PyObject** pvalue1, PyObject** pvalue2,
                                       int has_known_size, int decref_tuple) {
    Py_ssize_t index;
    PyObject *value1 = NULL, *value2 = NULL, *iter = NULL;
    iternextfunc iternext;
    iter = PyObject_GetIter(tuple);
    if (unlikely(!iter)) goto bad;
    if (decref_tuple) { Py_DECREF(tuple); tuple = NULL; }
    iternext = Py_TYPE(iter)->tp_iternext;
    value1 = iternext(iter); if (unlikely(!value1)) { index = 0; goto unpacking_failed; }
    value2 = iternext(iter); if (unlikely(!value2)) { index = 1; goto unpacking_failed; }
    if (!has_known_size && unlikely(__Pyx_IternextUnpackEndCheck(iternext(iter), 2))) goto bad;
    Py_DECREF(iter);
    *pvalue1 = value1;
    *pvalue2 = value2;
    return 0;
unpacking_failed:
    if (!has_known_size && __Pyx_IterFinish() == 0)
        __Pyx_RaiseNeedMoreValuesError(index);
bad:
    Py_XDECREF(iter);
    Py_XDECREF(value1);
    Py_XDECREF(value2);
    if (decref_tuple) { Py_XDECREF(tuple); }
    return -1;
}

/* dict_iter */
static CYTHON_INLINE PyObject* __Pyx_dict_iterator(PyObject* iterable, int is_dict, PyObject* method_name,
                                                   Py_ssize_t* p_orig_length, int* p_source_is_dict) {
    is_dict = is_dict || likely(PyDict_CheckExact(iterable));
    *p_source_is_dict = is_dict;
    if (is_dict) {
#if !CYTHON_COMPILING_IN_PYPY
        *p_orig_length = PyDict_Size(iterable);
        Py_INCREF(iterable);
        return iterable;
#elif PY_MAJOR_VERSION >= 3
        static PyObject *py_items = NULL, *py_keys = NULL, *py_values = NULL;
        PyObject **pp = NULL;
        if (method_name) {
            const char *name = PyUnicode_AsUTF8(method_name);
            if (strcmp(name, "iteritems") == 0) pp = &py_items;
            else if (strcmp(name, "iterkeys") == 0) pp = &py_keys;
            else if (strcmp(name, "itervalues") == 0) pp = &py_values;
            if (pp) {
                if (!*pp) {
                    *pp = PyUnicode_FromString(name + 4);
                    if (!*pp)
                        return NULL;
                }
                method_name = *pp;
            }
        }
#endif
    }
    *p_orig_length = 0;
    if (method_name) {
        PyObject* iter;
        iterable = __Pyx_PyObject_CallMethod0(iterable, method_name);
        if (!iterable)
            return NULL;
#if !CYTHON_COMPILING_IN_PYPY
        if (PyTuple_CheckExact(iterable) || PyList_CheckExact(iterable))
            return iterable;
#endif
        iter = PyObject_GetIter(iterable);
        Py_DECREF(iterable);
        return iter;
    }
    return PyObject_GetIter(iterable);
}
static CYTHON_INLINE int __Pyx_dict_iter_next(
        PyObject* iter_obj, CYTHON_NCP_UNUSED Py_ssize_t orig_length, CYTHON_NCP_UNUSED Py_ssize_t* ppos,
        PyObject** pkey, PyObject** pvalue, PyObject** pitem, int source_is_dict) {
    PyObject* next_item;
#if !CYTHON_COMPILING_IN_PYPY
    if (source_is_dict) {
        PyObject *key, *value;
        if (unlikely(orig_length != PyDict_Size(iter_obj))) {
            PyErr_SetString(PyExc_RuntimeError, "dictionary changed size during iteration");
            return -1;
        }
        if (unlikely(!PyDict_Next(iter_obj, ppos, &key, &value))) {
            return 0;
        }
        if (pitem) {
            PyObject* tuple = PyTuple_New(2);
            if (unlikely(!tuple)) {
                return -1;
            }
            Py_INCREF(key);
            Py_INCREF(value);
            PyTuple_SET_ITEM(tuple, 0, key);
            PyTuple_SET_ITEM(tuple, 1, value);
            *pitem = tuple;
        } else {
            if (pkey) {
                Py_INCREF(key);
                *pkey = key;
            }
            if (pvalue) {
                Py_INCREF(value);
                *pvalue = value;
            }
        }
        return 1;
    } else if (PyTuple_CheckExact(iter_obj)) {
        Py_ssize_t pos = *ppos;
        if (unlikely(pos >= PyTuple_GET_SIZE(iter_obj))) return 0;
        *ppos = pos + 1;
        next_item = PyTuple_GET_ITEM(iter_obj, pos);
        Py_INCREF(next_item);
    } else if (PyList_CheckExact(iter_obj)) {
        Py_ssize_t pos = *ppos;
        if (unlikely(pos >= PyList_GET_SIZE(iter_obj))) return 0;
        *ppos = pos + 1;
        next_item = PyList_GET_ITEM(iter_obj, pos);
        Py_INCREF(next_item);
    } else
#endif
    {
        next_item = PyIter_Next(iter_obj);
        if (unlikely(!next_item)) {
            return __Pyx_IterFinish();
        }
    }
    if (pitem) {
        *pitem = next_item;
    } else if (pkey && pvalue) {
        if (__Pyx_unpack_tuple2(next_item, pkey, pvalue, source_is_dict, source_is_dict, 1))
            return -1;
    } else if (pkey) {
        *pkey = next_item;
    } else {
        *pvalue = next_item;
    }
    return 1;
}

/* pyfrozenset_new */
static CYTHON_INLINE PyObject* __Pyx_PyFrozenSet_New(PyObject* it) {
    if (it) {
        PyObject* result;
#if CYTHON_COMPILING_IN_PYPY
        PyObject* args;
        args = PyTuple_Pack(1, it);
        if (unlikely(!args))
            return NULL;
        result = PyObject_Call((PyObject*)&PyFrozenSet_Type, args, NULL);
        Py_DECREF(args);
        return result;
#else
        if (PyFrozenSet_CheckExact(it)) {
            Py_INCREF(it);
            return it;
        }
        result = PyFrozenSet_New(it);
        if (unlikely(!result))
            return NULL;
        if ((PY_VERSION_HEX >= 0x031000A1) || likely(PySet_GET_SIZE(result)))
            return result;
        Py_DECREF(result);
#endif
    }
#if CYTHON_USE_TYPE_SLOTS
    return PyFrozenSet_Type.tp_new(&PyFrozenSet_Type, __pyx_empty_tuple, NULL);
#else
    return PyObject_Call((PyObject*)&PyFrozenSet_Type, __pyx_empty_tuple, NULL);
#endif
}

/* PySetContains */
static int __Pyx_PySet_ContainsUnhashable(PyObject *set, PyObject *key) {
    int result = -1;
    if (PySet_Check(key) && PyErr_ExceptionMatches(PyExc_TypeError)) {
        PyObject *tmpkey;
        PyErr_Clear();
        tmpkey = __Pyx_PyFrozenSet_New(key);
        if (tmpkey != NULL) {
            result = PySet_Contains(set, tmpkey);
            Py_DECREF(tmpkey);
        }
    }
    return result;
}
static CYTHON_INLINE int __Pyx_PySet_ContainsTF(PyObject* key, PyObject* set, int eq) {
    int result = PySet_Contains(set, key);
    if (unlikely(result < 0)) {
        result = __Pyx_PySet_ContainsUnhashable(set, key);
    }
    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
}

/* None */
static CYTHON_INLINE void __Pyx_RaiseClosureNameError(const char *varname) {
    PyErr_Format(PyExc_NameError, "free variable '%s' referenced before assignment in enclosing scope", varname);
}

/* PyErrFetchRestore */
#if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
}
#endif

/* RaiseException */
#if PY_MAJOR_VERSION < 3
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                        CYTHON_UNUSED PyObject *cause) {
    __Pyx_PyThreadState_declare
    Py_XINCREF(type);
    if (!value || value == Py_None)
        value = NULL;
    else
        Py_INCREF(value);
    if (!tb || tb == Py_None)
        tb = NULL;
    else {
        Py_INCREF(tb);
        if (!PyTraceBack_Check(tb)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: arg 3 must be a traceback or None");
            goto raise_error;
        }
    }
    if (PyType_Check(type)) {
#if CYTHON_COMPILING_IN_PYPY
        if (!value) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#endif
        PyErr_NormalizeException(&type, &value, &tb);
    } else {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        value = type;
        type = (PyObject*) Py_TYPE(type);
        Py_INCREF(type);
        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: exception class must be a subclass of BaseException");
            goto raise_error;
        }
    }
    __Pyx_PyThreadState_assign
    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}
#else
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
    PyObject* owned_instance = NULL;
    if (tb == Py_None) {
        tb = 0;
    } else if (tb && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto bad;
    }
    if (value == Py_None)
        value = 0;
    if (PyExceptionInstance_Check(type)) {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto bad;
        }
        value = type;
        type = (PyObject*) Py_TYPE(value);
    } else if (PyExceptionClass_Check(type)) {
        PyObject *instance_class = NULL;
        if (value && PyExceptionInstance_Check(value)) {
            instance_class = (PyObject*) Py_TYPE(value);
            if (instance_class != type) {
                int is_subclass = PyObject_IsSubclass(instance_class, type);
                if (!is_subclass) {
                    instance_class = NULL;
                } else if (unlikely(is_subclass == -1)) {
                    goto bad;
                } else {
                    type = instance_class;
                }
            }
        }
        if (!instance_class) {
            PyObject *args;
            if (!value)
                args = PyTuple_New(0);
            else if (PyTuple_Check(value)) {
                Py_INCREF(value);
                args = value;
            } else
                args = PyTuple_Pack(1, value);
            if (!args)
                goto bad;
            owned_instance = PyObject_Call(type, args, NULL);
            Py_DECREF(args);
            if (!owned_instance)
                goto bad;
            value = owned_instance;
            if (!PyExceptionInstance_Check(value)) {
                PyErr_Format(PyExc_TypeError,
                             "calling %R should have returned an instance of "
                             "BaseException, not %R",
                             type, Py_TYPE(value));
                goto bad;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,
            "raise: exception class must be a subclass of BaseException");
        goto bad;
    }
    if (cause) {
        PyObject *fixed_cause;
        if (cause == Py_None) {
            fixed_cause = NULL;
        } else if (PyExceptionClass_Check(cause)) {
            fixed_cause = PyObject_CallObject(cause, NULL);
            if (fixed_cause == NULL)
                goto bad;
        } else if (PyExceptionInstance_Check(cause)) {
            fixed_cause = cause;
            Py_INCREF(fixed_cause);
        } else {
            PyErr_SetString(PyExc_TypeError,
                            "exception causes must derive from "
                            "BaseException");
            goto bad;
        }
        PyException_SetCause(value, fixed_cause);
    }
    PyErr_SetObject(type, value);
    if (tb) {
#if CYTHON_FAST_THREAD_STATE
        PyThreadState *tstate = __Pyx_PyThreadState_Current;
        PyObject* tmp_tb = tstate->curexc_traceback;
        if (tb != tmp_tb) {
            Py_INCREF(tb);
            tstate->curexc_traceback = tb;
            Py_XDECREF(tmp_tb);
        }
#else
        PyObject *tmp_type, *tmp_value, *tmp_tb;
        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
        Py_INCREF(tb);
        PyErr_Restore(tmp_type, tmp_value, tb);
        Py_XDECREF(tmp_tb);
#endif
    }
bad:
    Py_XDECREF(owned_instance);
    return;
}
#endif

/* BytesEquals */
static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
#if CYTHON_COMPILING_IN_PYPY
    return PyObject_RichCompareBool(s1, s2, equals);
#else
    if (s1 == s2) {
        return (equals == Py_EQ);
    } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
        const char *ps1, *ps2;
        Py_ssize_t length = PyBytes_GET_SIZE(s1);
        if (length != PyBytes_GET_SIZE(s2))
            return (equals == Py_NE);
        ps1 = PyBytes_AS_STRING(s1);
        ps2 = PyBytes_AS_STRING(s2);
        if (ps1[0] != ps2[0]) {
            return (equals == Py_NE);
        } else if (length == 1) {
            return (equals == Py_EQ);
        } else {
            int result;
#if CYTHON_USE_UNICODE_INTERNALS && (PY_VERSION_HEX < 0x030B0000)
            Py_hash_t hash1, hash2;
            hash1 = ((PyBytesObject*)s1)->ob_shash;
            hash2 = ((PyBytesObject*)s2)->ob_shash;
            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
                return (equals == Py_NE);
            }
#endif
            result = memcmp(ps1, ps2, (size_t)length);
            return (equals == Py_EQ) ? (result == 0) : (result != 0);
        }
    } else if ((s1 == Py_None) & PyBytes_CheckExact(s2)) {
        return (equals == Py_NE);
    } else if ((s2 == Py_None) & PyBytes_CheckExact(s1)) {
        return (equals == Py_NE);
    } else {
        int result;
        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
        if (!py_result)
            return -1;
        result = __Pyx_PyObject_IsTrue(py_result);
        Py_DECREF(py_result);
        return result;
    }
#endif
}

/* UnicodeEquals */
static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals) {
#if CYTHON_COMPILING_IN_PYPY
    return PyObject_RichCompareBool(s1, s2, equals);
#else
#if PY_MAJOR_VERSION < 3
    PyObject* owned_ref = NULL;
#endif
    int s1_is_unicode, s2_is_unicode;
    if (s1 == s2) {
        goto return_eq;
    }
    s1_is_unicode = PyUnicode_CheckExact(s1);
    s2_is_unicode = PyUnicode_CheckExact(s2);
#if PY_MAJOR_VERSION < 3
    if ((s1_is_unicode & (!s2_is_unicode)) && PyString_CheckExact(s2)) {
        owned_ref = PyUnicode_FromObject(s2);
        if (unlikely(!owned_ref))
            return -1;
        s2 = owned_ref;
        s2_is_unicode = 1;
    } else if ((s2_is_unicode & (!s1_is_unicode)) && PyString_CheckExact(s1)) {
        owned_ref = PyUnicode_FromObject(s1);
        if (unlikely(!owned_ref))
            return -1;
        s1 = owned_ref;
        s1_is_unicode = 1;
    } else if (((!s2_is_unicode) & (!s1_is_unicode))) {
        return __Pyx_PyBytes_Equals(s1, s2, equals);
    }
#endif
    if (s1_is_unicode & s2_is_unicode) {
        Py_ssize_t length;
        int kind;
        void *data1, *data2;
        if (unlikely(__Pyx_PyUnicode_READY(s1) < 0) || unlikely(__Pyx_PyUnicode_READY(s2) < 0))
            return -1;
        length = __Pyx_PyUnicode_GET_LENGTH(s1);
        if (length != __Pyx_PyUnicode_GET_LENGTH(s2)) {
            goto return_ne;
        }
#if CYTHON_USE_UNICODE_INTERNALS
        {
            Py_hash_t hash1, hash2;
        #if CYTHON_PEP393_ENABLED
            hash1 = ((PyASCIIObject*)s1)->hash;
            hash2 = ((PyASCIIObject*)s2)->hash;
        #else
            hash1 = ((PyUnicodeObject*)s1)->hash;
            hash2 = ((PyUnicodeObject*)s2)->hash;
        #endif
            if (hash1 != hash2 && hash1 != -1 && hash2 != -1) {
                goto return_ne;
            }
        }
#endif
        kind = __Pyx_PyUnicode_KIND(s1);
        if (kind != __Pyx_PyUnicode_KIND(s2)) {
            goto return_ne;
        }
        data1 = __Pyx_PyUnicode_DATA(s1);
        data2 = __Pyx_PyUnicode_DATA(s2);
        if (__Pyx_PyUnicode_READ(kind, data1, 0) != __Pyx_PyUnicode_READ(kind, data2, 0)) {
            goto return_ne;
        } else if (length == 1) {
            goto return_eq;
        } else {
            int result = memcmp(data1, data2, (size_t)(length * kind));
            #if PY_MAJOR_VERSION < 3
            Py_XDECREF(owned_ref);
            #endif
            return (equals == Py_EQ) ? (result == 0) : (result != 0);
        }
    } else if ((s1 == Py_None) & s2_is_unicode) {
        goto return_ne;
    } else if ((s2 == Py_None) & s1_is_unicode) {
        goto return_ne;
    } else {
        int result;
        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
        #if PY_MAJOR_VERSION < 3
        Py_XDECREF(owned_ref);
        #endif
        if (!py_result)
            return -1;
        result = __Pyx_PyObject_IsTrue(py_result);
        Py_DECREF(py_result);
        return result;
    }
return_eq:
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(owned_ref);
    #endif
    return (equals == Py_EQ);
return_ne:
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(owned_ref);
    #endif
    return (equals == Py_NE);
#endif
}

/* JoinPyUnicode */
static PyObject* __Pyx_PyUnicode_Join(PyObject* value_tuple, Py_ssize_t value_count, Py_ssize_t result_ulength,
                                      CYTHON_UNUSED Py_UCS4 max_char) {
#if CYTHON_USE_UNICODE_INTERNALS && CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    PyObject *result_uval;
    int result_ukind;
    Py_ssize_t i, char_pos;
    void *result_udata;
#if CYTHON_PEP393_ENABLED
    result_uval = PyUnicode_New(result_ulength, max_char);
    if (unlikely(!result_uval)) return NULL;
    result_ukind = (max_char <= 255) ? PyUnicode_1BYTE_KIND : (max_char <= 65535) ? PyUnicode_2BYTE_KIND : PyUnicode_4BYTE_KIND;
    result_udata = PyUnicode_DATA(result_uval);
#else
    result_uval = PyUnicode_FromUnicode(NULL, result_ulength);
    if (unlikely(!result_uval)) return NULL;
    result_ukind = sizeof(Py_UNICODE);
    result_udata = PyUnicode_AS_UNICODE(result_uval);
#endif
    char_pos = 0;
    for (i=0; i < value_count; i++) {
        int ukind;
        Py_ssize_t ulength;
        void *udata;
        PyObject *uval = PyTuple_GET_ITEM(value_tuple, i);
        if (unlikely(__Pyx_PyUnicode_READY(uval)))
            goto bad;
        ulength = __Pyx_PyUnicode_GET_LENGTH(uval);
        if (unlikely(!ulength))
            continue;
        if (unlikely(char_pos + ulength < 0))
            goto overflow;
        ukind = __Pyx_PyUnicode_KIND(uval);
        udata = __Pyx_PyUnicode_DATA(uval);
        if (!CYTHON_PEP393_ENABLED || ukind == result_ukind) {
            memcpy((char *)result_udata + char_pos * result_ukind, udata, (size_t) (ulength * result_ukind));
        } else {
            #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030300F0 || defined(_PyUnicode_FastCopyCharacters)
            _PyUnicode_FastCopyCharacters(result_uval, char_pos, uval, 0, ulength);
            #else
            Py_ssize_t j;
            for (j=0; j < ulength; j++) {
                Py_UCS4 uchar = __Pyx_PyUnicode_READ(ukind, udata, j);
                __Pyx_PyUnicode_WRITE(result_ukind, result_udata, char_pos+j, uchar);
            }
            #endif
        }
        char_pos += ulength;
    }
    return result_uval;
overflow:
    PyErr_SetString(PyExc_OverflowError, "join() result is too long for a Python string");
bad:
    Py_DECREF(result_uval);
    return NULL;
#else
    result_ulength++;
    value_count++;
    return PyUnicode_Join(__pyx_empty_unicode, value_tuple);
#endif
}

/* PyIntCompare */
static CYTHON_INLINE PyObject* __Pyx_PyInt_NeObjC(PyObject *op1, PyObject *op2, CYTHON_UNUSED long intval, CYTHON_UNUSED long inplace) {
    if (op1 == op2) {
        Py_RETURN_FALSE;
    }
    #if PY_MAJOR_VERSION < 3
    if (likely(PyInt_CheckExact(op1))) {
        const long b = intval;
        long a = PyInt_AS_LONG(op1);
        if (a != b) Py_RETURN_TRUE; else Py_RETURN_FALSE;
    }
    #endif
    #if CYTHON_USE_PYLONG_INTERNALS
    if (likely(PyLong_CheckExact(op1))) {
        int unequal;
        unsigned long uintval;
        Py_ssize_t size = Py_SIZE(op1);
        const digit* digits = ((PyLongObject*)op1)->ob_digit;
        if (intval == 0) {
            if (size != 0) Py_RETURN_TRUE; else Py_RETURN_FALSE;
        } else if (intval < 0) {
            if (size >= 0)
                Py_RETURN_TRUE;
            intval = -intval;
            size = -size;
        } else {
            if (size <= 0)
                Py_RETURN_TRUE;
        }
        uintval = (unsigned long) intval;
#if PyLong_SHIFT * 4 < SIZEOF_LONG*8
        if (uintval >> (PyLong_SHIFT * 4)) {
            unequal = (size != 5) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[2] != ((uintval >> (2 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[3] != ((uintval >> (3 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[4] != ((uintval >> (4 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
        } else
#endif
#if PyLong_SHIFT * 3 < SIZEOF_LONG*8
        if (uintval >> (PyLong_SHIFT * 3)) {
            unequal = (size != 4) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[2] != ((uintval >> (2 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[3] != ((uintval >> (3 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
        } else
#endif
#if PyLong_SHIFT * 2 < SIZEOF_LONG*8
        if (uintval >> (PyLong_SHIFT * 2)) {
            unequal = (size != 3) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[2] != ((uintval >> (2 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
        } else
#endif
#if PyLong_SHIFT * 1 < SIZEOF_LONG*8
        if (uintval >> (PyLong_SHIFT * 1)) {
            unequal = (size != 2) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
        } else
#endif
            unequal = (size != 1) || (((unsigned long) digits[0]) != (uintval & (unsigned long) PyLong_MASK));
        if (unequal != 0) Py_RETURN_TRUE; else Py_RETURN_FALSE;
    }
    #endif
    if (PyFloat_CheckExact(op1)) {
        const long b = intval;
        double a = PyFloat_AS_DOUBLE(op1);
        if ((double)a != (double)b) Py_RETURN_TRUE; else Py_RETURN_FALSE;
    }
    return (
        PyObject_RichCompare(op1, op2, Py_NE));
}

/* GetItemInt */
static PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
    PyObject *r;
    if (!j) return NULL;
    r = PyObject_GetItem(o, j);
    Py_DECREF(j);
    return r;
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              CYTHON_NCP_UNUSED int wraparound,
                                                              CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    Py_ssize_t wrapped_i = i;
    if (wraparound & unlikely(i < 0)) {
        wrapped_i += PyList_GET_SIZE(o);
    }
    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyList_GET_SIZE(o)))) {
        PyObject *r = PyList_GET_ITEM(o, wrapped_i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              CYTHON_NCP_UNUSED int wraparound,
                                                              CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    Py_ssize_t wrapped_i = i;
    if (wraparound & unlikely(i < 0)) {
        wrapped_i += PyTuple_GET_SIZE(o);
    }
    if ((!boundscheck) || likely(__Pyx_is_valid_index(wrapped_i, PyTuple_GET_SIZE(o)))) {
        PyObject *r = PyTuple_GET_ITEM(o, wrapped_i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int is_list,
                                                     CYTHON_NCP_UNUSED int wraparound,
                                                     CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS && CYTHON_USE_TYPE_SLOTS
    if (is_list || PyList_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
        if ((!boundscheck) || (likely(__Pyx_is_valid_index(n, PyList_GET_SIZE(o))))) {
            PyObject *r = PyList_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    }
    else if (PyTuple_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
        if ((!boundscheck) || likely(__Pyx_is_valid_index(n, PyTuple_GET_SIZE(o)))) {
            PyObject *r = PyTuple_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    } else {
        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
        if (likely(m && m->sq_item)) {
            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
                Py_ssize_t l = m->sq_length(o);
                if (likely(l >= 0)) {
                    i += l;
                } else {
                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
                        return NULL;
                    PyErr_Clear();
                }
            }
            return m->sq_item(o, i);
        }
    }
#else
    if (is_list || PySequence_Check(o)) {
        return PySequence_GetItem(o, i);
    }
#endif
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
}

/* GetTopmostException */
#if CYTHON_USE_EXC_INFO_STACK
static _PyErr_StackItem *
__Pyx_PyErr_GetTopmostException(PyThreadState *tstate)
{
    _PyErr_StackItem *exc_info = tstate->exc_info;
    while ((exc_info->exc_type == NULL || exc_info->exc_type == Py_None) &&
           exc_info->previous_item != NULL)
    {
        exc_info = exc_info->previous_item;
    }
    return exc_info;
}
#endif

/* SaveResetException */
#if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    #if CYTHON_USE_EXC_INFO_STACK
    _PyErr_StackItem *exc_info = __Pyx_PyErr_GetTopmostException(tstate);
    *type = exc_info->exc_type;
    *value = exc_info->exc_value;
    *tb = exc_info->exc_traceback;
    #else
    *type = tstate->exc_type;
    *value = tstate->exc_value;
    *tb = tstate->exc_traceback;
    #endif
    Py_XINCREF(*type);
    Py_XINCREF(*value);
    Py_XINCREF(*tb);
}
static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    #if CYTHON_USE_EXC_INFO_STACK
    _PyErr_StackItem *exc_info = tstate->exc_info;
    tmp_type = exc_info->exc_type;
    tmp_value = exc_info->exc_value;
    tmp_tb = exc_info->exc_traceback;
    exc_info->exc_type = type;
    exc_info->exc_value = value;
    exc_info->exc_traceback = tb;
    #else
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = type;
    tstate->exc_value = value;
    tstate->exc_traceback = tb;
    #endif
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}
#endif

/* PyErrExceptionMatches */
#if CYTHON_FAST_THREAD_STATE
static int __Pyx_PyErr_ExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
    Py_ssize_t i, n;
    n = PyTuple_GET_SIZE(tuple);
#if PY_MAJOR_VERSION >= 3
    for (i=0; i<n; i++) {
        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
    }
#endif
    for (i=0; i<n; i++) {
        if (__Pyx_PyErr_GivenExceptionMatches(exc_type, PyTuple_GET_ITEM(tuple, i))) return 1;
    }
    return 0;
}
static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
    PyObject *exc_type = tstate->curexc_type;
    if (exc_type == err) return 1;
    if (unlikely(!exc_type)) return 0;
    if (unlikely(PyTuple_Check(err)))
        return __Pyx_PyErr_ExceptionMatchesTuple(exc_type, err);
    return __Pyx_PyErr_GivenExceptionMatches(exc_type, err);
}
#endif

/* GetException */
#if CYTHON_FAST_THREAD_STATE
static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb)
#else
static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb)
#endif
{
    PyObject *local_type, *local_value, *local_tb;
#if CYTHON_FAST_THREAD_STATE
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    local_type = tstate->curexc_type;
    local_value = tstate->curexc_value;
    local_tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
#else
    PyErr_Fetch(&local_type, &local_value, &local_tb);
#endif
    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
#if CYTHON_FAST_THREAD_STATE
    if (unlikely(tstate->curexc_type))
#else
    if (unlikely(PyErr_Occurred()))
#endif
        goto bad;
    #if PY_MAJOR_VERSION >= 3
    if (local_tb) {
        if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
            goto bad;
    }
    #endif
    Py_XINCREF(local_tb);
    Py_XINCREF(local_type);
    Py_XINCREF(local_value);
    *type = local_type;
    *value = local_value;
    *tb = local_tb;
#if CYTHON_FAST_THREAD_STATE
    #if CYTHON_USE_EXC_INFO_STACK
    {
        _PyErr_StackItem *exc_info = tstate->exc_info;
        tmp_type = exc_info->exc_type;
        tmp_value = exc_info->exc_value;
        tmp_tb = exc_info->exc_traceback;
        exc_info->exc_type = local_type;
        exc_info->exc_value = local_value;
        exc_info->exc_traceback = local_tb;
    }
    #else
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = local_type;
    tstate->exc_value = local_value;
    tstate->exc_traceback = local_tb;
    #endif
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_SetExcInfo(local_type, local_value, local_tb);
#endif
    return 0;
bad:
    *type = 0;
    *value = 0;
    *tb = 0;
    Py_XDECREF(local_type);
    Py_XDECREF(local_value);
    Py_XDECREF(local_tb);
    return -1;
}

/* SwapException */
#if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    #if CYTHON_USE_EXC_INFO_STACK
    _PyErr_StackItem *exc_info = tstate->exc_info;
    tmp_type = exc_info->exc_type;
    tmp_value = exc_info->exc_value;
    tmp_tb = exc_info->exc_traceback;
    exc_info->exc_type = *type;
    exc_info->exc_value = *value;
    exc_info->exc_traceback = *tb;
    #else
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = *type;
    tstate->exc_value = *value;
    tstate->exc_traceback = *tb;
    #endif
    *type = tmp_type;
    *value = tmp_value;
    *tb = tmp_tb;
}
#else
static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyErr_GetExcInfo(&tmp_type, &tmp_value, &tmp_tb);
    PyErr_SetExcInfo(*type, *value, *tb);
    *type = tmp_type;
    *value = tmp_value;
    *tb = tmp_tb;
}
#endif

/* PyIntCompare */
static CYTHON_INLINE PyObject* __Pyx_PyInt_EqObjC(PyObject *op1, PyObject *op2, CYTHON_UNUSED long intval, CYTHON_UNUSED long inplace) {
    if (op1 == op2) {
        Py_RETURN_TRUE;
    }
    #if PY_MAJOR_VERSION < 3
    if (likely(PyInt_CheckExact(op1))) {
        const long b = intval;
        long a = PyInt_AS_LONG(op1);
        if (a == b) Py_RETURN_TRUE; else Py_RETURN_FALSE;
    }
    #endif
    #if CYTHON_USE_PYLONG_INTERNALS
    if (likely(PyLong_CheckExact(op1))) {
        int unequal;
        unsigned long uintval;
        Py_ssize_t size = Py_SIZE(op1);
        const digit* digits = ((PyLongObject*)op1)->ob_digit;
        if (intval == 0) {
            if (size == 0) Py_RETURN_TRUE; else Py_RETURN_FALSE;
        } else if (intval < 0) {
            if (size >= 0)
                Py_RETURN_FALSE;
            intval = -intval;
            size = -size;
        } else {
            if (size <= 0)
                Py_RETURN_FALSE;
        }
        uintval = (unsigned long) intval;
#if PyLong_SHIFT * 4 < SIZEOF_LONG*8
        if (uintval >> (PyLong_SHIFT * 4)) {
            unequal = (size != 5) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[2] != ((uintval >> (2 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[3] != ((uintval >> (3 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[4] != ((uintval >> (4 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
        } else
#endif
#if PyLong_SHIFT * 3 < SIZEOF_LONG*8
        if (uintval >> (PyLong_SHIFT * 3)) {
            unequal = (size != 4) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[2] != ((uintval >> (2 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[3] != ((uintval >> (3 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
        } else
#endif
#if PyLong_SHIFT * 2 < SIZEOF_LONG*8
        if (uintval >> (PyLong_SHIFT * 2)) {
            unequal = (size != 3) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK)) | (digits[2] != ((uintval >> (2 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
        } else
#endif
#if PyLong_SHIFT * 1 < SIZEOF_LONG*8
        if (uintval >> (PyLong_SHIFT * 1)) {
            unequal = (size != 2) || (digits[0] != (uintval & (unsigned long) PyLong_MASK))
                 | (digits[1] != ((uintval >> (1 * PyLong_SHIFT)) & (unsigned long) PyLong_MASK));
        } else
#endif
            unequal = (size != 1) || (((unsigned long) digits[0]) != (uintval & (unsigned long) PyLong_MASK));
        if (unequal == 0) Py_RETURN_TRUE; else Py_RETURN_FALSE;
    }
    #endif
    if (PyFloat_CheckExact(op1)) {
        const long b = intval;
        double a = PyFloat_AS_DOUBLE(op1);
        if ((double)a == (double)b) Py_RETURN_TRUE; else Py_RETURN_FALSE;
    }
    return (
        PyObject_RichCompare(op1, op2, Py_EQ));
}

/* PyObjectFormatAndDecref */
static CYTHON_INLINE PyObject* __Pyx_PyObject_FormatSimpleAndDecref(PyObject* s, PyObject* f) {
    if (unlikely(!s)) return NULL;
    if (likely(PyUnicode_CheckExact(s))) return s;
    #if PY_MAJOR_VERSION < 3
    if (likely(PyString_CheckExact(s))) {
        PyObject *result = PyUnicode_FromEncodedObject(s, NULL, "strict");
        Py_DECREF(s);
        return result;
    }
    #endif
    return __Pyx_PyObject_FormatAndDecref(s, f);
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_FormatAndDecref(PyObject* s, PyObject* f) {
    PyObject *result = PyObject_Format(s, f);
    Py_DECREF(s);
    return result;
}

/* PyObjectSetAttrStr */
#if CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_setattro))
        return tp->tp_setattro(obj, attr_name, value);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_setattr))
        return tp->tp_setattr(obj, PyString_AS_STRING(attr_name), value);
#endif
    return PyObject_SetAttr(obj, attr_name, value);
}
#endif

/* ObjectGetItem */
#if CYTHON_USE_TYPE_SLOTS
static PyObject *__Pyx_PyObject_GetIndex(PyObject *obj, PyObject* index) {
    PyObject *runerr = NULL;
    Py_ssize_t key_value;
    PySequenceMethods *m = Py_TYPE(obj)->tp_as_sequence;
    if (unlikely(!(m && m->sq_item))) {
        PyErr_Format(PyExc_TypeError, "'%.200s' object is not subscriptable", Py_TYPE(obj)->tp_name);
        return NULL;
    }
    key_value = __Pyx_PyIndex_AsSsize_t(index);
    if (likely(key_value != -1 || !(runerr = PyErr_Occurred()))) {
        return __Pyx_GetItemInt_Fast(obj, key_value, 0, 1, 1);
    }
    if (PyErr_GivenExceptionMatches(runerr, PyExc_OverflowError)) {
        PyErr_Clear();
        PyErr_Format(PyExc_IndexError, "cannot fit '%.200s' into an index-sized integer", Py_TYPE(index)->tp_name);
    }
    return NULL;
}
static PyObject *__Pyx_PyObject_GetItem(PyObject *obj, PyObject* key) {
    PyMappingMethods *m = Py_TYPE(obj)->tp_as_mapping;
    if (likely(m && m->mp_subscript)) {
        return m->mp_subscript(obj, key);
    }
    return __Pyx_PyObject_GetIndex(obj, key);
}
#endif

/* FetchCommonType */
static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type) {
    PyObject* fake_module;
    PyTypeObject* cached_type = NULL;
    fake_module = PyImport_AddModule((char*) "_cython_" CYTHON_ABI);
    if (!fake_module) return NULL;
    Py_INCREF(fake_module);
    cached_type = (PyTypeObject*) PyObject_GetAttrString(fake_module, type->tp_name);
    if (cached_type) {
        if (!PyType_Check((PyObject*)cached_type)) {
            PyErr_Format(PyExc_TypeError,
                "Shared Cython type %.200s is not a type object",
                type->tp_name);
            goto bad;
        }
        if (cached_type->tp_basicsize != type->tp_basicsize) {
            PyErr_Format(PyExc_TypeError,
                "Shared Cython type %.200s has the wrong size, try recompiling",
                type->tp_name);
            goto bad;
        }
    } else {
        if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
        PyErr_Clear();
        if (PyType_Ready(type) < 0) goto bad;
        if (PyObject_SetAttrString(fake_module, type->tp_name, (PyObject*) type) < 0)
            goto bad;
        Py_INCREF(type);
        cached_type = type;
    }
done:
    Py_DECREF(fake_module);
    return cached_type;
bad:
    Py_XDECREF(cached_type);
    cached_type = NULL;
    goto done;
}

/* CythonFunctionShared */
#include <structmember.h>
static PyObject *
__Pyx_CyFunction_get_doc(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *closure)
{
    if (unlikely(op->func_doc == NULL)) {
        if (op->func.m_ml->ml_doc) {
#if PY_MAJOR_VERSION >= 3
            op->func_doc = PyUnicode_FromString(op->func.m_ml->ml_doc);
#else
            op->func_doc = PyString_FromString(op->func.m_ml->ml_doc);
#endif
            if (unlikely(op->func_doc == NULL))
                return NULL;
        } else {
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    Py_INCREF(op->func_doc);
    return op->func_doc;
}
static int
__Pyx_CyFunction_set_doc(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
{
    PyObject *tmp = op->func_doc;
    if (value == NULL) {
        value = Py_None;
    }
    Py_INCREF(value);
    op->func_doc = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_name(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
{
    if (unlikely(op->func_name == NULL)) {
#if PY_MAJOR_VERSION >= 3
        op->func_name = PyUnicode_InternFromString(op->func.m_ml->ml_name);
#else
        op->func_name = PyString_InternFromString(op->func.m_ml->ml_name);
#endif
        if (unlikely(op->func_name == NULL))
            return NULL;
    }
    Py_INCREF(op->func_name);
    return op->func_name;
}
static int
__Pyx_CyFunction_set_name(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value)))
#else
    if (unlikely(value == NULL || !PyString_Check(value)))
#endif
    {
        PyErr_SetString(PyExc_TypeError,
                        "__name__ must be set to a string object");
        return -1;
    }
    tmp = op->func_name;
    Py_INCREF(value);
    op->func_name = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_qualname(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
{
    Py_INCREF(op->func_qualname);
    return op->func_qualname;
}
static int
__Pyx_CyFunction_set_qualname(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value)))
#else
    if (unlikely(value == NULL || !PyString_Check(value)))
#endif
    {
        PyErr_SetString(PyExc_TypeError,
                        "__qualname__ must be set to a string object");
        return -1;
    }
    tmp = op->func_qualname;
    Py_INCREF(value);
    op->func_qualname = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_self(__pyx_CyFunctionObject *m, CYTHON_UNUSED void *closure)
{
    PyObject *self;
    self = m->func_closure;
    if (self == NULL)
        self = Py_None;
    Py_INCREF(self);
    return self;
}
static PyObject *
__Pyx_CyFunction_get_dict(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
{
    if (unlikely(op->func_dict == NULL)) {
        op->func_dict = PyDict_New();
        if (unlikely(op->func_dict == NULL))
            return NULL;
    }
    Py_INCREF(op->func_dict);
    return op->func_dict;
}
static int
__Pyx_CyFunction_set_dict(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
{
    PyObject *tmp;
    if (unlikely(value == NULL)) {
        PyErr_SetString(PyExc_TypeError,
               "function's dictionary may not be deleted");
        return -1;
    }
    if (unlikely(!PyDict_Check(value))) {
        PyErr_SetString(PyExc_TypeError,
               "setting function's dictionary to a non-dict");
        return -1;
    }
    tmp = op->func_dict;
    Py_INCREF(value);
    op->func_dict = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_globals(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
{
    Py_INCREF(op->func_globals);
    return op->func_globals;
}
static PyObject *
__Pyx_CyFunction_get_closure(CYTHON_UNUSED __pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
{
    Py_INCREF(Py_None);
    return Py_None;
}
static PyObject *
__Pyx_CyFunction_get_code(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
{
    PyObject* result = (op->func_code) ? op->func_code : Py_None;
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_init_defaults(__pyx_CyFunctionObject *op) {
    int result = 0;
    PyObject *res = op->defaults_getter((PyObject *) op);
    if (unlikely(!res))
        return -1;
    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
    op->defaults_tuple = PyTuple_GET_ITEM(res, 0);
    Py_INCREF(op->defaults_tuple);
    op->defaults_kwdict = PyTuple_GET_ITEM(res, 1);
    Py_INCREF(op->defaults_kwdict);
    #else
    op->defaults_tuple = PySequence_ITEM(res, 0);
    if (unlikely(!op->defaults_tuple)) result = -1;
    else {
        op->defaults_kwdict = PySequence_ITEM(res, 1);
        if (unlikely(!op->defaults_kwdict)) result = -1;
    }
    #endif
    Py_DECREF(res);
    return result;
}
static int
__Pyx_CyFunction_set_defaults(__pyx_CyFunctionObject *op, PyObject* value, CYTHON_UNUSED void *context) {
    PyObject* tmp;
    if (!value) {
        value = Py_None;
    } else if (value != Py_None && !PyTuple_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__defaults__ must be set to a tuple object");
        return -1;
    }
    Py_INCREF(value);
    tmp = op->defaults_tuple;
    op->defaults_tuple = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_defaults(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context) {
    PyObject* result = op->defaults_tuple;
    if (unlikely(!result)) {
        if (op->defaults_getter) {
            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
            result = op->defaults_tuple;
        } else {
            result = Py_None;
        }
    }
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_set_kwdefaults(__pyx_CyFunctionObject *op, PyObject* value, CYTHON_UNUSED void *context) {
    PyObject* tmp;
    if (!value) {
        value = Py_None;
    } else if (value != Py_None && !PyDict_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__kwdefaults__ must be set to a dict object");
        return -1;
    }
    Py_INCREF(value);
    tmp = op->defaults_kwdict;
    op->defaults_kwdict = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_kwdefaults(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context) {
    PyObject* result = op->defaults_kwdict;
    if (unlikely(!result)) {
        if (op->defaults_getter) {
            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
            result = op->defaults_kwdict;
        } else {
            result = Py_None;
        }
    }
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_set_annotations(__pyx_CyFunctionObject *op, PyObject* value, CYTHON_UNUSED void *context) {
    PyObject* tmp;
    if (!value || value == Py_None) {
        value = NULL;
    } else if (!PyDict_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__annotations__ must be set to a dict object");
        return -1;
    }
    Py_XINCREF(value);
    tmp = op->func_annotations;
    op->func_annotations = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_annotations(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context) {
    PyObject* result = op->func_annotations;
    if (unlikely(!result)) {
        result = PyDict_New();
        if (unlikely(!result)) return NULL;
        op->func_annotations = result;
    }
    Py_INCREF(result);
    return result;
}
static PyGetSetDef __pyx_CyFunction_getsets[] = {
    {(char *) "func_doc", (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
    {(char *) "__doc__",  (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
    {(char *) "func_name", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
    {(char *) "__name__", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
    {(char *) "__qualname__", (getter)__Pyx_CyFunction_get_qualname, (setter)__Pyx_CyFunction_set_qualname, 0, 0},
    {(char *) "__self__", (getter)__Pyx_CyFunction_get_self, 0, 0, 0},
    {(char *) "func_dict", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
    {(char *) "__dict__", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
    {(char *) "func_globals", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
    {(char *) "__globals__", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
    {(char *) "func_closure", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
    {(char *) "__closure__", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
    {(char *) "func_code", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
    {(char *) "__code__", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
    {(char *) "func_defaults", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
    {(char *) "__defaults__", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
    {(char *) "__kwdefaults__", (getter)__Pyx_CyFunction_get_kwdefaults, (setter)__Pyx_CyFunction_set_kwdefaults, 0, 0},
    {(char *) "__annotations__", (getter)__Pyx_CyFunction_get_annotations, (setter)__Pyx_CyFunction_set_annotations, 0, 0},
    {0, 0, 0, 0, 0}
};
static PyMemberDef __pyx_CyFunction_members[] = {
    {(char *) "__module__", T_OBJECT, offsetof(PyCFunctionObject, m_module), PY_WRITE_RESTRICTED, 0},
    {0, 0, 0,  0, 0}
};
static PyObject *
__Pyx_CyFunction_reduce(__pyx_CyFunctionObject *m, CYTHON_UNUSED PyObject *args)
{
#if PY_MAJOR_VERSION >= 3
    Py_INCREF(m->func_qualname);
    return m->func_qualname;
#else
    return PyString_FromString(m->func.m_ml->ml_name);
#endif
}
static PyMethodDef __pyx_CyFunction_methods[] = {
    {"__reduce__", (PyCFunction)__Pyx_CyFunction_reduce, METH_VARARGS, 0},
    {0, 0, 0, 0}
};
#if PY_VERSION_HEX < 0x030500A0
#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func_weakreflist)
#else
#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func.m_weakreflist)
#endif
static PyObject *__Pyx_CyFunction_Init(__pyx_CyFunctionObject *op, PyMethodDef *ml, int flags, PyObject* qualname,
                                       PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
    if (unlikely(op == NULL))
        return NULL;
    op->flags = flags;
    __Pyx_CyFunction_weakreflist(op) = NULL;
    op->func.m_ml = ml;
    op->func.m_self = (PyObject *) op;
    Py_XINCREF(closure);
    op->func_closure = closure;
    Py_XINCREF(module);
    op->func.m_module = module;
    op->func_dict = NULL;
    op->func_name = NULL;
    Py_INCREF(qualname);
    op->func_qualname = qualname;
    op->func_doc = NULL;
    op->func_classobj = NULL;
    op->func_globals = globals;
    Py_INCREF(op->func_globals);
    Py_XINCREF(code);
    op->func_code = code;
    op->defaults_pyobjects = 0;
    op->defaults_size = 0;
    op->defaults = NULL;
    op->defaults_tuple = NULL;
    op->defaults_kwdict = NULL;
    op->defaults_getter = NULL;
    op->func_annotations = NULL;
    return (PyObject *) op;
}
static int
__Pyx_CyFunction_clear(__pyx_CyFunctionObject *m)
{
    Py_CLEAR(m->func_closure);
    Py_CLEAR(m->func.m_module);
    Py_CLEAR(m->func_dict);
    Py_CLEAR(m->func_name);
    Py_CLEAR(m->func_qualname);
    Py_CLEAR(m->func_doc);
    Py_CLEAR(m->func_globals);
    Py_CLEAR(m->func_code);
    Py_CLEAR(m->func_classobj);
    Py_CLEAR(m->defaults_tuple);
    Py_CLEAR(m->defaults_kwdict);
    Py_CLEAR(m->func_annotations);
    if (m->defaults) {
        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
        int i;
        for (i = 0; i < m->defaults_pyobjects; i++)
            Py_XDECREF(pydefaults[i]);
        PyObject_Free(m->defaults);
        m->defaults = NULL;
    }
    return 0;
}
static void __Pyx__CyFunction_dealloc(__pyx_CyFunctionObject *m)
{
    if (__Pyx_CyFunction_weakreflist(m) != NULL)
        PyObject_ClearWeakRefs((PyObject *) m);
    __Pyx_CyFunction_clear(m);
    PyObject_GC_Del(m);
}
static void __Pyx_CyFunction_dealloc(__pyx_CyFunctionObject *m)
{
    PyObject_GC_UnTrack(m);
    __Pyx__CyFunction_dealloc(m);
}
static int __Pyx_CyFunction_traverse(__pyx_CyFunctionObject *m, visitproc visit, void *arg)
{
    Py_VISIT(m->func_closure);
    Py_VISIT(m->func.m_module);
    Py_VISIT(m->func_dict);
    Py_VISIT(m->func_name);
    Py_VISIT(m->func_qualname);
    Py_VISIT(m->func_doc);
    Py_VISIT(m->func_globals);
    Py_VISIT(m->func_code);
    Py_VISIT(m->func_classobj);
    Py_VISIT(m->defaults_tuple);
    Py_VISIT(m->defaults_kwdict);
    if (m->defaults) {
        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
        int i;
        for (i = 0; i < m->defaults_pyobjects; i++)
            Py_VISIT(pydefaults[i]);
    }
    return 0;
}
static PyObject *__Pyx_CyFunction_descr_get(PyObject *func, PyObject *obj, PyObject *type)
{
#if PY_MAJOR_VERSION < 3
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    if (m->flags & __Pyx_CYFUNCTION_STATICMETHOD) {
        Py_INCREF(func);
        return func;
    }
    if (m->flags & __Pyx_CYFUNCTION_CLASSMETHOD) {
        if (type == NULL)
            type = (PyObject *)(Py_TYPE(obj));
        return __Pyx_PyMethod_New(func, type, (PyObject *)(Py_TYPE(type)));
    }
    if (obj == Py_None)
        obj = NULL;
#endif
    return __Pyx_PyMethod_New(func, obj, type);
}
static PyObject*
__Pyx_CyFunction_repr(__pyx_CyFunctionObject *op)
{
#if PY_MAJOR_VERSION >= 3
    return PyUnicode_FromFormat("<cyfunction %U at %p>",
                                op->func_qualname, (void *)op);
#else
    return PyString_FromFormat("<cyfunction %s at %p>",
                               PyString_AsString(op->func_qualname), (void *)op);
#endif
}
static PyObject * __Pyx_CyFunction_CallMethod(PyObject *func, PyObject *self, PyObject *arg, PyObject *kw) {
    PyCFunctionObject* f = (PyCFunctionObject*)func;
    PyCFunction meth = f->m_ml->ml_meth;
    Py_ssize_t size;
    switch (f->m_ml->ml_flags & (METH_VARARGS | METH_KEYWORDS | METH_NOARGS | METH_O)) {
    case METH_VARARGS:
        if (likely(kw == NULL || PyDict_Size(kw) == 0))
            return (*meth)(self, arg);
        break;
    case METH_VARARGS | METH_KEYWORDS:
        return (*(PyCFunctionWithKeywords)(void*)meth)(self, arg, kw);
    case METH_NOARGS:
        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
            size = PyTuple_GET_SIZE(arg);
            if (likely(size == 0))
                return (*meth)(self, NULL);
            PyErr_Format(PyExc_TypeError,
                "%.200s() takes no arguments (%" CYTHON_FORMAT_SSIZE_T "d given)",
                f->m_ml->ml_name, size);
            return NULL;
        }
        break;
    case METH_O:
        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
            size = PyTuple_GET_SIZE(arg);
            if (likely(size == 1)) {
                PyObject *result, *arg0;
                #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
                arg0 = PyTuple_GET_ITEM(arg, 0);
                #else
                arg0 = PySequence_ITEM(arg, 0); if (unlikely(!arg0)) return NULL;
                #endif
                result = (*meth)(self, arg0);
                #if !(CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS)
                Py_DECREF(arg0);
                #endif
                return result;
            }
            PyErr_Format(PyExc_TypeError,
                "%.200s() takes exactly one argument (%" CYTHON_FORMAT_SSIZE_T "d given)",
                f->m_ml->ml_name, size);
            return NULL;
        }
        break;
    default:
        PyErr_SetString(PyExc_SystemError, "Bad call flags in "
                        "__Pyx_CyFunction_Call. METH_OLDARGS is no "
                        "longer supported!");
        return NULL;
    }
    PyErr_Format(PyExc_TypeError, "%.200s() takes no keyword arguments",
                 f->m_ml->ml_name);
    return NULL;
}
static CYTHON_INLINE PyObject *__Pyx_CyFunction_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    return __Pyx_CyFunction_CallMethod(func, ((PyCFunctionObject*)func)->m_self, arg, kw);
}
static PyObject *__Pyx_CyFunction_CallAsMethod(PyObject *func, PyObject *args, PyObject *kw) {
    PyObject *result;
    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *) func;
    if ((cyfunc->flags & __Pyx_CYFUNCTION_CCLASS) && !(cyfunc->flags & __Pyx_CYFUNCTION_STATICMETHOD)) {
        Py_ssize_t argc;
        PyObject *new_args;
        PyObject *self;
        argc = PyTuple_GET_SIZE(args);
        new_args = PyTuple_GetSlice(args, 1, argc);
        if (unlikely(!new_args))
            return NULL;
        self = PyTuple_GetItem(args, 0);
        if (unlikely(!self)) {
            Py_DECREF(new_args);
#if PY_MAJOR_VERSION > 2
            PyErr_Format(PyExc_TypeError,
                         "unbound method %.200S() needs an argument",
                         cyfunc->func_qualname);
#else
            PyErr_SetString(PyExc_TypeError,
                            "unbound method needs an argument");
#endif
            return NULL;
        }
        result = __Pyx_CyFunction_CallMethod(func, self, new_args, kw);
        Py_DECREF(new_args);
    } else {
        result = __Pyx_CyFunction_Call(func, args, kw);
    }
    return result;
}
static PyTypeObject __pyx_CyFunctionType_type = {
    PyVarObject_HEAD_INIT(0, 0)
    "cython_function_or_method",
    sizeof(__pyx_CyFunctionObject),
    0,
    (destructor) __Pyx_CyFunction_dealloc,
    0,
    0,
    0,
#if PY_MAJOR_VERSION < 3
    0,
#else
    0,
#endif
    (reprfunc) __Pyx_CyFunction_repr,
    0,
    0,
    0,
    0,
    __Pyx_CyFunction_CallAsMethod,
    0,
    0,
    0,
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
    0,
    (traverseproc) __Pyx_CyFunction_traverse,
    (inquiry) __Pyx_CyFunction_clear,
    0,
#if PY_VERSION_HEX < 0x030500A0
    offsetof(__pyx_CyFunctionObject, func_weakreflist),
#else
    offsetof(PyCFunctionObject, m_weakreflist),
#endif
    0,
    0,
    __pyx_CyFunction_methods,
    __pyx_CyFunction_members,
    __pyx_CyFunction_getsets,
    0,
    0,
    __Pyx_CyFunction_descr_get,
    0,
    offsetof(__pyx_CyFunctionObject, func_dict),
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
#if PY_VERSION_HEX >= 0x030400a1
    0,
#endif
#if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
    0,
#endif
#if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
    0,
#endif
#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
    0,
#endif
};
static int __pyx_CyFunction_init(void) {
    __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
    if (unlikely(__pyx_CyFunctionType == NULL)) {
        return -1;
    }
    return 0;
}
static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *func, size_t size, int pyobjects) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults = PyObject_Malloc(size);
    if (unlikely(!m->defaults))
        return PyErr_NoMemory();
    memset(m->defaults, 0, size);
    m->defaults_pyobjects = pyobjects;
    m->defaults_size = size;
    return m->defaults;
}
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *func, PyObject *tuple) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults_tuple = tuple;
    Py_INCREF(tuple);
}
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *func, PyObject *dict) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults_kwdict = dict;
    Py_INCREF(dict);
}
static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *func, PyObject *dict) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->func_annotations = dict;
    Py_INCREF(dict);
}

/* CythonFunction */
static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml, int flags, PyObject* qualname,
                                      PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
    PyObject *op = __Pyx_CyFunction_Init(
        PyObject_GC_New(__pyx_CyFunctionObject, __pyx_CyFunctionType),
        ml, flags, qualname, closure, module, globals, code
    );
    if (likely(op)) {
        PyObject_GC_Track(op);
    }
    return op;
}

/* MergeKeywords */
static int __Pyx_MergeKeywords(PyObject *kwdict, PyObject *source_mapping) {
    PyObject *iter, *key = NULL, *value = NULL;
    int source_is_dict, result;
    Py_ssize_t orig_length, ppos = 0;
    iter = __Pyx_dict_iterator(source_mapping, 0, __pyx_n_s_items, &orig_length, &source_is_dict);
    if (unlikely(!iter)) {
        PyObject *args;
        if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
        PyErr_Clear();
        args = PyTuple_Pack(1, source_mapping);
        if (likely(args)) {
            PyObject *fallback = PyObject_Call((PyObject*)&PyDict_Type, args, NULL);
            Py_DECREF(args);
            if (likely(fallback)) {
                iter = __Pyx_dict_iterator(fallback, 1, __pyx_n_s_items, &orig_length, &source_is_dict);
                Py_DECREF(fallback);
            }
        }
        if (unlikely(!iter)) goto bad;
    }
    while (1) {
        result = __Pyx_dict_iter_next(iter, orig_length, &ppos, &key, &value, NULL, source_is_dict);
        if (unlikely(result < 0)) goto bad;
        if (!result) break;
        if (unlikely(PyDict_Contains(kwdict, key))) {
            __Pyx_RaiseDoubleKeywordsError("function", key);
            result = -1;
        } else {
            result = PyDict_SetItem(kwdict, key, value);
        }
        Py_DECREF(key);
        Py_DECREF(value);
        if (unlikely(result < 0)) goto bad;
    }
    Py_XDECREF(iter);
    return 0;
bad:
    Py_XDECREF(iter);
    return -1;
}

/* Import */
static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    #if PY_MAJOR_VERSION < 3
    PyObject *py_import;
    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
    if (!py_import)
        goto bad;
    #endif
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    {
        #if PY_MAJOR_VERSION >= 3
        if (level == -1) {
            if ((1) && (strchr(__Pyx_MODULE_NAME, '.'))) {
                module = PyImport_ImportModuleLevelObject(
                    name, global_dict, empty_dict, list, 1);
                if (!module) {
                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                        goto bad;
                    PyErr_Clear();
                }
            }
            level = 0;
        }
        #endif
        if (!module) {
            #if PY_MAJOR_VERSION < 3
            PyObject *py_level = PyInt_FromLong(level);
            if (!py_level)
                goto bad;
            module = PyObject_CallFunctionObjArgs(py_import,
                name, global_dict, empty_dict, list, py_level, (PyObject *)NULL);
            Py_DECREF(py_level);
            #else
            module = PyImport_ImportModuleLevelObject(
                name, global_dict, empty_dict, list, level);
            #endif
        }
    }
bad:
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(py_import);
    #endif
    Py_XDECREF(empty_list);
    Py_XDECREF(empty_dict);
    return module;
}

/* ImportFrom */
static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
        PyErr_Format(PyExc_ImportError,
        #if PY_MAJOR_VERSION < 3
            "cannot import name %.230s", PyString_AS_STRING(name));
        #else
            "cannot import name %S", name);
        #endif
    }
    return value;
}

/* GetAttr */
static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *o, PyObject *n) {
#if CYTHON_USE_TYPE_SLOTS
#if PY_MAJOR_VERSION >= 3
    if (likely(PyUnicode_Check(n)))
#else
    if (likely(PyString_Check(n)))
#endif
        return __Pyx_PyObject_GetAttrStr(o, n);
#endif
    return PyObject_GetAttr(o, n);
}

/* HasAttr */
static CYTHON_INLINE int __Pyx_HasAttr(PyObject *o, PyObject *n) {
    PyObject *r;
    if (unlikely(!__Pyx_PyBaseString_Check(n))) {
        PyErr_SetString(PyExc_TypeError,
                        "hasattr(): attribute name must be string");
        return -1;
    }
    r = __Pyx_GetAttr(o, n);
    if (unlikely(!r)) {
        PyErr_Clear();
        return 0;
    } else {
        Py_DECREF(r);
        return 1;
    }
}

/* PyIntBinop */
#if !CYTHON_COMPILING_IN_PYPY
static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, CYTHON_UNUSED long intval, int inplace, int zerodivision_check) {
    (void)inplace;
    (void)zerodivision_check;
    #if PY_MAJOR_VERSION < 3
    if (likely(PyInt_CheckExact(op1))) {
        const long b = intval;
        long x;
        long a = PyInt_AS_LONG(op1);
            x = (long)((unsigned long)a + b);
            if (likely((x^a) >= 0 || (x^b) >= 0))
                return PyInt_FromLong(x);
            return PyLong_Type.tp_as_number->nb_add(op1, op2);
    }
    #endif
    #if CYTHON_USE_PYLONG_INTERNALS
    if (likely(PyLong_CheckExact(op1))) {
        const long b = intval;
        long a, x;
#ifdef HAVE_LONG_LONG
        const PY_LONG_LONG llb = intval;
        PY_LONG_LONG lla, llx;
#endif
        const digit* digits = ((PyLongObject*)op1)->ob_digit;
        const Py_ssize_t size = Py_SIZE(op1);
        if (likely(__Pyx_sst_abs(size) <= 1)) {
            a = likely(size) ? digits[0] : 0;
            if (size == -1) a = -a;
        } else {
            switch (size) {
                case -2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
#ifdef HAVE_LONG_LONG
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
#endif
                    }
                    CYTHON_FALLTHROUGH;
                case 2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = (long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
#ifdef HAVE_LONG_LONG
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
#endif
                    }
                    CYTHON_FALLTHROUGH;
                case -3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
#ifdef HAVE_LONG_LONG
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
#endif
                    }
                    CYTHON_FALLTHROUGH;
                case 3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = (long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
#ifdef HAVE_LONG_LONG
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
#endif
                    }
                    CYTHON_FALLTHROUGH;
                case -4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
#ifdef HAVE_LONG_LONG
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
#endif
                    }
                    CYTHON_FALLTHROUGH;
                case 4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = (long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
#ifdef HAVE_LONG_LONG
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
#endif
                    }
                    CYTHON_FALLTHROUGH;
                default: return PyLong_Type.tp_as_number->nb_add(op1, op2);
            }
        }
                x = a + b;
            return PyLong_FromLong(x);
#ifdef HAVE_LONG_LONG
        long_long:
                llx = lla + llb;
            return PyLong_FromLongLong(llx);
#endif
        
        
    }
    #endif
    if (PyFloat_CheckExact(op1)) {
        const long b = intval;
        double a = PyFloat_AS_DOUBLE(op1);
            double result;
            PyFPE_START_PROTECT("add", return NULL)
            result = ((double)a) + (double)b;
            PyFPE_END_PROTECT(result)
            return PyFloat_FromDouble(result);
    }
    return (inplace ? PyNumber_InPlaceAdd : PyNumber_Add)(op1, op2);
}
#endif

/* SliceTupleAndList */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE void __Pyx_crop_slice(Py_ssize_t* _start, Py_ssize_t* _stop, Py_ssize_t* _length) {
    Py_ssize_t start = *_start, stop = *_stop, length = *_length;
    if (start < 0) {
        start += length;
        if (start < 0)
            start = 0;
    }
    if (stop < 0)
        stop += length;
    else if (stop > length)
        stop = length;
    *_length = stop - start;
    *_start = start;
    *_stop = stop;
}
static CYTHON_INLINE void __Pyx_copy_object_array(PyObject** CYTHON_RESTRICT src, PyObject** CYTHON_RESTRICT dest, Py_ssize_t length) {
    PyObject *v;
    Py_ssize_t i;
    for (i = 0; i < length; i++) {
        v = dest[i] = src[i];
        Py_INCREF(v);
    }
}
static CYTHON_INLINE PyObject* __Pyx_PyList_GetSlice(
            PyObject* src, Py_ssize_t start, Py_ssize_t stop) {
    PyObject* dest;
    Py_ssize_t length = PyList_GET_SIZE(src);
    __Pyx_crop_slice(&start, &stop, &length);
    if (unlikely(length <= 0))
        return PyList_New(0);
    dest = PyList_New(length);
    if (unlikely(!dest))
        return NULL;
    __Pyx_copy_object_array(
        ((PyListObject*)src)->ob_item + start,
        ((PyListObject*)dest)->ob_item,
        length);
    return dest;
}
static CYTHON_INLINE PyObject* __Pyx_PyTuple_GetSlice(
            PyObject* src, Py_ssize_t start, Py_ssize_t stop) {
    PyObject* dest;
    Py_ssize_t length = PyTuple_GET_SIZE(src);
    __Pyx_crop_slice(&start, &stop, &length);
    if (unlikely(length <= 0))
        return PyTuple_New(0);
    dest = PyTuple_New(length);
    if (unlikely(!dest))
        return NULL;
    __Pyx_copy_object_array(
        ((PyTupleObject*)src)->ob_item + start,
        ((PyTupleObject*)dest)->ob_item,
        length);
    return dest;
}
#endif

/* PyUnicode_Unicode */
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_Unicode(PyObject *obj) {
    if (unlikely(obj == Py_None))
        obj = __pyx_kp_u_None;
    return __Pyx_NewRef(obj);
}

/* KeywordStringCheck */
static int __Pyx_CheckKeywordStrings(
    PyObject *kwdict,
    const char* function_name,
    int kw_allowed)
{
    PyObject* key = 0;
    Py_ssize_t pos = 0;
#if CYTHON_COMPILING_IN_PYPY
    if (!kw_allowed && PyDict_Next(kwdict, &pos, &key, 0))
        goto invalid_keyword;
    return 1;
#else
    while (PyDict_Next(kwdict, &pos, &key, 0)) {
        #if PY_MAJOR_VERSION < 3
        if (unlikely(!PyString_Check(key)))
        #endif
            if (unlikely(!PyUnicode_Check(key)))
                goto invalid_keyword_type;
    }
    if ((!kw_allowed) && unlikely(key))
        goto invalid_keyword;
    return 1;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    return 0;
#endif
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
    return 0;
}

/* ArgTypeTest */
static int __Pyx__ArgTypeTest(PyObject *obj, PyTypeObject *type, const char *name, int exact)
{
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    else if (exact) {
        #if PY_MAJOR_VERSION == 2
        if ((type == &PyBaseString_Type) && likely(__Pyx_PyBaseString_CheckExact(obj))) return 1;
        #endif
    }
    else {
        if (likely(__Pyx_TypeCheck(obj, type))) return 1;
    }
    PyErr_Format(PyExc_TypeError,
        "Argument '%.200s' has incorrect type (expected %.200s, got %.200s)",
        name, type->tp_name, Py_TYPE(obj)->tp_name);
    return 0;
}

/* IterNext */
static PyObject *__Pyx_PyIter_Next2Default(PyObject* defval) {
    PyObject* exc_type;
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    exc_type = __Pyx_PyErr_Occurred();
    if (unlikely(exc_type)) {
        if (!defval || unlikely(!__Pyx_PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration)))
            return NULL;
        __Pyx_PyErr_Clear();
        Py_INCREF(defval);
        return defval;
    }
    if (defval) {
        Py_INCREF(defval);
        return defval;
    }
    __Pyx_PyErr_SetNone(PyExc_StopIteration);
    return NULL;
}
static void __Pyx_PyIter_Next_ErrorNoIterator(PyObject *iterator) {
    PyErr_Format(PyExc_TypeError,
        "%.200s object is not an iterator", Py_TYPE(iterator)->tp_name);
}
static CYTHON_INLINE PyObject *__Pyx_PyIter_Next2(PyObject* iterator, PyObject* defval) {
    PyObject* next;
    iternextfunc iternext = Py_TYPE(iterator)->tp_iternext;
    if (likely(iternext)) {
#if CYTHON_USE_TYPE_SLOTS
        next = iternext(iterator);
        if (likely(next))
            return next;
        #if PY_VERSION_HEX >= 0x02070000
        if (unlikely(iternext == &_PyObject_NextNotImplemented))
            return NULL;
        #endif
#else
        next = PyIter_Next(iterator);
        if (likely(next))
            return next;
#endif
    } else if (CYTHON_USE_TYPE_SLOTS || unlikely(!PyIter_Check(iterator))) {
        __Pyx_PyIter_Next_ErrorNoIterator(iterator);
        return NULL;
    }
#if !CYTHON_USE_TYPE_SLOTS
    else {
        next = PyIter_Next(iterator);
        if (likely(next))
            return next;
    }
#endif
    return __Pyx_PyIter_Next2Default(defval);
}

/* UnpackUnboundCMethod */
static int __Pyx_TryUnpackUnboundCMethod(__Pyx_CachedCFunction* target) {
    PyObject *method;
    method = __Pyx_PyObject_GetAttrStr(target->type, *target->method_name);
    if (unlikely(!method))
        return -1;
    target->method = method;
#if CYTHON_COMPILING_IN_CPYTHON
    #if PY_MAJOR_VERSION >= 3
    if (likely(__Pyx_TypeCheck(method, &PyMethodDescr_Type)))
    #endif
    {
        PyMethodDescrObject *descr = (PyMethodDescrObject*) method;
        target->func = descr->d_method->ml_meth;
        target->flag = descr->d_method->ml_flags & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_STACKLESS);
    }
#endif
    return 0;
}

/* CallUnboundCMethod1 */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_CallUnboundCMethod1(__Pyx_CachedCFunction* cfunc, PyObject* self, PyObject* arg) {
    if (likely(cfunc->func)) {
        int flag = cfunc->flag;
        if (flag == METH_O) {
            return (*(cfunc->func))(self, arg);
        } else if (PY_VERSION_HEX >= 0x030600B1 && flag == METH_FASTCALL) {
            #if PY_VERSION_HEX >= 0x030700A0
                return (*(__Pyx_PyCFunctionFast)(void*)(PyCFunction)cfunc->func)(self, &arg, 1);
            #else
                return (*(__Pyx_PyCFunctionFastWithKeywords)(void*)(PyCFunction)cfunc->func)(self, &arg, 1, NULL);
            #endif
        } else if (PY_VERSION_HEX >= 0x030700A0 && flag == (METH_FASTCALL | METH_KEYWORDS)) {
            return (*(__Pyx_PyCFunctionFastWithKeywords)(void*)(PyCFunction)cfunc->func)(self, &arg, 1, NULL);
        }
    }
    return __Pyx__CallUnboundCMethod1(cfunc, self, arg);
}
#endif
static PyObject* __Pyx__CallUnboundCMethod1(__Pyx_CachedCFunction* cfunc, PyObject* self, PyObject* arg){
    PyObject *args, *result = NULL;
    if (unlikely(!cfunc->func && !cfunc->method) && unlikely(__Pyx_TryUnpackUnboundCMethod(cfunc) < 0)) return NULL;
#if CYTHON_COMPILING_IN_CPYTHON
    if (cfunc->func && (cfunc->flag & METH_VARARGS)) {
        args = PyTuple_New(1);
        if (unlikely(!args)) goto bad;
        Py_INCREF(arg);
        PyTuple_SET_ITEM(args, 0, arg);
        if (cfunc->flag & METH_KEYWORDS)
            result = (*(PyCFunctionWithKeywords)(void*)(PyCFunction)cfunc->func)(self, args, NULL);
        else
            result = (*cfunc->func)(self, args);
    } else {
        args = PyTuple_New(2);
        if (unlikely(!args)) goto bad;
        Py_INCREF(self);
        PyTuple_SET_ITEM(args, 0, self);
        Py_INCREF(arg);
        PyTuple_SET_ITEM(args, 1, arg);
        result = __Pyx_PyObject_Call(cfunc->method, args, NULL);
    }
#else
    args = PyTuple_Pack(2, self, arg);
    if (unlikely(!args)) goto bad;
    result = __Pyx_PyObject_Call(cfunc->method, args, NULL);
#endif
bad:
    Py_XDECREF(args);
    return result;
}

/* CallUnboundCMethod2 */
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030600B1
static CYTHON_INLINE PyObject *__Pyx_CallUnboundCMethod2(__Pyx_CachedCFunction *cfunc, PyObject *self, PyObject *arg1, PyObject *arg2) {
    if (likely(cfunc->func)) {
        PyObject *args[2] = {arg1, arg2};
        if (cfunc->flag == METH_FASTCALL) {
            #if PY_VERSION_HEX >= 0x030700A0
            return (*(__Pyx_PyCFunctionFast)(void*)(PyCFunction)cfunc->func)(self, args, 2);
            #else
            return (*(__Pyx_PyCFunctionFastWithKeywords)(void*)(PyCFunction)cfunc->func)(self, args, 2, NULL);
            #endif
        }
        #if PY_VERSION_HEX >= 0x030700A0
        if (cfunc->flag == (METH_FASTCALL | METH_KEYWORDS))
            return (*(__Pyx_PyCFunctionFastWithKeywords)(void*)(PyCFunction)cfunc->func)(self, args, 2, NULL);
        #endif
    }
    return __Pyx__CallUnboundCMethod2(cfunc, self, arg1, arg2);
}
#endif
static PyObject* __Pyx__CallUnboundCMethod2(__Pyx_CachedCFunction* cfunc, PyObject* self, PyObject* arg1, PyObject* arg2){
    PyObject *args, *result = NULL;
    if (unlikely(!cfunc->func && !cfunc->method) && unlikely(__Pyx_TryUnpackUnboundCMethod(cfunc) < 0)) return NULL;
#if CYTHON_COMPILING_IN_CPYTHON
    if (cfunc->func && (cfunc->flag & METH_VARARGS)) {
        args = PyTuple_New(2);
        if (unlikely(!args)) goto bad;
        Py_INCREF(arg1);
        PyTuple_SET_ITEM(args, 0, arg1);
        Py_INCREF(arg2);
        PyTuple_SET_ITEM(args, 1, arg2);
        if (cfunc->flag & METH_KEYWORDS)
            result = (*(PyCFunctionWithKeywords)(void*)(PyCFunction)cfunc->func)(self, args, NULL);
        else
            result = (*cfunc->func)(self, args);
    } else {
        args = PyTuple_New(3);
        if (unlikely(!args)) goto bad;
        Py_INCREF(self);
        PyTuple_SET_ITEM(args, 0, self);
        Py_INCREF(arg1);
        PyTuple_SET_ITEM(args, 1, arg1);
        Py_INCREF(arg2);
        PyTuple_SET_ITEM(args, 2, arg2);
        result = __Pyx_PyObject_Call(cfunc->method, args, NULL);
    }
#else
    args = PyTuple_Pack(3, self, arg1, arg2);
    if (unlikely(!args)) goto bad;
    result = __Pyx_PyObject_Call(cfunc->method, args, NULL);
#endif
bad:
    Py_XDECREF(args);
    return result;
}

/* dict_getitem_default */
static PyObject* __Pyx_PyDict_GetItemDefault(PyObject* d, PyObject* key, PyObject* default_value) {
    PyObject* value;
#if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
    value = PyDict_GetItemWithError(d, key);
    if (unlikely(!value)) {
        if (unlikely(PyErr_Occurred()))
            return NULL;
        value = default_value;
    }
    Py_INCREF(value);
    if ((1));
#else
    if (PyString_CheckExact(key) || PyUnicode_CheckExact(key) || PyInt_CheckExact(key)) {
        value = PyDict_GetItem(d, key);
        if (unlikely(!value)) {
            value = default_value;
        }
        Py_INCREF(value);
    }
#endif
    else {
        if (default_value == Py_None)
            value = __Pyx_CallUnboundCMethod1(&__pyx_umethod_PyDict_Type_get, d, key);
        else
            value = __Pyx_CallUnboundCMethod2(&__pyx_umethod_PyDict_Type_get, d, key, default_value);
    }
    return value;
}

/* DictGetItem */
#if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
static PyObject *__Pyx_PyDict_GetItem(PyObject *d, PyObject* key) {
    PyObject *value;
    value = PyDict_GetItemWithError(d, key);
    if (unlikely(!value)) {
        if (!PyErr_Occurred()) {
            if (unlikely(PyTuple_Check(key))) {
                PyObject* args = PyTuple_Pack(1, key);
                if (likely(args)) {
                    PyErr_SetObject(PyExc_KeyError, args);
                    Py_DECREF(args);
                }
            } else {
                PyErr_SetObject(PyExc_KeyError, key);
            }
        }
        return NULL;
    }
    Py_INCREF(value);
    return value;
}
#endif

/* py_abs */
#if CYTHON_USE_PYLONG_INTERNALS
static PyObject *__Pyx_PyLong_AbsNeg(PyObject *n) {
    if (likely(Py_SIZE(n) == -1)) {
        return PyLong_FromLong(((PyLongObject*)n)->ob_digit[0]);
    }
#if CYTHON_COMPILING_IN_CPYTHON
    {
        PyObject *copy = _PyLong_Copy((PyLongObject*)n);
        if (likely(copy)) {
            __Pyx_SET_SIZE(copy, -Py_SIZE(copy));
        }
        return copy;
    }
#else
    return PyNumber_Negative(n);
#endif
}
#endif

/* set_iter */
static CYTHON_INLINE PyObject* __Pyx_set_iterator(PyObject* iterable, int is_set,
                                                  Py_ssize_t* p_orig_length, int* p_source_is_set) {
#if CYTHON_COMPILING_IN_CPYTHON
    is_set = is_set || likely(PySet_CheckExact(iterable) || PyFrozenSet_CheckExact(iterable));
    *p_source_is_set = is_set;
    if (likely(is_set)) {
        *p_orig_length = PySet_Size(iterable);
        Py_INCREF(iterable);
        return iterable;
    }
#else
    (void)is_set;
    *p_source_is_set = 0;
#endif
    *p_orig_length = 0;
    return PyObject_GetIter(iterable);
}
static CYTHON_INLINE int __Pyx_set_iter_next(
        PyObject* iter_obj, Py_ssize_t orig_length,
        Py_ssize_t* ppos, PyObject **value,
        int source_is_set) {
    if (!CYTHON_COMPILING_IN_CPYTHON || unlikely(!source_is_set)) {
        *value = PyIter_Next(iter_obj);
        if (unlikely(!*value)) {
            return __Pyx_IterFinish();
        }
        (void)orig_length;
        (void)ppos;
        return 1;
    }
#if CYTHON_COMPILING_IN_CPYTHON
    if (unlikely(PySet_GET_SIZE(iter_obj) != orig_length)) {
        PyErr_SetString(
            PyExc_RuntimeError,
            "set changed size during iteration");
        return -1;
    }
    {
        Py_hash_t hash;
        int ret = _PySet_NextEntry(iter_obj, ppos, value, &hash);
        assert (ret != -1);
        if (likely(ret)) {
            Py_INCREF(*value);
            return 1;
        }
    }
#endif
    return 0;
}

/* GetAttr3 */
static PyObject *__Pyx_GetAttr3Default(PyObject *d) {
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    if (unlikely(!__Pyx_PyErr_ExceptionMatches(PyExc_AttributeError)))
        return NULL;
    __Pyx_PyErr_Clear();
    Py_INCREF(d);
    return d;
}
static CYTHON_INLINE PyObject *__Pyx_GetAttr3(PyObject *o, PyObject *n, PyObject *d) {
    PyObject *r = __Pyx_GetAttr(o, n);
    return (likely(r)) ? r : __Pyx_GetAttr3Default(d);
}

/* CIntToDigits */
static const char DIGIT_PAIRS_10[2*10*10+1] = {
    "00010203040506070809"
    "10111213141516171819"
    "20212223242526272829"
    "30313233343536373839"
    "40414243444546474849"
    "50515253545556575859"
    "60616263646566676869"
    "70717273747576777879"
    "80818283848586878889"
    "90919293949596979899"
};
static const char DIGIT_PAIRS_8[2*8*8+1] = {
    "0001020304050607"
    "1011121314151617"
    "2021222324252627"
    "3031323334353637"
    "4041424344454647"
    "5051525354555657"
    "6061626364656667"
    "7071727374757677"
};
static const char DIGITS_HEX[2*16+1] = {
    "0123456789abcdef"
    "0123456789ABCDEF"
};

/* BuildPyUnicode */
static PyObject* __Pyx_PyUnicode_BuildFromAscii(Py_ssize_t ulength, char* chars, int clength,
                                                int prepend_sign, char padding_char) {
    PyObject *uval;
    Py_ssize_t uoffset = ulength - clength;
#if CYTHON_USE_UNICODE_INTERNALS
    Py_ssize_t i;
#if CYTHON_PEP393_ENABLED
    void *udata;
    uval = PyUnicode_New(ulength, 127);
    if (unlikely(!uval)) return NULL;
    udata = PyUnicode_DATA(uval);
#else
    Py_UNICODE *udata;
    uval = PyUnicode_FromUnicode(NULL, ulength);
    if (unlikely(!uval)) return NULL;
    udata = PyUnicode_AS_UNICODE(uval);
#endif
    if (uoffset > 0) {
        i = 0;
        if (prepend_sign) {
            __Pyx_PyUnicode_WRITE(PyUnicode_1BYTE_KIND, udata, 0, '-');
            i++;
        }
        for (; i < uoffset; i++) {
            __Pyx_PyUnicode_WRITE(PyUnicode_1BYTE_KIND, udata, i, padding_char);
        }
    }
    for (i=0; i < clength; i++) {
        __Pyx_PyUnicode_WRITE(PyUnicode_1BYTE_KIND, udata, uoffset+i, chars[i]);
    }
#else
    {
        PyObject *sign = NULL, *padding = NULL;
        uval = NULL;
        if (uoffset > 0) {
            prepend_sign = !!prepend_sign;
            if (uoffset > prepend_sign) {
                padding = PyUnicode_FromOrdinal(padding_char);
                if (likely(padding) && uoffset > prepend_sign + 1) {
                    PyObject *tmp;
                    PyObject *repeat = PyInt_FromSsize_t(uoffset - prepend_sign);
                    if (unlikely(!repeat)) goto done_or_error;
                    tmp = PyNumber_Multiply(padding, repeat);
                    Py_DECREF(repeat);
                    Py_DECREF(padding);
                    padding = tmp;
                }
                if (unlikely(!padding)) goto done_or_error;
            }
            if (prepend_sign) {
                sign = PyUnicode_FromOrdinal('-');
                if (unlikely(!sign)) goto done_or_error;
            }
        }
        uval = PyUnicode_DecodeASCII(chars, clength, NULL);
        if (likely(uval) && padding) {
            PyObject *tmp = PyNumber_Add(padding, uval);
            Py_DECREF(uval);
            uval = tmp;
        }
        if (likely(uval) && sign) {
            PyObject *tmp = PyNumber_Add(sign, uval);
            Py_DECREF(uval);
            uval = tmp;
        }
done_or_error:
        Py_XDECREF(padding);
        Py_XDECREF(sign);
    }
#endif
    return uval;
}

/* CIntToPyUnicode */
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_From_Py_ssize_t(Py_ssize_t value, Py_ssize_t width, char padding_char, char format_char) {
    char digits[sizeof(Py_ssize_t)*3+2];
    char *dpos, *end = digits + sizeof(Py_ssize_t)*3+2;
    const char *hex_digits = DIGITS_HEX;
    Py_ssize_t length, ulength;
    int prepend_sign, last_one_off;
    Py_ssize_t remaining;
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#endif
    const Py_ssize_t neg_one = (Py_ssize_t) -1, const_zero = (Py_ssize_t) 0;
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic pop
#endif
    const int is_unsigned = neg_one > const_zero;
    if (format_char == 'X') {
        hex_digits += 16;
        format_char = 'x';
    }
    remaining = value;
    last_one_off = 0;
    dpos = end;
    do {
        int digit_pos;
        switch (format_char) {
        case 'o':
            digit_pos = abs((int)(remaining % (8*8)));
            remaining = (Py_ssize_t) (remaining / (8*8));
            dpos -= 2;
            memcpy(dpos, DIGIT_PAIRS_8 + digit_pos * 2, 2);
            last_one_off = (digit_pos < 8);
            break;
        case 'd':
            digit_pos = abs((int)(remaining % (10*10)));
            remaining = (Py_ssize_t) (remaining / (10*10));
            dpos -= 2;
            memcpy(dpos, DIGIT_PAIRS_10 + digit_pos * 2, 2);
            last_one_off = (digit_pos < 10);
            break;
        case 'x':
            *(--dpos) = hex_digits[abs((int)(remaining % 16))];
            remaining = (Py_ssize_t) (remaining / 16);
            break;
        default:
            assert(0);
            break;
        }
    } while (unlikely(remaining != 0));
    if (last_one_off) {
        assert(*dpos == '0');
        dpos++;
    }
    length = end - dpos;
    ulength = length;
    prepend_sign = 0;
    if (!is_unsigned && value <= neg_one) {
        if (padding_char == ' ' || width <= length + 1) {
            *(--dpos) = '-';
            ++length;
        } else {
            prepend_sign = 1;
        }
        ++ulength;
    }
    if (width > ulength) {
        ulength = width;
    }
    if (ulength == 1) {
        return PyUnicode_FromOrdinal(*dpos);
    }
    return __Pyx_PyUnicode_BuildFromAscii(ulength, dpos, (int) length, prepend_sign, padding_char);
}

/* FastTypeChecks */
#if CYTHON_COMPILING_IN_CPYTHON
static int __Pyx_InBases(PyTypeObject *a, PyTypeObject *b) {
    while (a) {
        a = a->tp_base;
        if (a == b)
            return 1;
    }
    return b == &PyBaseObject_Type;
}
static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b) {
    PyObject *mro;
    if (a == b) return 1;
    mro = a->tp_mro;
    if (likely(mro)) {
        Py_ssize_t i, n;
        n = PyTuple_GET_SIZE(mro);
        for (i = 0; i < n; i++) {
            if (PyTuple_GET_ITEM(mro, i) == (PyObject *)b)
                return 1;
        }
        return 0;
    }
    return __Pyx_InBases(a, b);
}
#if PY_MAJOR_VERSION == 2
static int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject* exc_type2) {
    PyObject *exception, *value, *tb;
    int res;
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ErrFetch(&exception, &value, &tb);
    res = exc_type1 ? PyObject_IsSubclass(err, exc_type1) : 0;
    if (unlikely(res == -1)) {
        PyErr_WriteUnraisable(err);
        res = 0;
    }
    if (!res) {
        res = PyObject_IsSubclass(err, exc_type2);
        if (unlikely(res == -1)) {
            PyErr_WriteUnraisable(err);
            res = 0;
        }
    }
    __Pyx_ErrRestore(exception, value, tb);
    return res;
}
#else
static CYTHON_INLINE int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject *exc_type2) {
    int res = exc_type1 ? __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type1) : 0;
    if (!res) {
        res = __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type2);
    }
    return res;
}
#endif
static int __Pyx_PyErr_GivenExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
    Py_ssize_t i, n;
    assert(PyExceptionClass_Check(exc_type));
    n = PyTuple_GET_SIZE(tuple);
#if PY_MAJOR_VERSION >= 3
    for (i=0; i<n; i++) {
        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
    }
#endif
    for (i=0; i<n; i++) {
        PyObject *t = PyTuple_GET_ITEM(tuple, i);
        #if PY_MAJOR_VERSION < 3
        if (likely(exc_type == t)) return 1;
        #endif
        if (likely(PyExceptionClass_Check(t))) {
            if (__Pyx_inner_PyErr_GivenExceptionMatches2(exc_type, NULL, t)) return 1;
        } else {
        }
    }
    return 0;
}
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject* exc_type) {
    if (likely(err == exc_type)) return 1;
    if (likely(PyExceptionClass_Check(err))) {
        if (likely(PyExceptionClass_Check(exc_type))) {
            return __Pyx_inner_PyErr_GivenExceptionMatches2(err, NULL, exc_type);
        } else if (likely(PyTuple_Check(exc_type))) {
            return __Pyx_PyErr_GivenExceptionMatchesTuple(err, exc_type);
        } else {
        }
    }
    return PyErr_GivenExceptionMatches(err, exc_type);
}
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *exc_type1, PyObject *exc_type2) {
    assert(PyExceptionClass_Check(exc_type1));
    assert(PyExceptionClass_Check(exc_type2));
    if (likely(err == exc_type1 || err == exc_type2)) return 1;
    if (likely(PyExceptionClass_Check(err))) {
        return __Pyx_inner_PyErr_GivenExceptionMatches2(err, exc_type1, exc_type2);
    }
    return (PyErr_GivenExceptionMatches(err, exc_type1) || PyErr_GivenExceptionMatches(err, exc_type2));
}
#endif

/* None */
static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname) {
    PyErr_Format(PyExc_UnboundLocalError, "local variable '%s' referenced before assignment", varname);
}

/* PyObject_GenericGetAttrNoDict */
#if CYTHON_USE_TYPE_SLOTS && CYTHON_USE_PYTYPE_LOOKUP && PY_VERSION_HEX < 0x03070000
static PyObject *__Pyx_RaiseGenericGetAttributeError(PyTypeObject *tp, PyObject *attr_name) {
    PyErr_Format(PyExc_AttributeError,
#if PY_MAJOR_VERSION >= 3
                 "'%.50s' object has no attribute '%U'",
                 tp->tp_name, attr_name);
#else
                 "'%.50s' object has no attribute '%.400s'",
                 tp->tp_name, PyString_AS_STRING(attr_name));
#endif
    return NULL;
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_GenericGetAttrNoDict(PyObject* obj, PyObject* attr_name) {
    PyObject *descr;
    PyTypeObject *tp = Py_TYPE(obj);
    if (unlikely(!PyString_Check(attr_name))) {
        return PyObject_GenericGetAttr(obj, attr_name);
    }
    assert(!tp->tp_dictoffset);
    descr = _PyType_Lookup(tp, attr_name);
    if (unlikely(!descr)) {
        return __Pyx_RaiseGenericGetAttributeError(tp, attr_name);
    }
    Py_INCREF(descr);
    #if PY_MAJOR_VERSION < 3
    if (likely(PyType_HasFeature(Py_TYPE(descr), Py_TPFLAGS_HAVE_CLASS)))
    #endif
    {
        descrgetfunc f = Py_TYPE(descr)->tp_descr_get;
        if (unlikely(f)) {
            PyObject *res = f(descr, obj, (PyObject *)tp);
            Py_DECREF(descr);
            return res;
        }
    }
    return descr;
}
#endif

/* PatchModuleWithCoroutine */
static PyObject* __Pyx_Coroutine_patch_module(PyObject* module, const char* py_code) {
#if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
    int result;
    PyObject *globals, *result_obj;
    globals = PyDict_New();  if (unlikely(!globals)) goto ignore;
    result = PyDict_SetItemString(globals, "_cython_coroutine_type",
    #ifdef __Pyx_Coroutine_USED
        (PyObject*)__pyx_CoroutineType);
    #else
        Py_None);
    #endif
    if (unlikely(result < 0)) goto ignore;
    result = PyDict_SetItemString(globals, "_cython_generator_type",
    #ifdef __Pyx_Generator_USED
        (PyObject*)__pyx_GeneratorType);
    #else
        Py_None);
    #endif
    if (unlikely(result < 0)) goto ignore;
    if (unlikely(PyDict_SetItemString(globals, "_module", module) < 0)) goto ignore;
    if (unlikely(PyDict_SetItemString(globals, "__builtins__", __pyx_b) < 0)) goto ignore;
    result_obj = PyRun_String(py_code, Py_file_input, globals, globals);
    if (unlikely(!result_obj)) goto ignore;
    Py_DECREF(result_obj);
    Py_DECREF(globals);
    return module;
ignore:
    Py_XDECREF(globals);
    PyErr_WriteUnraisable(module);
    if (unlikely(PyErr_WarnEx(PyExc_RuntimeWarning, "Cython module failed to patch module with custom type", 1) < 0)) {
        Py_DECREF(module);
        module = NULL;
    }
#else
    py_code++;
#endif
    return module;
}

/* PatchInspect */
static PyObject* __Pyx_patch_inspect(PyObject* module) {
#if defined(__Pyx_Generator_USED) && (!defined(CYTHON_PATCH_INSPECT) || CYTHON_PATCH_INSPECT)
    static int inspect_patched = 0;
    if (unlikely((!inspect_patched) && module)) {
        module = __Pyx_Coroutine_patch_module(
            module, ""
"old_types = getattr(_module.isgenerator, '_cython_generator_types', None)\n"
"if old_types is None or not isinstance(old_types, set):\n"
"    old_types = set()\n"
"    def cy_wrap(orig_func, type=type, cython_generator_types=old_types):\n"
"        def cy_isgenerator(obj): return type(obj) in cython_generator_types or orig_func(obj)\n"
"        cy_isgenerator._cython_generator_types = cython_generator_types\n"
"        return cy_isgenerator\n"
"    _module.isgenerator = cy_wrap(_module.isgenerator)\n"
"old_types.add(_cython_generator_type)\n"
        );
        inspect_patched = 1;
    }
#else
    if ((0)) return __Pyx_Coroutine_patch_module(module, NULL);
#endif
    return module;
}

/* CalculateMetaclass */
static PyObject *__Pyx_CalculateMetaclass(PyTypeObject *metaclass, PyObject *bases) {
    Py_ssize_t i, nbases = PyTuple_GET_SIZE(bases);
    for (i=0; i < nbases; i++) {
        PyTypeObject *tmptype;
        PyObject *tmp = PyTuple_GET_ITEM(bases, i);
        tmptype = Py_TYPE(tmp);
#if PY_MAJOR_VERSION < 3
        if (tmptype == &PyClass_Type)
            continue;
#endif
        if (!metaclass) {
            metaclass = tmptype;
            continue;
        }
        if (PyType_IsSubtype(metaclass, tmptype))
            continue;
        if (PyType_IsSubtype(tmptype, metaclass)) {
            metaclass = tmptype;
            continue;
        }
        PyErr_SetString(PyExc_TypeError,
                        "metaclass conflict: "
                        "the metaclass of a derived class "
                        "must be a (non-strict) subclass "
                        "of the metaclasses of all its bases");
        return NULL;
    }
    if (!metaclass) {
#if PY_MAJOR_VERSION < 3
        metaclass = &PyClass_Type;
#else
        metaclass = &PyType_Type;
#endif
    }
    Py_INCREF((PyObject*) metaclass);
    return (PyObject*) metaclass;
}

/* Py3ClassCreate */
static PyObject *__Pyx_Py3MetaclassPrepare(PyObject *metaclass, PyObject *bases, PyObject *name,
                                           PyObject *qualname, PyObject *mkw, PyObject *modname, PyObject *doc) {
    PyObject *ns;
    if (metaclass) {
        PyObject *prep = __Pyx_PyObject_GetAttrStr(metaclass, __pyx_n_s_prepare);
        if (prep) {
            PyObject *pargs = PyTuple_Pack(2, name, bases);
            if (unlikely(!pargs)) {
                Py_DECREF(prep);
                return NULL;
            }
            ns = PyObject_Call(prep, pargs, mkw);
            Py_DECREF(prep);
            Py_DECREF(pargs);
        } else {
            if (unlikely(!PyErr_ExceptionMatches(PyExc_AttributeError)))
                return NULL;
            PyErr_Clear();
            ns = PyDict_New();
        }
    } else {
        ns = PyDict_New();
    }
    if (unlikely(!ns))
        return NULL;
    if (unlikely(PyObject_SetItem(ns, __pyx_n_s_module, modname) < 0)) goto bad;
    if (unlikely(PyObject_SetItem(ns, __pyx_n_s_qualname, qualname) < 0)) goto bad;
    if (unlikely(doc && PyObject_SetItem(ns, __pyx_n_s_doc, doc) < 0)) goto bad;
    return ns;
bad:
    Py_DECREF(ns);
    return NULL;
}
static PyObject *__Pyx_Py3ClassCreate(PyObject *metaclass, PyObject *name, PyObject *bases,
                                      PyObject *dict, PyObject *mkw,
                                      int calculate_metaclass, int allow_py2_metaclass) {
    PyObject *result, *margs;
    PyObject *owned_metaclass = NULL;
    if (allow_py2_metaclass) {
        owned_metaclass = PyObject_GetItem(dict, __pyx_n_s_metaclass);
        if (owned_metaclass) {
            metaclass = owned_metaclass;
        } else if (likely(PyErr_ExceptionMatches(PyExc_KeyError))) {
            PyErr_Clear();
        } else {
            return NULL;
        }
    }
    if (calculate_metaclass && (!metaclass || PyType_Check(metaclass))) {
        metaclass = __Pyx_CalculateMetaclass((PyTypeObject*) metaclass, bases);
        Py_XDECREF(owned_metaclass);
        if (unlikely(!metaclass))
            return NULL;
        owned_metaclass = metaclass;
    }
    margs = PyTuple_Pack(3, name, bases, dict);
    if (unlikely(!margs)) {
        result = NULL;
    } else {
        result = PyObject_Call(metaclass, margs, mkw);
        Py_DECREF(margs);
    }
    Py_XDECREF(owned_metaclass);
    return result;
}

/* CLineInTraceback */
#ifndef CYTHON_CLINE_IN_TRACEBACK
static int __Pyx_CLineForTraceback(CYTHON_UNUSED PyThreadState *tstate, int c_line) {
    PyObject *use_cline;
    PyObject *ptype, *pvalue, *ptraceback;
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject **cython_runtime_dict;
#endif
    if (unlikely(!__pyx_cython_runtime)) {
        return c_line;
    }
    __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
#if CYTHON_COMPILING_IN_CPYTHON
    cython_runtime_dict = _PyObject_GetDictPtr(__pyx_cython_runtime);
    if (likely(cython_runtime_dict)) {
        __PYX_PY_DICT_LOOKUP_IF_MODIFIED(
            use_cline, *cython_runtime_dict,
            __Pyx_PyDict_GetItemStr(*cython_runtime_dict, __pyx_n_s_cline_in_traceback))
    } else
#endif
    {
      PyObject *use_cline_obj = __Pyx_PyObject_GetAttrStr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback);
      if (use_cline_obj) {
        use_cline = PyObject_Not(use_cline_obj) ? Py_False : Py_True;
        Py_DECREF(use_cline_obj);
      } else {
        PyErr_Clear();
        use_cline = NULL;
      }
    }
    if (!use_cline) {
        c_line = 0;
        (void) PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
    }
    else if (use_cline == Py_False || (use_cline != Py_True && PyObject_Not(use_cline) != 0)) {
        c_line = 0;
    }
    __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
    return c_line;
}
#endif

/* CodeObjectCache */
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
    int start = 0, mid = 0, end = count - 1;
    if (end >= 0 && code_line > entries[end].code_line) {
        return count;
    }
    while (start < end) {
        mid = start + (end - start) / 2;
        if (code_line < entries[mid].code_line) {
            end = mid;
        } else if (code_line > entries[mid].code_line) {
             start = mid + 1;
        } else {
            return mid;
        }
    }
    if (code_line <= entries[mid].code_line) {
        return mid;
    } else {
        return mid + 1;
    }
}
static PyCodeObject *__pyx_find_code_object(int code_line) {
    PyCodeObject* code_object;
    int pos;
    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
        return NULL;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
        return NULL;
    }
    code_object = __pyx_code_cache.entries[pos].code_object;
    Py_INCREF(code_object);
    return code_object;
}
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
    int pos, i;
    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
    if (unlikely(!code_line)) {
        return;
    }
    if (unlikely(!entries)) {
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
        if (likely(entries)) {
            __pyx_code_cache.entries = entries;
            __pyx_code_cache.max_count = 64;
            __pyx_code_cache.count = 1;
            entries[0].code_line = code_line;
            entries[0].code_object = code_object;
            Py_INCREF(code_object);
        }
        return;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
        PyCodeObject* tmp = entries[pos].code_object;
        entries[pos].code_object = code_object;
        Py_DECREF(tmp);
        return;
    }
    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
        int new_max = __pyx_code_cache.max_count + 64;
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
            __pyx_code_cache.entries, ((size_t)new_max) * sizeof(__Pyx_CodeObjectCacheEntry));
        if (unlikely(!entries)) {
            return;
        }
        __pyx_code_cache.entries = entries;
        __pyx_code_cache.max_count = new_max;
    }
    for (i=__pyx_code_cache.count; i>pos; i--) {
        entries[i] = entries[i-1];
    }
    entries[pos].code_line = code_line;
    entries[pos].code_object = code_object;
    __pyx_code_cache.count++;
    Py_INCREF(code_object);
}

/* AddTraceback */
#include "compile.h"
#include "frameobject.h"
#include "traceback.h"
#if PY_VERSION_HEX >= 0x030b00a6
  #ifndef Py_BUILD_CORE
    #define Py_BUILD_CORE 1
  #endif
  #include "internal/pycore_frame.h"
#endif
static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
            const char *funcname, int c_line,
            int py_line, const char *filename) {
    PyCodeObject *py_code = NULL;
    PyObject *py_funcname = NULL;
    #if PY_MAJOR_VERSION < 3
    PyObject *py_srcfile = NULL;
    py_srcfile = PyString_FromString(filename);
    if (!py_srcfile) goto bad;
    #endif
    if (c_line) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        if (!py_funcname) goto bad;
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        if (!py_funcname) goto bad;
        funcname = PyUnicode_AsUTF8(py_funcname);
        if (!funcname) goto bad;
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        if (!py_funcname) goto bad;
        #endif
    }
    #if PY_MAJOR_VERSION < 3
    py_code = __Pyx_PyCode_New(
        0,
        0,
        0,
        0,
        0,
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple, /*PyObject *consts,*/
        __pyx_empty_tuple, /*PyObject *names,*/
        __pyx_empty_tuple, /*PyObject *varnames,*/
        __pyx_empty_tuple, /*PyObject *freevars,*/
        __pyx_empty_tuple, /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        py_line,
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    Py_DECREF(py_srcfile);
    #else
    py_code = PyCode_NewEmpty(filename, funcname, py_line);
    #endif
    Py_XDECREF(py_funcname);  // XDECREF since it's only set on Py3 if cline
    return py_code;
bad:
    Py_XDECREF(py_funcname);
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(py_srcfile);
    #endif
    return NULL;
}
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;
    PyThreadState *tstate = __Pyx_PyThreadState_Current;
    PyObject *ptype, *pvalue, *ptraceback;
    if (c_line) {
        c_line = __Pyx_CLineForTraceback(tstate, c_line);
    }
    py_code = __pyx_find_code_object(c_line ? -c_line : py_line);
    if (!py_code) {
        __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
        py_code = __Pyx_CreateCodeObjectForTraceback(
            funcname, c_line, py_line, filename);
        if (!py_code) {
            /* If the code object creation fails, then we should clear the
               fetched exception references and propagate the new exception */
            Py_XDECREF(ptype);
            Py_XDECREF(pvalue);
            Py_XDECREF(ptraceback);
            goto bad;
        }
        __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
        __pyx_insert_code_object(c_line ? -c_line : py_line, py_code);
    }
    py_frame = PyFrame_New(
        tstate,            /*PyThreadState *tstate,*/
        py_code,           /*PyCodeObject *code,*/
        __pyx_d,    /*PyObject *globals,*/
        0                  /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    __Pyx_PyFrame_SetLineNumber(py_frame, py_line);
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

/* CIntToPy */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#endif
    const long neg_one = (long) -1, const_zero = (long) 0;
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic pop
#endif
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(long) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(long) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(long),
                                     little, !is_unsigned);
    }
}

/* CIntFromPyVerify */
#define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 0)
#define __PYX_VERIFY_RETURN_INT_EXC(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 1)
#define __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, exc)\
    {\
        func_type value = func_value;\
        if (sizeof(target_type) < sizeof(func_type)) {\
            if (unlikely(value != (func_type) (target_type) value)) {\
                func_type zero = 0;\
                if (exc && unlikely(value == (func_type)-1 && PyErr_Occurred()))\
                    return (target_type) -1;\
                if (is_unsigned && unlikely(value < zero))\
                    goto raise_neg_overflow;\
                else\
                    goto raise_overflow;\
            }\
        }\
        return (target_type) value;\
    }

/* CIntFromPy */
static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#endif
    const long neg_one = (long) -1, const_zero = (long) 0;
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic pop
#endif
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(long) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (long) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case  1: __PYX_VERIFY_RETURN_INT(long, digit, digits[0])
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 2 * PyLong_SHIFT) {
                            return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 3 * PyLong_SHIFT) {
                            return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                            return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (long) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(long) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(long) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(long) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            long val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (long) -1;
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (long) -1;
        val = __Pyx_PyInt_As_long(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to long");
    return (long) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to long");
    return (long) -1;
}

/* CIntFromPy */
static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#endif
    const int neg_one = (int) -1, const_zero = (int) 0;
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic pop
#endif
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case  1: __PYX_VERIFY_RETURN_INT(int, digit, digits[0])
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 2 * PyLong_SHIFT) {
                            return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 3 * PyLong_SHIFT) {
                            return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                            return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (int) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(int) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(int) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(int) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int) -1;
        }
    } else {
        int val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (int) -1;
        val = __Pyx_PyInt_As_int(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int");
    return (int) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int");
    return (int) -1;
}

/* PyObjectCallMethod1 */
static PyObject* __Pyx__PyObject_CallMethod1(PyObject* method, PyObject* arg) {
    PyObject *result = __Pyx_PyObject_CallOneArg(method, arg);
    Py_DECREF(method);
    return result;
}
static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg) {
    PyObject *method = NULL, *result;
    int is_method = __Pyx_PyObject_GetMethod(obj, method_name, &method);
    if (likely(is_method)) {
        result = __Pyx_PyObject_Call2Args(method, obj, arg);
        Py_DECREF(method);
        return result;
    }
    if (unlikely(!method)) return NULL;
    return __Pyx__PyObject_CallMethod1(method, arg);
}

/* CoroutineBase */
#include <structmember.h>
#include <frameobject.h>
#if PY_VERSION_HEX >= 0x030b00a6
  #ifndef Py_BUILD_CORE
    #define Py_BUILD_CORE 1
  #endif
  #include "internal/pycore_frame.h"
#endif
#define __Pyx_Coroutine_Undelegate(gen) Py_CLEAR((gen)->yieldfrom)
static int __Pyx_PyGen__FetchStopIterationValue(CYTHON_UNUSED PyThreadState *__pyx_tstate, PyObject **pvalue) {
    PyObject *et, *ev, *tb;
    PyObject *value = NULL;
    __Pyx_ErrFetch(&et, &ev, &tb);
    if (!et) {
        Py_XDECREF(tb);
        Py_XDECREF(ev);
        Py_INCREF(Py_None);
        *pvalue = Py_None;
        return 0;
    }
    if (likely(et == PyExc_StopIteration)) {
        if (!ev) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#if PY_VERSION_HEX >= 0x030300A0
        else if (Py_TYPE(ev) == (PyTypeObject*)PyExc_StopIteration) {
            value = ((PyStopIterationObject *)ev)->value;
            Py_INCREF(value);
            Py_DECREF(ev);
        }
#endif
        else if (unlikely(PyTuple_Check(ev))) {
            if (PyTuple_GET_SIZE(ev) >= 1) {
#if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
                value = PyTuple_GET_ITEM(ev, 0);
                Py_INCREF(value);
#else
                value = PySequence_ITEM(ev, 0);
#endif
            } else {
                Py_INCREF(Py_None);
                value = Py_None;
            }
            Py_DECREF(ev);
        }
        else if (!__Pyx_TypeCheck(ev, (PyTypeObject*)PyExc_StopIteration)) {
            value = ev;
        }
        if (likely(value)) {
            Py_XDECREF(tb);
            Py_DECREF(et);
            *pvalue = value;
            return 0;
        }
    } else if (!__Pyx_PyErr_GivenExceptionMatches(et, PyExc_StopIteration)) {
        __Pyx_ErrRestore(et, ev, tb);
        return -1;
    }
    PyErr_NormalizeException(&et, &ev, &tb);
    if (unlikely(!PyObject_TypeCheck(ev, (PyTypeObject*)PyExc_StopIteration))) {
        __Pyx_ErrRestore(et, ev, tb);
        return -1;
    }
    Py_XDECREF(tb);
    Py_DECREF(et);
#if PY_VERSION_HEX >= 0x030300A0
    value = ((PyStopIterationObject *)ev)->value;
    Py_INCREF(value);
    Py_DECREF(ev);
#else
    {
        PyObject* args = __Pyx_PyObject_GetAttrStr(ev, __pyx_n_s_args);
        Py_DECREF(ev);
        if (likely(args)) {
            value = PySequence_GetItem(args, 0);
            Py_DECREF(args);
        }
        if (unlikely(!value)) {
            __Pyx_ErrRestore(NULL, NULL, NULL);
            Py_INCREF(Py_None);
            value = Py_None;
        }
    }
#endif
    *pvalue = value;
    return 0;
}
static CYTHON_INLINE
void __Pyx_Coroutine_ExceptionClear(__Pyx_ExcInfoStruct *exc_state) {
    PyObject *t, *v, *tb;
    t = exc_state->exc_type;
    v = exc_state->exc_value;
    tb = exc_state->exc_traceback;
    exc_state->exc_type = NULL;
    exc_state->exc_value = NULL;
    exc_state->exc_traceback = NULL;
    Py_XDECREF(t);
    Py_XDECREF(v);
    Py_XDECREF(tb);
}
#define __Pyx_Coroutine_AlreadyRunningError(gen)  (__Pyx__Coroutine_AlreadyRunningError(gen), (PyObject*)NULL)
static void __Pyx__Coroutine_AlreadyRunningError(CYTHON_UNUSED __pyx_CoroutineObject *gen) {
    const char *msg;
    if ((0)) {
    #ifdef __Pyx_Coroutine_USED
    } else if (__Pyx_Coroutine_Check((PyObject*)gen)) {
        msg = "coroutine already executing";
    #endif
    #ifdef __Pyx_AsyncGen_USED
    } else if (__Pyx_AsyncGen_CheckExact((PyObject*)gen)) {
        msg = "async generator already executing";
    #endif
    } else {
        msg = "generator already executing";
    }
    PyErr_SetString(PyExc_ValueError, msg);
}
#define __Pyx_Coroutine_NotStartedError(gen)  (__Pyx__Coroutine_NotStartedError(gen), (PyObject*)NULL)
static void __Pyx__Coroutine_NotStartedError(CYTHON_UNUSED PyObject *gen) {
    const char *msg;
    if ((0)) {
    #ifdef __Pyx_Coroutine_USED
    } else if (__Pyx_Coroutine_Check(gen)) {
        msg = "can't send non-None value to a just-started coroutine";
    #endif
    #ifdef __Pyx_AsyncGen_USED
    } else if (__Pyx_AsyncGen_CheckExact(gen)) {
        msg = "can't send non-None value to a just-started async generator";
    #endif
    } else {
        msg = "can't send non-None value to a just-started generator";
    }
    PyErr_SetString(PyExc_TypeError, msg);
}
#define __Pyx_Coroutine_AlreadyTerminatedError(gen, value, closing)  (__Pyx__Coroutine_AlreadyTerminatedError(gen, value, closing), (PyObject*)NULL)
static void __Pyx__Coroutine_AlreadyTerminatedError(CYTHON_UNUSED PyObject *gen, PyObject *value, CYTHON_UNUSED int closing) {
    #ifdef __Pyx_Coroutine_USED
    if (!closing && __Pyx_Coroutine_Check(gen)) {
        PyErr_SetString(PyExc_RuntimeError, "cannot reuse already awaited coroutine");
    } else
    #endif
    if (value) {
        #ifdef __Pyx_AsyncGen_USED
        if (__Pyx_AsyncGen_CheckExact(gen))
            PyErr_SetNone(__Pyx_PyExc_StopAsyncIteration);
        else
        #endif
        PyErr_SetNone(PyExc_StopIteration);
    }
}
static
PyObject *__Pyx_Coroutine_SendEx(__pyx_CoroutineObject *self, PyObject *value, int closing) {
    __Pyx_PyThreadState_declare
    PyThreadState *tstate;
    __Pyx_ExcInfoStruct *exc_state;
    PyObject *retval;
    assert(!self->is_running);
    if (unlikely(self->resume_label == 0)) {
        if (unlikely(value && value != Py_None)) {
            return __Pyx_Coroutine_NotStartedError((PyObject*)self);
        }
    }
    if (unlikely(self->resume_label == -1)) {
        return __Pyx_Coroutine_AlreadyTerminatedError((PyObject*)self, value, closing);
    }
#if CYTHON_FAST_THREAD_STATE
    __Pyx_PyThreadState_assign
    tstate = __pyx_tstate;
#else
    tstate = __Pyx_PyThreadState_Current;
#endif
    exc_state = &self->gi_exc_state;
    if (exc_state->exc_type) {
        #if CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_PYSTON
        #else
        if (exc_state->exc_traceback) {
            PyTracebackObject *tb = (PyTracebackObject *) exc_state->exc_traceback;
            PyFrameObject *f = tb->tb_frame;
            assert(f->f_back == NULL);
            #if PY_VERSION_HEX >= 0x030B00A1
            f->f_back = PyThreadState_GetFrame(tstate);
            #else
            Py_XINCREF(tstate->frame);
            f->f_back = tstate->frame;
            #endif
        }
        #endif
    }
#if CYTHON_USE_EXC_INFO_STACK
    exc_state->previous_item = tstate->exc_info;
    tstate->exc_info = exc_state;
#else
    if (exc_state->exc_type) {
        __Pyx_ExceptionSwap(&exc_state->exc_type, &exc_state->exc_value, &exc_state->exc_traceback);
    } else {
        __Pyx_Coroutine_ExceptionClear(exc_state);
        __Pyx_ExceptionSave(&exc_state->exc_type, &exc_state->exc_value, &exc_state->exc_traceback);
    }
#endif
    self->is_running = 1;
    retval = self->body((PyObject *) self, tstate, value);
    self->is_running = 0;
#if CYTHON_USE_EXC_INFO_STACK
    exc_state = &self->gi_exc_state;
    tstate->exc_info = exc_state->previous_item;
    exc_state->previous_item = NULL;
    __Pyx_Coroutine_ResetFrameBackpointer(exc_state);
#endif
    return retval;
}
static CYTHON_INLINE void __Pyx_Coroutine_ResetFrameBackpointer(__Pyx_ExcInfoStruct *exc_state) {
    PyObject *exc_tb = exc_state->exc_traceback;
    if (likely(exc_tb)) {
#if CYTHON_COMPILING_IN_PYPY || CYTHON_COMPILING_IN_PYSTON
#else
        PyTracebackObject *tb = (PyTracebackObject *) exc_tb;
        PyFrameObject *f = tb->tb_frame;
        Py_CLEAR(f->f_back);
#endif
    }
}
static CYTHON_INLINE
PyObject *__Pyx_Coroutine_MethodReturn(CYTHON_UNUSED PyObject* gen, PyObject *retval) {
    if (unlikely(!retval)) {
        __Pyx_PyThreadState_declare
        __Pyx_PyThreadState_assign
        if (!__Pyx_PyErr_Occurred()) {
            PyObject *exc = PyExc_StopIteration;
            #ifdef __Pyx_AsyncGen_USED
            if (__Pyx_AsyncGen_CheckExact(gen))
                exc = __Pyx_PyExc_StopAsyncIteration;
            #endif
            __Pyx_PyErr_SetNone(exc);
        }
    }
    return retval;
}
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03030000 && (defined(__linux__) || PY_VERSION_HEX >= 0x030600B3)
static CYTHON_INLINE
PyObject *__Pyx_PyGen_Send(PyGenObject *gen, PyObject *arg) {
#if PY_VERSION_HEX <= 0x030A00A1
    return _PyGen_Send(gen, arg);
#else
    PyObject *result;
    if (PyIter_Send((PyObject*)gen, arg ? arg : Py_None, &result) == PYGEN_RETURN) {
        if (PyAsyncGen_CheckExact(gen)) {
            assert(result == Py_None);
            PyErr_SetNone(PyExc_StopAsyncIteration);
        }
        else if (result == Py_None) {
            PyErr_SetNone(PyExc_StopIteration);
        }
        else {
            _PyGen_SetStopIterationValue(result);
        }
        Py_CLEAR(result);
    }
    return result;
#endif
}
#endif
static CYTHON_INLINE
PyObject *__Pyx_Coroutine_FinishDelegation(__pyx_CoroutineObject *gen) {
    PyObject *ret;
    PyObject *val = NULL;
    __Pyx_Coroutine_Undelegate(gen);
    __Pyx_PyGen__FetchStopIterationValue(__Pyx_PyThreadState_Current, &val);
    ret = __Pyx_Coroutine_SendEx(gen, val, 0);
    Py_XDECREF(val);
    return ret;
}
static PyObject *__Pyx_Coroutine_Send(PyObject *self, PyObject *value) {
    PyObject *retval;
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject*) self;
    PyObject *yf = gen->yieldfrom;
    if (unlikely(gen->is_running))
        return __Pyx_Coroutine_AlreadyRunningError(gen);
    if (yf) {
        PyObject *ret;
        gen->is_running = 1;
        #ifdef __Pyx_Generator_USED
        if (__Pyx_Generator_CheckExact(yf)) {
            ret = __Pyx_Coroutine_Send(yf, value);
        } else
        #endif
        #ifdef __Pyx_Coroutine_USED
        if (__Pyx_Coroutine_Check(yf)) {
            ret = __Pyx_Coroutine_Send(yf, value);
        } else
        #endif
        #ifdef __Pyx_AsyncGen_USED
        if (__pyx_PyAsyncGenASend_CheckExact(yf)) {
            ret = __Pyx_async_gen_asend_send(yf, value);
        } else
        #endif
        #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03030000 && (defined(__linux__) || PY_VERSION_HEX >= 0x030600B3)
        if (PyGen_CheckExact(yf)) {
            ret = __Pyx_PyGen_Send((PyGenObject*)yf, value == Py_None ? NULL : value);
        } else
        #endif
        #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03050000 && defined(PyCoro_CheckExact) && (defined(__linux__) || PY_VERSION_HEX >= 0x030600B3)
        if (PyCoro_CheckExact(yf)) {
            ret = __Pyx_PyGen_Send((PyGenObject*)yf, value == Py_None ? NULL : value);
        } else
        #endif
        {
            if (value == Py_None)
                ret = Py_TYPE(yf)->tp_iternext(yf);
            else
                ret = __Pyx_PyObject_CallMethod1(yf, __pyx_n_s_send, value);
        }
        gen->is_running = 0;
        if (likely(ret)) {
            return ret;
        }
        retval = __Pyx_Coroutine_FinishDelegation(gen);
    } else {
        retval = __Pyx_Coroutine_SendEx(gen, value, 0);
    }
    return __Pyx_Coroutine_MethodReturn(self, retval);
}
static int __Pyx_Coroutine_CloseIter(__pyx_CoroutineObject *gen, PyObject *yf) {
    PyObject *retval = NULL;
    int err = 0;
    #ifdef __Pyx_Generator_USED
    if (__Pyx_Generator_CheckExact(yf)) {
        retval = __Pyx_Coroutine_Close(yf);
        if (!retval)
            return -1;
    } else
    #endif
    #ifdef __Pyx_Coroutine_USED
    if (__Pyx_Coroutine_Check(yf)) {
        retval = __Pyx_Coroutine_Close(yf);
        if (!retval)
            return -1;
    } else
    if (__Pyx_CoroutineAwait_CheckExact(yf)) {
        retval = __Pyx_CoroutineAwait_Close((__pyx_CoroutineAwaitObject*)yf, NULL);
        if (!retval)
            return -1;
    } else
    #endif
    #ifdef __Pyx_AsyncGen_USED
    if (__pyx_PyAsyncGenASend_CheckExact(yf)) {
        retval = __Pyx_async_gen_asend_close(yf, NULL);
    } else
    if (__pyx_PyAsyncGenAThrow_CheckExact(yf)) {
        retval = __Pyx_async_gen_athrow_close(yf, NULL);
    } else
    #endif
    {
        PyObject *meth;
        gen->is_running = 1;
        meth = __Pyx_PyObject_GetAttrStr(yf, __pyx_n_s_close);
        if (unlikely(!meth)) {
            if (!PyErr_ExceptionMatches(PyExc_AttributeError)) {
                PyErr_WriteUnraisable(yf);
            }
            PyErr_Clear();
        } else {
            retval = PyObject_CallFunction(meth, NULL);
            Py_DECREF(meth);
            if (!retval)
                err = -1;
        }
        gen->is_running = 0;
    }
    Py_XDECREF(retval);
    return err;
}
static PyObject *__Pyx_Generator_Next(PyObject *self) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject*) self;
    PyObject *yf = gen->yieldfrom;
    if (unlikely(gen->is_running))
        return __Pyx_Coroutine_AlreadyRunningError(gen);
    if (yf) {
        PyObject *ret;
        gen->is_running = 1;
        #ifdef __Pyx_Generator_USED
        if (__Pyx_Generator_CheckExact(yf)) {
            ret = __Pyx_Generator_Next(yf);
        } else
        #endif
        #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03030000 && (defined(__linux__) || PY_VERSION_HEX >= 0x030600B3)
        if (PyGen_CheckExact(yf)) {
            ret = __Pyx_PyGen_Send((PyGenObject*)yf, NULL);
        } else
        #endif
        #ifdef __Pyx_Coroutine_USED
        if (__Pyx_Coroutine_Check(yf)) {
            ret = __Pyx_Coroutine_Send(yf, Py_None);
        } else
        #endif
            ret = Py_TYPE(yf)->tp_iternext(yf);
        gen->is_running = 0;
        if (likely(ret)) {
            return ret;
        }
        return __Pyx_Coroutine_FinishDelegation(gen);
    }
    return __Pyx_Coroutine_SendEx(gen, Py_None, 0);
}
static PyObject *__Pyx_Coroutine_Close_Method(PyObject *self, CYTHON_UNUSED PyObject *arg) {
    return __Pyx_Coroutine_Close(self);
}
static PyObject *__Pyx_Coroutine_Close(PyObject *self) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    PyObject *retval, *raised_exception;
    PyObject *yf = gen->yieldfrom;
    int err = 0;
    if (unlikely(gen->is_running))
        return __Pyx_Coroutine_AlreadyRunningError(gen);
    if (yf) {
        Py_INCREF(yf);
        err = __Pyx_Coroutine_CloseIter(gen, yf);
        __Pyx_Coroutine_Undelegate(gen);
        Py_DECREF(yf);
    }
    if (err == 0)
        PyErr_SetNone(PyExc_GeneratorExit);
    retval = __Pyx_Coroutine_SendEx(gen, NULL, 1);
    if (unlikely(retval)) {
        const char *msg;
        Py_DECREF(retval);
        if ((0)) {
        #ifdef __Pyx_Coroutine_USED
        } else if (__Pyx_Coroutine_Check(self)) {
            msg = "coroutine ignored GeneratorExit";
        #endif
        #ifdef __Pyx_AsyncGen_USED
        } else if (__Pyx_AsyncGen_CheckExact(self)) {
#if PY_VERSION_HEX < 0x03060000
            msg = "async generator ignored GeneratorExit - might require Python 3.6+ finalisation (PEP 525)";
#else
            msg = "async generator ignored GeneratorExit";
#endif
        #endif
        } else {
            msg = "generator ignored GeneratorExit";
        }
        PyErr_SetString(PyExc_RuntimeError, msg);
        return NULL;
    }
    raised_exception = PyErr_Occurred();
    if (likely(!raised_exception || __Pyx_PyErr_GivenExceptionMatches2(raised_exception, PyExc_GeneratorExit, PyExc_StopIteration))) {
        if (raised_exception) PyErr_Clear();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
}
static PyObject *__Pyx__Coroutine_Throw(PyObject *self, PyObject *typ, PyObject *val, PyObject *tb,
                                        PyObject *args, int close_on_genexit) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    PyObject *yf = gen->yieldfrom;
    if (unlikely(gen->is_running))
        return __Pyx_Coroutine_AlreadyRunningError(gen);
    if (yf) {
        PyObject *ret;
        Py_INCREF(yf);
        if (__Pyx_PyErr_GivenExceptionMatches(typ, PyExc_GeneratorExit) && close_on_genexit) {
            int err = __Pyx_Coroutine_CloseIter(gen, yf);
            Py_DECREF(yf);
            __Pyx_Coroutine_Undelegate(gen);
            if (err < 0)
                return __Pyx_Coroutine_MethodReturn(self, __Pyx_Coroutine_SendEx(gen, NULL, 0));
            goto throw_here;
        }
        gen->is_running = 1;
        if (0
        #ifdef __Pyx_Generator_USED
            || __Pyx_Generator_CheckExact(yf)
        #endif
        #ifdef __Pyx_Coroutine_USED
            || __Pyx_Coroutine_Check(yf)
        #endif
            ) {
            ret = __Pyx__Coroutine_Throw(yf, typ, val, tb, args, close_on_genexit);
        #ifdef __Pyx_Coroutine_USED
        } else if (__Pyx_CoroutineAwait_CheckExact(yf)) {
            ret = __Pyx__Coroutine_Throw(((__pyx_CoroutineAwaitObject*)yf)->coroutine, typ, val, tb, args, close_on_genexit);
        #endif
        } else {
            PyObject *meth = __Pyx_PyObject_GetAttrStr(yf, __pyx_n_s_throw);
            if (unlikely(!meth)) {
                Py_DECREF(yf);
                if (!PyErr_ExceptionMatches(PyExc_AttributeError)) {
                    gen->is_running = 0;
                    return NULL;
                }
                PyErr_Clear();
                __Pyx_Coroutine_Undelegate(gen);
                gen->is_running = 0;
                goto throw_here;
            }
            if (likely(args)) {
                ret = PyObject_CallObject(meth, args);
            } else {
                ret = PyObject_CallFunctionObjArgs(meth, typ, val, tb, NULL);
            }
            Py_DECREF(meth);
        }
        gen->is_running = 0;
        Py_DECREF(yf);
        if (!ret) {
            ret = __Pyx_Coroutine_FinishDelegation(gen);
        }
        return __Pyx_Coroutine_MethodReturn(self, ret);
    }
throw_here:
    __Pyx_Raise(typ, val, tb, NULL);
    return __Pyx_Coroutine_MethodReturn(self, __Pyx_Coroutine_SendEx(gen, NULL, 0));
}
static PyObject *__Pyx_Coroutine_Throw(PyObject *self, PyObject *args) {
    PyObject *typ;
    PyObject *val = NULL;
    PyObject *tb = NULL;
    if (!PyArg_UnpackTuple(args, (char *)"throw", 1, 3, &typ, &val, &tb))
        return NULL;
    return __Pyx__Coroutine_Throw(self, typ, val, tb, args, 1);
}
static CYTHON_INLINE int __Pyx_Coroutine_traverse_excstate(__Pyx_ExcInfoStruct *exc_state, visitproc visit, void *arg) {
    Py_VISIT(exc_state->exc_type);
    Py_VISIT(exc_state->exc_value);
    Py_VISIT(exc_state->exc_traceback);
    return 0;
}
static int __Pyx_Coroutine_traverse(__pyx_CoroutineObject *gen, visitproc visit, void *arg) {
    Py_VISIT(gen->closure);
    Py_VISIT(gen->classobj);
    Py_VISIT(gen->yieldfrom);
    return __Pyx_Coroutine_traverse_excstate(&gen->gi_exc_state, visit, arg);
}
static int __Pyx_Coroutine_clear(PyObject *self) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    Py_CLEAR(gen->closure);
    Py_CLEAR(gen->classobj);
    Py_CLEAR(gen->yieldfrom);
    __Pyx_Coroutine_ExceptionClear(&gen->gi_exc_state);
#ifdef __Pyx_AsyncGen_USED
    if (__Pyx_AsyncGen_CheckExact(self)) {
        Py_CLEAR(((__pyx_PyAsyncGenObject*)gen)->ag_finalizer);
    }
#endif
    Py_CLEAR(gen->gi_code);
    Py_CLEAR(gen->gi_frame);
    Py_CLEAR(gen->gi_name);
    Py_CLEAR(gen->gi_qualname);
    Py_CLEAR(gen->gi_modulename);
    return 0;
}
static void __Pyx_Coroutine_dealloc(PyObject *self) {
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    PyObject_GC_UnTrack(gen);
    if (gen->gi_weakreflist != NULL)
        PyObject_ClearWeakRefs(self);
    if (gen->resume_label >= 0) {
        PyObject_GC_Track(self);
#if PY_VERSION_HEX >= 0x030400a1 && CYTHON_USE_TP_FINALIZE
        if (PyObject_CallFinalizerFromDealloc(self))
#else
        Py_TYPE(gen)->tp_del(self);
        if (Py_REFCNT(self) > 0)
#endif
        {
            return;
        }
        PyObject_GC_UnTrack(self);
    }
#ifdef __Pyx_AsyncGen_USED
    if (__Pyx_AsyncGen_CheckExact(self)) {
        /* We have to handle this case for asynchronous generators
           right here, because this code has to be between UNTRACK
           and GC_Del. */
        Py_CLEAR(((__pyx_PyAsyncGenObject*)self)->ag_finalizer);
    }
#endif
    __Pyx_Coroutine_clear(self);
    PyObject_GC_Del(gen);
}
static void __Pyx_Coroutine_del(PyObject *self) {
    PyObject *error_type, *error_value, *error_traceback;
    __pyx_CoroutineObject *gen = (__pyx_CoroutineObject *) self;
    __Pyx_PyThreadState_declare
    if (gen->resume_label < 0) {
        return;
    }
#if !CYTHON_USE_TP_FINALIZE
    assert(self->ob_refcnt == 0);
    __Pyx_SET_REFCNT(self, 1);
#endif
    __Pyx_PyThreadState_assign
    __Pyx_ErrFetch(&error_type, &error_value, &error_traceback);
#ifdef __Pyx_AsyncGen_USED
    if (__Pyx_AsyncGen_CheckExact(self)) {
        __pyx_PyAsyncGenObject *agen = (__pyx_PyAsyncGenObject*)self;
        PyObject *finalizer = agen->ag_finalizer;
        if (finalizer && !agen->ag_closed) {
            PyObject *res = __Pyx_PyObject_CallOneArg(finalizer, self);
            if (unlikely(!res)) {
                PyErr_WriteUnraisable(self);
            } else {
                Py_DECREF(res);
            }
            __Pyx_ErrRestore(error_type, error_value, error_traceback);
            return;
        }
    }
#endif
    if (unlikely(gen->resume_label == 0 && !error_value)) {
#ifdef __Pyx_Coroutine_USED
#ifdef __Pyx_Generator_USED
    if (!__Pyx_Generator_CheckExact(self))
#endif
        {
        PyObject_GC_UnTrack(self);
#if PY_MAJOR_VERSION >= 3  || defined(PyErr_WarnFormat)
        if (unlikely(PyErr_WarnFormat(PyExc_RuntimeWarning, 1, "coroutine '%.50S' was never awaited", gen->gi_qualname) < 0))
            PyErr_WriteUnraisable(self);
#else
        {PyObject *msg;
        char *cmsg;
        #if CYTHON_COMPILING_IN_PYPY
        msg = NULL;
        cmsg = (char*) "coroutine was never awaited";
        #else
        char *cname;
        PyObject *qualname;
        qualname = gen->gi_qualname;
        cname = PyString_AS_STRING(qualname);
        msg = PyString_FromFormat("coroutine '%.50s' was never awaited", cname);
        if (unlikely(!msg)) {
            PyErr_Clear();
            cmsg = (char*) "coroutine was never awaited";
        } else {
            cmsg = PyString_AS_STRING(msg);
        }
        #endif
        if (unlikely(PyErr_WarnEx(PyExc_RuntimeWarning, cmsg, 1) < 0))
            PyErr_WriteUnraisable(self);
        Py_XDECREF(msg);}
#endif
        PyObject_GC_Track(self);
        }
#endif
    } else {
        PyObject *res = __Pyx_Coroutine_Close(self);
        if (unlikely(!res)) {
            if (PyErr_Occurred())
                PyErr_WriteUnraisable(self);
        } else {
            Py_DECREF(res);
        }
    }
    __Pyx_ErrRestore(error_type, error_value, error_traceback);
#if !CYTHON_USE_TP_FINALIZE
    assert(Py_REFCNT(self) > 0);
    if (--self->ob_refcnt == 0) {
        return;
    }
    {
        Py_ssize_t refcnt = Py_REFCNT(self);
        _Py_NewReference(self);
        __Pyx_SET_REFCNT(self, refcnt);
    }
#if CYTHON_COMPILING_IN_CPYTHON
    assert(PyType_IS_GC(Py_TYPE(self)) &&
           _Py_AS_GC(self)->gc.gc_refs != _PyGC_REFS_UNTRACKED);
    _Py_DEC_REFTOTAL;
#endif
#ifdef COUNT_ALLOCS
    --Py_TYPE(self)->tp_frees;
    --Py_TYPE(self)->tp_allocs;
#endif
#endif
}
static PyObject *
__Pyx_Coroutine_get_name(__pyx_CoroutineObject *self, CYTHON_UNUSED void *context)
{
    PyObject *name = self->gi_name;
    if (unlikely(!name)) name = Py_None;
    Py_INCREF(name);
    return name;
}
static int
__Pyx_Coroutine_set_name(__pyx_CoroutineObject *self, PyObject *value, CYTHON_UNUSED void *context)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value)))
#else
    if (unlikely(value == NULL || !PyString_Check(value)))
#endif
    {
        PyErr_SetString(PyExc_TypeError,
                        "__name__ must be set to a string object");
        return -1;
    }
    tmp = self->gi_name;
    Py_INCREF(value);
    self->gi_name = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_Coroutine_get_qualname(__pyx_CoroutineObject *self, CYTHON_UNUSED void *context)
{
    PyObject *name = self->gi_qualname;
    if (unlikely(!name)) name = Py_None;
    Py_INCREF(name);
    return name;
}
static int
__Pyx_Coroutine_set_qualname(__pyx_CoroutineObject *self, PyObject *value, CYTHON_UNUSED void *context)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value)))
#else
    if (unlikely(value == NULL || !PyString_Check(value)))
#endif
    {
        PyErr_SetString(PyExc_TypeError,
                        "__qualname__ must be set to a string object");
        return -1;
    }
    tmp = self->gi_qualname;
    Py_INCREF(value);
    self->gi_qualname = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_Coroutine_get_frame(__pyx_CoroutineObject *self, CYTHON_UNUSED void *context)
{
    PyObject *frame = self->gi_frame;
    if (!frame) {
        if (unlikely(!self->gi_code)) {
            Py_RETURN_NONE;
        }
        frame = (PyObject *) PyFrame_New(
            PyThreadState_Get(),            /*PyThreadState *tstate,*/
            (PyCodeObject*) self->gi_code,  /*PyCodeObject *code,*/
            __pyx_d,                 /*PyObject *globals,*/
            0                               /*PyObject *locals*/
        );
        if (unlikely(!frame))
            return NULL;
        self->gi_frame = frame;
    }
    Py_INCREF(frame);
    return frame;
}
static __pyx_CoroutineObject *__Pyx__Coroutine_New(
            PyTypeObject* type, __pyx_coroutine_body_t body, PyObject *code, PyObject *closure,
            PyObject *name, PyObject *qualname, PyObject *module_name) {
    __pyx_CoroutineObject *gen = PyObject_GC_New(__pyx_CoroutineObject, type);
    if (unlikely(!gen))
        return NULL;
    return __Pyx__Coroutine_NewInit(gen, body, code, closure, name, qualname, module_name);
}
static __pyx_CoroutineObject *__Pyx__Coroutine_NewInit(
            __pyx_CoroutineObject *gen, __pyx_coroutine_body_t body, PyObject *code, PyObject *closure,
            PyObject *name, PyObject *qualname, PyObject *module_name) {
    gen->body = body;
    gen->closure = closure;
    Py_XINCREF(closure);
    gen->is_running = 0;
    gen->resume_label = 0;
    gen->classobj = NULL;
    gen->yieldfrom = NULL;
    gen->gi_exc_state.exc_type = NULL;
    gen->gi_exc_state.exc_value = NULL;
    gen->gi_exc_state.exc_traceback = NULL;
#if CYTHON_USE_EXC_INFO_STACK
    gen->gi_exc_state.previous_item = NULL;
#endif
    gen->gi_weakreflist = NULL;
    Py_XINCREF(qualname);
    gen->gi_qualname = qualname;
    Py_XINCREF(name);
    gen->gi_name = name;
    Py_XINCREF(module_name);
    gen->gi_modulename = module_name;
    Py_XINCREF(code);
    gen->gi_code = code;
    gen->gi_frame = NULL;
    PyObject_GC_Track(gen);
    return gen;
}

/* PatchGeneratorABC */
#ifndef CYTHON_REGISTER_ABCS
#define CYTHON_REGISTER_ABCS 1
#endif
#if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
static PyObject* __Pyx_patch_abc_module(PyObject *module);
static PyObject* __Pyx_patch_abc_module(PyObject *module) {
    module = __Pyx_Coroutine_patch_module(
        module, ""
"if _cython_generator_type is not None:\n"
"    try: Generator = _module.Generator\n"
"    except AttributeError: pass\n"
"    else: Generator.register(_cython_generator_type)\n"
"if _cython_coroutine_type is not None:\n"
"    try: Coroutine = _module.Coroutine\n"
"    except AttributeError: pass\n"
"    else: Coroutine.register(_cython_coroutine_type)\n"
    );
    return module;
}
#endif
static int __Pyx_patch_abc(void) {
#if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
    static int abc_patched = 0;
    if (CYTHON_REGISTER_ABCS && !abc_patched) {
        PyObject *module;
        module = PyImport_ImportModule((PY_MAJOR_VERSION >= 3) ? "collections.abc" : "collections");
        if (!module) {
            PyErr_WriteUnraisable(NULL);
            if (unlikely(PyErr_WarnEx(PyExc_RuntimeWarning,
                    ((PY_MAJOR_VERSION >= 3) ?
                        "Cython module failed to register with collections.abc module" :
                        "Cython module failed to register with collections module"), 1) < 0)) {
                return -1;
            }
        } else {
            module = __Pyx_patch_abc_module(module);
            abc_patched = 1;
            if (unlikely(!module))
                return -1;
            Py_DECREF(module);
        }
        module = PyImport_ImportModule("backports_abc");
        if (module) {
            module = __Pyx_patch_abc_module(module);
            Py_XDECREF(module);
        }
        if (!module) {
            PyErr_Clear();
        }
    }
#else
    if ((0)) __Pyx_Coroutine_patch_module(NULL, NULL);
#endif
    return 0;
}

/* Generator */
static PyMethodDef __pyx_Generator_methods[] = {
    {"send", (PyCFunction) __Pyx_Coroutine_Send, METH_O,
     (char*) PyDoc_STR("send(arg) -> send 'arg' into generator,\nreturn next yielded value or raise StopIteration.")},
    {"throw", (PyCFunction) __Pyx_Coroutine_Throw, METH_VARARGS,
     (char*) PyDoc_STR("throw(typ[,val[,tb]]) -> raise exception in generator,\nreturn next yielded value or raise StopIteration.")},
    {"close", (PyCFunction) __Pyx_Coroutine_Close_Method, METH_NOARGS,
     (char*) PyDoc_STR("close() -> raise GeneratorExit inside generator.")},
    {0, 0, 0, 0}
};
static PyMemberDef __pyx_Generator_memberlist[] = {
    {(char *) "gi_running", T_BOOL, offsetof(__pyx_CoroutineObject, is_running), READONLY, NULL},
    {(char*) "gi_yieldfrom", T_OBJECT, offsetof(__pyx_CoroutineObject, yieldfrom), READONLY,
     (char*) PyDoc_STR("object being iterated by 'yield from', or None")},
    {(char*) "gi_code", T_OBJECT, offsetof(__pyx_CoroutineObject, gi_code), READONLY, NULL},
    {0, 0, 0, 0, 0}
};
static PyGetSetDef __pyx_Generator_getsets[] = {
    {(char *) "__name__", (getter)__Pyx_Coroutine_get_name, (setter)__Pyx_Coroutine_set_name,
     (char*) PyDoc_STR("name of the generator"), 0},
    {(char *) "__qualname__", (getter)__Pyx_Coroutine_get_qualname, (setter)__Pyx_Coroutine_set_qualname,
     (char*) PyDoc_STR("qualified name of the generator"), 0},
    {(char *) "gi_frame", (getter)__Pyx_Coroutine_get_frame, NULL,
     (char*) PyDoc_STR("Frame of the generator"), 0},
    {0, 0, 0, 0, 0}
};
static PyTypeObject __pyx_GeneratorType_type = {
    PyVarObject_HEAD_INIT(0, 0)
    "generator",
    sizeof(__pyx_CoroutineObject),
    0,
    (destructor) __Pyx_Coroutine_dealloc,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_HAVE_FINALIZE,
    0,
    (traverseproc) __Pyx_Coroutine_traverse,
    0,
    0,
    offsetof(__pyx_CoroutineObject, gi_weakreflist),
    0,
    (iternextfunc) __Pyx_Generator_Next,
    __pyx_Generator_methods,
    __pyx_Generator_memberlist,
    __pyx_Generator_getsets,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
#if CYTHON_USE_TP_FINALIZE
    0,
#else
    __Pyx_Coroutine_del,
#endif
    0,
#if CYTHON_USE_TP_FINALIZE
    __Pyx_Coroutine_del,
#elif PY_VERSION_HEX >= 0x030400a1
    0,
#endif
#if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
    0,
#endif
#if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
    0,
#endif
#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
    0,
#endif
};
static int __pyx_Generator_init(void) {
    __pyx_GeneratorType_type.tp_getattro = __Pyx_PyObject_GenericGetAttrNoDict;
    __pyx_GeneratorType_type.tp_iter = PyObject_SelfIter;
    __pyx_GeneratorType = __Pyx_FetchCommonType(&__pyx_GeneratorType_type);
    if (unlikely(!__pyx_GeneratorType)) {
        return -1;
    }
    return 0;
}

/* CheckBinaryVersion */
static int __Pyx_check_binary_version(void) {
    char ctversion[5];
    int same=1, i, found_dot;
    const char* rt_from_call = Py_GetVersion();
    PyOS_snprintf(ctversion, 5, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
    found_dot = 0;
    for (i = 0; i < 4; i++) {
        if (!ctversion[i]) {
            same = (rt_from_call[i] < '0' || rt_from_call[i] > '9');
            break;
        }
        if (rt_from_call[i] != ctversion[i]) {
            same = 0;
            break;
        }
    }
    if (!same) {
        char rtversion[5] = {'\0'};
        char message[200];
        for (i=0; i<4; ++i) {
            if (rt_from_call[i] == '.') {
                if (found_dot) break;
                found_dot = 1;
            } else if (rt_from_call[i] < '0' || rt_from_call[i] > '9') {
                break;
            }
            rtversion[i] = rt_from_call[i];
        }
        PyOS_snprintf(message, sizeof(message),
                      "compiletime version %s of module '%.100s' "
                      "does not match runtime version %s",
                      ctversion, __Pyx_MODULE_NAME, rtversion);
        return PyErr_WarnEx(NULL, message, 1);
    }
    return 0;
}

/* InitStrings */
static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        if (PyObject_Hash(*t->p) == -1)
            return -1;
        ++t;
    }
    return 0;
}

static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
    return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
}
static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject* o) {
    Py_ssize_t ignore;
    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
}
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
#if !CYTHON_PEP393_ENABLED
static const char* __Pyx_PyUnicode_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
    char* defenc_c;
    PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
    if (!defenc) return NULL;
    defenc_c = PyBytes_AS_STRING(defenc);
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
    {
        char* end = defenc_c + PyBytes_GET_SIZE(defenc);
        char* c;
        for (c = defenc_c; c < end; c++) {
            if ((unsigned char) (*c) >= 128) {
                PyUnicode_AsASCIIString(o);
                return NULL;
            }
        }
    }
#endif
    *length = PyBytes_GET_SIZE(defenc);
    return defenc_c;
}
#else
static CYTHON_INLINE const char* __Pyx_PyUnicode_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
    if (unlikely(__Pyx_PyUnicode_READY(o) == -1)) return NULL;
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
    if (likely(PyUnicode_IS_ASCII(o))) {
        *length = PyUnicode_GET_LENGTH(o);
        return PyUnicode_AsUTF8(o);
    } else {
        PyUnicode_AsASCIIString(o);
        return NULL;
    }
#else
    return PyUnicode_AsUTF8AndSize(o, length);
#endif
}
#endif
#endif
static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
    if (
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
            __Pyx_sys_getdefaultencoding_not_ascii &&
#endif
            PyUnicode_Check(o)) {
        return __Pyx_PyUnicode_AsStringAndSize(o, length);
    } else
#endif
#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
    if (PyByteArray_Check(o)) {
        *length = PyByteArray_GET_SIZE(o);
        return PyByteArray_AS_STRING(o);
    } else
#endif
    {
        char* result;
        int r = PyBytes_AsStringAndSize(o, &result, length);
        if (unlikely(r < 0)) {
            return NULL;
        } else {
            return result;
        }
    }
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject* x) {
    int retval;
    if (unlikely(!x)) return -1;
    retval = __Pyx_PyObject_IsTrue(x);
    Py_DECREF(x);
    return retval;
}
static PyObject* __Pyx_PyNumber_IntOrLongWrongResultType(PyObject* result, const char* type_name) {
#if PY_MAJOR_VERSION >= 3
    if (PyLong_Check(result)) {
        if (PyErr_WarnFormat(PyExc_DeprecationWarning, 1,
                "__int__ returned non-int (type %.200s).  "
                "The ability to return an instance of a strict subclass of int "
                "is deprecated, and may be removed in a future version of Python.",
                Py_TYPE(result)->tp_name)) {
            Py_DECREF(result);
            return NULL;
        }
        return result;
    }
#endif
    PyErr_Format(PyExc_TypeError,
                 "__%.4s__ returned non-%.4s (type %.200s)",
                 type_name, type_name, Py_TYPE(result)->tp_name);
    Py_DECREF(result);
    return NULL;
}
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x) {
#if CYTHON_USE_TYPE_SLOTS
  PyNumberMethods *m;
#endif
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_Check(x) || PyLong_Check(x)))
#else
  if (likely(PyLong_Check(x)))
#endif
    return __Pyx_NewRef(x);
#if CYTHON_USE_TYPE_SLOTS
  m = Py_TYPE(x)->tp_as_number;
  #if PY_MAJOR_VERSION < 3
  if (m && m->nb_int) {
    name = "int";
    res = m->nb_int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = m->nb_long(x);
  }
  #else
  if (likely(m && m->nb_int)) {
    name = "int";
    res = m->nb_int(x);
  }
  #endif
#else
  if (!PyBytes_CheckExact(x) && !PyUnicode_CheckExact(x)) {
    res = PyNumber_Int(x);
  }
#endif
  if (likely(res)) {
#if PY_MAJOR_VERSION < 3
    if (unlikely(!PyInt_Check(res) && !PyLong_Check(res))) {
#else
    if (unlikely(!PyLong_CheckExact(res))) {
#endif
        return __Pyx_PyNumber_IntOrLongWrongResultType(res, name);
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject *x;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_CheckExact(b))) {
    if (sizeof(Py_ssize_t) >= sizeof(long))
        return PyInt_AS_LONG(b);
    else
        return PyInt_AsSsize_t(b);
  }
#endif
  if (likely(PyLong_CheckExact(b))) {
    #if CYTHON_USE_PYLONG_INTERNALS
    const digit* digits = ((PyLongObject*)b)->ob_digit;
    const Py_ssize_t size = Py_SIZE(b);
    if (likely(__Pyx_sst_abs(size) <= 1)) {
        ival = likely(size) ? digits[0] : 0;
        if (size == -1) ival = -ival;
        return ival;
    } else {
      switch (size) {
         case 2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
      }
    }
    #endif
    return PyLong_AsSsize_t(b);
  }
  x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}
static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject* o) {
  if (sizeof(Py_hash_t) == sizeof(Py_ssize_t)) {
    return (Py_hash_t) __Pyx_PyIndex_AsSsize_t(o);
#if PY_MAJOR_VERSION < 3
  } else if (likely(PyInt_CheckExact(o))) {
    return PyInt_AS_LONG(o);
#endif
  } else {
    Py_ssize_t ival;
    PyObject *x;
    x = PyNumber_Index(o);
    if (!x) return -1;
    ival = PyInt_AsLong(x);
    Py_DECREF(x);
    return ival;
  }
}
static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b) {
  return b ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False);
}
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
    return PyInt_FromSize_t(ival);
}


#endif /* Py_PYTHON_H */
